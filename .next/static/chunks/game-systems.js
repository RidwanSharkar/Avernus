"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["game-systems"],{

/***/ "(app-pages-browser)/./src/core/DamageCalculator.ts":
/*!**************************************!*\
  !*** ./src/core/DamageCalculator.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDamage: function() { return /* binding */ calculateDamage; },\n/* harmony export */   getCriticalChance: function() { return /* binding */ getCriticalChance; },\n/* harmony export */   getCriticalDamageMultiplier: function() { return /* binding */ getCriticalDamageMultiplier; },\n/* harmony export */   getGlobalRuneCounts: function() { return /* binding */ getGlobalRuneCounts; },\n/* harmony export */   setGlobalCritDamageRuneCount: function() { return /* binding */ setGlobalCritDamageRuneCount; },\n/* harmony export */   setGlobalCriticalRuneCount: function() { return /* binding */ setGlobalCriticalRuneCount; }\n/* harmony export */ });\n// Core damage calculation system with critical hit mechanics\n// Placed in core/ for performance and shared access across all systems\n// Global rune counts - will be updated by the GameState context\nlet globalCriticalRuneCount = 0;\nlet globalCritDamageRuneCount = 0;\nfunction setGlobalCriticalRuneCount(count) {\n    globalCriticalRuneCount = count;\n}\nfunction setGlobalCritDamageRuneCount(count) {\n    globalCritDamageRuneCount = count;\n}\nfunction calculateDamage(baseAmount) {\n    // Base crit chance is 11%, each rune adds 3%\n    const criticalChance = 0.11 + globalCriticalRuneCount * 0.03;\n    const isCritical = Math.random() < criticalChance;\n    // Base crit damage multiplier is 2x, each crit damage rune adds 0.15x\n    const criticalDamageMultiplier = 2.0 + globalCritDamageRuneCount * 0.15;\n    const rawDamage = isCritical ? baseAmount * criticalDamageMultiplier : baseAmount;\n    // Round down to integer to avoid floating point precision issues\n    const damage = Math.floor(rawDamage);\n    return {\n        damage,\n        isCritical\n    };\n}\n// Utility functions for debugging and testing\nfunction getCriticalChance() {\n    return 0.11 + globalCriticalRuneCount * 0.03;\n}\nfunction getCriticalDamageMultiplier() {\n    return 2.0 + globalCritDamageRuneCount * 0.15;\n}\nfunction getGlobalRuneCounts() {\n    return {\n        criticalRunes: globalCriticalRuneCount,\n        critDamageRunes: globalCritDamageRuneCount\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0RhbWFnZUNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQzdELHVFQUF1RTtBQU92RSxnRUFBZ0U7QUFDaEUsSUFBSUEsMEJBQTBCO0FBQzlCLElBQUlDLDRCQUE0QjtBQUV6QixTQUFTQywyQkFBMkJDLEtBQWE7SUFDdERILDBCQUEwQkc7QUFDNUI7QUFFTyxTQUFTQyw2QkFBNkJELEtBQWE7SUFDeERGLDRCQUE0QkU7QUFDOUI7QUFFTyxTQUFTRSxnQkFBZ0JDLFVBQWtCO0lBQ2hELDZDQUE2QztJQUM3QyxNQUFNQyxpQkFBaUIsT0FBUVAsMEJBQTBCO0lBQ3pELE1BQU1RLGFBQWFDLEtBQUtDLE1BQU0sS0FBS0g7SUFFbkMsc0VBQXNFO0lBQ3RFLE1BQU1JLDJCQUEyQixNQUFPViw0QkFBNEI7SUFDcEUsTUFBTVcsWUFBWUosYUFBYUYsYUFBYUssMkJBQTJCTDtJQUV2RSxpRUFBaUU7SUFDakUsTUFBTU8sU0FBU0osS0FBS0ssS0FBSyxDQUFDRjtJQUUxQixPQUFPO1FBQUVDO1FBQVFMO0lBQVc7QUFDOUI7QUFFQSw4Q0FBOEM7QUFDdkMsU0FBU087SUFDZCxPQUFPLE9BQVFmLDBCQUEwQjtBQUMzQztBQUVPLFNBQVNnQjtJQUNkLE9BQU8sTUFBT2YsNEJBQTRCO0FBQzVDO0FBRU8sU0FBU2dCO0lBQ2QsT0FBTztRQUNMQyxlQUFlbEI7UUFDZm1CLGlCQUFpQmxCO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvRGFtYWdlQ2FsY3VsYXRvci50cz8yNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgZGFtYWdlIGNhbGN1bGF0aW9uIHN5c3RlbSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3Ncbi8vIFBsYWNlZCBpbiBjb3JlLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHNoYXJlZCBhY2Nlc3MgYWNyb3NzIGFsbCBzeXN0ZW1zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFtYWdlUmVzdWx0IHtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIGlzQ3JpdGljYWw6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBydW5lIGNvdW50cyAtIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgR2FtZVN0YXRlIGNvbnRleHRcbmxldCBnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCA9IDA7XG5sZXQgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0aWNhbFJ1bmVDb3VudChjb3VudDogbnVtYmVyKSB7XG4gIGdsb2JhbENyaXRpY2FsUnVuZUNvdW50ID0gY291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50KGNvdW50OiBudW1iZXIpIHtcbiAgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IGNvdW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGFtYWdlKGJhc2VBbW91bnQ6IG51bWJlcik6IERhbWFnZVJlc3VsdCB7XG4gIC8vIEJhc2UgY3JpdCBjaGFuY2UgaXMgMTElLCBlYWNoIHJ1bmUgYWRkcyAzJVxuICBjb25zdCBjcml0aWNhbENoYW5jZSA9IDAuMTEgKyAoZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQgKiAwLjAzKTtcbiAgY29uc3QgaXNDcml0aWNhbCA9IE1hdGgucmFuZG9tKCkgPCBjcml0aWNhbENoYW5jZTtcbiAgXG4gIC8vIEJhc2UgY3JpdCBkYW1hZ2UgbXVsdGlwbGllciBpcyAyeCwgZWFjaCBjcml0IGRhbWFnZSBydW5lIGFkZHMgMC4xNXhcbiAgY29uc3QgY3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyID0gMi4wICsgKGdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQgKiAwLjE1KTtcbiAgY29uc3QgcmF3RGFtYWdlID0gaXNDcml0aWNhbCA/IGJhc2VBbW91bnQgKiBjcml0aWNhbERhbWFnZU11bHRpcGxpZXIgOiBiYXNlQW1vdW50O1xuICBcbiAgLy8gUm91bmQgZG93biB0byBpbnRlZ2VyIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXNcbiAgY29uc3QgZGFtYWdlID0gTWF0aC5mbG9vcihyYXdEYW1hZ2UpO1xuICBcbiAgcmV0dXJuIHsgZGFtYWdlLCBpc0NyaXRpY2FsIH07XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcml0aWNhbENoYW5jZSgpOiBudW1iZXIge1xuICByZXR1cm4gMC4xMSArIChnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCAqIDAuMDMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyKCk6IG51bWJlciB7XG4gIHJldHVybiAyLjAgKyAoZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCAqIDAuMTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsUnVuZUNvdW50cygpOiB7IGNyaXRpY2FsUnVuZXM6IG51bWJlcjsgY3JpdERhbWFnZVJ1bmVzOiBudW1iZXIgfSB7XG4gIHJldHVybiB7XG4gICAgY3JpdGljYWxSdW5lczogZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQsXG4gICAgY3JpdERhbWFnZVJ1bmVzOiBnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50Iiwic2V0R2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJjb3VudCIsInNldEdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJiYXNlQW1vdW50IiwiY3JpdGljYWxDaGFuY2UiLCJpc0NyaXRpY2FsIiwiTWF0aCIsInJhbmRvbSIsImNyaXRpY2FsRGFtYWdlTXVsdGlwbGllciIsInJhd0RhbWFnZSIsImRhbWFnZSIsImZsb29yIiwiZ2V0Q3JpdGljYWxDaGFuY2UiLCJnZXRDcml0aWNhbERhbWFnZU11bHRpcGxpZXIiLCJnZXRHbG9iYWxSdW5lQ291bnRzIiwiY3JpdGljYWxSdW5lcyIsImNyaXREYW1hZ2VSdW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/DamageCalculator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/Engine.ts":
/*!****************************!*\
  !*** ./src/core/Engine.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: function() { return /* binding */ Engine; }\n/* harmony export */ });\n/* harmony import */ var _ecs_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/World */ \"(app-pages-browser)/./src/ecs/World.ts\");\n/* harmony import */ var _GameLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameLoop */ \"(app-pages-browser)/./src/core/GameLoop.ts\");\n/* harmony import */ var _InputManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InputManager */ \"(app-pages-browser)/./src/core/InputManager.ts\");\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Main game engine with ECS integration\n\n\n\n\nclass Engine extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    async initialize(canvas) {\n        if (this.isInitialized) {\n            return;\n        }\n        this.canvas = canvas;\n        this.inputManager.initialize(canvas);\n        this.isInitialized = true;\n        this.emit(\"initialized\");\n    }\n    start() {\n        if (!this.isInitialized) {\n            throw new Error(\"Engine must be initialized before starting\");\n        }\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.gameLoop.start();\n        this.emit(\"started\");\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.gameLoop.stop();\n        this.emit(\"stopped\");\n    }\n    pause() {\n        if (this.isRunning) {\n            this.gameLoop.pause();\n            this.emit(\"paused\");\n        }\n    }\n    resume() {\n        if (this.isRunning) {\n            this.gameLoop.resume();\n            this.emit(\"resumed\");\n        }\n    }\n    getWorld() {\n        return this.world;\n    }\n    getInputManager() {\n        return this.inputManager;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isEngineRunning() {\n        return this.isRunning;\n    }\n    getCurrentFPS() {\n        return this.gameLoop.getCurrentFPS();\n    }\n    getPerformanceStats() {\n        return {\n            fps: this.gameLoop.getCurrentFPS(),\n            frameTime: this.frameTime,\n            updateTime: this.updateTime,\n            renderTime: this.renderTime\n        };\n    }\n    enableDebugMode(enabled) {\n        this.debugMode = enabled;\n    }\n    isDebugMode() {\n        return this.debugMode;\n    }\n    setupGameLoop() {\n        // Handle fixed timestep updates (physics)\n        this.gameLoop.on(\"fixedUpdate\", (param)=>{\n            let { fixedDeltaTime } = param;\n            const startTime = performance.now();\n            this.world.fixedUpdate(fixedDeltaTime);\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n        });\n        // Handle variable timestep updates (game logic)\n        this.gameLoop.on(\"update\", (param)=>{\n            let { deltaTime } = param;\n            const startTime = performance.now();\n            // Update world systems first so they can read input deltas\n            this.world.update(deltaTime);\n            // Update input manager after systems have processed input\n            this.inputManager.update();\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n            this.emit(\"update\", {\n                deltaTime\n            });\n        });\n        // Handle rendering\n        this.gameLoop.on(\"render\", (param)=>{\n            let { deltaTime, interpolation } = param;\n            const startTime = performance.now();\n            // Render world\n            this.world.render(deltaTime);\n            if (this.debugMode) {\n                this.renderTime = performance.now() - startTime;\n                this.frameTime = this.updateTime + this.renderTime;\n            }\n            this.emit(\"render\", {\n                deltaTime,\n                interpolation\n            });\n        });\n    }\n    destroy() {\n        this.stop();\n        // Clean up systems\n        this.world.destroy();\n        this.inputManager.destroy();\n        // Clear event listeners\n        this.removeAllListeners();\n        this.isInitialized = false;\n    }\n    // Utility methods for common operations\n    requestPointerLock() {\n        this.inputManager.requestPointerLock();\n    }\n    exitPointerLock() {\n        this.inputManager.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.inputManager.isKeyPressed(key);\n    }\n    isMouseButtonPressed(button) {\n        return this.inputManager.isMouseButtonPressed(button);\n    }\n    getMouseDelta() {\n        return this.inputManager.getMouseDelta();\n    }\n    constructor(config = {}){\n        super();\n        this.canvas = null;\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.debugMode = false;\n        // Performance monitoring\n        this.frameTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.world = new _ecs_World__WEBPACK_IMPORTED_MODULE_0__.World();\n        this.gameLoop = new _GameLoop__WEBPACK_IMPORTED_MODULE_1__.GameLoop();\n        this.inputManager = new _InputManager__WEBPACK_IMPORTED_MODULE_2__.InputManager();\n        this.debugMode = config.enableDebug || false;\n        this.setupGameLoop();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QztBQUNKO0FBQ0U7QUFDUTtBQUNNO0FBUTdDLE1BQU1JLGVBQWVELDZEQUFZQTtJQXlCdEMsTUFBYUUsV0FBV0MsTUFBeUIsRUFBaUI7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRSxZQUFZLENBQUNILFVBQVUsQ0FBQ0M7UUFFN0IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRSxJQUFJLENBQUM7SUFFWjtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNILGFBQWEsRUFBRTtZQUN2QixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsS0FBSztRQUNuQixJQUFJLENBQUNELElBQUksQ0FBQztJQUdaO0lBRU9LLE9BQWE7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0YsU0FBUyxFQUFFO1FBRXJCLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO1FBQ2xCLElBQUksQ0FBQ0wsSUFBSSxDQUFDO0lBR1o7SUFFT00sUUFBYztRQUNuQixJQUFJLElBQUksQ0FBQ0gsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxDQUFDRSxLQUFLO1lBQ25CLElBQUksQ0FBQ04sSUFBSSxDQUFDO1FBQ1o7SUFDRjtJQUVPTyxTQUFlO1FBQ3BCLElBQUksSUFBSSxDQUFDSixTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQyxRQUFRLENBQUNHLE1BQU07WUFDcEIsSUFBSSxDQUFDUCxJQUFJLENB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bkM7SUFFT0MsYUFBYUMsR0FBVyxFQUFXO1FBQ3hDLE9BQU8sSUFBSSxDQUFDeEMsWUFBWSxDQUFDdUMsWUFBWSxDQUFDQztJQUN4QztJQUVPQyxxQkFBcUJDLE1BQWMsRUFBVztRQUNuRCxPQUFPLElBQUksQ0FBQzFDLFlBQVksQ0FBQ3lDLG9CQUFvQixDQUFDQztJQUNoRDtJQUVPQyxnQkFBMEM7UUFDL0MsT0FBTyxJQUFJLENBQUMzQyxZQUFZLENBQUMyQyxhQUFhO0lBQ3hDO0lBbExBQyxZQUFZQyxTQUF1QixDQUFDLENBQUMsQ0FBRTtRQUNyQyxLQUFLO2FBWEMvQyxTQUFtQzthQUNuQ0MsZ0JBQWdCO2FBQ2hCSyxZQUFZO2FBQ1prQixZQUFZO1FBRXBCLHlCQUF5QjthQUNqQkwsWUFBWTthQUNaQyxhQUFhO2FBQ2JDLGFBQWE7UUFLbkIsSUFBSSxDQUFDVCxLQUFLLEdBQUcsSUFBSWxCLDZDQUFLQTtRQUN0QixJQUFJLENBQUNhLFFBQVEsR0FBRyxJQUFJWiwrQ0FBUUE7UUFDNUIsSUFBSSxDQUFDTyxZQUFZLEdBQUcsSUFBSU4sdURBQVlBO1FBQ3BDLElBQUksQ0FBQzRCLFNBQVMsR0FBR3VCLE9BQU9DLFdBQVcsSUFBSTtRQUV2QyxJQUFJLENBQUN0QixhQUFhO0lBQ3BCO0FBMEtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb3JlL0VuZ2luZS50cz8yZjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1haW4gZ2FtZSBlbmdpbmUgd2l0aCBFQ1MgaW50ZWdyYXRpb25cbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgR2FtZUxvb3AgfSBmcm9tICcuL0dhbWVMb29wJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJy4vSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0AvdXRpbHMvRXZlbnRFbWl0dGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBFbmdpbmVDb25maWcge1xuICBjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgZW5hYmxlRGVidWc/OiBib29sZWFuO1xuICB0YXJnZXRGUFM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBFbmdpbmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBnYW1lTG9vcDogR2FtZUxvb3A7XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc1J1bm5pbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWJ1Z01vZGUgPSBmYWxzZTtcblxuICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gIHByaXZhdGUgZnJhbWVUaW1lID0gMDtcbiAgcHJpdmF0ZSB1cGRhdGVUaW1lID0gMDtcbiAgcHJpdmF0ZSByZW5kZXJUaW1lID0gMDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEVuZ2luZUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLndvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgdGhpcy5nYW1lTG9vcCA9IG5ldyBHYW1lTG9vcCgpO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gbmV3IElucHV0TWFuYWdlcigpO1xuICAgIHRoaXMuZGVidWdNb2RlID0gY29uZmlnLmVuYWJsZURlYnVnIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5zZXR1cEdhbWVMb29wKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLmluaXRpYWxpemUoY2FudmFzKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnKTtcbiAgICBcbiAgfVxuXG4gIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmdpbmUgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgc3RhcnRpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5nYW1lTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnBhdXNlKCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnJlc3VtZSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFdvcmxkKCk6IFdvcmxkIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dE1hbmFnZXIoKTogSW5wdXRNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXI7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgcHVibGljIGlzRW5naW5lUnVubmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1J1bm5pbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdhbWVMb29wLmdldEN1cnJlbnRGUFMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcHM6IHRoaXMuZ2FtZUxvb3AuZ2V0Q3VycmVudEZQUygpLFxuICAgICAgZnJhbWVUaW1lOiB0aGlzLmZyYW1lVGltZSxcbiAgICAgIHVwZGF0ZVRpbWU6IHRoaXMudXBkYXRlVGltZSxcbiAgICAgIHJlbmRlclRpbWU6IHRoaXMucmVuZGVyVGltZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVuYWJsZURlYnVnTW9kZShlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBlbmFibGVkO1xuICB9XG5cbiAgcHVibGljIGlzRGVidWdNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRlYnVnTW9kZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBHYW1lTG9vcCgpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgZml4ZWQgdGltZXN0ZXAgdXBkYXRlcyAocGh5c2ljcylcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdmaXhlZFVwZGF0ZScsICh7IGZpeGVkRGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICB0aGlzLndvcmxkLmZpeGVkVXBkYXRlKGZpeGVkRGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXMgKGdhbWUgbG9naWMpXG4gICAgdGhpcy5nYW1lTG9vcC5vbigndXBkYXRlJywgKHsgZGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgd29ybGQgc3lzdGVtcyBmaXJzdCBzbyB0aGV5IGNhbiByZWFkIGlucHV0IGRlbHRhc1xuICAgICAgdGhpcy53b3JsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGlucHV0IG1hbmFnZXIgYWZ0ZXIgc3lzdGVtcyBoYXZlIHByb2Nlc3NlZCBpbnB1dFxuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIudXBkYXRlKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGRlbHRhVGltZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZW5kZXJpbmdcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdyZW5kZXInLCAoeyBkZWx0YVRpbWUsIGludGVycG9sYXRpb24gfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciB3b3JsZFxuICAgICAgdGhpcy53b3JsZC5yZW5kZXIoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IHRoaXMudXBkYXRlVGltZSArIHRoaXMucmVuZGVyVGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICB0aGlzLndvcmxkLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZChrZXkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXb3JsZCIsIkdhbWVMb29wIiwiSW5wdXRNYW5hZ2VyIiwiRXZlbnRFbWl0dGVyIiwiRW5naW5lIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImlzSW5pdGlhbGl6ZWQiLCJpbnB1dE1hbmFnZXIiLCJlbWl0Iiwic3RhcnQiLCJFcnJvciIsImlzUnVubmluZyIsImdhbWVMb29wIiwic3RvcCIsInBhdXNlIiwicmVzdW1lIiwiZ2V0V29ybGQiLCJ3b3JsZCIsImdldElucHV0TWFuYWdlciIsImdldENhbnZhcyIsImlzRW5naW5lUnVubmluZyIsImdldEN1cnJlbnRGUFMiLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwiZnBzIiwiZnJhbWVUaW1lIiwidXBkYXRlVGltZSIsInJlbmRlclRpbWUiLCJlbmFibGVEZWJ1Z01vZGUiLCJlbmFibGVkIiwiZGVidWdNb2RlIiwiaXNEZWJ1Z01vZGUiLCJzZXR1cEdhbWVMb29wIiwib24iLCJmaXhlZERlbHRhVGltZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZml4ZWRVcGRhdGUiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJpbnRlcnBvbGF0aW9uIiwicmVuZGVyIiwiZGVzdHJveSIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlcXVlc3RQb2ludGVyTG9jayIsImV4aXRQb2ludGVyTG9jayIsImlzS2V5UHJlc3NlZCIsImtleSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwiZ2V0TW91c2VEZWx0YSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiZW5hYmxlRGVidWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/Engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/GameLoop.ts":
/*!******************************!*\
  !*** ./src/core/GameLoop.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameLoop: function() { return /* binding */ GameLoop; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Optimized game loop with fixed timestep physics\n\nclass GameLoop extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.lastTime = performance.now();\n        this.accumulator = 0;\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = 0;\n        }\n    }\n    getCurrentFPS() {\n        return this.currentFPS;\n    }\n    getFixedTimeStep() {\n        return this.fixedTimeStep;\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning) return;\n        // Calculate delta time and clamp it to prevent large jumps\n        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.maxFrameTime);\n        this.lastTime = currentTime;\n        this.currentTime = currentTime;\n        // Update FPS counter\n        this.updateFPS(deltaTime);\n        // Accumulate time for fixed timestep physics\n        this.accumulator += deltaTime;\n        // Fixed timestep physics updates\n        let subSteps = 0;\n        while(this.accumulator >= this.fixedTimeStep && subSteps < this.maxSubSteps){\n            this.emit(\"fixedUpdate\", {\n                fixedDeltaTime: this.fixedTimeStep\n            });\n            this.accumulator -= this.fixedTimeStep;\n            subSteps++;\n        }\n        // Variable timestep game logic update\n        this.emit(\"update\", {\n            deltaTime\n        });\n        // Calculate interpolation factor for smooth rendering\n        const interpolation = this.accumulator / this.fixedTimeStep;\n        // Render with interpolation\n        this.emit(\"render\", {\n            deltaTime,\n            interpolation\n        });\n        // Schedule next frame\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    updateFPS(deltaTime) {\n        this.frameCount++;\n        this.fpsUpdateTime += deltaTime;\n        // Update FPS every second\n        if (this.fpsUpdateTime >= 1.0) {\n            this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);\n            this.frameCount = 0;\n            this.fpsUpdateTime = 0;\n        }\n    }\n    pause() {\n        if (this.isRunning) {\n            this.stop();\n        }\n    }\n    resume() {\n        if (!this.isRunning) {\n            this.start();\n        }\n    }\n    isPaused() {\n        return !this.isRunning;\n    }\n    // Get current time for systems that need it\n    getCurrentTime() {\n        return this.currentTime;\n    }\n    // Get accumulator ratio for interpolation\n    getInterpolationRatio() {\n        return this.accumulator / this.fixedTimeStep;\n    }\n    constructor(){\n        super();\n        this.isRunning = false;\n        this.lastTime = 0;\n        this.accumulator = 0;\n        this.currentTime = 0;\n        this.frameId = 0;\n        // Performance settings\n        this.fixedTimeStep = 1 / 60 // 60 FPS physics\n        ;\n        this.maxFrameTime = 1 / 30 // Prevent spiral of death at 30 FPS\n        ;\n        this.maxSubSteps = 5 // Maximum physics substeps per frame\n        ;\n        // Performance monitoring\n        this.frameCount = 0;\n        this.fpsUpdateTime = 0;\n        this.currentFPS = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0dhbWVMb29wLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBQ0U7QUFRN0MsTUFBTUMsaUJBQWlCRCw2REFBWUE7SUFxQmpDRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7UUFFcEIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVlDLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLHNCQUFzQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDOUQ7SUFFT0MsT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNLLE9BQU8sRUFBRTtZQUNoQksscUJBQXFCLElBQUksQ0FBQ0wsT0FBTztZQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNqQjtJQUNGO0lBRU9NLGdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtJQUVPQyxtQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNDLGFBQWE7SUFDM0I7SUFFUVAsU0FBU1EsV0FBbUIsRUFBUTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLEVBQUU7UUFFckIsMkRBQTJEO1FBQzNELE1BQU1nQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsY0FBYyxJQUFJLENBQUNkLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQ2tCLFlBQVk7UUFDbEYsSUFBSSxDQUFDbEIsUUFBUSxHQUFHYztRQUNoQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFFbkIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssU0FBUyxDQUFDSjtRQUVmLDZDQUE2QztRQUM3QyxJQUFJLENBQUNaLFdBQVcsSUFBSVk7UUFFcEIsaUNBQWlDO1FBQ2pDLElBQUlLLFdBQVc7UUFDZixNQUFPLElBQUksQ0FBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUNVLGFBQWEsSUFBSU8sV0FBVyxJQUFJLENBQUNDLFdBQVcsQ0FBRTtZQUM1RSxJQUFJLENBQUNDLElBQUksQ0FBQyxlQUFlO2dCQUFFQyxnQkFBZ0IsSUFBSSxDQUFDVixhQUFhO1lBQUM7WUFDOUQsSUFBSSxDQUFDVixXQUFXLElBQUksSUFBSSxDQUFDVSxhQUFhO1lBQ3RDTztRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVU7WUFBRVA7UUFBVTtRQUVoQyxzREFBc0Q7UUFDdEQsTUFBTVMsZ0JBQWdCLElBQUksQ0FBQ3JCLFdBQVcsR0FBRyxJQUFJLENBQUNVLGFBQWE7UUFFM0QsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ1MsSUFBSSxDQUFDLFVBQVU7WUFBRVA7WUFBV1M7UUFBYztRQUUvQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHQyxzQkFBc0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzlEO0lBRVFZLFVBQVVKLFNBQWlCLEVBQVE7UUFDekMsSUFBSSxDQUFDVSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLElBQUlYO1FBRXRCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ1csYUFBYSxJQUFJLEtBQUs7WUFDN0IsSUFBSSxDQUFDZixVQUFVLEdBQUdLLEtBQUtXLEtBQUssQ0FBQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWE7WUFDakUsSUFBSSxDQUFDRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVPRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ1MsSUFBSTtRQUNYO0lBQ0Y7SUFFT3FCLFNBQWU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNELEtBQUs7UUFDWjtJQUNGO0lBRU9nQyxXQUFvQjtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDL0IsU0FBUztJQUN4QjtJQUVBLDRDQUE0QztJQUNyQ2dDLGlCQUF5QjtRQUM5QixPQUFPLElBQUksQ0FBQ2pCLFdBQVc7SUFDekI7SUFFQSwwQ0FBMEM7SUFDbkNrQix3QkFBZ0M7UUFDckMsT0FBTyxJQUFJLENBQUM3QixXQUFXLEdBQUcsSUFBSSxDQUFDVSxhQUFhO0lBQzlDO0lBdEdBb0IsYUFBYztRQUNaLEtBQUs7YUFqQkNsQyxZQUFZO2FBQ1pDLFdBQVc7YUFDWEcsY0FBYzthQUNkVyxjQUFjO2FBQ2RWLFVBQVU7UUFFbEIsdUJBQXVCO2FBQ05TLGdCQUFnQixJQUFJLEdBQUksaUJBQWlCOzthQUN6Q0ssZUFBZSxJQUFJLEdBQUssb0NBQW9DOzthQUM1REcsY0FBYyxFQUFVLHFDQUFxQzs7UUFFOUUseUJBQXlCO2FBQ2pCSSxhQUFhO2FBQ2JDLGdCQUFnQjthQUNoQmYsYUFBYTtJQUlyQjtBQXFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9HYW1lTG9vcC50cz82ZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9wdGltaXplZCBnYW1lIGxvb3Agd2l0aCBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZUxvb3BFdmVudHMge1xuICB1cGRhdGU6IHsgZGVsdGFUaW1lOiBudW1iZXIgfTtcbiAgZml4ZWRVcGRhdGU6IHsgZml4ZWREZWx0YVRpbWU6IG51bWJlciB9O1xuICByZW5kZXI6IHsgZGVsdGFUaW1lOiBudW1iZXI7IGludGVycG9sYXRpb246IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2FtZUxvb3AgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBhY2N1bXVsYXRvciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFRpbWUgPSAwO1xuICBwcml2YXRlIGZyYW1lSWQgPSAwO1xuXG4gIC8vIFBlcmZvcm1hbmNlIHNldHRpbmdzXG4gIHByaXZhdGUgcmVhZG9ubHkgZml4ZWRUaW1lU3RlcCA9IDEgLyA2MDsgLy8gNjAgRlBTIHBoeXNpY3NcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGcmFtZVRpbWUgPSAxIC8gMzA7ICAvLyBQcmV2ZW50IHNwaXJhbCBvZiBkZWF0aCBhdCAzMCBGUFNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTdWJTdGVwcyA9IDU7ICAgICAgICAvLyBNYXhpbXVtIHBoeXNpY3Mgc3Vic3RlcHMgcGVyIGZyYW1lXG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuICBwcml2YXRlIGZwc1VwZGF0ZVRpbWUgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRGUFMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVMb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGUFM7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rml4ZWRUaW1lU3RlcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZVN0ZXA7XG4gIH1cblxuICBwcml2YXRlIGdhbWVMb29wKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGEgdGltZSBhbmQgY2xhbXAgaXQgdG8gcHJldmVudCBsYXJnZSBqdW1wc1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMCwgdGhpcy5tYXhGcmFtZVRpbWUpO1xuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnVwZGF0ZUZQUyhkZWx0YVRpbWUpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB0aW1lIGZvciBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YVRpbWU7XG5cbiAgICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZXNcbiAgICBsZXQgc3ViU3RlcHMgPSAwO1xuICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IHRoaXMuZml4ZWRUaW1lU3RlcCAmJiBzdWJTdGVwcyA8IHRoaXMubWF4U3ViU3RlcHMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZml4ZWRVcGRhdGUnLCB7IGZpeGVkRGVsdGFUaW1lOiB0aGlzLmZpeGVkVGltZVN0ZXAgfSk7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IHRoaXMuZml4ZWRUaW1lU3RlcDtcbiAgICAgIHN1YlN0ZXBzKys7XG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGUgdGltZXN0ZXAgZ2FtZSBsb2dpYyB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZGVsdGFUaW1lIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHRoaXMuYWNjdW11bGF0b3IgLyB0aGlzLmZpeGVkVGltZVN0ZXA7XG5cbiAgICAvLyBSZW5kZXIgd2l0aCBpbnRlcnBvbGF0aW9uXG4gICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcblxuICAgIC8vIFNjaGVkdWxlIG5leHQgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lTG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRlBTKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHNVcGRhdGVUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIC8vIFVwZGF0ZSBGUFMgZXZlcnkgc2Vjb25kXG4gICAgaWYgKHRoaXMuZnBzVXBkYXRlVGltZSA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3VycmVudEZQUyA9IE1hdGgucm91bmQodGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcHNVcGRhdGVUaW1lKTtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICB0aGlzLmZwc1VwZGF0ZVRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgdGltZSBmb3Igc3lzdGVtcyB0aGF0IG5lZWQgaXRcbiAgcHVibGljIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cblxuICAvLyBHZXQgYWNjdW11bGF0b3IgcmF0aW8gZm9yIGludGVycG9sYXRpb25cbiAgcHVibGljIGdldEludGVycG9sYXRpb25SYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yIC8gdGhpcy5maXhlZFRpbWVTdGVwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiR2FtZUxvb3AiLCJzdGFydCIsImlzUnVubmluZyIsImxhc3RUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhY2N1bXVsYXRvciIsImZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnYW1lTG9vcCIsImJpbmQiLCJzdG9wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRDdXJyZW50RlBTIiwiY3VycmVudEZQUyIsImdldEZpeGVkVGltZVN0ZXAiLCJmaXhlZFRpbWVTdGVwIiwiY3VycmVudFRpbWUiLCJkZWx0YVRpbWUiLCJNYXRoIiwibWluIiwibWF4RnJhbWVUaW1lIiwidXBkYXRlRlBTIiwic3ViU3RlcHMiLCJtYXhTdWJTdGVwcyIsImVtaXQiLCJmaXhlZERlbHRhVGltZSIsImludGVycG9sYXRpb24iLCJmcmFtZUNvdW50IiwiZnBzVXBkYXRlVGltZSIsInJvdW5kIiwicGF1c2UiLCJyZXN1bWUiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwiZ2V0SW50ZXJwb2xhdGlvblJhdGlvIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/GameLoop.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/InputManager.ts":
/*!**********************************!*\
  !*** ./src/core/InputManager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: function() { return /* binding */ InputManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Centralized input handling system\n\nclass InputManager extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initialize(canvas) {\n        this.canvas = canvas;\n        // Add canvas-specific event listeners to ensure we capture events\n        // that might be handled by React Three Fiber\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        canvas.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        canvas.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    // Don't automatically request pointer lock - let systems handle this\n    // canvas.addEventListener('click', () => {\n    //   if (!this.isPointerLocked) {\n    //     this.requestPointerLock();\n    //   }\n    // });\n    }\n    requestPointerLock() {\n        if (this.canvas) {\n            this.canvas.requestPointerLock();\n        }\n    }\n    exitPointerLock() {\n        document.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.keys.has(key.toLowerCase());\n    }\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    getMousePosition() {\n        return {\n            ...this.mousePosition\n        };\n    }\n    getMouseDelta() {\n        return {\n            ...this.mouseDelta\n        };\n    }\n    getInputState() {\n        return {\n            keys: new Set(this.keys),\n            mouse: {\n                x: this.mousePosition.x,\n                y: this.mousePosition.y,\n                deltaX: this.mouseDelta.x,\n                deltaY: this.mouseDelta.y,\n                buttons: new Set(this.mouseButtons)\n            }\n        };\n    }\n    checkDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return false;\n        const now = Date.now();\n        // Only return true if we have a valid double-tap sequence:\n        // 1. We have a valid first tap (press + release)\n        // 2. We're currently in a double-tap sequence\n        // 3. The second press happened within the threshold after the first release\n        if (timing.hasValidFirstTap && timing.isInDoubleTapSequence && timing.secondPressTime > 0) {\n            const timeBetweenTaps = timing.secondPressTime - timing.firstReleaseTime;\n            return timeBetweenTaps <= this.DOUBLE_TAP_THRESHOLD;\n        }\n        return false;\n    }\n    resetDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (timing) {\n            timing.firstPressTime = 0;\n            timing.firstReleaseTime = 0;\n            timing.secondPressTime = 0;\n            timing.isInDoubleTapSequence = false;\n            timing.hasValidFirstTap = false;\n        }\n    }\n    update() {\n        // Reset mouse delta each frame\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n        // Clean up old timing entries to prevent memory leaks\n        this.cleanupOldTimings();\n    }\n    cleanupOldTimings() {\n        const now = Date.now();\n        const CLEANUP_THRESHOLD = 5000; // 5 seconds\n        const keysToDelete = [];\n        // Use forEach instead of for...of to avoid ES2015 iteration issues\n        this.keyTimings.forEach((timing, key)=>{\n            // Remove entries that haven't been used in a while\n            const lastActivity = Math.max(timing.firstPressTime, timing.firstReleaseTime, timing.secondPressTime);\n            if (lastActivity > 0 && now - lastActivity > CLEANUP_THRESHOLD) {\n                keysToDelete.push(key);\n            }\n        });\n        // Delete the keys after iteration to avoid modifying map during iteration\n        keysToDelete.forEach((key)=>this.keyTimings.delete(key));\n    }\n    // Debug method to help track double tap detection\n    getDoubleTapDebugInfo(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return null;\n        const now = Date.now();\n        return {\n            key: keyLower,\n            firstPressTime: timing.firstPressTime,\n            firstReleaseTime: timing.firstReleaseTime,\n            secondPressTime: timing.secondPressTime,\n            hasValidFirstTap: timing.hasValidFirstTap,\n            isInDoubleTapSequence: timing.isInDoubleTapSequence,\n            timeSinceFirstPress: timing.firstPressTime > 0 ? now - timing.firstPressTime : 0,\n            timeSinceFirstRelease: timing.firstReleaseTime > 0 ? now - timing.firstReleaseTime : 0,\n            timeSinceSecondPress: timing.secondPressTime > 0 ? now - timing.secondPressTime : 0,\n            threshold: this.DOUBLE_TAP_THRESHOLD\n        };\n    }\n    setupEventListeners() {\n        // Keyboard events\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\n        // Mouse events\n        document.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        // Pointer lock events\n        document.addEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.addEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        // Prevent context menu\n        document.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n        // Handle window focus/blur to reset input state\n        window.addEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.addEventListener(\"focus\", this.onWindowFocus.bind(this));\n    }\n    onKeyDown(event) {\n        const key = event.key.toLowerCase();\n        if (!this.keys.has(key)) {\n            this.keys.add(key);\n            this.emit(\"keyDown\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key timing for double-tap detection\n            const now = Date.now();\n            let timing = this.keyTimings.get(key);\n            if (!timing) {\n                timing = {\n                    firstPressTime: 0,\n                    firstReleaseTime: 0,\n                    secondPressTime: 0,\n                    isInDoubleTapSequence: false,\n                    hasValidFirstTap: false\n                };\n                this.keyTimings.set(key, timing);\n            }\n            // Handle double-tap sequence logic\n            if (!timing.hasValidFirstTap) {\n                // This is the first press\n                timing.firstPressTime = now;\n                timing.isInDoubleTapSequence = false;\n                timing.hasValidFirstTap = false; // Will be set to true on release\n            } else if (timing.hasValidFirstTap && !timing.isInDoubleTapSequence) {\n                // This could be the second press - check if it's within threshold\n                const timeSinceFirstRelease = now - timing.firstReleaseTime;\n                if (timeSinceFirstRelease <= this.DOUBLE_TAP_THRESHOLD) {\n                    // Valid second press\n                    timing.secondPressTime = now;\n                    timing.isInDoubleTapSequence = true;\n                } else {\n                    // Too late for double-tap, treat as new first press\n                    timing.firstPressTime = now;\n                    timing.firstReleaseTime = 0;\n                    timing.secondPressTime = 0;\n                    timing.isInDoubleTapSequence = false;\n                    timing.hasValidFirstTap = false;\n                }\n            }\n        }\n        // Prevent default for game keys\n        if (this.isGameKey(key)) {\n            event.preventDefault();\n        }\n    }\n    onKeyUp(event) {\n        const key = event.key.toLowerCase();\n        if (this.keys.has(key)) {\n            this.keys.delete(key);\n            this.emit(\"keyUp\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key release timing for double-tap detection\n            const timing = this.keyTimings.get(key);\n            if (timing) {\n                const now = Date.now();\n                if (!timing.hasValidFirstTap && timing.firstPressTime > 0) {\n                    // This completes the first tap\n                    timing.firstReleaseTime = now;\n                    timing.hasValidFirstTap = true;\n                } else if (timing.isInDoubleTapSequence) {\n                    // This completes the double-tap sequence\n                    // The double-tap detection should have already been triggered\n                    // Reset for next potential sequence\n                    setTimeout(()=>{\n                        if (timing) {\n                            timing.firstPressTime = 0;\n                            timing.firstReleaseTime = 0;\n                            timing.secondPressTime = 0;\n                            timing.isInDoubleTapSequence = false;\n                            timing.hasValidFirstTap = false;\n                        }\n                    }, 100); // Small delay to allow dash system to process\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n        this.emit(\"mouseDown\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n        this.emit(\"mouseUp\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseMove(event) {\n        if (this.isPointerLocked) {\n            // Use movement deltas when pointer is locked\n            this.mouseDelta.x += event.movementX;\n            this.mouseDelta.y += event.movementY;\n        } else {\n            // Use absolute position when not locked\n            this.previousMousePosition.x = this.mousePosition.x;\n            this.previousMousePosition.y = this.mousePosition.y;\n            this.mousePosition.x = event.clientX;\n            this.mousePosition.y = event.clientY;\n            // Calculate delta from previous position\n            const deltaX = this.mousePosition.x - this.previousMousePosition.x;\n            const deltaY = this.mousePosition.y - this.previousMousePosition.y;\n            // Accumulate delta for this frame\n            this.mouseDelta.x += deltaX;\n            this.mouseDelta.y += deltaY;\n        }\n        this.emit(\"mouseMove\", {\n            x: this.mousePosition.x,\n            y: this.mousePosition.y,\n            deltaX: this.mouseDelta.x,\n            deltaY: this.mouseDelta.y\n        });\n    }\n    onWheel(event) {\n        this.emit(\"wheel\", {\n            deltaX: event.deltaX,\n            deltaY: event.deltaY,\n            deltaZ: event.deltaZ\n        });\n        event.preventDefault();\n    }\n    onPointerLockChange() {\n        this.isPointerLocked = document.pointerLockElement !== null;\n    }\n    onPointerLockError() {\n        // console.warn('Pointer lock failed');\n        this.isPointerLocked = false;\n    }\n    onWindowBlur() {\n        // Clear all input state when window loses focus\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n    }\n    onWindowFocus() {\n        // Reset mouse delta when window regains focus\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n    isGameKey(key) {\n        // Define which keys should have their default behavior prevented\n        const gameKeys = [\n            \"w\",\n            \"a\",\n            \"s\",\n            \"d\",\n            \" \",\n            \"shift\",\n            \"tab\",\n            \"escape\"\n        ];\n        return gameKeys.includes(key);\n    }\n    destroy() {\n        // Remove document event listeners\n        document.removeEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.removeEventListener(\"keyup\", this.onKeyUp.bind(this));\n        document.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        document.removeEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.removeEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        window.removeEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.removeEventListener(\"focus\", this.onWindowFocus.bind(this));\n        // Remove canvas event listeners if canvas exists\n        if (this.canvas) {\n            this.canvas.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n            this.canvas.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n            this.canvas.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n            this.canvas.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        }\n        // Clear state\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n        this.removeAllListeners();\n    }\n    constructor(){\n        super();\n        this.keys = new Set();\n        this.mouseButtons = new Set();\n        this.mousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.mouseDelta = {\n            x: 0,\n            y: 0\n        };\n        this.previousMousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.isPointerLocked = false;\n        this.canvas = null;\n        // Double-tap detection for dash system\n        this.keyTimings = new Map();\n        this.DOUBLE_TAP_THRESHOLD = 200 // 200ms window for double-tap (reduced from 250ms)\n        ;\n        this.setupEventListeners();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUFvQztBQUNnQjtBQXNCN0MsTUFBTUMscUJBQXFCRCw2REFBWUE7SUF3QnJDRSxXQUFXQyxNQUF5QixFQUFRO1FBQ2pELElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUVkLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0NBLE9BQU9DLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQy9ESCxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ0csU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMzREgsT0FBT0MsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNJLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDL0RILE9BQU9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDSyxPQUFPLENBQUNILElBQUksQ0FBQyxJQUFJLEdBQUc7WUFBRUksU0FBUztRQUFNO1FBQzNFUCxPQUFPQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUNPLElBQU1BLEVBQUVDLGNBQWM7SUFFOUQscUVBQXFFO0lBQ3JFLDJDQUEyQztJQUMzQyxpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU07SUFDTixNQUFNO0lBQ1I7SUFFT0MscUJBQTJCO1FBQ2hDLElBQUksSUFBSSxDQUFDVixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ1Usa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFT0Msa0JBQXdCO1FBQzdCQyxTQUFTRCxlQUFlO0lBQzFCO0lBRU9FLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxHQUFHLENBQUNGLElBQUlHLFdBQVc7SUFDdEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0osR0FB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Q1ksSUFBSSxDQUFDdUUsS0FBSztRQUNmLElBQUksQ0FBQ2xFLFlBQVksQ0FBQ2tFLEtBQUs7UUFDdkIsSUFBSSxDQUFDbEQsVUFBVSxDQUFDa0QsS0FBSztRQUNyQixJQUFJLENBQUNLLGtCQUFrQjtJQUN6QjtJQXBYQUMsYUFBYztRQUNaLEtBQUs7YUFuQkM3RSxPQUFPLElBQUlXO2FBQ1hOLGVBQWUsSUFBSU07YUFDbkJKLGdCQUFnQjtZQUFFTSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUM3QkwsYUFBYTtZQUFFSSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUMxQnNELHdCQUF3QjtZQUFFdkQsR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDckNtRCxrQkFBa0I7YUFDbEJoRixTQUFtQztRQUUzQyx1Q0FBdUM7YUFDL0JvQyxhQUFhLElBQUl5RDthQU9SaEQsdUJBQXVCLElBQUssbURBQW1EOztRQUk5RixJQUFJLENBQUNrQixtQkFBbUI7SUFDMUI7QUFrWEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvSW5wdXRNYW5hZ2VyLnRzPzBkMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VudHJhbGl6ZWQgaW5wdXQgaGFuZGxpbmcgc3lzdGVtXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRFdmVudHMge1xuICBrZXlEb3duOiB7IGtleTogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfTtcbiAga2V5VXA6IHsga2V5OiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9O1xuICBtb3VzZURvd246IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlVXA6IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlTW92ZTogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgZGVsdGFYOiBudW1iZXI7IGRlbHRhWTogbnVtYmVyIH07XG4gIHdoZWVsOiB7IGRlbHRhWDogbnVtYmVyOyBkZWx0YVk6IG51bWJlcjsgZGVsdGFaOiBudW1iZXIgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dFN0YXRlIHtcbiAga2V5czogU2V0PHN0cmluZz47XG4gIG1vdXNlOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBkZWx0YVg6IG51bWJlcjtcbiAgICBkZWx0YVk6IG51bWJlcjtcbiAgICBidXR0b25zOiBTZXQ8bnVtYmVyPjtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIElucHV0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUga2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIG1vdXNlQnV0dG9ucyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBwcml2YXRlIG1vdXNlUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgcHJpdmF0ZSBtb3VzZURlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgcHJldmlvdXNNb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8vIERvdWJsZS10YXAgZGV0ZWN0aW9uIGZvciBkYXNoIHN5c3RlbVxuICBwcml2YXRlIGtleVRpbWluZ3MgPSBuZXcgTWFwPHN0cmluZywgeyBcbiAgICBmaXJzdFByZXNzVGltZTogbnVtYmVyO1xuICAgIGZpcnN0UmVsZWFzZVRpbWU6IG51bWJlcjtcbiAgICBzZWNvbmRQcmVzc1RpbWU6IG51bWJlcjtcbiAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IGJvb2xlYW47XG4gICAgaGFzVmFsaWRGaXJzdFRhcDogYm9vbGVhbjtcbiAgfT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBET1VCTEVfVEFQX1RIUkVTSE9MRCA9IDIwMDsgLy8gMjAwbXMgd2luZG93IGZvciBkb3VibGUtdGFwIChyZWR1Y2VkIGZyb20gMjUwbXMpXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICBcbiAgICAvLyBBZGQgY2FudmFzLXNwZWNpZmljIGV2ZW50IGxpc3RlbmVycyB0byBlbnN1cmUgd2UgY2FwdHVyZSBldmVudHNcbiAgICAvLyB0aGF0IG1pZ2h0IGJlIGhhbmRsZWQgYnkgUmVhY3QgVGhyZWUgRmliZXJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbC5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIFxuICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgcmVxdWVzdCBwb2ludGVyIGxvY2sgLSBsZXQgc3lzdGVtcyBoYW5kbGUgdGhpc1xuICAgIC8vIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAvLyAgIGlmICghdGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAvLyAgICAgdGhpcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1ZXN0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZXhpdFBvaW50ZXJMb2NrKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICB9XG5cbiAgcHVibGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmtleXMuaGFzKGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc01vdXNlQnV0dG9uUHJlc3NlZChidXR0b246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1vdXNlQnV0dG9ucy5oYXMoYnV0dG9uKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb3VzZVBvc2l0aW9uIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMubW91c2VEZWx0YSB9O1xuICB9XG5cbiAgcHVibGljIGdldElucHV0U3RhdGUoKTogSW5wdXRTdGF0ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IG5ldyBTZXQodGhpcy5rZXlzKSxcbiAgICAgIG1vdXNlOiB7XG4gICAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgICB5OiB0aGlzLm1vdXNlUG9zaXRpb24ueSxcbiAgICAgICAgZGVsdGFYOiB0aGlzLm1vdXNlRGVsdGEueCxcbiAgICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICAgICAgYnV0dG9uczogbmV3IFNldCh0aGlzLm1vdXNlQnV0dG9ucyksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgY2hlY2tEb3VibGVUYXAoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIE9ubHkgcmV0dXJuIHRydWUgaWYgd2UgaGF2ZSBhIHZhbGlkIGRvdWJsZS10YXAgc2VxdWVuY2U6XG4gICAgLy8gMS4gV2UgaGF2ZSBhIHZhbGlkIGZpcnN0IHRhcCAocHJlc3MgKyByZWxlYXNlKVxuICAgIC8vIDIuIFdlJ3JlIGN1cnJlbnRseSBpbiBhIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAvLyAzLiBUaGUgc2Vjb25kIHByZXNzIGhhcHBlbmVkIHdpdGhpbiB0aGUgdGhyZXNob2xkIGFmdGVyIHRoZSBmaXJzdCByZWxlYXNlXG4gICAgaWYgKHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwICYmIFxuICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlICYmIFxuICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID4gMCkge1xuICAgICAgXG4gICAgICBjb25zdCB0aW1lQmV0d2VlblRhcHMgPSB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lIC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWU7XG4gICAgICByZXR1cm4gdGltZUJldHdlZW5UYXBzIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldERvdWJsZVRhcChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXlMb3dlcik7XG4gICAgaWYgKHRpbWluZykge1xuICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lID0gMDtcbiAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gMDtcbiAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIGVhY2ggZnJhbWVcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIG9sZCB0aW1pbmcgZW50cmllcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgIHRoaXMuY2xlYW51cE9sZFRpbWluZ3MoKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBjbGVhbnVwT2xkVGltaW5ncygpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IENMRUFOVVBfVEhSRVNIT0xEID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSBmb3JFYWNoIGluc3RlYWQgb2YgZm9yLi4ub2YgdG8gYXZvaWQgRVMyMDE1IGl0ZXJhdGlvbiBpc3N1ZXNcbiAgICB0aGlzLmtleVRpbWluZ3MuZm9yRWFjaCgodGltaW5nLCBrZXkpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgaW4gYSB3aGlsZVxuICAgICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gTWF0aC5tYXgoXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSwgXG4gICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLCBcbiAgICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGxhc3RBY3Rpdml0eSA+IDAgJiYgbm93IC0gbGFzdEFjdGl2aXR5ID4gQ0xFQU5VUF9USFJFU0hPTEQpIHtcbiAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIGtleXMgYWZ0ZXIgaXRlcmF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyBtYXAgZHVyaW5nIGl0ZXJhdGlvblxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiB0aGlzLmtleVRpbWluZ3MuZGVsZXRlKGtleSkpO1xuICB9XG4gIFxuICAvLyBEZWJ1ZyBtZXRob2QgdG8gaGVscCB0cmFjayBkb3VibGUgdGFwIGRldGVjdGlvblxuICBwdWJsaWMgZ2V0RG91YmxlVGFwRGVidWdJbmZvKGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleUxvd2VyLFxuICAgICAgZmlyc3RQcmVzc1RpbWU6IHRpbWluZy5maXJzdFByZXNzVGltZSxcbiAgICAgIGZpcnN0UmVsZWFzZVRpbWU6IHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLFxuICAgICAgc2Vjb25kUHJlc3NUaW1lOiB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lLFxuICAgICAgaGFzVmFsaWRGaXJzdFRhcDogdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAsXG4gICAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UsXG4gICAgICB0aW1lU2luY2VGaXJzdFByZXNzOiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UHJlc3NUaW1lIDogMCxcbiAgICAgIHRpbWVTaW5jZUZpcnN0UmVsZWFzZTogdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgOiAwLFxuICAgICAgdGltZVNpbmNlU2Vjb25kUHJlc3M6IHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLnNlY29uZFByZXNzVGltZSA6IDAsXG4gICAgICB0aHJlc2hvbGQ6IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTERcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIEtleWJvYXJkIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIC8vIFBvaW50ZXIgbG9jayBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Qb2ludGVyTG9ja0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2Vycm9yJywgdGhpcy5vblBvaW50ZXJMb2NrRXJyb3IuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBQcmV2ZW50IGNvbnRleHQgbWVudVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IGZvY3VzL2JsdXIgdG8gcmVzZXQgaW5wdXQgc3RhdGVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKCF0aGlzLmtleXMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMua2V5cy5hZGQoa2V5KTtcbiAgICAgIHRoaXMuZW1pdCgna2V5RG93bicsIHsga2V5OiBldmVudC5rZXksIGNvZGU6IGV2ZW50LmNvZGUgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGtleSB0aW1pbmcgZm9yIGRvdWJsZS10YXAgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5KTtcbiAgICAgIFxuICAgICAgaWYgKCF0aW1pbmcpIHtcbiAgICAgICAgdGltaW5nID0geyBcbiAgICAgICAgICBmaXJzdFByZXNzVGltZTogMCwgXG4gICAgICAgICAgZmlyc3RSZWxlYXNlVGltZTogMCwgXG4gICAgICAgICAgc2Vjb25kUHJlc3NUaW1lOiAwLFxuICAgICAgICAgIGlzSW5Eb3VibGVUYXBTZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgaGFzVmFsaWRGaXJzdFRhcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXlUaW1pbmdzLnNldChrZXksIHRpbWluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBkb3VibGUtdGFwIHNlcXVlbmNlIGxvZ2ljXG4gICAgICBpZiAoIXRpbWluZy5oYXNWYWxpZEZpcnN0VGFwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHByZXNzXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSA9IG5vdztcbiAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlOyAvLyBXaWxsIGJlIHNldCB0byB0cnVlIG9uIHJlbGVhc2VcbiAgICAgIH0gZWxzZSBpZiAodGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgIXRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSB0aGUgc2Vjb25kIHByZXNzIC0gY2hlY2sgaWYgaXQncyB3aXRoaW4gdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0UmVsZWFzZSA9IG5vdyAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lO1xuICAgICAgICBpZiAodGltZVNpbmNlRmlyc3RSZWxlYXNlIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBWYWxpZCBzZWNvbmQgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvbyBsYXRlIGZvciBkb3VibGUtdGFwLCB0cmVhdCBhcyBuZXcgZmlyc3QgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSBub3c7XG4gICAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGZvciBnYW1lIGtleXNcbiAgICBpZiAodGhpcy5pc0dhbWVLZXkoa2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBpZiAodGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmtleXMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2tleVVwJywgeyBrZXk6IGV2ZW50LmtleSwgY29kZTogZXZlbnQuY29kZSB9KTtcblxuICAgICAgLy8gVHJhY2sga2V5IHJlbGVhc2UgdGltaW5nIGZvciBkb3VibGUtdGFwIGRldGVjdGlvblxuICAgICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXkpO1xuICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCAmJiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGZpcnN0IHRhcFxuICAgICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAgICAgICAvLyBUaGUgZG91YmxlLXRhcCBkZXRlY3Rpb24gc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgIC8vIFJlc2V0IGZvciBuZXh0IHBvdGVudGlhbCBzZXF1ZW5jZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IDA7XG4gICAgICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gYWxsb3cgZGFzaCBzeXN0ZW0gdG8gcHJvY2Vzc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMubW91c2VCdXR0b25zLmFkZChldmVudC5idXR0b24pO1xuICAgIHRoaXMuZW1pdCgnbW91c2VEb3duJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZVVwKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuZGVsZXRlKGV2ZW50LmJ1dHRvbik7XG4gICAgdGhpcy5lbWl0KCdtb3VzZVVwJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAgIC8vIFVzZSBtb3ZlbWVudCBkZWx0YXMgd2hlbiBwb2ludGVyIGlzIGxvY2tlZFxuICAgICAgdGhpcy5tb3VzZURlbHRhLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgdGhpcy5tb3VzZURlbHRhLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgYWJzb2x1dGUgcG9zaXRpb24gd2hlbiBub3QgbG9ja2VkXG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi54ID0gdGhpcy5tb3VzZVBvc2l0aW9uLng7XG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi55ID0gdGhpcy5tb3VzZVBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YSBmcm9tIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1vdXNlUG9zaXRpb24ueCAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLng7XG4gICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1vdXNlUG9zaXRpb24ueSAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIC8vIEFjY3VtdWxhdGUgZGVsdGEgZm9yIHRoaXMgZnJhbWVcbiAgICAgIHRoaXMubW91c2VEZWx0YS54ICs9IGRlbHRhWDtcbiAgICAgIHRoaXMubW91c2VEZWx0YS55ICs9IGRlbHRhWTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ21vdXNlTW92ZScsIHtcbiAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnksXG4gICAgICBkZWx0YVg6IHRoaXMubW91c2VEZWx0YS54LFxuICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25XaGVlbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnd2hlZWwnLCB7XG4gICAgICBkZWx0YVg6IGV2ZW50LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuICAgICAgZGVsdGFaOiBldmVudC5kZWx0YVosXG4gICAgfSk7XG4gICAgXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0NoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUG9pbnRlckxvY2tlZCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAhPT0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0Vycm9yKCk6IHZvaWQge1xuICAgIC8vIGNvbnNvbGUud2FybignUG9pbnRlciBsb2NrIGZhaWxlZCcpO1xuICAgIHRoaXMuaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uV2luZG93Qmx1cigpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbGwgaW5wdXQgc3RhdGUgd2hlbiB3aW5kb3cgbG9zZXMgZm9jdXNcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldpbmRvd0ZvY3VzKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIHdoZW4gd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0dhbWVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBEZWZpbmUgd2hpY2gga2V5cyBzaG91bGQgaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIHByZXZlbnRlZFxuICAgIGNvbnN0IGdhbWVLZXlzID0gWyd3JywgJ2EnLCAncycsICdkJywgJyAnLCAnc2hpZnQnLCAndGFiJywgJ2VzY2FwZSddO1xuICAgIHJldHVybiBnYW1lS2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vblBvaW50ZXJMb2NrQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrZXJyb3InLCB0aGlzLm9uUG9pbnRlckxvY2tFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFJlbW92ZSBjYW52YXMgZXZlbnQgbGlzdGVuZXJzIGlmIGNhbnZhcyBleGlzdHNcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhdGVcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJJbnB1dE1hbmFnZXIiLCJpbml0aWFsaXplIiwiY2FudmFzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VEb3duIiwiYmluZCIsIm9uTW91c2VVcCIsIm9uTW91c2VNb3ZlIiwib25XaGVlbCIsInBhc3NpdmUiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZXF1ZXN0UG9pbnRlckxvY2siLCJleGl0UG9pbnRlckxvY2siLCJkb2N1bWVudCIsImlzS2V5UHJlc3NlZCIsImtleSIsImtleXMiLCJoYXMiLCJ0b0xvd2VyQ2FzZSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwibW91c2VCdXR0b25zIiwiZ2V0TW91c2VQb3NpdGlvbiIsIm1vdXNlUG9zaXRpb24iLCJnZXRNb3VzZURlbHRhIiwibW91c2VEZWx0YSIsImdldElucHV0U3RhdGUiLCJTZXQiLCJtb3VzZSIsIngiLCJ5IiwiZGVsdGFYIiwiZGVsdGFZIiwiYnV0dG9ucyIsImNoZWNrRG91YmxlVGFwIiwia2V5TG93ZXIiLCJ0aW1pbmciLCJrZXlUaW1pbmdzIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImhhc1ZhbGlkRmlyc3RUYXAiLCJpc0luRG91YmxlVGFwU2VxdWVuY2UiLCJzZWNvbmRQcmVzc1RpbWUiLCJ0aW1lQmV0d2VlblRhcHMiLCJmaXJzdFJlbGVhc2VUaW1lIiwiRE9VQkxFX1RBUF9USFJFU0hPTEQiLCJyZXNldERvdWJsZVRhcCIsImZpcnN0UHJlc3NUaW1lIiwidXBkYXRlIiwiY2xlYW51cE9sZFRpbWluZ3MiLCJDTEVBTlVQX1RIUkVTSE9MRCIsImtleXNUb0RlbGV0ZSIsImZvckVhY2giLCJsYXN0QWN0aXZpdHkiLCJNYXRoIiwibWF4IiwicHVzaCIsImRlbGV0ZSIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsInRpbWVTaW5jZUZpcnN0UHJlc3MiLCJ0aW1lU2luY2VGaXJzdFJlbGVhc2UiLCJ0aW1lU2luY2VTZWNvbmRQcmVzcyIsInRocmVzaG9sZCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJvbktleURvd24iLCJvbktleVVwIiwib25Qb2ludGVyTG9ja0NoYW5nZSIsIm9uUG9pbnRlckxvY2tFcnJvciIsIndpbmRvdyIsIm9uV2luZG93Qmx1ciIsIm9uV2luZG93Rm9jdXMiLCJldmVudCIsImFkZCIsImVtaXQiLCJjb2RlIiwic2V0IiwiaXNHYW1lS2V5Iiwic2V0VGltZW91dCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNQb2ludGVyTG9ja2VkIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwicHJldmlvdXNNb3VzZVBvc2l0aW9uIiwiZGVsdGFaIiwicG9pbnRlckxvY2tFbGVtZW50IiwiY2xlYXIiLCJnYW1lS2V5cyIsImluY2x1ZGVzIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjb25zdHJ1Y3RvciIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/InputManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/Entity.ts":
/*!***************************!*\
  !*** ./src/ecs/Entity.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ Component; },\n/* harmony export */   Entity: function() { return /* binding */ Entity; }\n/* harmony export */ });\n// Entity Component System - Entity Management\nclass Entity {\n    addComponent(component) {\n        // Use explicit componentType if available, fallback to constructor name\n        const componentName = component.componentType || component.constructor.name;\n        this.components.set(componentName, component);\n        return component;\n    }\n    removeComponent(componentType) {\n        this.components.delete(componentType.name);\n    }\n    getComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        let component = this.components.get(requestedType);\n        // If not found with explicit type, try searching by constructor name as fallback\n        if (!component && componentType.componentType) {\n            component = this.components.get(componentType.name);\n            if (component) {}\n        }\n        // If still not found, search through all components to find a match by type\n        if (!component) {\n            const entries = Array.from(this.components.entries());\n            for (const [key, comp] of entries){\n                if (comp instanceof componentType) {\n                    // Reduce spam - only log occasionally for instanceof fallback usage\n                    if (Math.random() < 0.01) {}\n                    component = comp;\n                    break;\n                }\n            }\n        }\n        if (component) {\n            const actualType = component.componentType || component.constructor.name;\n            if (actualType !== requestedType && !component.constructor.name.match(/^[a-z]$/)) {\n            // Only warn if it's not a minified single-letter class name\n            }\n        } else {\n            // Reduce spam - only log occasionally for missing components\n            if (Math.random() < 0.001) {}\n        }\n        return component;\n    }\n    hasComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        // Check with explicit type first\n        if (this.components.has(requestedType)) {\n            return true;\n        }\n        // If not found with explicit type, try constructor name as fallback\n        if (componentType.componentType && this.components.has(componentType.name)) {\n            return true;\n        }\n        // If still not found, search through all components to find a match by type\n        const components = Array.from(this.components.values());\n        for (const comp of components){\n            if (comp instanceof componentType) {\n                return true;\n            }\n        }\n        return false;\n    }\n    hasComponents(componentTypes) {\n        return componentTypes.every((type)=>this.hasComponent(type));\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getComponentNames() {\n        return Array.from(this.components.keys());\n    }\n    isActive() {\n        return this.active;\n    }\n    setActive(active) {\n        this.active = active;\n    }\n    destroy() {\n        this.components.clear();\n        this.active = false;\n    }\n    constructor(){\n        this.components = new Map();\n        this.active = true;\n        this.id = Entity.nextId++;\n    }\n}\nEntity.nextId = 1;\nclass Component {\n    constructor(){\n        this.enabled = true;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBRU9DLFdBQW9CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDQyxNQUFNO0lBQ3BCO0lBRU9DLFVBQVVELE1BQWUsRUFBUTtRQUN0QyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7SUFDaEI7SUFFT0UsVUFBZ0I7UUFDckIsSUFBSSxDQUFDN0IsVUFBVSxDQUFDOEIsS0FBSztRQUNyQixJQUFJLENBQUNILE1BQU0sR0FBRztJQUNoQjtJQXZHQTdCLGFBQWM7YUFITkUsYUFBYSxJQUFJK0I7YUFDakJKLFNBQVM7UUFHZixJQUFJLENBQUNLLEVBQUUsR0FBR3ZDLE9BQU93QyxNQUFNO0lBQ3pCO0FBc0dGO0FBOUdheEMsT0FDSXdDLFNBQW1CO0FBK0c3QixNQUFlQzs7YUFDYkMsVUFBVTs7QUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9FbnRpdHkudHM/NWYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEVudGl0eSBNYW5hZ2VtZW50XG5leHBvcnQgdHlwZSBFbnRpdHlJZCA9IG51bWJlcjtcblxuZXhwb3J0IGNsYXNzIEVudGl0eSB7XG4gIHByaXZhdGUgc3RhdGljIG5leHRJZDogRW50aXR5SWQgPSAxO1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IEVudGl0eUlkO1xuICBwcml2YXRlIGNvbXBvbmVudHMgPSBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50PigpO1xuICBwcml2YXRlIGFjdGl2ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IEVudGl0eS5uZXh0SWQrKztcbiAgfVxuXG4gIHB1YmxpYyBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50OiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IChjb21wb25lbnQgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50VHlwZTogbmV3ICgpID0+IFQpOiBUIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgY29tcG9uZW50VHlwZSBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGNvbnN0cnVjdG9yIG5hbWVcbiAgICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICBsZXQgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzLmdldChyZXF1ZXN0ZWRUeXBlKTtcbiAgICBcbiAgICAvLyBJZiBub3QgZm91bmQgd2l0aCBleHBsaWNpdCB0eXBlLCB0cnkgc2VhcmNoaW5nIGJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoIWNvbXBvbmVudCAmJiAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50cy5nZXQoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgc3RpbGwgbm90IGZvdW5kLCBzZWFyY2ggdGhyb3VnaCBhbGwgY29tcG9uZW50cyB0byBmaW5kIGEgbWF0Y2ggYnkgdHlwZVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMuZW50cmllcygpKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgY29tcF0gb2YgZW50cmllcykge1xuICAgICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgaW5zdGFuY2VvZiBmYWxsYmFjayB1c2FnZVxuICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkgeyAvLyBPbmx5IGxvZyAxJSBvZiB0aGUgdGltZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSAoY29tcG9uZW50IGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChhY3R1YWxUeXBlICE9PSByZXF1ZXN0ZWRUeXBlICYmICFjb21wb25lbnQuY29uc3RydWN0b3IubmFtZS5tYXRjaCgvXlthLXpdJC8pKSB7XG4gICAgICAgIC8vIE9ubHkgd2FybiBpZiBpdCdzIG5vdCBhIG1pbmlmaWVkIHNpbmdsZS1sZXR0ZXIgY2xhc3MgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgbWlzc2luZyBjb21wb25lbnRzXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDAxKSB7IC8vIE9ubHkgbG9nIDAuMSUgb2YgdGhlIHRpbWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbXBvbmVudCBhcyBUO1xuICB9XG5cbiAgcHVibGljIGhhc0NvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IGJvb2xlYW4ge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IHJlcXVlc3RlZFR5cGUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIENoZWNrIHdpdGggZXhwbGljaXQgdHlwZSBmaXJzdFxuICAgIGlmICh0aGlzLmNvbXBvbmVudHMuaGFzKHJlcXVlc3RlZFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm90IGZvdW5kIHdpdGggZXhwbGljaXQgdHlwZSwgdHJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlICYmIHRoaXMuY29tcG9uZW50cy5oYXMoY29tcG9uZW50VHlwZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgc2VhcmNoIHRocm91Z2ggYWxsIGNvbXBvbmVudHMgdG8gZmluZCBhIG1hdGNoIGJ5IHR5cGVcbiAgICBjb25zdCBjb21wb25lbnRzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wb25lbnRzKSB7XG4gICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzOiAobmV3ICgpID0+IENvbXBvbmVudClbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjb21wb25lbnRUeXBlcy5ldmVyeSh0eXBlID0+IHRoaXMuaGFzQ29tcG9uZW50KHR5cGUpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICB9XG5cbiAgcHVibGljIGdldENvbXBvbmVudE5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMua2V5cygpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gIH1cblxuICBwdWJsaWMgc2V0QWN0aXZlKGFjdGl2ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jb21wb25lbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcbiAgcHVibGljIGVuYWJsZWQgPSB0cnVlO1xuICBcbiAgcHVibGljIGFic3RyYWN0IHJlc2V0KCk6IHZvaWQ7IC8vIEZvciBvYmplY3QgcG9vbGluZ1xufVxuIl0sIm5hbWVzIjpbIkVudGl0eSIsImFkZENvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbXBvbmVudE5hbWUiLCJjb21wb25lbnRUeXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29tcG9uZW50cyIsInNldCIsInJlbW92ZUNvbXBvbmVudCIsImRlbGV0ZSIsImdldENvbXBvbmVudCIsInJlcXVlc3RlZFR5cGUiLCJnZXQiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwia2V5IiwiY29tcCIsIk1hdGgiLCJyYW5kb20iLCJhY3R1YWxUeXBlIiwibWF0Y2giLCJoYXNDb21wb25lbnQiLCJoYXMiLCJ2YWx1ZXMiLCJoYXNDb21wb25lbnRzIiwiY29tcG9uZW50VHlwZXMiLCJldmVyeSIsInR5cGUiLCJnZXRBbGxDb21wb25lbnRzIiwiZ2V0Q29tcG9uZW50TmFtZXMiLCJrZXlzIiwiaXNBY3RpdmUiLCJhY3RpdmUiLCJzZXRBY3RpdmUiLCJkZXN0cm95IiwiY2xlYXIiLCJNYXAiLCJpZCIsIm5leHRJZCIsIkNvbXBvbmVudCIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/Entity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/System.ts":
/*!***************************!*\
  !*** ./src/ecs/System.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; },\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; },\n/* harmony export */   System: function() { return /* binding */ System; }\n/* harmony export */ });\n// Entity Component System - Base System Classes\nclass System {\n    matchesEntity(entity) {\n        return entity.isActive() && entity.hasComponents(this.requiredComponents);\n    }\n    constructor(){\n        this.enabled = true;\n        this.priority = 0 // Lower numbers run first\n        ;\n    }\n}\nclass RenderSystem extends System {\n}\nclass PhysicsSystem extends System {\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUd6QyxNQUFlQTtJQU9iQyxjQUFjQyxNQUFjLEVBQVc7UUFDNUMsT0FBT0EsT0FBT0MsUUFBUSxNQUFNRCxPQUFPRSxhQUFhLENBQUMsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7O2FBUE9DLFVBQVU7YUFDVkMsV0FBVyxFQUFHLDBCQUEwQjs7O0FBWWpEO0FBRU8sTUFBZUMscUJBQXFCUjtBQUUzQztBQUVPLE1BQWVTLHNCQUFzQlQ7QUFFNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9TeXN0ZW0udHM/YTgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEJhc2UgU3lzdGVtIENsYXNzZXNcbmltcG9ydCB7IEVudGl0eSwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50czogKG5ldyAoKSA9PiBDb21wb25lbnQpW107XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgcHVibGljIHByaW9yaXR5ID0gMDsgLy8gTG93ZXIgbnVtYmVycyBydW4gZmlyc3RcblxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkO1xuXG4gIHB1YmxpYyBtYXRjaGVzRW50aXR5KGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKHRoaXMucmVxdWlyZWRDb21wb25lbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkPyhlbnRpdHk6IEVudGl0eSk6IHZvaWQ7XG4gIHB1YmxpYyBvbkVudGl0eVJlbW92ZWQ/KGVudGl0eTogRW50aXR5KTogdm9pZDtcbiAgcHVibGljIG9uRW5hYmxlPygpOiB2b2lkO1xuICBwdWJsaWMgb25EaXNhYmxlPygpOiB2b2lkO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgYWJzdHJhY3QgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJtYXRjaGVzRW50aXR5IiwiZW50aXR5IiwiaXNBY3RpdmUiLCJoYXNDb21wb25lbnRzIiwicmVxdWlyZWRDb21wb25lbnRzIiwiZW5hYmxlZCIsInByaW9yaXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/System.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/World.ts":
/*!**************************!*\
  !*** ./src/ecs/World.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: function() { return /* binding */ World; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Entity Component System - World Management\n\n\n\nclass World {\n    // Entity management\n    createEntity() {\n        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity();\n        this.entities.set(entity.id, entity);\n        return entity;\n    }\n    destroyEntity(entityId) {\n        this.entitiesToDestroy.push(entityId);\n    }\n    // Notify systems that an entity has been fully configured and is ready\n    notifyEntityAdded(entity) {\n        for (const system of this.systems){\n            if (system.onEntityAdded && system.matchesEntity(entity)) {\n                system.onEntityAdded(entity);\n            }\n        }\n    }\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    // System management\n    addSystem(system) {\n        var _system_onEnable;\n        this.systems.push(system);\n        this.systems.sort((a, b)=>a.priority - b.priority);\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem) {\n            this.renderSystems.push(system);\n        }\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem) {\n            this.physicsSystems.push(system);\n        }\n        (_system_onEnable = system.onEnable) === null || _system_onEnable === void 0 ? void 0 : _system_onEnable.call(system);\n    }\n    getSystem(systemClass) {\n        return this.systems.find((system)=>system instanceof systemClass);\n    }\n    removeSystem(systemType) {\n        const index = this.systems.findIndex((s)=>s instanceof systemType);\n        if (index !== -1) {\n            var _system_onDisable;\n            const system = this.systems[index];\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n            this.systems.splice(index, 1);\n            // Remove from specialized arrays\n            const renderIndex = this.renderSystems.findIndex((s)=>s === system);\n            if (renderIndex !== -1) this.renderSystems.splice(renderIndex, 1);\n            const physicsIndex = this.physicsSystems.findIndex((s)=>s === system);\n            if (physicsIndex !== -1) this.physicsSystems.splice(physicsIndex, 1);\n        }\n    }\n    // Component pooling for performance\n    createComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const typeName = componentType.componentType || componentType.name;\n        // Disable pooling for components that have prototype method issues in production\n        const problematicComponents = [\n            \"Health\",\n            \"HealthBar\",\n            \"Transform\",\n            \"Movement\",\n            \"Collider\",\n            \"Renderer\",\n            \"Enemy\",\n            \"Projectile\",\n            \"Animation\"\n        ];\n        if (problematicComponents.includes(typeName)) {\n            return new componentType();\n        }\n        let pool = this.componentPools.get(typeName);\n        if (!pool) {\n            pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__.ObjectPool(()=>new componentType(), (obj)=>obj.reset(), 100);\n            this.componentPools.set(typeName, pool);\n        }\n        return pool.acquire();\n    }\n    returnComponent(component) {\n        const pool = this.componentPools.get(component.constructor.name);\n        if (pool) {\n            pool.release(component);\n        }\n    }\n    // Main update loop\n    update(deltaTime) {\n        // Clean up destroyed entities\n        this.cleanupDestroyedEntities();\n        // Update all systems\n        for (const system of this.systems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.update(matchingEntities, deltaTime);\n        }\n    }\n    // Fixed timestep physics update\n    fixedUpdate(fixedDeltaTime) {\n        for (const system of this.physicsSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.fixedUpdate(matchingEntities, fixedDeltaTime);\n        }\n    }\n    // Render update\n    render(deltaTime) {\n        for (const system of this.renderSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.render(matchingEntities, deltaTime);\n        }\n    }\n    // Get entities that match a system's requirements\n    getEntitiesForSystem(system) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (system.matchesEntity(entity)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Clean up destroyed entities\n    cleanupDestroyedEntities() {\n        for (const entityId of this.entitiesToDestroy){\n            const entity = this.entities.get(entityId);\n            if (entity) {\n                // Notify systems about entity removal\n                for (const system of this.systems){\n                    if (system.onEntityRemoved && system.matchesEntity(entity)) {\n                        system.onEntityRemoved(entity);\n                    }\n                }\n                // Return components to pools\n                for (const component of entity.getAllComponents()){\n                    this.returnComponent(component);\n                }\n                entity.destroy();\n                this.entities.delete(entityId);\n            }\n        }\n        this.entitiesToDestroy.length = 0;\n    }\n    // Query entities by components\n    queryEntities(componentTypes) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (entity.isActive() && entity.hasComponents(componentTypes)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Event system\n    emitEvent(eventType, eventData) {\n        if (!this.events.has(eventType)) {\n            this.events.set(eventType, []);\n        }\n        this.events.get(eventType).push(eventData);\n    }\n    getEvents(eventType) {\n        return this.events.get(eventType) || [];\n    }\n    clearEvents(eventType) {\n        this.events.set(eventType, []);\n    }\n    destroy() {\n        // Clean up all entities\n        for (const entity of Array.from(this.entities.values())){\n            entity.destroy();\n        }\n        this.entities.clear();\n        // Clean up systems\n        for (const system of this.systems){\n            var _system_onDisable;\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n        }\n        this.systems.length = 0;\n        this.renderSystems.length = 0;\n        this.physicsSystems.length = 0;\n        // Clear component pools\n        this.componentPools.clear();\n        // Clear events\n        this.events.clear();\n    }\n    constructor(){\n        this.entities = new Map();\n        this.systems = [];\n        this.renderSystems = [];\n        this.physicsSystems = [];\n        this.componentPools = new Map();\n        this.entitiesToDestroy = [];\n        this.events = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLE9BQU8sQ0FBRTtnQkFDakNEO2FBQUFBLG9CQUFBQSxPQUFPMEIsU0FBUyxjQUFoQjFCLHdDQUFBQSx1QkFBQUE7UUFDRjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxDQUFDeUQsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQzNDLGFBQWEsQ0FBQzJDLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUMxQyxjQUFjLENBQUMwQyxNQUFNLEdBQUc7UUFFN0Isd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ3JCLGNBQWMsQ0FBQ2lDLEtBQUs7UUFFekIsZUFBZTtRQUNmLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxLQUFLO0lBQ25COzthQTNOUTlFLFdBQVcsSUFBSStFO2FBQ2Z0RSxVQUFvQixFQUFFO2FBQ3RCYyxnQkFBZ0MsRUFBRTthQUNsQ0MsaUJBQWtDLEVBQUU7YUFDcENxQixpQkFBaUIsSUFBSWtDO2FBQ3JCMUUsb0JBQWdDLEVBQUU7YUFDbENxRSxTQUFTLElBQUlLOztBQXNOdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9Xb3JsZC50cz8zMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gV29ybGQgTWFuYWdlbWVudFxuaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlJZCwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuaW1wb3J0IHsgU3lzdGVtLCBSZW5kZXJTeXN0ZW0sIFBoeXNpY3NTeXN0ZW0gfSBmcm9tICcuL1N5c3RlbSc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuZXhwb3J0IGNsYXNzIFdvcmxkIHtcbiAgcHJpdmF0ZSBlbnRpdGllcyA9IG5ldyBNYXA8RW50aXR5SWQsIEVudGl0eT4oKTtcbiAgcHJpdmF0ZSBzeXN0ZW1zOiBTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIHJlbmRlclN5c3RlbXM6IFJlbmRlclN5c3RlbVtdID0gW107XG4gIHByaXZhdGUgcGh5c2ljc1N5c3RlbXM6IFBoeXNpY3NTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIGNvbXBvbmVudFBvb2xzID0gbmV3IE1hcDxzdHJpbmcsIE9iamVjdFBvb2w8YW55Pj4oKTtcbiAgcHJpdmF0ZSBlbnRpdGllc1RvRGVzdHJveTogRW50aXR5SWRbXSA9IFtdO1xuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcblxuICAvLyBFbnRpdHkgbWFuYWdlbWVudFxuICBwdWJsaWMgY3JlYXRlRW50aXR5KCk6IEVudGl0eSB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSgpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcbiAgICByZXR1cm4gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3lFbnRpdHkoZW50aXR5SWQ6IEVudGl0eUlkKTogdm9pZCB7XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5wdXNoKGVudGl0eUlkKTtcbiAgfVxuXG4gIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgYW4gZW50aXR5IGhhcyBiZWVuIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIGlzIHJlYWR5XG4gIHB1YmxpYyBub3RpZnlFbnRpdHlBZGRlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eUFkZGVkICYmIHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLm9uRW50aXR5QWRkZWQoZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RW50aXR5KGVudGl0eUlkOiBFbnRpdHlJZCk6IEVudGl0eSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxFbnRpdGllcygpOiBFbnRpdHlbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyBTeXN0ZW0gbWFuYWdlbWVudFxuICBwdWJsaWMgYWRkU3lzdGVtKHN5c3RlbTogU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB0aGlzLnN5c3RlbXMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFJlbmRlclN5c3RlbSkge1xuICAgICAgdGhpcy5yZW5kZXJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB9XG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFBoeXNpY3NTeXN0ZW0pIHtcbiAgICAgIHRoaXMucGh5c2ljc1N5c3RlbXMucHVzaChzeXN0ZW0pO1xuICAgIH1cblxuICAgIHN5c3RlbS5vbkVuYWJsZT8uKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3lzdGVtPFQgZXh0ZW5kcyBTeXN0ZW0+KHN5c3RlbUNsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3lzdGVtcy5maW5kKHN5c3RlbSA9PiBzeXN0ZW0gaW5zdGFuY2VvZiBzeXN0ZW1DbGFzcykgYXMgVCB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTeXN0ZW0oc3lzdGVtVHlwZTogbmV3ICgpID0+IFN5c3RlbSk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zeXN0ZW1zLmZpbmRJbmRleChzID0+IHMgaW5zdGFuY2VvZiBzeXN0ZW1UeXBlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSB0aGlzLnN5c3RlbXNbaW5kZXhdO1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgICB0aGlzLnN5c3RlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gc3BlY2lhbGl6ZWQgYXJyYXlzXG4gICAgICBjb25zdCByZW5kZXJJbmRleCA9IHRoaXMucmVuZGVyU3lzdGVtcy5maW5kSW5kZXgocyA9PiBzID09PSBzeXN0ZW0pO1xuICAgICAgaWYgKHJlbmRlckluZGV4ICE9PSAtMSkgdGhpcy5yZW5kZXJTeXN0ZW1zLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG5cbiAgICAgIGNvbnN0IHBoeXNpY3NJbmRleCA9IHRoaXMucGh5c2ljc1N5c3RlbXMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3lzdGVtKTtcbiAgICAgIGlmIChwaHlzaWNzSW5kZXggIT09IC0xKSB0aGlzLnBoeXNpY3NTeXN0ZW1zLnNwbGljZShwaHlzaWNzSW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBvbmVudCBwb29saW5nIGZvciBwZXJmb3JtYW5jZVxuICBwdWJsaWMgY3JlYXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgdHlwZU5hbWUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIERpc2FibGUgcG9vbGluZyBmb3IgY29tcG9uZW50cyB0aGF0IGhhdmUgcHJvdG90eXBlIG1ldGhvZCBpc3N1ZXMgaW4gcHJvZHVjdGlvblxuICAgIGNvbnN0IHByb2JsZW1hdGljQ29tcG9uZW50cyA9IFsnSGVhbHRoJywgJ0hlYWx0aEJhcicsICdUcmFuc2Zvcm0nLCAnTW92ZW1lbnQnLCAnQ29sbGlkZXInLCAnUmVuZGVyZXInLCAnRW5lbXknLCAnUHJvamVjdGlsZScsICdBbmltYXRpb24nXTtcbiAgICBpZiAocHJvYmxlbWF0aWNDb21wb25lbnRzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnRUeXBlKCk7XG4gICAgfVxuICAgIFxuICAgIGxldCBwb29sID0gdGhpcy5jb21wb25lbnRQb29scy5nZXQodHlwZU5hbWUpO1xuICAgIFxuICAgIGlmICghcG9vbCkge1xuICAgICAgcG9vbCA9IG5ldyBPYmplY3RQb29sPFQ+KCgpID0+IG5ldyBjb21wb25lbnRUeXBlKCksIChvYmopID0+IG9iai5yZXNldCgpLCAxMDApO1xuICAgICAgdGhpcy5jb21wb25lbnRQb29scy5zZXQodHlwZU5hbWUsIHBvb2wpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9vbC5hY3F1aXJlKCk7XG4gIH1cblxuICBwdWJsaWMgcmV0dXJuQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmNvbXBvbmVudFBvb2xzLmdldChjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHBvb2wucmVsZWFzZShjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1haW4gdXBkYXRlIGxvb3BcbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICAgIHRoaXMuY2xlYW51cERlc3Ryb3llZEVudGl0aWVzKCk7XG5cbiAgICAvLyBVcGRhdGUgYWxsIHN5c3RlbXNcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLnVwZGF0ZShtYXRjaGluZ0VudGl0aWVzLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpeGVkIHRpbWVzdGVwIHBoeXNpY3MgdXBkYXRlXG4gIHB1YmxpYyBmaXhlZFVwZGF0ZShmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5waHlzaWNzU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0uZml4ZWRVcGRhdGUobWF0Y2hpbmdFbnRpdGllcywgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciB1cGRhdGVcbiAgcHVibGljIHJlbmRlcihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMucmVuZGVyU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0ucmVuZGVyKG1hdGNoaW5nRW50aXRpZXMsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGVudGl0aWVzIHRoYXQgbWF0Y2ggYSBzeXN0ZW0ncyByZXF1aXJlbWVudHNcbiAgcHJpdmF0ZSBnZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW06IFN5c3RlbSk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBBcnJheS5mcm9tKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKSB7XG4gICAgICBpZiAoc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICBwcml2YXRlIGNsZWFudXBEZXN0cm95ZWRFbnRpdGllcygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgLy8gTm90aWZ5IHN5c3RlbXMgYWJvdXQgZW50aXR5IHJlbW92YWxcbiAgICAgICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5zeXN0ZW1zKSB7XG4gICAgICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eVJlbW92ZWQgJiYgc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICAgICAgc3lzdGVtLm9uRW50aXR5UmVtb3ZlZChlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJuIGNvbXBvbmVudHMgdG8gcG9vbHNcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZW50aXR5LmdldEFsbENvbXBvbmVudHMoKSkge1xuICAgICAgICAgIHRoaXMucmV0dXJuQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVudGl0eS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gUXVlcnkgZW50aXRpZXMgYnkgY29tcG9uZW50c1xuICBwdWJsaWMgcXVlcnlFbnRpdGllcyhjb21wb25lbnRUeXBlczogKG5ldyAoKSA9PiBDb21wb25lbnQpW10pOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgaWYgKGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzKSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIEV2ZW50IHN5c3RlbVxuICBwdWJsaWMgZW1pdEV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudERhdGE6IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSkhLnB1c2goZXZlbnREYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFdmVudHMoZXZlbnRUeXBlOiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpIHx8IFtdO1xuICB9XG5cbiAgcHVibGljIGNsZWFyRXZlbnRzKGV2ZW50VHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50VHlwZSwgW10pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIGVudGl0aWVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbnRpdGllcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYW4gdXAgc3lzdGVtc1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVuZGVyU3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGh5c2ljc1N5c3RlbXMubGVuZ3RoID0gMDtcblxuICAgIC8vIENsZWFyIGNvbXBvbmVudCBwb29sc1xuICAgIHRoaXMuY29tcG9uZW50UG9vbHMuY2xlYXIoKTtcbiAgICBcbiAgICAvLyBDbGVhciBldmVudHNcbiAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRW50aXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSIsIk9iamVjdFBvb2wiLCJXb3JsZCIsImNyZWF0ZUVudGl0eSIsImVudGl0eSIsImVudGl0aWVzIiwic2V0IiwiaWQiLCJkZXN0cm95RW50aXR5IiwiZW50aXR5SWQiLCJlbnRpdGllc1RvRGVzdHJveSIsInB1c2giLCJub3RpZnlFbnRpdHlBZGRlZCIsInN5c3RlbSIsInN5c3RlbXMiLCJvbkVudGl0eUFkZGVkIiwibWF0Y2hlc0VudGl0eSIsImdldEVudGl0eSIsImdldCIsImdldEFsbEVudGl0aWVzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYWRkU3lzdGVtIiwic29ydCIsImEiLCJiIiwicHJpb3JpdHkiLCJyZW5kZXJTeXN0ZW1zIiwicGh5c2ljc1N5c3RlbXMiLCJvbkVuYWJsZSIsImdldFN5c3RlbSIsInN5c3RlbUNsYXNzIiwiZmluZCIsInJlbW92ZVN5c3RlbSIsInN5c3RlbVR5cGUiLCJpbmRleCIsImZpbmRJbmRleCIsInMiLCJvbkRpc2FibGUiLCJzcGxpY2UiLCJyZW5kZXJJbmRleCIsInBoeXNpY3NJbmRleCIsImNyZWF0ZUNvbXBvbmVudCIsImNvbXBvbmVudFR5cGUiLCJ0eXBlTmFtZSIsIm5hbWUiLCJwcm9ibGVtYXRpY0NvbXBvbmVudHMiLCJpbmNsdWRlcyIsInBvb2wiLCJjb21wb25lbnRQb29scyIsIm9iaiIsInJlc2V0IiwiYWNxdWlyZSIsInJldHVybkNvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicmVsZWFzZSIsInVwZGF0ZSIsImRlbHRhVGltZSIsImNsZWFudXBEZXN0cm95ZWRFbnRpdGllcyIsImVuYWJsZWQiLCJtYXRjaGluZ0VudGl0aWVzIiwiZ2V0RW50aXRpZXNGb3JTeXN0ZW0iLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwicmVuZGVyIiwib25FbnRpdHlSZW1vdmVkIiwiZ2V0QWxsQ29tcG9uZW50cyIsImRlc3Ryb3kiLCJkZWxldGUiLCJsZW5ndGgiLCJxdWVyeUVudGl0aWVzIiwiY29tcG9uZW50VHlwZXMiLCJpc0FjdGl2ZSIsImhhc0NvbXBvbmVudHMiLCJlbWl0RXZlbnQiLCJldmVudFR5cGUiLCJldmVudERhdGEiLCJldmVudHMiLCJoYXMiLCJnZXRFdmVudHMiLCJjbGVhckV2ZW50cyIsImNsZWFyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/World.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Collider.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Collider.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collider: function() { return /* binding */ Collider; },\n/* harmony export */   ColliderType: function() { return /* binding */ ColliderType; },\n/* harmony export */   CollisionLayer: function() { return /* binding */ CollisionLayer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Collider component for collision detection\n\n\nvar ColliderType;\n(function(ColliderType) {\n    ColliderType[\"SPHERE\"] = \"sphere\";\n    ColliderType[\"BOX\"] = \"box\";\n    ColliderType[\"CAPSULE\"] = \"capsule\";\n    ColliderType[\"CYLINDER\"] = \"cylinder\";\n})(ColliderType || (ColliderType = {}));\nvar CollisionLayer;\n(function(CollisionLayer) {\n    CollisionLayer[CollisionLayer[\"DEFAULT\"] = 1] = \"DEFAULT\";\n    CollisionLayer[CollisionLayer[\"PLAYER\"] = 2] = \"PLAYER\";\n    CollisionLayer[CollisionLayer[\"ENEMY\"] = 4] = \"ENEMY\";\n    CollisionLayer[CollisionLayer[\"PROJECTILE\"] = 8] = \"PROJECTILE\";\n    CollisionLayer[CollisionLayer[\"ENVIRONMENT\"] = 16] = \"ENVIRONMENT\";\n    CollisionLayer[CollisionLayer[\"PICKUP\"] = 32] = \"PICKUP\";\n})(CollisionLayer || (CollisionLayer = {}));\nclass Collider extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    getDefaultMask(layer) {\n        switch(layer){\n            case 2:\n                return 4 | 16 | 32;\n            case 4:\n                return 2 | 8 | 16;\n            case 8:\n                return 2 | 4 | 16;\n            case 16:\n                return 2 | 4 | 8;\n            case 32:\n                return 2;\n            default:\n                return 0xFFFFFFFF; // Collide with everything\n        }\n    }\n    static createSphere(radius) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return new Collider(\"sphere\", radius, layer);\n    }\n    static createBox(size) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const collider = new Collider(\"box\", 0, layer);\n        collider.size.copy(size);\n        return collider;\n    }\n    static createCapsule(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"capsule\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    static createCylinder(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"cylinder\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    setOffset(x, y, z) {\n        this.offset.set(x, y, z);\n        this.boundsNeedUpdate = true;\n    }\n    setLayer(layer) {\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n    }\n    setMask(mask) {\n        this.mask = mask;\n    }\n    canCollideWith(other) {\n        return (this.mask & other.layer) !== 0 && (other.mask & this.layer) !== 0;\n    }\n    updateBounds(worldPosition) {\n        if (!this.boundsNeedUpdate && !this.isStatic) {\n            return;\n        }\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                this.boundingSphere.set(center, this.radius);\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.radius * 2, this.radius * 2));\n                break;\n            case \"box\":\n                this.bounds.setFromCenterAndSize(center, this.size);\n                this.boundingSphere.setFromPoints([\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-this.size.x / 2, -this.size.y / 2, -this.size.z / 2)),\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.size.x / 2, this.size.y / 2, this.size.z / 2))\n                ]);\n                break;\n            case \"capsule\":\n                const capsuleRadius = Math.max(this.radius, this.size.x / 2, this.size.z / 2);\n                this.boundingSphere.set(center, Math.max(capsuleRadius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(capsuleRadius * 2, this.height, capsuleRadius * 2));\n                break;\n            case \"cylinder\":\n                this.boundingSphere.set(center, Math.max(this.radius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.height, this.radius * 2));\n                break;\n        }\n        this.boundsNeedUpdate = false;\n    }\n    intersects(other, thisPosition, otherPosition) {\n        // Update bounds if needed\n        this.updateBounds(thisPosition);\n        other.updateBounds(otherPosition);\n        // Quick bounding sphere check first\n        if (!this.boundingSphere.intersectsSphere(other.boundingSphere)) {\n            return false;\n        }\n        // More precise collision detection based on collider types\n        return this.preciseIntersection(other, thisPosition, otherPosition);\n    }\n    preciseIntersection(other, thisPosition, otherPosition) {\n        const thisCenter = thisPosition.clone().add(this.offset);\n        const otherCenter = otherPosition.clone().add(other.offset);\n        // Sphere vs Sphere\n        if (this.type === \"sphere\" && other.type === \"sphere\") {\n            const distance = thisCenter.distanceTo(otherCenter);\n            return distance <= this.radius + other.radius;\n        }\n        // Box vs Box\n        if (this.type === \"box\" && other.type === \"box\") {\n            return this.bounds.intersectsBox(other.bounds);\n        }\n        // Sphere vs Box\n        if (this.type === \"sphere\" && other.type === \"box\" || this.type === \"box\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const box = this.type === \"box\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            box.bounds.clampPoint(sphereCenter, closestPoint);\n            return sphereCenter.distanceTo(closestPoint) <= sphere.radius;\n        }\n        // Sphere vs Cylinder (for pillar collisions)\n        if (this.type === \"sphere\" && other.type === \"cylinder\" || this.type === \"cylinder\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const cylinder = this.type === \"cylinder\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const cylinderCenter = this.type === \"cylinder\" ? thisCenter : otherCenter;\n            // Check if sphere is within cylinder's height range\n            const heightDiff = Math.abs(sphereCenter.y - cylinderCenter.y);\n            if (heightDiff > cylinder.height / 2 + sphere.radius) {\n                return false; // Sphere is above or below cylinder\n            }\n            // Check horizontal distance (XZ plane)\n            const horizontalDistance = Math.sqrt(Math.pow(sphereCenter.x - cylinderCenter.x, 2) + Math.pow(sphereCenter.z - cylinderCenter.z, 2));\n            return horizontalDistance <= sphere.radius + cylinder.radius;\n        }\n        // For other combinations, fall back to bounding box intersection\n        return this.bounds.intersectsBox(other.bounds);\n    }\n    getClosestPoint(point, worldPosition) {\n        this.updateBounds(worldPosition);\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                const direction = point.clone().sub(center).normalize();\n                return center.clone().add(direction.multiplyScalar(this.radius));\n            case \"box\":\n                const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, closestPoint);\n                return closestPoint;\n            default:\n                // For other types, use bounding box\n                const boxClosest = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, boxClosest);\n                return boxClosest;\n        }\n    }\n    getVolume() {\n        switch(this.type){\n            case \"sphere\":\n                return 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n            case \"box\":\n                return this.size.x * this.size.y * this.size.z;\n            case \"cylinder\":\n                return Math.PI * Math.pow(this.radius, 2) * this.height;\n            case \"capsule\":\n                const sphereVolume = 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n                const cylinderVolume = Math.PI * Math.pow(this.radius, 2) * (this.height - 2 * this.radius);\n                return sphereVolume + cylinderVolume;\n            default:\n                return 1;\n        }\n    }\n    reset() {\n        this.type = \"sphere\";\n        this.radius = 0.5;\n        this.size.set(1, 1, 1);\n        this.height = 2;\n        this.offset.set(0, 0, 0);\n        this.layer = 1;\n        this.mask = this.getDefaultMask(1);\n        this.isTrigger = false;\n        this.isStatic = false;\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n        this.onCollisionEnter = undefined;\n        this.onCollisionStay = undefined;\n        this.onCollisionExit = undefined;\n        this.onTriggerEnter = undefined;\n        this.onTriggerStay = undefined;\n        this.onTriggerExit = undefined;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Collider(this.type, this.radius, this.layer);\n        clone.size.copy(this.size);\n        clone.height = this.height;\n        clone.offset.copy(this.offset);\n        clone.mask = this.mask;\n        clone.isTrigger = this.isTrigger;\n        clone.isStatic = this.isStatic;\n        return clone;\n    }\n    constructor(type = \"sphere\", radius = 0.5, layer = 1){\n        super();\n        this.componentType = \"Collider\" // Instance identifier\n        ;\n        this.type = type;\n        this.radius = radius;\n        this.size = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.height = 2;\n        this.offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n        this.isTrigger = false;\n        this.isStatic = false;\n        // Initialize bounds\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n    }\n}\nCollider.componentType = \"Collider\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Db2xsaWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDZDQUE2QztBQUNpQjtBQUN4Qjs7VUFFMUJJOzs7OztHQUFBQSxpQkFBQUE7O1VBT0FDOzs7Ozs7O0dBQUFBLG1CQUFBQTtBQVNMLE1BQU1DLGlCQUFpQkgsOENBQVNBO0lBaUQ3QkksZUFBZUMsS0FBcUIsRUFBVTtRQUNwRCxPQUFRQTtZQUNOO2dCQUNFLE9BQU9IO1lBQ1Q7Z0JBQ0UsT0FBT0E7WUFDVDtnQkFDRSxPQUFPQTtZQUNUO2dCQUNFLE9BQU9BO1lBQ1Q7Z0JBQ0U7WUFDRjtnQkFDRSxPQUFPLFlBQVksMEJBQTBCO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFjSSxhQUFhQyxNQUFjLEVBQTREO1lBQTFERixRQUFBQTtRQUN6QyxPQUFPLElBQUlGLG1CQUE4QkksUUFBUUY7SUFDbkQ7SUFFQSxPQUFjRyxVQUFVQyxJQUFhLEVBQTREO1lBQTFESixRQUFBQTtRQUNyQyxNQUFNSyxXQUFXLElBQUlQLGdCQUEyQixHQUFHRTtRQUNuREssU0FBU0QsSUFBSSxDQUFDRSxJQUFJLENBQUNGO1FBQ25CLE9BQU9DO0lBQ1Q7SUFFQSxPQUFjRSxjQUFjTCxNQUFjLEVBQUVNLE1BQWMsRUFBNEQ7WUFBMURSLFFBQUFBO1FBQzFELE1BQU1LLFdBQVcsSUFBSVAsb0JBQStCSSxRQUFRRjtRQUM1REssU0FBU0csTUFBTSxHQUFHQTtRQUNsQixPQUFPSDtJQUNUO0lBRUEsT0FBY0ksZUFBZVAsTUFBYyxFQUFFTSxNQUFjLEVBQTREO1lBQTFEUixRQUFBQTtRQUMzRCxNQUFNSyxXQUFXLElBQUlQLHFCQUFnQ0ksUUFBUUY7UUFDN0RLLFNBQVNHLE1BQU0sR0FBR0E7UUFDbEIsT0FBT0g7SUFDVDtJQUVPSyxVQUFVQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFRO1FBQ3RELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUNK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QjtRQUNwQixJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJckMsc0RBQUlBO1FBQ3RCLElBQUksQ0FBQ29DLGNBQWMsR0FBRyxJQUFJbkMsd0RBQU1BO1FBQ2hDLElBQUksQ0FBQ3NCLGdCQUFnQixHQUFHO0lBQzFCO0FBZ1BGO0FBL1JhbEIsU0FDWWtGLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXIudHM/MzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsaWRlciBjb21wb25lbnQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMsIFNwaGVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBDb2xsaWRlclR5cGUge1xuICBTUEhFUkUgPSAnc3BoZXJlJyxcbiAgQk9YID0gJ2JveCcsXG4gIENBUFNVTEUgPSAnY2Fwc3VsZScsXG4gIENZTElOREVSID0gJ2N5bGluZGVyJ1xufVxuXG5leHBvcnQgZW51bSBDb2xsaXNpb25MYXllciB7XG4gIERFRkFVTFQgPSAxLFxuICBQTEFZRVIgPSAyLFxuICBFTkVNWSA9IDQsXG4gIFBST0pFQ1RJTEUgPSA4LFxuICBFTlZJUk9OTUVOVCA9IDE2LFxuICBQSUNLVVAgPSAzMlxufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB0eXBlOiBDb2xsaWRlclR5cGU7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjsgLy8gRm9yIHNwaGVyZSBhbmQgY3lsaW5kZXJcbiAgcHVibGljIHNpemU6IFZlY3RvcjM7IC8vIEZvciBib3ggKHdpZHRoLCBoZWlnaHQsIGRlcHRoKVxuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7IC8vIEZvciBjYXBzdWxlIGFuZCBjeWxpbmRlclxuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzOyAvLyBPZmZzZXQgZnJvbSB0cmFuc2Zvcm0gcG9zaXRpb25cbiAgcHVibGljIGxheWVyOiBDb2xsaXNpb25MYXllcjtcbiAgcHVibGljIG1hc2s6IG51bWJlcjsgLy8gV2hpY2ggbGF5ZXJzIHRoaXMgY29sbGlkZXIgY2FuIGNvbGxpZGUgd2l0aFxuICBwdWJsaWMgaXNUcmlnZ2VyOiBib29sZWFuOyAvLyBJZiB0cnVlLCBkb2Vzbid0IGJsb2NrIG1vdmVtZW50IGJ1dCBzdGlsbCBkZXRlY3RzIGNvbGxpc2lvbnNcbiAgcHVibGljIGlzU3RhdGljOiBib29sZWFuOyAvLyBJZiB0cnVlLCBjb2xsaWRlciBkb2Vzbid0IG1vdmUgKG9wdGltaXphdGlvbilcbiAgXG4gIC8vIENhY2hlZCBib3VuZHMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBib3VuZHM6IEJveDM7XG4gIHB1YmxpYyBib3VuZGluZ1NwaGVyZTogU3BoZXJlO1xuICBwdWJsaWMgYm91bmRzTmVlZFVwZGF0ZTogYm9vbGVhbjtcbiAgXG4gIC8vIENvbGxpc2lvbiBjYWxsYmFja3NcbiAgcHVibGljIG9uQ29sbGlzaW9uRW50ZXI/OiAob3RoZXI6IENvbGxpZGVyLCBlbnRpdHk6IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIG9uQ29sbGlzaW9uU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25Db2xsaXNpb25FeGl0PzogKG90aGVyOiBDb2xsaWRlciwgZW50aXR5OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBvblRyaWdnZXJFbnRlcj86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyRXhpdD86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IENvbGxpZGVyVHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkUsXG4gICAgcmFkaXVzOiBudW1iZXIgPSAwLjUsXG4gICAgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSAyO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2sobGF5ZXIpO1xuICAgIHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYm91bmRzXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1hc2sobGF5ZXI6IENvbGxpc2lvbkxheWVyKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGxheWVyKSB7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBMQVlFUjpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLkVORU1ZIHwgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQgfCBDb2xsaXNpb25MYXllci5QSUNLVVA7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLkVORU1ZOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRSB8IENvbGxpc2lvbkxheWVyLkVOVklST05NRU5UO1xuICAgICAgY2FzZSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuRU5FTVkgfCBDb2xsaXNpb25MYXllci5FTlZJUk9OTUVOVDtcbiAgICAgIGNhc2UgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQ6XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25MYXllci5QTEFZRVIgfCBDb2xsaXNpb25MYXllci5FTkVNWSB8IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBJQ0tVUDpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLlBMQVlFUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAweEZGRkZGRkZGOyAvLyBDb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3BoZXJlKHJhZGl1czogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIHJldHVybiBuZXcgQ29sbGlkZXIoQ29sbGlkZXJUeXBlLlNQSEVSRSwgcmFkaXVzLCBsYXllcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUJveChzaXplOiBWZWN0b3IzLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5CT1gsIDAsIGxheWVyKTtcbiAgICBjb2xsaWRlci5zaXplLmNvcHkoc2l6ZSk7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYXBzdWxlKHJhZGl1czogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk6IENvbGxpZGVyIHtcbiAgICBjb25zdCBjb2xsaWRlciA9IG5ldyBDb2xsaWRlcihDb2xsaWRlclR5cGUuQ0FQU1VMRSwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ3lsaW5kZXIocmFkaXVzOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5DWUxJTkRFUiwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPZmZzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0LnNldCh4LCB5LCB6KTtcbiAgICB0aGlzLmJvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNldExheWVyKGxheWVyOiBDb2xsaXNpb25MYXllcik6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLm1hc2sgPSB0aGlzLmdldERlZmF1bHRNYXNrKGxheWVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXNrKG1hc2s6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cblxuICBwdWJsaWMgY2FuQ29sbGlkZVdpdGgob3RoZXI6IENvbGxpZGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBvdGhlci5sYXllcikgIT09IDAgJiYgKG90aGVyLm1hc2sgJiB0aGlzLmxheWVyKSAhPT0gMDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVCb3VuZHMod29ybGRQb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ib3VuZHNOZWVkVXBkYXRlICYmICF0aGlzLmlzU3RhdGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuU1BIRVJFOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQk9YOlxuICAgICAgICB0aGlzLmJvdW5kcy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgICAgY2VudGVyLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IzKC10aGlzLnNpemUueC8yLCAtdGhpcy5zaXplLnkvMiwgLXRoaXMuc2l6ZS56LzIpKSxcbiAgICAgICAgICBjZW50ZXIuY2xvbmUoKS5hZGQobmV3IFZlY3RvcjModGhpcy5zaXplLngvMiwgdGhpcy5zaXplLnkvMiwgdGhpcy5zaXplLnovMikpXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQ0FQU1VMRTpcbiAgICAgICAgY29uc3QgY2Fwc3VsZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLnNpemUueCAvIDIsIHRoaXMuc2l6ZS56IC8gMik7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KGNlbnRlciwgTWF0aC5tYXgoY2Fwc3VsZVJhZGl1cywgdGhpcy5oZWlnaHQgLyAyKSk7XG4gICAgICAgIHRoaXMuYm91bmRzLnNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgbmV3IFZlY3RvcjMoXG4gICAgICAgICAgY2Fwc3VsZVJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCBjYXBzdWxlUmFkaXVzICogMlxuICAgICAgICApKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNZTElOREVSOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodCAvIDIpKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyAqIDJcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGludGVyc2VjdHMob3RoZXI6IENvbGxpZGVyLCB0aGlzUG9zaXRpb246IFZlY3RvcjMsIG90aGVyUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAvLyBVcGRhdGUgYm91bmRzIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlQm91bmRzKHRoaXNQb3NpdGlvbik7XG4gICAgb3RoZXIudXBkYXRlQm91bmRzKG90aGVyUG9zaXRpb24pO1xuXG4gICAgLy8gUXVpY2sgYm91bmRpbmcgc3BoZXJlIGNoZWNrIGZpcnN0XG4gICAgaWYgKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNTcGhlcmUob3RoZXIuYm91bmRpbmdTcGhlcmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9yZSBwcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmFzZWQgb24gY29sbGlkZXIgdHlwZXNcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyLCB0aGlzUG9zaXRpb24sIG90aGVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyOiBDb2xsaWRlciwgdGhpc1Bvc2l0aW9uOiBWZWN0b3IzLCBvdGhlclBvc2l0aW9uOiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGhpc0NlbnRlciA9IHRoaXNQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgY29uc3Qgb3RoZXJDZW50ZXIgPSBvdGhlclBvc2l0aW9uLmNsb25lKCkuYWRkKG90aGVyLm9mZnNldCk7XG5cbiAgICAvLyBTcGhlcmUgdnMgU3BoZXJlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXNDZW50ZXIuZGlzdGFuY2VUbyhvdGhlckNlbnRlcik7XG4gICAgICByZXR1cm4gZGlzdGFuY2UgPD0gKHRoaXMucmFkaXVzICsgb3RoZXIucmFkaXVzKTtcbiAgICB9XG5cbiAgICAvLyBCb3ggdnMgQm94XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLkJPWCAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuaW50ZXJzZWN0c0JveChvdGhlci5ib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFNwaGVyZSB2cyBCb3hcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB8fFxuICAgICAgICAodGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YICYmIG90aGVyLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUpKSB7XG4gICAgICBjb25zdCBzcGhlcmUgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBib3ggPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5CT1ggPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBzcGhlcmVDZW50ZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBib3guYm91bmRzLmNsYW1wUG9pbnQoc3BoZXJlQ2VudGVyLCBjbG9zZXN0UG9pbnQpO1xuICAgICAgcmV0dXJuIHNwaGVyZUNlbnRlci5kaXN0YW5jZVRvKGNsb3Nlc3RQb2ludCkgPD0gc3BoZXJlLnJhZGl1cztcbiAgICB9XG5cbiAgICAvLyBTcGhlcmUgdnMgQ3lsaW5kZXIgKGZvciBwaWxsYXIgY29sbGlzaW9ucylcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIpIHx8XG4gICAgICAgICh0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSkge1xuICAgICAgY29uc3Qgc3BoZXJlID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFID8gdGhpcyA6IG90aGVyO1xuICAgICAgY29uc3QgY3lsaW5kZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiA/IHRoaXMgOiBvdGhlcjtcbiAgICAgIGNvbnN0IHNwaGVyZUNlbnRlciA9IHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSA/IHRoaXNDZW50ZXIgOiBvdGhlckNlbnRlcjtcbiAgICAgIGNvbnN0IGN5bGluZGVyQ2VudGVyID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNwaGVyZSBpcyB3aXRoaW4gY3lsaW5kZXIncyBoZWlnaHQgcmFuZ2VcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhzcGhlcmVDZW50ZXIueSAtIGN5bGluZGVyQ2VudGVyLnkpO1xuICAgICAgaWYgKGhlaWdodERpZmYgPiAoY3lsaW5kZXIuaGVpZ2h0IC8gMiArIHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3BoZXJlIGlzIGFib3ZlIG9yIGJlbG93IGN5bGluZGVyXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKFhaIHBsYW5lKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzcGhlcmVDZW50ZXIueCAtIGN5bGluZGVyQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KHNwaGVyZUNlbnRlci56IC0gY3lsaW5kZXJDZW50ZXIueiwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBob3Jpem9udGFsRGlzdGFuY2UgPD0gKHNwaGVyZS5yYWRpdXMgKyBjeWxpbmRlci5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBjb21iaW5hdGlvbnMsIGZhbGwgYmFjayB0byBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3gob3RoZXIuYm91bmRzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDbG9zZXN0UG9pbnQocG9pbnQ6IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcyh3b3JsZFBvc2l0aW9uKTtcbiAgICBjb25zdCBjZW50ZXIgPSB3b3JsZFBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKSk7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkJPWDpcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuY2xhbXBQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yIG90aGVyIHR5cGVzLCB1c2UgYm91bmRpbmcgYm94XG4gICAgICAgIGNvbnN0IGJveENsb3Nlc3QgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmJvdW5kcy5jbGFtcFBvaW50KHBvaW50LCBib3hDbG9zZXN0KTtcbiAgICAgICAgcmV0dXJuIGJveENsb3Nlc3Q7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZvbHVtZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIHJldHVybiAoNC8zKSAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMyk7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5CT1g6XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55ICogdGhpcy5zaXplLno7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5DWUxJTkRFUjpcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNBUFNVTEU6XG4gICAgICAgIGNvbnN0IHNwaGVyZVZvbHVtZSA9ICg0LzMpICogTWF0aC5QSSAqIE1hdGgucG93KHRoaXMucmFkaXVzLCAzKTtcbiAgICAgICAgY29uc3QgY3lsaW5kZXJWb2x1bWUgPSBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICogKHRoaXMuaGVpZ2h0IC0gMiAqIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHNwaGVyZVZvbHVtZSArIGN5bGluZGVyVm9sdW1lO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjU7XG4gICAgdGhpcy5zaXplLnNldCgxLCAxLCAxKTtcbiAgICB0aGlzLmhlaWdodCA9IDI7XG4gICAgdGhpcy5vZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2soQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk7XG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uQ29sbGlzaW9uRW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvblN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvbkV4aXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpZ2dlclN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFeGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IENvbGxpZGVyKHRoaXMudHlwZSwgdGhpcy5yYWRpdXMsIHRoaXMubGF5ZXIpO1xuICAgIGNsb25lLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTtcbiAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgIGNsb25lLmlzVHJpZ2dlciA9IHRoaXMuaXNUcmlnZ2VyO1xuICAgIGNsb25lLmlzU3RhdGljID0gdGhpcy5pc1N0YXRpYztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwaGVyZSIsIkNvbXBvbmVudCIsIkNvbGxpZGVyVHlwZSIsIkNvbGxpc2lvbkxheWVyIiwiQ29sbGlkZXIiLCJnZXREZWZhdWx0TWFzayIsImxheWVyIiwiY3JlYXRlU3BoZXJlIiwicmFkaXVzIiwiY3JlYXRlQm94Iiwic2l6ZSIsImNvbGxpZGVyIiwiY29weSIsImNyZWF0ZUNhcHN1bGUiLCJoZWlnaHQiLCJjcmVhdGVDeWxpbmRlciIsInNldE9mZnNldCIsIngiLCJ5IiwieiIsIm9mZnNldCIsInNldCIsImJvdW5kc05lZWRVcGRhdGUiLCJzZXRMYXllciIsIm1hc2siLCJzZXRNYXNrIiwiY2FuQ29sbGlkZVdpdGgiLCJvdGhlciIsInVwZGF0ZUJvdW5kcyIsIndvcmxkUG9zaXRpb24iLCJpc1N0YXRpYyIsImNlbnRlciIsImNsb25lIiwiYWRkIiwidHlwZSIsImJvdW5kaW5nU3BoZXJlIiwiYm91bmRzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJzZXRGcm9tUG9pbnRzIiwiY2Fwc3VsZVJhZGl1cyIsIk1hdGgiLCJtYXgiLCJpbnRlcnNlY3RzIiwidGhpc1Bvc2l0aW9uIiwib3RoZXJQb3NpdGlvbiIsImludGVyc2VjdHNTcGhlcmUiLCJwcmVjaXNlSW50ZXJzZWN0aW9uIiwidGhpc0NlbnRlciIsIm90aGVyQ2VudGVyIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiaW50ZXJzZWN0c0JveCIsInNwaGVyZSIsImJveCIsInNwaGVyZUNlbnRlciIsImNsb3Nlc3RQb2ludCIsImNsYW1wUG9pbnQiLCJjeWxpbmRlciIsImN5bGluZGVyQ2VudGVyIiwiaGVpZ2h0RGlmZiIsImFicyIsImhvcml6b250YWxEaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJnZXRDbG9zZXN0UG9pbnQiLCJwb2ludCIsImRpcmVjdGlvbiIsInN1YiIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiYm94Q2xvc2VzdCIsImdldFZvbHVtZSIsIlBJIiwic3BoZXJlVm9sdW1lIiwiY3lsaW5kZXJWb2x1bWUiLCJyZXNldCIsImlzVHJpZ2dlciIsIm9uQ29sbGlzaW9uRW50ZXIiLCJ1bmRlZmluZWQiLCJvbkNvbGxpc2lvblN0YXkiLCJvbkNvbGxpc2lvbkV4aXQiLCJvblRyaWdnZXJFbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvblRyaWdnZXJFeGl0IiwiZW5hYmxlZCIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Collider.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Enemy.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Enemy.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: function() { return /* binding */ Enemy; },\n/* harmony export */   EnemyType: function() { return /* binding */ EnemyType; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Enemy component for identifying enemy entities\n\nvar EnemyType;\n(function(EnemyType) {\n    EnemyType[\"DUMMY\"] = \"dummy\";\n    EnemyType[\"GRUNT\"] = \"grunt\";\n    EnemyType[\"ELITE\"] = \"elite\";\n    EnemyType[\"BOSS\"] = \"boss\";\n})(EnemyType || (EnemyType = {}));\nclass Enemy extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    calculateExperienceReward() {\n        const baseExp = {\n            [\"dummy\"]: 5,\n            [\"grunt\"]: 10,\n            [\"elite\"]: 25,\n            [\"boss\"]: 100\n        };\n        return baseExp[this.type] * this.level;\n    }\n    calculateAggroRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 5,\n            [\"elite\"]: 8,\n            [\"boss\"]: 12\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 1.5,\n            [\"elite\"]: 2,\n            [\"boss\"]: 3\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackDamage() {\n        const baseDamage = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 15,\n            [\"elite\"]: 25,\n            [\"boss\"]: 50\n        };\n        return baseDamage[this.type] * this.level;\n    }\n    calculateAttackCooldown() {\n        const baseCooldown = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 2,\n            [\"elite\"]: 1.5,\n            [\"boss\"]: 1\n        };\n        return baseCooldown[this.type];\n    }\n    calculateMovementSpeed() {\n        const baseSpeed = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 3,\n            [\"elite\"]: 0,\n            [\"boss\"]: 2.5\n        };\n        return baseSpeed[this.type];\n    }\n    canAttack(currentTime) {\n        if (!this.isAggressive || this.isDead || this.attackDamage === 0) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    takeDamage() {\n    // This will be handled by the Health component\n    // This method is for enemy-specific damage reactions\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.deathTime = currentTime;\n    }\n    canRespawnNow(currentTime) {\n        if (!this.canRespawn || !this.isDead) {\n            return false;\n        }\n        return currentTime - this.deathTime >= this.respawnTime;\n    }\n    respawn() {\n        this.isDead = false;\n        this.deathTime = 0;\n        this.lastAttackTime = 0;\n        // Clear freeze status on respawn\n        this.unfreeze();\n        // Clear venom status on respawn\n        this.removeVenom();\n    }\n    freeze(duration, currentTime) {\n        if (this.isDead) return; // Can't freeze dead enemies\n        this.isFrozen = true;\n        this.freezeStartTime = currentTime;\n        this.freezeDuration = duration;\n        // Set movement speed to 0 when frozen\n        this.movementSpeed = 0;\n    }\n    unfreeze() {\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        // Restore original movement speed\n        this.movementSpeed = this.originalMovementSpeed;\n    }\n    updateFreezeStatus(currentTime) {\n        if (!this.isFrozen) return;\n        const elapsed = currentTime - this.freezeStartTime;\n        if (elapsed >= this.freezeDuration) {\n            this.unfreeze();\n        }\n    }\n    canMove() {\n        return !this.isFrozen && !this.isDead;\n    }\n    applyVenom(duration, damagePerSecond, currentTime) {\n        if (this.isDead) return; // Can't apply venom to dead enemies\n        this.isVenomous = true;\n        this.venomStartTime = currentTime;\n        this.venomDuration = duration;\n        this.venomDamagePerSecond = damagePerSecond;\n        this.lastVenomDamageTime = currentTime;\n    }\n    removeVenom() {\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    updateVenomStatus(currentTime) {\n        if (!this.isVenomous) return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n        const elapsed = currentTime - this.venomStartTime;\n        if (elapsed >= this.venomDuration) {\n            this.removeVenom();\n            return {\n                shouldDealDamage: false,\n                damage: 0\n            };\n        }\n        // Check if we should deal damage (every second)\n        const timeSinceLastDamage = currentTime - this.lastVenomDamageTime;\n        if (timeSinceLastDamage >= 1.0) {\n            this.lastVenomDamageTime = currentTime;\n            return {\n                shouldDealDamage: true,\n                damage: this.venomDamagePerSecond\n            };\n        }\n        return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n    }\n    applySunderStack(currentTime) {\n        if (this.isDead) return; // Can't apply sunder to dead enemies\n        // Check if existing stacks have expired\n        if (this.sunderStacks > 0 && currentTime - this.sunderLastApplied > this.sunderDuration) {\n            this.sunderStacks = 0;\n        }\n        // Add new stack (max 3)\n        if (this.sunderStacks < 3) {\n            this.sunderStacks++;\n        }\n        // Update timing\n        this.sunderLastApplied = currentTime;\n    }\n    getSunderStacks() {\n        return this.sunderStacks;\n    }\n    clearSunderStacks() {\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n    }\n    updateSunderStatus(currentTime) {\n        if (this.sunderStacks <= 0) return;\n        const elapsed = currentTime - this.sunderLastApplied;\n        if (elapsed >= this.sunderDuration) {\n            this.clearSunderStacks();\n        }\n    }\n    setLevel(newLevel) {\n        this.level = Math.max(1, newLevel);\n        this.experienceReward = this.calculateExperienceReward();\n        this.attackDamage = this.calculateAttackDamage();\n    }\n    getDisplayName() {\n        const typeNames = {\n            [\"dummy\"]: \"Training Dummy\",\n            [\"grunt\"]: \"Grunt\",\n            [\"elite\"]: \"Elite\",\n            [\"boss\"]: \"Boss\"\n        };\n        return \"\".concat(typeNames[this.type], \" (Lv.\").concat(this.level, \")\");\n    }\n    reset() {\n        this.type = \"dummy\";\n        this.level = 1;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = false;\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30;\n        this.canRespawn = true;\n        this.enabled = true;\n        // Reset freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Reset venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n        // Reset sunder stacks\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n    }\n    clone() {\n        const clone = new Enemy(this.type, this.level);\n        clone.experienceReward = this.experienceReward;\n        clone.isAggressive = this.isAggressive;\n        clone.aggroRange = this.aggroRange;\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.movementSpeed = this.movementSpeed;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.respawnTime = this.respawnTime;\n        clone.canRespawn = this.canRespawn;\n        // Clone freeze status\n        clone.isFrozen = this.isFrozen;\n        clone.freezeStartTime = this.freezeStartTime;\n        clone.freezeDuration = this.freezeDuration;\n        clone.originalMovementSpeed = this.originalMovementSpeed;\n        // Clone venom status\n        clone.isVenomous = this.isVenomous;\n        clone.venomStartTime = this.venomStartTime;\n        clone.venomDuration = this.venomDuration;\n        clone.venomDamagePerSecond = this.venomDamagePerSecond;\n        clone.lastVenomDamageTime = this.lastVenomDamageTime;\n        // Clone sunder stacks\n        clone.sunderStacks = this.sunderStacks;\n        clone.sunderLastApplied = this.sunderLastApplied;\n        return clone;\n    }\n    constructor(type = \"dummy\", level = 1){\n        super();\n        this.componentType = \"Enemy\" // Instance identifier\n        ;\n        this.type = type;\n        this.level = level;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = type !== \"dummy\";\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30; // 30 seconds default respawn time\n        this.canRespawn = true;\n        // Initialize freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Initialize venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n        // Initialize sunder stacks\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n        this.sunderDuration = 10.0; // 10 seconds\n    }\n}\nEnemy.componentType = \"Enemy\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9FbmVteS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBaUQ7QUFDWDs7VUFFMUJDOzs7OztHQUFBQSxjQUFBQTtBQU9MLE1BQU1DLGNBQWNGLDhDQUFTQTtJQTRFMUJHLDRCQUFvQztRQUMxQyxNQUFNQyxVQUFVO1lBQ2QsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUN4QztJQUVRQyxzQkFBOEI7UUFDcEMsTUFBTUMsWUFBWTtZQUNoQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsU0FBUyxDQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDO0lBQzdCO0lBRVFJLHVCQUErQjtRQUNyQyxNQUFNRCxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDSCxJQUFJLENBQUM7SUFDN0I7SUFFUUssd0JBQWdDO1FBQ3RDLE1BQU1DLGFBQWE7WUFDakIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLFVBQVUsQ0FBQyxJQUFJLENBQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUMzQztJQUVRTSwwQkFBa0M7UUFDeEMsTUFBTUMsZUFBZTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixF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QUksQ0FBQ00sWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsTUFBTSxhQUFhO0lBQzNDO0FBZ1NGO0FBMVdhdkQsTUFDWXdFLGdCQUFnQixRQUFTLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvRW5lbXkudHM/M2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmVteSBjb21wb25lbnQgZm9yIGlkZW50aWZ5aW5nIGVuZW15IGVudGl0aWVzXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBFbmVteVR5cGUge1xuICBEVU1NWSA9ICdkdW1teScsXG4gIEdSVU5UID0gJ2dydW50JyxcbiAgRUxJVEUgPSAnZWxpdGUnLFxuICBCT1NTID0gJ2Jvc3MnXG59XG5cbmV4cG9ydCBjbGFzcyBFbmVteSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHR5cGU6IEVuZW15VHlwZTtcbiAgcHVibGljIGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyBleHBlcmllbmNlUmV3YXJkOiBudW1iZXI7XG4gIHB1YmxpYyBpc0FnZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBhZ2dyb1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tSYW5nZTogbnVtYmVyO1xuICBwdWJsaWMgYXR0YWNrRGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tDb29sZG93bjogbnVtYmVyO1xuICBwdWJsaWMgbGFzdEF0dGFja1RpbWU6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcmVzcGF3blRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNhblJlc3Bhd246IGJvb2xlYW47XG4gIFxuICAvLyBGcmVlemUgc3RhdHVzIGVmZmVjdFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcmVlemVTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGZyZWV6ZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvcmlnaW5hbE1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgXG4gIC8vIFZlbm9tIGRlYnVmZiBlZmZlY3RcbiAgcHVibGljIGlzVmVub21vdXM6IGJvb2xlYW47XG4gIHB1YmxpYyB2ZW5vbVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EYW1hZ2VQZXJTZWNvbmQ6IG51bWJlcjtcbiAgcHVibGljIGxhc3RWZW5vbURhbWFnZVRpbWU6IG51bWJlcjtcbiAgXG4gIC8vIFN1bmRlciBzdGFja3MgZWZmZWN0XG4gIHB1YmxpYyBzdW5kZXJTdGFja3M6IG51bWJlcjtcbiAgcHVibGljIHN1bmRlckxhc3RBcHBsaWVkOiBudW1iZXI7XG4gIHB1YmxpYyBzdW5kZXJEdXJhdGlvbjogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IEVuZW15VHlwZSA9IEVuZW15VHlwZS5EVU1NWSxcbiAgICBsZXZlbDogbnVtYmVyID0gMVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuaXNBZ2dyZXNzaXZlID0gdHlwZSAhPT0gRW5lbXlUeXBlLkRVTU1ZO1xuICAgIHRoaXMuYWdncm9SYW5nZSA9IHRoaXMuY2FsY3VsYXRlQWdncm9SYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0Nvb2xkb3duKCk7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5jYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5yZXNwYXduVGltZSA9IDMwOyAvLyAzMCBzZWNvbmRzIGRlZmF1bHQgcmVzcGF3biB0aW1lXG4gICAgdGhpcy5jYW5SZXNwYXduID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGZyZWV6ZSBzdGF0dXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZnJlZXplRHVyYXRpb24gPSAwO1xuICAgIHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkID0gdGhpcy5tb3ZlbWVudFNwZWVkO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdmVub20gc3RhdHVzXG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgc3VuZGVyIHN0YWNrc1xuICAgIHRoaXMuc3VuZGVyU3RhY2tzID0gMDtcbiAgICB0aGlzLnN1bmRlckxhc3RBcHBsaWVkID0gMDtcbiAgICB0aGlzLnN1bmRlckR1cmF0aW9uID0gMTAuMDsgLy8gMTAgc2Vjb25kc1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZUV4cCA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiA1LFxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDEwLFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDI1LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMTAwXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZUV4cFt0aGlzLnR5cGVdICogdGhpcy5sZXZlbDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQWdncm9SYW5nZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VSYW5nZSA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGFnZ3JvXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogNSxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiA4LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMTJcbiAgICB9O1xuICAgIHJldHVybiBiYXNlUmFuZ2VbdGhpcy50eXBlXTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQXR0YWNrUmFuZ2UoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlUmFuZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBhdHRhY2tcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAxLjUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMixcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDNcbiAgICB9O1xuICAgIHJldHVybiBiYXNlUmFuZ2VbdGhpcy50eXBlXTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZURhbWFnZSA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGRlYWwgZGFtYWdlXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMTUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMjUsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiA1MFxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VEYW1hZ2VbdGhpcy50eXBlXSAqIHRoaXMubGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja0Nvb2xkb3duKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZUNvb2xkb3duID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgYXR0YWNrXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMixcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAxLjUsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAxXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZUNvb2xkb3duW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU1vdmVtZW50U3BlZWQoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlU3BlZWQgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBtb3ZlXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMyxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAwLCAvLyBFbGl0ZSBlbmVtaWVzIGFyZSBzdGF0aW9uYXJ5IGxpa2UgdHJhaW5pbmcgZHVtbWllc1xuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMi41XG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVNwZWVkW3RoaXMudHlwZV07XG4gIH1cblxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBZ2dyZXNzaXZlIHx8IHRoaXMuaXNEZWFkIHx8IHRoaXMuYXR0YWNrRGFtYWdlID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RBdHRhY2tUaW1lKSA+PSB0aGlzLmF0dGFja0Nvb2xkb3duO1xuICB9XG5cbiAgcHVibGljIHBlcmZvcm1BdHRhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHB1YmxpYyB0YWtlRGFtYWdlKCk6IHZvaWQge1xuICAgIC8vIFRoaXMgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBIZWFsdGggY29tcG9uZW50XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgZm9yIGVuZW15LXNwZWNpZmljIGRhbWFnZSByZWFjdGlvbnNcbiAgfVxuXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHVibGljIGNhblJlc3Bhd25Ob3coY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5jYW5SZXNwYXduIHx8ICF0aGlzLmlzRGVhZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5kZWF0aFRpbWUpID49IHRoaXMucmVzcGF3blRpbWU7XG4gIH1cblxuICBwdWJsaWMgcmVzcGF3bigpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICAvLyBDbGVhciBmcmVlemUgc3RhdHVzIG9uIHJlc3Bhd25cbiAgICB0aGlzLnVuZnJlZXplKCk7XG4gICAgLy8gQ2xlYXIgdmVub20gc3RhdHVzIG9uIHJlc3Bhd25cbiAgICB0aGlzLnJlbW92ZVZlbm9tKCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBmcmVlemUoZHVyYXRpb246IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBmcmVlemUgZGVhZCBlbmVtaWVzXG4gICAgXG4gICAgdGhpcy5pc0Zyb3plbiA9IHRydWU7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgLy8gU2V0IG1vdmVtZW50IHNwZWVkIHRvIDAgd2hlbiBmcm96ZW5cbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdW5mcmVlemUoKTogdm9pZCB7XG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1vdmVtZW50IHNwZWVkXG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5vcmlnaW5hbE1vdmVtZW50U3BlZWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVGcmVlemVTdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc0Zyb3plbikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMuZnJlZXplRHVyYXRpb24pIHtcbiAgICAgIHRoaXMudW5mcmVlemUoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHB1YmxpYyBjYW5Nb3ZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5pc0Zyb3plbiAmJiAhdGhpcy5pc0RlYWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyBhcHBseVZlbm9tKGR1cmF0aW9uOiBudW1iZXIsIGRhbWFnZVBlclNlY29uZDogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZWFkKSByZXR1cm47IC8vIENhbid0IGFwcGx5IHZlbm9tIHRvIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIHRoaXMuaXNWZW5vbW91cyA9IHRydWU7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSBkYW1hZ2VQZXJTZWNvbmQ7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyByZW1vdmVWZW5vbSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzVmVub21vdXMgPSBmYWxzZTtcbiAgICB0aGlzLnZlbm9tU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSAwO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IDA7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVWZW5vbVN0YXR1cyhjdXJyZW50VGltZTogbnVtYmVyKTogeyBzaG91bGREZWFsRGFtYWdlOiBib29sZWFuOyBkYW1hZ2U6IG51bWJlciB9IHtcbiAgICBpZiAoIXRoaXMuaXNWZW5vbW91cykgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogZmFsc2UsIGRhbWFnZTogMCB9O1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMudmVub21TdGFydFRpbWU7XG4gICAgaWYgKGVsYXBzZWQgPj0gdGhpcy52ZW5vbUR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnJlbW92ZVZlbm9tKCk7XG4gICAgICByZXR1cm4geyBzaG91bGREZWFsRGFtYWdlOiBmYWxzZSwgZGFtYWdlOiAwIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBkZWFsIGRhbWFnZSAoZXZlcnkgc2Vjb25kKVxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZTtcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSAxLjApIHtcbiAgICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogdHJ1ZSwgZGFtYWdlOiB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IGZhbHNlLCBkYW1hZ2U6IDAgfTtcbiAgfVxuICBcbiAgcHVibGljIGFwcGx5U3VuZGVyU3RhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBhcHBseSBzdW5kZXIgdG8gZGVhZCBlbmVtaWVzXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhY2tzIGhhdmUgZXhwaXJlZFxuICAgIGlmICh0aGlzLnN1bmRlclN0YWNrcyA+IDAgJiYgKGN1cnJlbnRUaW1lIC0gdGhpcy5zdW5kZXJMYXN0QXBwbGllZCkgPiB0aGlzLnN1bmRlckR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnN1bmRlclN0YWNrcyA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBuZXcgc3RhY2sgKG1heCAzKVxuICAgIGlmICh0aGlzLnN1bmRlclN0YWNrcyA8IDMpIHtcbiAgICAgIHRoaXMuc3VuZGVyU3RhY2tzKys7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aW1pbmdcbiAgICB0aGlzLnN1bmRlckxhc3RBcHBsaWVkID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXRTdW5kZXJTdGFja3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdW5kZXJTdGFja3M7XG4gIH1cbiAgXG4gIHB1YmxpYyBjbGVhclN1bmRlclN0YWNrcygpOiB2b2lkIHtcbiAgICB0aGlzLnN1bmRlclN0YWNrcyA9IDA7XG4gICAgdGhpcy5zdW5kZXJMYXN0QXBwbGllZCA9IDA7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVTdW5kZXJTdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnN1bmRlclN0YWNrcyA8PSAwKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5zdW5kZXJMYXN0QXBwbGllZDtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aGlzLnN1bmRlckR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmNsZWFyU3VuZGVyU3RhY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldExldmVsKG5ld0xldmVsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxldmVsID0gTWF0aC5tYXgoMSwgbmV3TGV2ZWwpO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tEYW1hZ2UoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHR5cGVOYW1lcyA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAnVHJhaW5pbmcgRHVtbXknLFxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06ICdHcnVudCcsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogJ0VsaXRlJyxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106ICdCb3NzJ1xuICAgIH07XG4gICAgcmV0dXJuIGAke3R5cGVOYW1lc1t0aGlzLnR5cGVdfSAoTHYuJHt0aGlzLmxldmVsfSlgO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IEVuZW15VHlwZS5EVU1NWTtcbiAgICB0aGlzLmxldmVsID0gMTtcbiAgICB0aGlzLmV4cGVyaWVuY2VSZXdhcmQgPSB0aGlzLmNhbGN1bGF0ZUV4cGVyaWVuY2VSZXdhcmQoKTtcbiAgICB0aGlzLmlzQWdncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHRoaXMuYWdncm9SYW5nZSA9IHRoaXMuY2FsY3VsYXRlQWdncm9SYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0Nvb2xkb3duKCk7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5jYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5yZXNwYXduVGltZSA9IDMwO1xuICAgIHRoaXMuY2FuUmVzcGF3biA9IHRydWU7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBSZXNldCBmcmVlemUgc3RhdHVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBSZXNldCB2ZW5vbSBzdGF0dXNcbiAgICB0aGlzLmlzVmVub21vdXMgPSBmYWxzZTtcbiAgICB0aGlzLnZlbm9tU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSAwO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IDA7XG4gICAgXG4gICAgLy8gUmVzZXQgc3VuZGVyIHN0YWNrc1xuICAgIHRoaXMuc3VuZGVyU3RhY2tzID0gMDtcbiAgICB0aGlzLnN1bmRlckxhc3RBcHBsaWVkID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBFbmVteSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRW5lbXkodGhpcy50eXBlLCB0aGlzLmxldmVsKTtcbiAgICBjbG9uZS5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5leHBlcmllbmNlUmV3YXJkO1xuICAgIGNsb25lLmlzQWdncmVzc2l2ZSA9IHRoaXMuaXNBZ2dyZXNzaXZlO1xuICAgIGNsb25lLmFnZ3JvUmFuZ2UgPSB0aGlzLmFnZ3JvUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUubW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICBjbG9uZS5yZXNwYXduVGltZSA9IHRoaXMucmVzcGF3blRpbWU7XG4gICAgY2xvbmUuY2FuUmVzcGF3biA9IHRoaXMuY2FuUmVzcGF3bjtcbiAgICBcbiAgICAvLyBDbG9uZSBmcmVlemUgc3RhdHVzXG4gICAgY2xvbmUuaXNGcm96ZW4gPSB0aGlzLmlzRnJvemVuO1xuICAgIGNsb25lLmZyZWV6ZVN0YXJ0VGltZSA9IHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGNsb25lLmZyZWV6ZUR1cmF0aW9uID0gdGhpcy5mcmVlemVEdXJhdGlvbjtcbiAgICBjbG9uZS5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBDbG9uZSB2ZW5vbSBzdGF0dXNcbiAgICBjbG9uZS5pc1Zlbm9tb3VzID0gdGhpcy5pc1Zlbm9tb3VzO1xuICAgIGNsb25lLnZlbm9tU3RhcnRUaW1lID0gdGhpcy52ZW5vbVN0YXJ0VGltZTtcbiAgICBjbG9uZS52ZW5vbUR1cmF0aW9uID0gdGhpcy52ZW5vbUR1cmF0aW9uO1xuICAgIGNsb25lLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZDtcbiAgICBjbG9uZS5sYXN0VmVub21EYW1hZ2VUaW1lID0gdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lO1xuICAgIFxuICAgIC8vIENsb25lIHN1bmRlciBzdGFja3NcbiAgICBjbG9uZS5zdW5kZXJTdGFja3MgPSB0aGlzLnN1bmRlclN0YWNrcztcbiAgICBjbG9uZS5zdW5kZXJMYXN0QXBwbGllZCA9IHRoaXMuc3VuZGVyTGFzdEFwcGxpZWQ7XG4gICAgXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiRW5lbXlUeXBlIiwiRW5lbXkiLCJjYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkIiwiYmFzZUV4cCIsInR5cGUiLCJsZXZlbCIsImNhbGN1bGF0ZUFnZ3JvUmFuZ2UiLCJiYXNlUmFuZ2UiLCJjYWxjdWxhdGVBdHRhY2tSYW5nZSIsImNhbGN1bGF0ZUF0dGFja0RhbWFnZSIsImJhc2VEYW1hZ2UiLCJjYWxjdWxhdGVBdHRhY2tDb29sZG93biIsImJhc2VDb29sZG93biIsImNhbGN1bGF0ZU1vdmVtZW50U3BlZWQiLCJiYXNlU3BlZWQiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWdncmVzc2l2ZSIsImlzRGVhZCIsImF0dGFja0RhbWFnZSIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwidGFrZURhbWFnZSIsImRpZSIsImRlYXRoVGltZSIsImNhblJlc3Bhd25Ob3ciLCJjYW5SZXNwYXduIiwicmVzcGF3blRpbWUiLCJyZXNwYXduIiwidW5mcmVlemUiLCJyZW1vdmVWZW5vbSIsImZyZWV6ZSIsImR1cmF0aW9uIiwiaXNGcm96ZW4iLCJmcmVlemVTdGFydFRpbWUiLCJmcmVlemVEdXJhdGlvbiIsIm1vdmVtZW50U3BlZWQiLCJvcmlnaW5hbE1vdmVtZW50U3BlZWQiLCJ1cGRhdGVGcmVlemVTdGF0dXMiLCJlbGFwc2VkIiwiY2FuTW92ZSIsImFwcGx5VmVub20iLCJkYW1hZ2VQZXJTZWNvbmQiLCJpc1Zlbm9tb3VzIiwidmVub21TdGFydFRpbWUiLCJ2ZW5vbUR1cmF0aW9uIiwidmVub21EYW1hZ2VQZXJTZWNvbmQiLCJsYXN0VmVub21EYW1hZ2VUaW1lIiwidXBkYXRlVmVub21TdGF0dXMiLCJzaG91bGREZWFsRGFtYWdlIiwiZGFtYWdlIiwidGltZVNpbmNlTGFzdERhbWFnZSIsImFwcGx5U3VuZGVyU3RhY2siLCJzdW5kZXJTdGFja3MiLCJzdW5kZXJMYXN0QXBwbGllZCIsInN1bmRlckR1cmF0aW9uIiwiZ2V0U3VuZGVyU3RhY2tzIiwiY2xlYXJTdW5kZXJTdGFja3MiLCJ1cGRhdGVTdW5kZXJTdGF0dXMiLCJzZXRMZXZlbCIsIm5ld0xldmVsIiwiTWF0aCIsIm1heCIsImV4cGVyaWVuY2VSZXdhcmQiLCJnZXREaXNwbGF5TmFtZSIsInR5cGVOYW1lcyIsInJlc2V0IiwiYWdncm9SYW5nZSIsImF0dGFja1JhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Enemy.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Health.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Health.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Health: function() { return /* binding */ Health; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _Shield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n// Health component for damage and healing\n\n\nclass Health extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    takeDamage(amount) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000, entity = arguments.length > 2 ? arguments[2] : void 0, bypassInvulnerability = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        if (this.isDead || !bypassInvulnerability && this.isInvulnerable || amount <= 0) {\n            return false;\n        }\n        let finalDamage = amount;\n        // Check if entity has a shield component and absorb damage through it first\n        if (entity) {\n            const shield = entity.getComponent(_Shield__WEBPACK_IMPORTED_MODULE_1__.Shield);\n            if (shield) {\n                finalDamage = shield.absorbDamage(amount);\n            }\n        }\n        // Apply remaining damage to health\n        if (finalDamage > 0) {\n            this.currentHealth = Math.max(0, this.currentHealth - finalDamage);\n            this.lastDamageTime = currentTime;\n            // Start invulnerability period\n            this.isInvulnerable = true;\n            this.invulnerabilityTimer = this.invulnerabilityDuration;\n            // Check if dead\n            if (this.currentHealth <= 0) {\n                this.isDead = true;\n            }\n        }\n        return true;\n    }\n    heal(amount) {\n        if (this.isDead || amount <= 0) {\n            return false;\n        }\n        const oldHealth = this.currentHealth;\n        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);\n        return this.currentHealth > oldHealth;\n    }\n    setMaxHealth(newMaxHealth) {\n        const healthRatio = this.getHealthRatio();\n        this.maxHealth = Math.max(1, newMaxHealth);\n        this.currentHealth = Math.floor(this.maxHealth * healthRatio);\n    }\n    getHealthRatio() {\n        return this.maxHealth > 0 ? this.currentHealth / this.maxHealth : 0;\n    }\n    getHealthPercentage() {\n        return this.getHealthRatio() * 100;\n    }\n    isFullHealth() {\n        return this.currentHealth >= this.maxHealth;\n    }\n    isLowHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.25;\n        return this.getHealthRatio() <= threshold;\n    }\n    isCriticalHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.1;\n        return this.getHealthRatio() <= threshold;\n    }\n    revive(healthAmount) {\n        this.isDead = false;\n        this.currentHealth = healthAmount !== undefined ? Math.min(this.maxHealth, healthAmount) : this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    update(deltaTime) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000;\n        // Update invulnerability timer\n        if (this.isInvulnerable) {\n            this.invulnerabilityTimer -= deltaTime;\n            if (this.invulnerabilityTimer <= 0) {\n                this.isInvulnerable = false;\n                this.invulnerabilityTimer = 0;\n            }\n        }\n        // Handle regeneration\n        if (this.canRegenerate && !this.isDead && !this.isFullHealth()) {\n            const timeSinceLastDamage = currentTime - this.lastDamageTime;\n            if (timeSinceLastDamage >= this.regenerationDelay) {\n                this.heal(this.regenerationRate * deltaTime);\n            }\n        }\n    }\n    setInvulnerable(duration) {\n        this.isInvulnerable = true;\n        this.invulnerabilityTimer = duration;\n    }\n    removeInvulnerability() {\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    enableRegeneration() {\n        let rate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n        this.canRegenerate = true;\n        this.regenerationRate = rate;\n        this.regenerationDelay = delay;\n    }\n    disableRegeneration() {\n        this.canRegenerate = false;\n    }\n    reset() {\n        this.currentHealth = this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5;\n        this.regenerationDelay = 3;\n        this.lastDamageTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Health(this.maxHealth);\n        clone.currentHealth = this.currentHealth;\n        clone.isInvulnerable = this.isInvulnerable;\n        clone.invulnerabilityDuration = this.invulnerabilityDuration;\n        clone.invulnerabilityTimer = this.invulnerabilityTimer;\n        clone.isDead = this.isDead;\n        clone.canRegenerate = this.canRegenerate;\n        clone.regenerationRate = this.regenerationRate;\n        clone.regenerationDelay = this.regenerationDelay;\n        clone.lastDamageTime = this.lastDamageTime;\n        return clone;\n    }\n    constructor(maxHealth = 100){\n        super();\n        this.componentType = \"Health\" // Instance identifier\n        ;\n        this.maxHealth = maxHealth;\n        this.currentHealth = maxHealth; // Always start with full health\n        this.isInvulnerable = false;\n        this.invulnerabilityDuration = 0.5; // 0.5 seconds of invulnerability after damage\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5; // Health per second\n        this.regenerationDelay = 3; // Seconds after damage before regeneration starts\n        this.lastDamageTime = 0;\n    }\n}\nHealth.componentType = \"Health\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQ0o7QUFDSjtBQUUzQixNQUFNRSxlQUFlRiw4Q0FBU0E7SUE2QjVCRyxXQUFXQyxNQUFjLEVBQTBHO1lBQXhHQyxjQUFBQSxpRUFBc0JDLEtBQUtDLEdBQUcsS0FBSyxNQUFNQyx1REFBY0Msd0JBQUFBLGlFQUFpQztRQUN4SCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFLLENBQUNELHlCQUF5QixJQUFJLENBQUNFLGNBQWMsSUFBS1AsVUFBVSxHQUFHO1lBQ2pGLE9BQU87UUFDVDtRQUVBLElBQUlRLGNBQWNSO1FBRWxCLDRFQUE0RTtRQUM1RSxJQUFJSSxRQUFRO1lBQ1YsTUFBTUssU0FBU0wsT0FBT00sWUFBWSxDQUFDYiwyQ0FBTUE7WUFDekMsSUFBSVksUUFBUTtnQkFDVkQsY0FBY0MsT0FBT0UsWUFBWSxDQUFDWDtZQUNwQztRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlRLGNBQWMsR0FBRztZQUNuQixJQUFJLENBQUNJLGFBQWEsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDRixhQUFhLEdBQUdKO1lBQ3RELElBQUksQ0FBQ08sY0FBYyxHQUFHZDtZQUV0QiwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDTSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRyxJQUFJLENBQUNDLHVCQUF1QjtZQUV4RCxnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNMLGFBQWEsSUFBSSxHQUFHO2dCQUMzQixJQUFJLENBQUNOLE1BQU0sR0FBRztZQUNoQjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRU9ZLEtBQUtsQixNQUFjLEVBQVc7UUFDbkMsSUFBSSxJQUFJLENBQUNNLE1BQU0sSUFBSU4sVUFBVSxHQUFHO1lBQzlCLE9BQU87UUFDVDtRQUVBLE1BQU1tQixZQUFZLElBQUksQ0FBQ1AsYUFBYTtRQUNwQyxJQUFJLENBQUNBLGFBQWEsR0FBR0MsS0FBS08sR0FBRyxDQUFDLElBQUksQ0FBQ0MsU0FBUyxFQUFFLElBQUksQ0FBQ1QsYUFBYSxHQUFHWjtRQUVuRSxPQUFPLElBQUksQ0FBQ1ksYUFBYSxHQUFHTztJQUM5QjtJQUVPRyxhQUFhQyxZQUFvQixFQUFRO1FBQzlDLE1BQU1DLGNBQWMsSUFBSSxDQUFDQyxjQUFjO1FBQ3ZDLElBQUksQ0FBQ0osU0FBUyxHQUFHUixLQUFLQyxHQUFHLENBQUMsR0FBR1M7UUFDN0IsSUFBSSxDQUFDWCxhQUFhLEdBQUdDLEtBQUthLEtBQUssQ0FBQyxJQUFJLENBQUNMLFNBQVMsR0FBR0c7SUFDbkQ7SUFFT0MsaUJBQXlCO1FBQzlCLE9BQU8sSUFBSSxDQUFDSixTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUNULGFBQWEsR0FBRyxJQUFJLENBQUNTLFNBQVMsR0FBRztJQUNwRTtJQUVPTSxzQkFBOEI7UUFDbkMsT0FBTyxJQUFJLENBQUNGLGNBQWMsS0FBSztJQUNqQztJQUVPRyxlQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ2hCLGFBQWEsSUFBSSxJQUFJLENBQUNTLFNBQVM7SUFDN0M7SUFFT1EsY0FBK0M7WUFBbkNDLFlBQUFBLGlFQUFvQjtRQUNyQyxPQUFPLElBQUksQ0FBQ0wsY0FBYyxNQUFNSztJQUNsQztJQUVPQyxtQkFBbUQ7WUFBbENELFlBQUFBLGlFQUFvQjtRQUMxQyxPQUFPLElBQUksQ0FBQ0wsY0FBYyxNQUFNSztJQUNsQztJQUVPRSxPQUFPQyxZQUFxQixFQUFRO1FBQ3pDLElBQUksQ0FBQzNCLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ00sYUFBYSxHQUFHcUIsaUJBQWlCQyxZQUNwQ3JCLEtBQUtPLEdBQUcsQ0FBQyxJQUFJLENBQUNDLFNBQVMsRUFBRVksZ0JBQ3pCLElBQUksQ0FBQ1osU0FBUztRQUNoQixJQUFJLENBQUNkLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNTLG9CQUFvQixHQUFHO0lBQzlCO0lBRU9tQixPQUFPQyxTQUFpQixFQUFpRDtZQUEvQ25DLGNBQUFBLGlFQUFzQkMsS0FBS0MsR0FBRyxLQUFLO1FBQ2xFLCtCQUErQjtRQUMvQixJQUFJLElBQUksQ0FBQ0ksY0FBYyxFQUFFO1lBQ3ZCLElBQUksQ0FBQ1Msb0JBQW9CLElBQUlvQjtZQUM3QixJQUFJLElBQUksQ0FBQ3BCLG9CQUFvQixJQUFJLEdBQUc7Z0JBQ2xDLElBQUksQ0FBQ1QsY0FBYyxHQUFHO2dCQUN0QixJQUFJLENBQUNTLG9CQUFvQixHQUFHO1lBQzlCO1FBQ0Y7UUFFQSxzQkFBc0I7UUFDdEIsSUFBSSxJQUFJLENBQUNxQixhQUFhLElBQUksQ0FBQyxJQUFJLENBQUMvQixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNzQixZQUFZLElBQUk7WUFDOUQsTUFBTVUsc0JBQXNCckMsY0FBYyxJQUFJLENBQUNjLGNBQWM7WUFDN0QsSUFBSXVCLHVCQUF1QixJQUFJLENBQUNDLGlCQUFpQixFQUFFO2dCQUNqRCxJQUFJLENBQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDc0IsZ0JBQWdCLEdBQUdKO1lBQ3BDO1FBQ0Y7SUFDRjtJQUVPSyxnQkFBZ0JDLFFBQWdCLEVBQVE7UUFDN0MsSUFBSSxDQUFDbkMsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ1Msb0JBQW9CLEdBQUcwQjtJQUM5QjtJQUVPQyx3QkFBOEI7UUFDbkMsSUFBSSxDQUFDcEMsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ1Msb0JBQW9CLEdBQUc7SUFDOUI7SUFFTzRCLHFCQUE4RDtZQUEzQ0MsT0FBQUEsaUVBQWUsR0FBR0MsUUFBQUEsaUVBQWdCO1FBQzFELElBQUksQ0FBQ1QsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUdLO1FBQ3hCLElBQUksQ0FBQ04saUJBQWlCLEdBQUdPO0lBQzNCO0lBRU9DLHNCQUE0QjtRQUNqQyxJQUFJLENBQUNWLGFBQWEsR0FBRztJQUN2QjtJQUVPVyxRQUFjO1FBQ25CLElBQUksQ0FBQ3BDLGFBQWEsR0FBRyxJQUFJLENBQUNTLFNBQVM7UUFDbkMsSUFBSSxDQUFDZCxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNWLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQytCLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNHLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0QsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDeEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tDLE9BQU8sR0FBRztJQUNqQjtJQUVPQyxRQUFnQjtRQUNyQixNQUFNQSxRQUFRLElBQUlwRCxPQUFPLElBQUksQ0FBQ3VCLFNBQVM7UUFDdkM2QixNQUFNdEMsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NDLE1BQU0zQyxjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDMkMsTUFBTWpDLHVCQUF1QixHQUFHLElBQUksQ0FBQ0EsdUJBQXVCO1FBQzVEaUMsTUFBTWxDLG9CQUFvQixHQUFHLElBQUksQ0FBQ0Esb0JBQW9CO1FBQ3REa0MsTUFBTTVDLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU07UUFDMUI0QyxNQUFNYixhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3hDYSxNQUFNVixnQkFBZ0IsR0FBRyxJQUFJLENBQUNBLGdCQUFnQjtRQUM5Q1UsTUFBTVgsaUJBQWlCLEdBQUcsSUFBSSxDQUFDQSxpQkFBaUI7UUFDaERXLE1BQU1uQyxjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDLE9BQU9tQztJQUNUO0lBN0pBQyxZQUFZOUIsWUFBb0IsR0FBRyxDQUFFO1FBQ25DLEtBQUs7YUFiUytCLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFlOUQsSUFBSSxDQUFDL0IsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNULGFBQWEsR0FBR1MsV0FBVyxnQ0FBZ0M7UUFDaEUsSUFBSSxDQUFDZCxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDVSx1QkFBdUIsR0FBRyxLQUFLLDhDQUE4QztRQUNsRixJQUFJLENBQUNELG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1YsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDK0IsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUcsR0FBRyxvQkFBb0I7UUFDL0MsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRyxHQUFHLGtEQUFrRDtRQUM5RSxJQUFJLENBQUN4QixjQUFjLEdBQUc7SUFDeEI7QUFpSkY7QUE1S2FqQixPQUNZc0QsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHM/NWY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggY29tcG9uZW50IGZvciBkYW1hZ2UgYW5kIGhlYWxpbmdcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5pbXBvcnQgeyBTaGllbGQgfSBmcm9tICcuL1NoaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGggZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0hlYWx0aCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIGN1cnJlbnRIZWFsdGg6IG51bWJlcjtcbiAgcHVibGljIG1heEhlYWx0aDogbnVtYmVyO1xuICBwdWJsaWMgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW47XG4gIHB1YmxpYyBpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaW52dWxuZXJhYmlsaXR5VGltZXI6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGNhblJlZ2VuZXJhdGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZWdlbmVyYXRpb25SYXRlOiBudW1iZXI7XG4gIHB1YmxpYyByZWdlbmVyYXRpb25EZWxheTogbnVtYmVyO1xuICBwdWJsaWMgbGFzdERhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhIZWFsdGg6IG51bWJlciA9IDEwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5tYXhIZWFsdGggPSBtYXhIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gbWF4SGVhbHRoOyAvLyBBbHdheXMgc3RhcnQgd2l0aCBmdWxsIGhlYWx0aFxuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gMC41OyAvLyAwLjUgc2Vjb25kcyBvZiBpbnZ1bG5lcmFiaWxpdHkgYWZ0ZXIgZGFtYWdlXG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1OyAvLyBIZWFsdGggcGVyIHNlY29uZFxuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzOyAvLyBTZWNvbmRzIGFmdGVyIGRhbWFnZSBiZWZvcmUgcmVnZW5lcmF0aW9uIHN0YXJ0c1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIHRha2VEYW1hZ2UoYW1vdW50OiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpIC8gMTAwMCwgZW50aXR5PzogYW55LCBieXBhc3NJbnZ1bG5lcmFiaWxpdHk6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzRGVhZCB8fCAoIWJ5cGFzc0ludnVsbmVyYWJpbGl0eSAmJiB0aGlzLmlzSW52dWxuZXJhYmxlKSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmaW5hbERhbWFnZSA9IGFtb3VudDtcblxuICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgYSBzaGllbGQgY29tcG9uZW50IGFuZCBhYnNvcmIgZGFtYWdlIHRocm91Z2ggaXQgZmlyc3RcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIGZpbmFsRGFtYWdlID0gc2hpZWxkLmFic29yYkRhbWFnZShhbW91bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHJlbWFpbmluZyBkYW1hZ2UgdG8gaGVhbHRoXG4gICAgaWYgKGZpbmFsRGFtYWdlID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50SGVhbHRoIC0gZmluYWxEYW1hZ2UpO1xuICAgICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBpbnZ1bG5lcmFiaWxpdHkgcGVyaW9kXG4gICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuXG4gICAgICAvLyBDaGVjayBpZiBkZWFkXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGhlYWwoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5taW4odGhpcy5tYXhIZWFsdGgsIHRoaXMuY3VycmVudEhlYWx0aCArIGFtb3VudCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+IG9sZEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXhIZWFsdGgobmV3TWF4SGVhbHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBoZWFsdGhSYXRpbyA9IHRoaXMuZ2V0SGVhbHRoUmF0aW8oKTtcbiAgICB0aGlzLm1heEhlYWx0aCA9IE1hdGgubWF4KDEsIG5ld01heEhlYWx0aCk7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5mbG9vcih0aGlzLm1heEhlYWx0aCAqIGhlYWx0aFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFsdGhSYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm1heEhlYWx0aCA+IDAgPyB0aGlzLmN1cnJlbnRIZWFsdGggLyB0aGlzLm1heEhlYWx0aCA6IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0SGVhbHRoUGVyY2VudGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgKiAxMDA7XG4gIH1cblxuICBwdWJsaWMgaXNGdWxsSGVhbHRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFsdGggPj0gdGhpcy5tYXhIZWFsdGg7XG4gIH1cblxuICBwdWJsaWMgaXNMb3dIZWFsdGgodGhyZXNob2xkOiBudW1iZXIgPSAwLjI1KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSA8PSB0aHJlc2hvbGQ7XG4gIH1cblxuICBwdWJsaWMgaXNDcml0aWNhbEhlYWx0aCh0aHJlc2hvbGQ6IG51bWJlciA9IDAuMSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgPD0gdGhyZXNob2xkO1xuICB9XG5cbiAgcHVibGljIHJldml2ZShoZWFsdGhBbW91bnQ/OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IGhlYWx0aEFtb3VudCAhPT0gdW5kZWZpbmVkID8gXG4gICAgICBNYXRoLm1pbih0aGlzLm1heEhlYWx0aCwgaGVhbHRoQW1vdW50KSA6IFxuICAgICAgdGhpcy5tYXhIZWFsdGg7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlciA9IERhdGUubm93KCkgLyAxMDAwKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGludnVsbmVyYWJpbGl0eSB0aW1lclxuICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XG4gICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIGlmICh0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVnZW5lcmF0aW9uXG4gICAgaWYgKHRoaXMuY2FuUmVnZW5lcmF0ZSAmJiAhdGhpcy5pc0RlYWQgJiYgIXRoaXMuaXNGdWxsSGVhbHRoKCkpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5KSB7XG4gICAgICAgIHRoaXMuaGVhbCh0aGlzLnJlZ2VuZXJhdGlvblJhdGUgKiBkZWx0YVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnZ1bG5lcmFibGUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSB0cnVlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSBkdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVJbnZ1bG5lcmFiaWxpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVJlZ2VuZXJhdGlvbihyYXRlOiBudW1iZXIgPSA1LCBkZWxheTogbnVtYmVyID0gMyk6IHZvaWQge1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IHRydWU7XG4gICAgdGhpcy5yZWdlbmVyYXRpb25SYXRlID0gcmF0ZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBwdWJsaWMgZGlzYWJsZVJlZ2VuZXJhdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1O1xuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogSGVhbHRoIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBIZWFsdGgodGhpcy5tYXhIZWFsdGgpO1xuICAgIGNsb25lLmN1cnJlbnRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgY2xvbmUuaXNJbnZ1bG5lcmFibGUgPSB0aGlzLmlzSW52dWxuZXJhYmxlO1xuICAgIGNsb25lLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gdGhpcy5pbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjtcbiAgICBjbG9uZS5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXI7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuY2FuUmVnZW5lcmF0ZSA9IHRoaXMuY2FuUmVnZW5lcmF0ZTtcbiAgICBjbG9uZS5yZWdlbmVyYXRpb25SYXRlID0gdGhpcy5yZWdlbmVyYXRpb25SYXRlO1xuICAgIGNsb25lLnJlZ2VuZXJhdGlvbkRlbGF5ID0gdGhpcy5yZWdlbmVyYXRpb25EZWxheTtcbiAgICBjbG9uZS5sYXN0RGFtYWdlVGltZSA9IHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiSGVhbHRoIiwidGFrZURhbWFnZSIsImFtb3VudCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVudGl0eSIsImJ5cGFzc0ludnVsbmVyYWJpbGl0eSIsImlzRGVhZCIsImlzSW52dWxuZXJhYmxlIiwiZmluYWxEYW1hZ2UiLCJzaGllbGQiLCJnZXRDb21wb25lbnQiLCJhYnNvcmJEYW1hZ2UiLCJjdXJyZW50SGVhbHRoIiwiTWF0aCIsIm1heCIsImxhc3REYW1hZ2VUaW1lIiwiaW52dWxuZXJhYmlsaXR5VGltZXIiLCJpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbiIsImhlYWwiLCJvbGRIZWFsdGgiLCJtaW4iLCJtYXhIZWFsdGgiLCJzZXRNYXhIZWFsdGgiLCJuZXdNYXhIZWFsdGgiLCJoZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiZmxvb3IiLCJnZXRIZWFsdGhQZXJjZW50YWdlIiwiaXNGdWxsSGVhbHRoIiwiaXNMb3dIZWFsdGgiLCJ0aHJlc2hvbGQiLCJpc0NyaXRpY2FsSGVhbHRoIiwicmV2aXZlIiwiaGVhbHRoQW1vdW50IiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiY2FuUmVnZW5lcmF0ZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJyZWdlbmVyYXRpb25EZWxheSIsInJlZ2VuZXJhdGlvblJhdGUiLCJzZXRJbnZ1bG5lcmFibGUiLCJkdXJhdGlvbiIsInJlbW92ZUludnVsbmVyYWJpbGl0eSIsImVuYWJsZVJlZ2VuZXJhdGlvbiIsInJhdGUiLCJkZWxheSIsImRpc2FibGVSZWdlbmVyYXRpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Health.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/HealthBar.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/HealthBar.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBar: function() { return /* binding */ HealthBar; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Health bar component for rendering health bars above entities\n\n\nclass HealthBar extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    createHealthBarMeshes() {\n        this.group = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group();\n        // Create border (slightly larger than background)\n        const borderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width + this.borderWidth * 2, this.height + this.borderWidth * 2);\n        const borderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.borderColor,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.borderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(borderGeometry, borderMaterial);\n        this.borderMesh.position.z = -0.001; // Slightly behind\n        this.group.add(this.borderMesh);\n        // Create background\n        const backgroundGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const backgroundMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.backgroundColor,\n            transparent: true,\n            opacity: 0.7\n        });\n        this.backgroundMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(backgroundGeometry, backgroundMaterial);\n        this.group.add(this.backgroundMesh);\n        // Create health bar (starts full width)\n        const healthGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const healthMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.healthColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        this.healthMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(healthGeometry, healthMaterial);\n        this.healthMesh.position.z = 0.001; // Slightly in front\n        this.group.add(this.healthMesh);\n        // Make health bar always face camera\n        this.group.lookAt(0, 0, 1);\n    }\n    updateHealthBar(healthRatio, cameraPosition, worldPosition, deltaTime) {\n        this.currentHealthRatio = Math.max(0, Math.min(1, healthRatio));\n        // Animate health bar changes\n        if (Math.abs(this.lastHealthRatio - this.currentHealthRatio) > 0.01) {\n            this.lastHealthRatio = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this.lastHealthRatio, this.currentHealthRatio, this.animationSpeed * deltaTime);\n        } else {\n            this.lastHealthRatio = this.currentHealthRatio;\n        }\n        // Update health bar width and position\n        this.updateHealthMesh();\n        // Update health bar color based on health ratio\n        this.updateHealthColor();\n        // Update visibility based on distance and health\n        this.updateVisibility(cameraPosition, worldPosition);\n        // Update position and rotation to face camera\n        this.updatePositionAndRotation(cameraPosition, worldPosition);\n        // Update damage flash\n        this.updateDamageFlash(deltaTime);\n    }\n    updateHealthMesh() {\n        // Update scale to represent health\n        this.healthMesh.scale.x = this.lastHealthRatio;\n        // Adjust position so health bar shrinks from right to left\n        const offsetX = this.width * (1 - this.lastHealthRatio) / 2;\n        this.healthMesh.position.x = -offsetX;\n    }\n    updateHealthColor() {\n        let color;\n        if (this.currentHealthRatio <= this.criticalHealthThreshold) {\n            color = this.criticalHealthColor;\n        } else if (this.currentHealthRatio <= this.lowHealthThreshold) {\n            // Interpolate between low health and critical health colors\n            const t = (this.currentHealthRatio - this.criticalHealthThreshold) / (this.lowHealthThreshold - this.criticalHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.criticalHealthColor, this.lowHealthColor, t);\n        } else {\n            // Interpolate between health and low health colors\n            const t = (this.currentHealthRatio - this.lowHealthThreshold) / (1 - this.lowHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.lowHealthColor, this.healthColor, t);\n        }\n        this.healthMesh.material.color.copy(color);\n    }\n    updateVisibility(cameraPosition, worldPosition) {\n        // Calculate distance to camera\n        const distance = cameraPosition.distanceTo(worldPosition);\n        // Determine if should be visible\n        let shouldBeVisible = distance <= this.fadeDistance;\n        // Hide when full health if configured\n        if (!this.showWhenFull && this.currentHealthRatio >= 0.99) {\n            shouldBeVisible = false;\n        }\n        // Update visibility\n        this.isVisible = shouldBeVisible;\n        this.group.visible = this.isVisible;\n        // Fade based on distance\n        if (this.isVisible && distance > this.fadeDistance * 0.7) {\n            const fadeRatio = 1 - (distance - this.fadeDistance * 0.7) / (this.fadeDistance * 0.3);\n            const opacity = Math.max(0.1, fadeRatio);\n            this.backgroundMesh.material.opacity = opacity * 0.7;\n            this.healthMesh.material.opacity = opacity * 0.9;\n            this.borderMesh.material.opacity = opacity * 0.8;\n        } else if (this.isVisible) {\n            this.backgroundMesh.material.opacity = 0.7;\n            this.healthMesh.material.opacity = 0.9;\n            this.borderMesh.material.opacity = 0.8;\n        }\n    }\n    updatePositionAndRotation(cameraPosition, worldPosition) {\n        // Position health bar above entity\n        const barPosition = worldPosition.clone().add(this.offset);\n        this.group.position.copy(barPosition);\n        // Make health bar face camera\n        this.group.lookAt(cameraPosition);\n    }\n    updateDamageFlash(deltaTime) {\n        if (this.damageFlashTimer > 0) {\n            this.damageFlashTimer -= deltaTime;\n            // Flash effect - make health bar brighter\n            const flashIntensity = this.damageFlashTimer / this.damageFlashDuration;\n            const flashColor = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            // Mix current color with white for flash effect\n            const currentColor = this.healthMesh.material.color.clone();\n            currentColor.lerp(flashColor, flashIntensity * 0.5);\n            this.healthMesh.material.color.copy(currentColor);\n        }\n    }\n    triggerDamageFlash() {\n        this.damageFlashTimer = this.damageFlashDuration;\n    }\n    setHealthRatio(ratio) {\n        const oldRatio = this.currentHealthRatio;\n        this.currentHealthRatio = Math.max(0, Math.min(1, ratio));\n        // Trigger damage flash if health decreased\n        if (this.currentHealthRatio < oldRatio) {\n            this.triggerDamageFlash();\n        }\n    }\n    getGroup() {\n        return this.group;\n    }\n    dispose() {\n        // Clean up geometries and materials\n        this.backgroundMesh.geometry.dispose();\n        this.backgroundMesh.material.dispose();\n        this.healthMesh.geometry.dispose();\n        this.healthMesh.material.dispose();\n        this.borderMesh.geometry.dispose();\n        this.borderMesh.material.dispose();\n        // Remove from parent if it has one\n        if (this.group.parent) {\n            this.group.parent.remove(this.group);\n        }\n    }\n    reset() {\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.isVisible = true;\n        this.damageFlashTimer = 0;\n        this.enabled = true;\n        // Reset visual state\n        this.updateHealthMesh();\n        this.updateHealthColor();\n    }\n    clone() {\n        const config = {\n            width: this.width,\n            height: this.height,\n            offset: this.offset.clone(),\n            backgroundColor: this.backgroundColor.clone(),\n            healthColor: this.healthColor.clone(),\n            lowHealthColor: this.lowHealthColor.clone(),\n            criticalHealthColor: this.criticalHealthColor.clone(),\n            borderColor: this.borderColor.clone(),\n            borderWidth: this.borderWidth,\n            showWhenFull: this.showWhenFull,\n            fadeDistance: this.fadeDistance,\n            lowHealthThreshold: this.lowHealthThreshold,\n            criticalHealthThreshold: this.criticalHealthThreshold\n        };\n        return new HealthBar(config);\n    }\n    constructor(config = {}){\n        var _config_offset, _config_backgroundColor, _config_healthColor, _config_lowHealthColor, _config_criticalHealthColor, _config_borderColor;\n        super();\n        this.componentType = \"HealthBar\" // Instance identifier\n        ;\n        // Configuration\n        this.width = config.width || 1.0;\n        this.height = config.height || 0.1;\n        this.offset = ((_config_offset = config.offset) === null || _config_offset === void 0 ? void 0 : _config_offset.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0);\n        this.backgroundColor = ((_config_backgroundColor = config.backgroundColor) === null || _config_backgroundColor === void 0 ? void 0 : _config_backgroundColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x333333);\n        this.healthColor = ((_config_healthColor = config.healthColor) === null || _config_healthColor === void 0 ? void 0 : _config_healthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x00ff00);\n        this.lowHealthColor = ((_config_lowHealthColor = config.lowHealthColor) === null || _config_lowHealthColor === void 0 ? void 0 : _config_lowHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xffff00);\n        this.criticalHealthColor = ((_config_criticalHealthColor = config.criticalHealthColor) === null || _config_criticalHealthColor === void 0 ? void 0 : _config_criticalHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xff0000);\n        this.borderColor = ((_config_borderColor = config.borderColor) === null || _config_borderColor === void 0 ? void 0 : _config_borderColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);\n        this.borderWidth = config.borderWidth || 0.02;\n        this.showWhenFull = config.showWhenFull !== undefined ? config.showWhenFull : false;\n        this.fadeDistance = config.fadeDistance || 20;\n        this.lowHealthThreshold = config.lowHealthThreshold || 0.5;\n        this.criticalHealthThreshold = config.criticalHealthThreshold || 0.25;\n        // State\n        this.isVisible = true;\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.animationSpeed = 5.0; // How fast health bar animates\n        this.damageFlashTimer = 0;\n        this.damageFlashDuration = 0.2;\n        // Create rendering objects\n        this.createHealthBarMeshes();\n    }\n}\nHealthBar.componentType = \"HealthBar\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQzJEO0FBQ3JGO0FBa0IvQixNQUFNUSxrQkFBa0JELDhDQUFTQTtJQTZEOUJFLHdCQUE4QjtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJUix1REFBS0E7UUFFdEIsa0RBQWtEO1FBQ2xELE1BQU1TLGlCQUFpQixJQUFJUCwrREFBYUEsQ0FDdEMsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxXQUFXLEdBQUc7UUFFbkMsTUFBTUUsaUJBQWlCLElBQUlWLG1FQUFpQkEsQ0FBQztZQUMzQ1csT0FBTyxJQUFJLENBQUNDLFdBQVc7WUFDdkJDLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSWpCLHNEQUFJQSxDQUFDUSxnQkFBZ0JJO1FBQzNDLElBQUksQ0FBQ0ssVUFBVSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBRyxDQUFDLE9BQU8sa0JBQWtCO1FBQ3ZELElBQUksQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUMsSUFBSSxDQUFDSCxVQUFVO1FBRTlCLG9CQUFvQjtRQUNwQixNQUFNSSxxQkFBcUIsSUFBSXBCLCtEQUFhQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNwRSxNQUFNVyxxQkFBcUIsSUFBSXBCLG1FQUFpQkEsQ0FBQztZQUMvQ1csT0FBTyxJQUFJLENBQUNVLGVBQWU7WUFDM0JSLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSXhCLHNEQUFJQSxDQUFDcUIsb0JBQW9CQztRQUNuRCxJQUFJLENBQUNmLEtBQUssQ0FBQ2EsR0FBRyxDQUFDLElBQUksQ0FBQ0ksY0FB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LEdBQUc7UUFDdkIsSUFBSSxDQUFDRSxjQUFjLEdBQUcsS0FBSywrQkFBK0I7UUFDMUQsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBRztRQUUzQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbEUscUJBQXFCO0lBQzVCO0FBcU9GO0FBaFNhRCxVQUNZbUYsZ0JBQWdCLFlBQWEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHM/MzQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgR3JvdXAsIE1lc2gsIFBsYW5lR2VvbWV0cnksIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRoVXRpbHMsIE1hdGVyaWFsIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQmFyQ29uZmlnIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgb2Zmc2V0PzogVmVjdG9yMztcbiAgYmFja2dyb3VuZENvbG9yPzogQ29sb3I7XG4gIGhlYWx0aENvbG9yPzogQ29sb3I7XG4gIGxvd0hlYWx0aENvbG9yPzogQ29sb3I7XG4gIGNyaXRpY2FsSGVhbHRoQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyV2lkdGg/OiBudW1iZXI7XG4gIHNob3dXaGVuRnVsbD86IGJvb2xlYW47XG4gIGZhZGVEaXN0YW5jZT86IG51bWJlcjtcbiAgbG93SGVhbHRoVGhyZXNob2xkPzogbnVtYmVyO1xuICBjcml0aWNhbEhlYWx0aFRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGhCYXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoQmFyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzO1xuICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGhlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGxvd0hlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGNyaXRpY2FsSGVhbHRoQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyV2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHNob3dXaGVuRnVsbDogYm9vbGVhbjtcbiAgcHVibGljIGZhZGVEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgbG93SGVhbHRoVGhyZXNob2xkOiBudW1iZXI7XG4gIHB1YmxpYyBjcml0aWNhbEhlYWx0aFRocmVzaG9sZDogbnVtYmVyO1xuXG4gIC8vIFJlbmRlcmluZyBvYmplY3RzXG4gIHB1YmxpYyBncm91cCE6IEdyb3VwO1xuICBwdWJsaWMgYmFja2dyb3VuZE1lc2ghOiBNZXNoO1xuICBwdWJsaWMgaGVhbHRoTWVzaCE6IE1lc2g7XG4gIHB1YmxpYyBib3JkZXJNZXNoITogTWVzaDtcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc1Zpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyBjdXJyZW50SGVhbHRoUmF0aW86IG51bWJlcjtcbiAgcHVibGljIGxhc3RIZWFsdGhSYXRpbzogbnVtYmVyO1xuICBwdWJsaWMgYW5pbWF0aW9uU3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoVGltZXI6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoRHVyYXRpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhlYWx0aEJhckNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxLjA7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IDAuMTtcbiAgICB0aGlzLm9mZnNldCA9IGNvbmZpZy5vZmZzZXQ/LmNsb25lKCkgfHwgbmV3IFZlY3RvcjMoMCwgMS41LCAwKTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I/LmNsb25lKCkgfHwgbmV3IENvbG9yKDB4MzMzMzMzKTtcbiAgICB0aGlzLmhlYWx0aENvbG9yID0gY29uZmlnLmhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweDAwZmYwMCk7XG4gICAgdGhpcy5sb3dIZWFsdGhDb2xvciA9IGNvbmZpZy5sb3dIZWFsdGhDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHhmZmZmMDApO1xuICAgIHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvciA9IGNvbmZpZy5jcml0aWNhbEhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweGZmMDAwMCk7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZy5ib3JkZXJDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMC4wMjtcbiAgICB0aGlzLnNob3dXaGVuRnVsbCA9IGNvbmZpZy5zaG93V2hlbkZ1bGwgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zaG93V2hlbkZ1bGwgOiBmYWxzZTtcbiAgICB0aGlzLmZhZGVEaXN0YW5jZSA9IGNvbmZpZy5mYWRlRGlzdGFuY2UgfHwgMjA7XG4gICAgdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQgPSBjb25maWcubG93SGVhbHRoVGhyZXNob2xkIHx8IDAuNTtcbiAgICB0aGlzLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkID0gY29uZmlnLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIHx8IDAuMjU7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmxhc3RIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gNS4wOyAvLyBIb3cgZmFzdCBoZWFsdGggYmFyIGFuaW1hdGVzXG4gICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyID0gMDtcbiAgICB0aGlzLmRhbWFnZUZsYXNoRHVyYXRpb24gPSAwLjI7XG5cbiAgICAvLyBDcmVhdGUgcmVuZGVyaW5nIG9iamVjdHNcbiAgICB0aGlzLmNyZWF0ZUhlYWx0aEJhck1lc2hlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVIZWFsdGhCYXJNZXNoZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgLy8gQ3JlYXRlIGJvcmRlciAoc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gYmFja2dyb3VuZClcbiAgICBjb25zdCBib3JkZXJHZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KFxuICAgICAgdGhpcy53aWR0aCArIHRoaXMuYm9yZGVyV2lkdGggKiAyLCBcbiAgICAgIHRoaXMuaGVpZ2h0ICsgdGhpcy5ib3JkZXJXaWR0aCAqIDJcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlck1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgdGhpcy5ib3JkZXJNZXNoID0gbmV3IE1lc2goYm9yZGVyR2VvbWV0cnksIGJvcmRlck1hdGVyaWFsKTtcbiAgICB0aGlzLmJvcmRlck1lc2gucG9zaXRpb24ueiA9IC0wLjAwMTsgLy8gU2xpZ2h0bHkgYmVoaW5kXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5ib3JkZXJNZXNoKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgYmFja2dyb3VuZEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goYmFja2dyb3VuZEdlb21ldHJ5LCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuYmFja2dyb3VuZE1lc2gpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWx0aCBiYXIgKHN0YXJ0cyBmdWxsIHdpZHRoKVxuICAgIGNvbnN0IGhlYWx0aEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhlYWx0aE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5oZWFsdGhDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC45XG4gICAgfSk7XG4gICAgdGhpcy5oZWFsdGhNZXNoID0gbmV3IE1lc2goaGVhbHRoR2VvbWV0cnksIGhlYWx0aE1hdGVyaWFsKTtcbiAgICB0aGlzLmhlYWx0aE1lc2gucG9zaXRpb24ueiA9IDAuMDAxOyAvLyBTbGlnaHRseSBpbiBmcm9udFxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuaGVhbHRoTWVzaCk7XG5cbiAgICAvLyBNYWtlIGhlYWx0aCBiYXIgYWx3YXlzIGZhY2UgY2FtZXJhXG4gICAgdGhpcy5ncm91cC5sb29rQXQoMCwgMCwgMSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSGVhbHRoQmFyKFxuICAgIGhlYWx0aFJhdGlvOiBudW1iZXIsIFxuICAgIGNhbWVyYVBvc2l0aW9uOiBWZWN0b3IzLCBcbiAgICB3b3JsZFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRlbHRhVGltZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaGVhbHRoUmF0aW8pKTtcblxuICAgIC8vIEFuaW1hdGUgaGVhbHRoIGJhciBjaGFuZ2VzXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEhlYWx0aFJhdGlvIC0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8pID4gMC4wMSkge1xuICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8sIFxuICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbywgXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW87XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBjb2xvciBiYXNlZCBvbiBoZWFsdGggcmF0aW9cbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbG9yKCk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KGNhbWVyYVBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gdG8gZmFjZSBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGRhbWFnZSBmbGFzaFxuICAgIHRoaXMudXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoTWVzaCgpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc2NhbGUgdG8gcmVwcmVzZW50IGhlYWx0aFxuICAgIHRoaXMuaGVhbHRoTWVzaC5zY2FsZS54ID0gdGhpcy5sYXN0SGVhbHRoUmF0aW87XG4gICAgXG4gICAgLy8gQWRqdXN0IHBvc2l0aW9uIHNvIGhlYWx0aCBiYXIgc2hyaW5rcyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggKiAoMSAtIHRoaXMubGFzdEhlYWx0aFJhdGlvKSkgLyAyO1xuICAgIHRoaXMuaGVhbHRoTWVzaC5wb3NpdGlvbi54ID0gLW9mZnNldFg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhlYWx0aENvbG9yKCk6IHZvaWQge1xuICAgIGxldCBjb2xvcjogQ29sb3I7XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIDw9IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIGNvbG9yID0gdGhpcy5jcml0aWNhbEhlYWx0aENvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPD0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gbG93IGhlYWx0aCBhbmQgY3JpdGljYWwgaGVhbHRoIGNvbG9yc1xuICAgICAgY29uc3QgdCA9ICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyAtIHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKHRoaXMubG93SGVhbHRoVGhyZXNob2xkIC0gdGhpcy5jcml0aWNhbEhlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5jcml0aWNhbEhlYWx0aENvbG9yLCB0aGlzLmxvd0hlYWx0aENvbG9yLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBoZWFsdGggYW5kIGxvdyBoZWFsdGggY29sb3JzXG4gICAgICBjb25zdCB0ID0gKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIC0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKDEgLSB0aGlzLmxvd0hlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5sb3dIZWFsdGhDb2xvciwgdGhpcy5oZWFsdGhDb2xvciwgdCk7XG4gICAgfVxuXG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY29weShjb2xvcik7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2FtZXJhXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmFQb3NpdGlvbi5kaXN0YW5jZVRvKHdvcmxkUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiBzaG91bGQgYmUgdmlzaWJsZVxuICAgIGxldCBzaG91bGRCZVZpc2libGUgPSBkaXN0YW5jZSA8PSB0aGlzLmZhZGVEaXN0YW5jZTtcbiAgICBcbiAgICAvLyBIaWRlIHdoZW4gZnVsbCBoZWFsdGggaWYgY29uZmlndXJlZFxuICAgIGlmICghdGhpcy5zaG93V2hlbkZ1bGwgJiYgdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPj0gMC45OSkge1xuICAgICAgc2hvdWxkQmVWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpc2liaWxpdHlcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHNob3VsZEJlVmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcblxuICAgIC8vIEZhZGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZGlzdGFuY2UgPiB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykge1xuICAgICAgY29uc3QgZmFkZVJhdGlvID0gMSAtICgoZGlzdGFuY2UgLSB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykgLyAodGhpcy5mYWRlRGlzdGFuY2UgKiAwLjMpKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjEsIGZhZGVSYXRpbyk7XG4gICAgICBcbiAgICAgICh0aGlzLmJhY2tncm91bmRNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gb3BhY2l0eSAqIDAuNztcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSBvcGFjaXR5ICogMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IG9wYWNpdHkgKiAwLjg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgKHRoaXMuYmFja2dyb3VuZE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSAwLjc7XG4gICAgICAodGhpcy5oZWFsdGhNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuODtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQb3NpdGlvbiBoZWFsdGggYmFyIGFib3ZlIGVudGl0eVxuICAgIGNvbnN0IGJhclBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5ncm91cC5wb3NpdGlvbi5jb3B5KGJhclBvc2l0aW9uKTtcblxuICAgIC8vIE1ha2UgaGVhbHRoIGJhciBmYWNlIGNhbWVyYVxuICAgIHRoaXMuZ3JvdXAubG9va0F0KGNhbWVyYVBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYW1hZ2VGbGFzaFRpbWVyID4gMCkge1xuICAgICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIFxuICAgICAgLy8gRmxhc2ggZWZmZWN0IC0gbWFrZSBoZWFsdGggYmFyIGJyaWdodGVyXG4gICAgICBjb25zdCBmbGFzaEludGVuc2l0eSA9IHRoaXMuZGFtYWdlRmxhc2hUaW1lciAvIHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZsYXNoQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIE1peCBjdXJyZW50IGNvbG9yIHdpdGggd2hpdGUgZm9yIGZsYXNoIGVmZmVjdFxuICAgICAgY29uc3QgY3VycmVudENvbG9yID0gKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY2xvbmUoKTtcbiAgICAgIGN1cnJlbnRDb2xvci5sZXJwKGZsYXNoQ29sb3IsIGZsYXNoSW50ZW5zaXR5ICogMC41KTtcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLmNvcHkoY3VycmVudENvbG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJpZ2dlckRhbWFnZUZsYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlRmxhc2hUaW1lciA9IHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFsdGhSYXRpbyhyYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkUmF0aW8gPSB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbztcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhdGlvKSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkYW1hZ2UgZmxhc2ggaWYgaGVhbHRoIGRlY3JlYXNlZFxuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA8IG9sZFJhdGlvKSB7XG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VGbGFzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRHcm91cCgpOiBHcm91cCB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAodGhpcy5iYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuaGVhbHRoTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuYm9yZGVyTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBpZiBpdCBoYXMgb25lXG4gICAgaWYgKHRoaXMuZ3JvdXAucGFyZW50KSB7XG4gICAgICB0aGlzLmdyb3VwLnBhcmVudC5yZW1vdmUodGhpcy5ncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRhbWFnZUZsYXNoVGltZXIgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgdmlzdWFsIHN0YXRlXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb2xvcigpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEhlYWx0aEJhciB7XG4gICAgY29uc3QgY29uZmlnOiBIZWFsdGhCYXJDb25maWcgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLmNsb25lKCksXG4gICAgICBoZWFsdGhDb2xvcjogdGhpcy5oZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgbG93SGVhbHRoQ29sb3I6IHRoaXMubG93SGVhbHRoQ29sb3IuY2xvbmUoKSxcbiAgICAgIGNyaXRpY2FsSGVhbHRoQ29sb3I6IHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IuY2xvbmUoKSxcbiAgICAgIGJvcmRlcldpZHRoOiB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgc2hvd1doZW5GdWxsOiB0aGlzLnNob3dXaGVuRnVsbCxcbiAgICAgIGZhZGVEaXN0YW5jZTogdGhpcy5mYWRlRGlzdGFuY2UsXG4gICAgICBsb3dIZWFsdGhUaHJlc2hvbGQ6IHRoaXMubG93SGVhbHRoVGhyZXNob2xkLFxuICAgICAgY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQ6IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGRcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBuZXcgSGVhbHRoQmFyKGNvbmZpZyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJHcm91cCIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNYXRoVXRpbHMiLCJDb21wb25lbnQiLCJIZWFsdGhCYXIiLCJjcmVhdGVIZWFsdGhCYXJNZXNoZXMiLCJncm91cCIsImJvcmRlckdlb21ldHJ5Iiwid2lkdGgiLCJib3JkZXJXaWR0aCIsImhlaWdodCIsImJvcmRlck1hdGVyaWFsIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImJvcmRlck1lc2giLCJwb3NpdGlvbiIsInoiLCJhZGQiLCJiYWNrZ3JvdW5kR2VvbWV0cnkiLCJiYWNrZ3JvdW5kTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kTWVzaCIsImhlYWx0aEdlb21ldHJ5IiwiaGVhbHRoTWF0ZXJpYWwiLCJoZWFsdGhDb2xvciIsImhlYWx0aE1lc2giLCJsb29rQXQiLCJ1cGRhdGVIZWFsdGhCYXIiLCJoZWFsdGhSYXRpbyIsImNhbWVyYVBvc2l0aW9uIiwid29ybGRQb3NpdGlvbiIsImRlbHRhVGltZSIsImN1cnJlbnRIZWFsdGhSYXRpbyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhYnMiLCJsYXN0SGVhbHRoUmF0aW8iLCJsZXJwIiwiYW5pbWF0aW9uU3BlZWQiLCJ1cGRhdGVIZWFsdGhNZXNoIiwidXBkYXRlSGVhbHRoQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5IiwidXBkYXRlUG9zaXRpb25BbmRSb3RhdGlvbiIsInVwZGF0ZURhbWFnZUZsYXNoIiwic2NhbGUiLCJ4Iiwib2Zmc2V0WCIsImNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIiwiY3JpdGljYWxIZWFsdGhDb2xvciIsImxvd0hlYWx0aFRocmVzaG9sZCIsInQiLCJsZXJwQ29sb3JzIiwibG93SGVhbHRoQ29sb3IiLCJtYXRlcmlhbCIsImNvcHkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJzaG91bGRCZVZpc2libGUiLCJmYWRlRGlzdGFuY2UiLCJzaG93V2hlbkZ1bGwiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwiZmFkZVJhdGlvIiwiYmFyUG9zaXRpb24iLCJjbG9uZSIsIm9mZnNldCIsImRhbWFnZUZsYXNoVGltZXIiLCJmbGFzaEludGVuc2l0eSIsImRhbWFnZUZsYXNoRHVyYXRpb24iLCJmbGFzaENvbG9yIiwiY3VycmVudENvbG9yIiwidHJpZ2dlckRhbWFnZUZsYXNoIiwic2V0SGVhbHRoUmF0aW8iLCJyYXRpbyIsIm9sZFJhdGlvIiwiZ2V0R3JvdXAiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJwYXJlbnQiLCJyZW1vdmUiLCJyZXNldCIsImVuYWJsZWQiLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/HealthBar.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Interpolation.ts":
/*!*********************************************!*\
  !*** ./src/ecs/components/Interpolation.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterpolationBuffer: function() { return /* binding */ InterpolationBuffer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/**\n * Entity Interpolation System for Smooth Multiplayer Movement\n *\n * This system implements client-side prediction and entity interpolation to provide\n * smooth movement in multiplayer games, eliminating jerky position updates from server snapshots.\n *\n * Features:\n * - Linear interpolation (LERP) between server states\n * - Extrapolation for missing server updates\n * - Configurable interpolation delay and buffer size\n * - Automatic fallback to direct updates if interpolation fails\n *\n * Usage:\n * 1. Add InterpolationBuffer component to entities that need smooth movement\n * 2. Add InterpolationSystem to your ECS World\n * 3. Call addServerState() whenever you receive server position updates\n * 4. The InterpolationSystem will automatically handle smooth position/rotation updates\n *\n * Debug: Use window.getInterpolationStats() in browser console to monitor performance\n */ \n\nclass InterpolationBuffer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    /**\n   * Add a new server state to the interpolation buffer\n   */ addServerState(position, rotation, timestamp) {\n        const serverTimestamp = timestamp || Date.now();\n        const newState = {\n            timestamp: serverTimestamp,\n            position: position.clone(),\n            rotation: rotation.clone()\n        };\n        // Calculate velocity if we have a previous state\n        if (this.buffer.length > 0) {\n            const lastState = this.buffer[this.buffer.length - 1];\n            const timeDiff = (serverTimestamp - lastState.timestamp) / 1000; // Convert to seconds\n            if (timeDiff > 0) {\n                newState.velocity = position.clone().sub(lastState.position).divideScalar(timeDiff);\n                // Calculate angular velocity (simplified - could be improved)\n                const angleDiff = rotation.angleTo(lastState.rotation);\n                newState.angularVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, angleDiff / timeDiff, 0);\n            }\n        }\n        // Add to buffer\n        this.buffer.push(newState);\n        // Remove old states to maintain buffer size\n        while(this.buffer.length > this.maxBufferSize){\n            this.buffer.shift();\n        }\n        // Update interpolation state\n        this.updateInterpolationState(serverTimestamp);\n    }\n    /**\n   * Update the current interpolation state\n   */ updateInterpolationState(currentTime) {\n        if (this.buffer.length < 2) {\n            // Not enough states for interpolation\n            if (this.buffer.length === 1) {\n                this.currentState = {\n                    ...this.buffer[0]\n                };\n            }\n            return;\n        }\n        // Find the two states to interpolate between\n        const renderTime = currentTime - this.interpolationDelay;\n        let beforeState = null;\n        let afterState = null;\n        for(let i = 0; i < this.buffer.length - 1; i++){\n            if (this.buffer[i].timestamp <= renderTime && this.buffer[i + 1].timestamp >= renderTime) {\n                beforeState = this.buffer[i];\n                afterState = this.buffer[i + 1];\n                break;\n            }\n        }\n        if (beforeState && afterState) {\n            // We have states to interpolate between\n            this.currentState = beforeState;\n            this.targetState = afterState;\n            this.interpolationStartTime = currentTime;\n            this.interpolationDuration = afterState.timestamp - beforeState.timestamp;\n            this.extrapolationStartTime = 0; // Reset extrapolation\n        } else if (this.buffer.length > 0) {\n            // No states to interpolate - use extrapolation\n            const latestState = this.buffer[this.buffer.length - 1];\n            if (latestState.velocity) {\n                this.lastVelocity.copy(latestState.velocity);\n                this.extrapolationStartTime = currentTime;\n            }\n        }\n    }\n    /**\n   * Get the interpolated position at the current render time\n   */ getInterpolatedPosition(currentTime) {\n        if (!this.currentState || !this.targetState) {\n            // No interpolation available - use latest state or extrapolation\n            if (this.buffer.length > 0) {\n                const latestState = this.buffer[this.buffer.length - 1];\n                if (this.extrapolationStartTime > 0 && latestState.velocity) {\n                    const extrapolationTime = (currentTime - this.extrapolationStartTime) / 1000;\n                    const maxTime = this.maxExtrapolationTime / 1000;\n                    if (extrapolationTime < maxTime) {\n                        // Extrapolate position\n                        return latestState.position.clone().add(latestState.velocity.clone().multiplyScalar(extrapolationTime));\n                    }\n                }\n                return latestState.position.clone();\n            }\n            return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        }\n        // Calculate interpolation factor\n        const elapsed = currentTime - this.interpolationStartTime;\n        let t = elapsed / this.interpolationDuration;\n        // Clamp t between 0 and 1\n        t = Math.max(0, Math.min(1, t));\n        // Linear interpolation between current and target states\n        const interpolatedPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        interpolatedPosition.lerpVectors(this.currentState.position, this.targetState.position, t);\n        return interpolatedPosition;\n    }\n    /**\n   * Get the interpolated rotation at the current render time\n   */ getInterpolatedRotation(currentTime) {\n        if (!this.currentState || !this.targetState) {\n            // No interpolation available - use latest state\n            if (this.buffer.length > 0) {\n                return this.buffer[this.buffer.length - 1].rotation.clone();\n            }\n            return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        }\n        // Calculate interpolation factor\n        const elapsed = currentTime - this.interpolationStartTime;\n        let t = elapsed / this.interpolationDuration;\n        t = Math.max(0, Math.min(1, t));\n        // Spherical linear interpolation for rotations\n        const interpolatedRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        interpolatedRotation.copy(this.currentState.rotation);\n        interpolatedRotation.slerp(this.targetState.rotation, t);\n        return interpolatedRotation;\n    }\n    /**\n   * Get the interpolated transform (position and rotation) at the current render time\n   */ getInterpolatedTransform(currentTime) {\n        return {\n            position: this.getInterpolatedPosition(currentTime),\n            rotation: this.getInterpolatedRotation(currentTime)\n        };\n    }\n    /**\n   * Check if we're currently extrapolating (no recent server updates)\n   */ isExtrapolating(currentTime) {\n        return this.extrapolationStartTime > 0 && currentTime - this.extrapolationStartTime < this.maxExtrapolationTime;\n    }\n    /**\n   * Get buffer statistics for debugging\n   */ getBufferStats() {\n        return {\n            bufferSize: this.buffer.length,\n            maxBufferSize: this.maxBufferSize,\n            interpolationDelay: this.interpolationDelay,\n            isInterpolating: this.currentState !== null && this.targetState !== null,\n            isExtrapolating: this.extrapolationStartTime > 0,\n            latestTimestamp: this.buffer.length > 0 ? this.buffer[this.buffer.length - 1].timestamp : null\n        };\n    }\n    /**\n   * Clear the interpolation buffer\n   */ clearBuffer() {\n        this.buffer.length = 0;\n        this.currentState = null;\n        this.targetState = null;\n        this.interpolationStartTime = 0;\n        this.extrapolationStartTime = 0;\n    }\n    reset() {\n        this.clearBuffer();\n        this.lastVelocity.set(0, 0, 0);\n        this.lastAngularVelocity.set(0, 0, 0);\n        this.enabled = true;\n    }\n    constructor(){\n        super();\n        this.componentType = \"InterpolationBuffer\";\n        // Buffer to store recent server states\n        this.buffer = [];\n        this.maxBufferSize = 10 // Keep last 10 states for interpolation\n        ;\n        this.interpolationDelay = 100 // ms delay for interpolation (100ms = ~6-7 frames at 60fps)\n        ;\n        // Current interpolation state\n        this.currentState = null;\n        this.targetState = null;\n        this.interpolationStartTime = 0;\n        this.interpolationDuration = 0;\n        // Extrapolation settings\n        this.lastVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.lastAngularVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.extrapolationStartTime = 0;\n        this.maxExtrapolationTime = 500 // Max time to extrapolate before snapping (500ms)\n        ;\n    }\n}\nInterpolationBuffer.componentType = \"InterpolationBuffer\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQzJEO0FBQ3RCO0FBVS9CLE1BQU1HLDRCQUE0QkQsOENBQVNBO0lBeUJoRDs7R0FFQyxHQUNELGVBQXNCRyxRQUFpQixFQUFFQyxRQUFvQixFQUFFQyxTQUFrQixFQUFRO1FBQ3ZGLE1BQU1DLGtCQUFrQkQsYUFBYUUsS0FBS0MsR0FBRztRQUU3QyxNQUFNQyxXQUF3QjtZQUM1QkosV0FBV0M7WUFDWEgsVUFBVUEsU0FBU08sS0FBSztZQUN4Qk4sVUFBVUEsU0FBU00sS0FBSztRQUMxQjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLEdBQUcsR0FBRztZQUMxQixNQUFNQyxZQUFZLElBQUksQ0FBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtZQUNyRCxNQUFNRSxXQUFXLENBQUNSLGtCQUFrQk8sVUFBVVIsU0FBUyxJQUFJLE1BQU0scUJBQXFCO1lBRXRGLElBQUlTLFdBQVcsR0FBRztnQkFDaEJMLFNBQVNNLFFBQVEsR0FBR1osU0FBU08sS0FBSyxHQUFHTSxHQUFHLENBQUNILFVBQVVWLFFBQVEsRUFBRWMsWUFBWSxDQUFDSDtnQkFFMUUsOERBQThEO2dCQUM5RCxNQUFNSSxZQUFZZCxTQUFTZSxPQUFPLENBQUNOLFVBQVVULFFBQVE7Z0JBQ3JESyxTQUFTVyxlQUFlLEdBQUcsSUFBSXRCLHlEQUFPQSxDQUFDLEdBQUdvQixZQUFZSixVQUFVO1lBQ2xFO1FBQ0Y7UUFFQSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDSCxNQUFNLENBQUNVLElBQUksQ0FBQ1o7UUFFakIsNENBQTRDO1FBQzVDLE1BQU8sSUFBSSxDQUFDRSxNQUFNLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNVLGFBQWEs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SUFDaEM7SUFFTzJCLFFBQWM7UUFDbkIsSUFBSSxDQUFDRCxXQUFXO1FBQ2hCLElBQUksQ0FBQ3hCLFlBQVksQ0FBQzBCLEdBQUcsQ0FBQyxHQUFHLEdBQUc7UUFDNUIsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0QsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUNuQyxJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNqQjtJQXJNQUMsYUFBYztRQUNaLEtBQUs7YUFwQlNDLGdCQUFnQjtRQUVoQyx1Q0FBdUM7YUFDL0J4RCxTQUF3QixFQUFFO2FBQ2pCVyxnQkFBZ0IsR0FBSSx3Q0FBd0M7O2FBQzVETSxxQkFBcUIsSUFBSyw0REFBNEQ7O1FBRXZHLDhCQUE4QjthQUN0QkYsZUFBbUM7YUFDbkNNLGNBQWtDO2FBQ2xDQyx5QkFBeUI7YUFDekJDLHdCQUF3QjtRQUVoQyx5QkFBeUI7YUFDakJHLGVBQXdCLElBQUl2Qyx5REFBT0E7YUFDbkNrRSxzQkFBK0IsSUFBSWxFLHlEQUFPQTthQUMxQ3FDLHlCQUF5QjthQUN6Qk8sdUJBQXVCLElBQUssa0RBQWtEOztJQUl0RjtBQW9NRjtBQTNOYXpDLG9CQUNZa0UsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uLnRzP2FkZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbnRpdHkgSW50ZXJwb2xhdGlvbiBTeXN0ZW0gZm9yIFNtb290aCBNdWx0aXBsYXllciBNb3ZlbWVudFxuICpcbiAqIFRoaXMgc3lzdGVtIGltcGxlbWVudHMgY2xpZW50LXNpZGUgcHJlZGljdGlvbiBhbmQgZW50aXR5IGludGVycG9sYXRpb24gdG8gcHJvdmlkZVxuICogc21vb3RoIG1vdmVtZW50IGluIG11bHRpcGxheWVyIGdhbWVzLCBlbGltaW5hdGluZyBqZXJreSBwb3NpdGlvbiB1cGRhdGVzIGZyb20gc2VydmVyIHNuYXBzaG90cy5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gTGluZWFyIGludGVycG9sYXRpb24gKExFUlApIGJldHdlZW4gc2VydmVyIHN0YXRlc1xuICogLSBFeHRyYXBvbGF0aW9uIGZvciBtaXNzaW5nIHNlcnZlciB1cGRhdGVzXG4gKiAtIENvbmZpZ3VyYWJsZSBpbnRlcnBvbGF0aW9uIGRlbGF5IGFuZCBidWZmZXIgc2l6ZVxuICogLSBBdXRvbWF0aWMgZmFsbGJhY2sgdG8gZGlyZWN0IHVwZGF0ZXMgaWYgaW50ZXJwb2xhdGlvbiBmYWlsc1xuICpcbiAqIFVzYWdlOlxuICogMS4gQWRkIEludGVycG9sYXRpb25CdWZmZXIgY29tcG9uZW50IHRvIGVudGl0aWVzIHRoYXQgbmVlZCBzbW9vdGggbW92ZW1lbnRcbiAqIDIuIEFkZCBJbnRlcnBvbGF0aW9uU3lzdGVtIHRvIHlvdXIgRUNTIFdvcmxkXG4gKiAzLiBDYWxsIGFkZFNlcnZlclN0YXRlKCkgd2hlbmV2ZXIgeW91IHJlY2VpdmUgc2VydmVyIHBvc2l0aW9uIHVwZGF0ZXNcbiAqIDQuIFRoZSBJbnRlcnBvbGF0aW9uU3lzdGVtIHdpbGwgYXV0b21hdGljYWxseSBoYW5kbGUgc21vb3RoIHBvc2l0aW9uL3JvdGF0aW9uIHVwZGF0ZXNcbiAqXG4gKiBEZWJ1ZzogVXNlIHdpbmRvdy5nZXRJbnRlcnBvbGF0aW9uU3RhdHMoKSBpbiBicm93c2VyIGNvbnNvbGUgdG8gbW9uaXRvciBwZXJmb3JtYW5jZVxuICovXG5pbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyU3RhdGUge1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgcG9zaXRpb246IFZlY3RvcjM7XG4gIHJvdGF0aW9uOiBRdWF0ZXJuaW9uO1xuICB2ZWxvY2l0eT86IFZlY3RvcjM7XG4gIGFuZ3VsYXJWZWxvY2l0eT86IFZlY3RvcjM7XG59XG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uQnVmZmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0ludGVycG9sYXRpb25CdWZmZXInO1xuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdJbnRlcnBvbGF0aW9uQnVmZmVyJztcblxuICAvLyBCdWZmZXIgdG8gc3RvcmUgcmVjZW50IHNlcnZlciBzdGF0ZXNcbiAgcHJpdmF0ZSBidWZmZXI6IFNlcnZlclN0YXRlW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhCdWZmZXJTaXplID0gMTA7IC8vIEtlZXAgbGFzdCAxMCBzdGF0ZXMgZm9yIGludGVycG9sYXRpb25cbiAgcHJpdmF0ZSByZWFkb25seSBpbnRlcnBvbGF0aW9uRGVsYXkgPSAxMDA7IC8vIG1zIGRlbGF5IGZvciBpbnRlcnBvbGF0aW9uICgxMDBtcyA9IH42LTcgZnJhbWVzIGF0IDYwZnBzKVxuXG4gIC8vIEN1cnJlbnQgaW50ZXJwb2xhdGlvbiBzdGF0ZVxuICBwcml2YXRlIGN1cnJlbnRTdGF0ZTogU2VydmVyU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0YXJnZXRTdGF0ZTogU2VydmVyU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uRHVyYXRpb24gPSAwO1xuXG4gIC8vIEV4dHJhcG9sYXRpb24gc2V0dGluZ3NcbiAgcHJpdmF0ZSBsYXN0VmVsb2NpdHk6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGxhc3RBbmd1bGFyVmVsb2NpdHk6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGV4dHJhcG9sYXRpb25TdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIG1heEV4dHJhcG9sYXRpb25UaW1lID0gNTAwOyAvLyBNYXggdGltZSB0byBleHRyYXBvbGF0ZSBiZWZvcmUgc25hcHBpbmcgKDUwMG1zKVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHNlcnZlciBzdGF0ZSB0byB0aGUgaW50ZXJwb2xhdGlvbiBidWZmZXJcbiAgICovXG4gIHB1YmxpYyBhZGRTZXJ2ZXJTdGF0ZShwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHNlcnZlclRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgY29uc3QgbmV3U3RhdGU6IFNlcnZlclN0YXRlID0ge1xuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24uY2xvbmUoKSxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbi5jbG9uZSgpXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB2ZWxvY2l0eSBpZiB3ZSBoYXZlIGEgcHJldmlvdXMgc3RhdGVcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB0aW1lRGlmZiA9IChzZXJ2ZXJUaW1lc3RhbXAgLSBsYXN0U3RhdGUudGltZXN0YW1wKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuXG4gICAgICBpZiAodGltZURpZmYgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlLnZlbG9jaXR5ID0gcG9zaXRpb24uY2xvbmUoKS5zdWIobGFzdFN0YXRlLnBvc2l0aW9uKS5kaXZpZGVTY2FsYXIodGltZURpZmYpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbmd1bGFyIHZlbG9jaXR5IChzaW1wbGlmaWVkIC0gY291bGQgYmUgaW1wcm92ZWQpXG4gICAgICAgIGNvbnN0IGFuZ2xlRGlmZiA9IHJvdGF0aW9uLmFuZ2xlVG8obGFzdFN0YXRlLnJvdGF0aW9uKTtcbiAgICAgICAgbmV3U3RhdGUuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgYW5nbGVEaWZmIC8gdGltZURpZmYsIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBidWZmZXJcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKG5ld1N0YXRlKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgc3RhdGVzIHRvIG1haW50YWluIGJ1ZmZlciBzaXplXG4gICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgdGhpcy5idWZmZXIuc2hpZnQoKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgaW50ZXJwb2xhdGlvbiBzdGF0ZVxuICAgIHRoaXMudXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlKHNlcnZlclRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IGludGVycG9sYXRpb24gc3RhdGVcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgMikge1xuICAgICAgLy8gTm90IGVub3VnaCBzdGF0ZXMgZm9yIGludGVycG9sYXRpb25cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB7IC4uLnRoaXMuYnVmZmVyWzBdIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgdHdvIHN0YXRlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG4gICAgY29uc3QgcmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5pbnRlcnBvbGF0aW9uRGVsYXk7XG4gICAgbGV0IGJlZm9yZVN0YXRlOiBTZXJ2ZXJTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBhZnRlclN0YXRlOiBTZXJ2ZXJTdGF0ZSB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcltpXS50aW1lc3RhbXAgPD0gcmVuZGVyVGltZSAmJiB0aGlzLmJ1ZmZlcltpICsgMV0udGltZXN0YW1wID49IHJlbmRlclRpbWUpIHtcbiAgICAgICAgYmVmb3JlU3RhdGUgPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgYWZ0ZXJTdGF0ZSA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZVN0YXRlICYmIGFmdGVyU3RhdGUpIHtcbiAgICAgIC8vIFdlIGhhdmUgc3RhdGVzIHRvIGludGVycG9sYXRlIGJldHdlZW5cbiAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gYmVmb3JlU3RhdGU7XG4gICAgICB0aGlzLnRhcmdldFN0YXRlID0gYWZ0ZXJTdGF0ZTtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uRHVyYXRpb24gPSBhZnRlclN0YXRlLnRpbWVzdGFtcCAtIGJlZm9yZVN0YXRlLnRpbWVzdGFtcDtcbiAgICAgIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA9IDA7IC8vIFJlc2V0IGV4dHJhcG9sYXRpb25cbiAgICB9IGVsc2UgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIE5vIHN0YXRlcyB0byBpbnRlcnBvbGF0ZSAtIHVzZSBleHRyYXBvbGF0aW9uXG4gICAgICBjb25zdCBsYXRlc3RTdGF0ZSA9IHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhdGVzdFN0YXRlLnZlbG9jaXR5KSB7XG4gICAgICAgIHRoaXMubGFzdFZlbG9jaXR5LmNvcHkobGF0ZXN0U3RhdGUudmVsb2NpdHkpO1xuICAgICAgICB0aGlzLmV4dHJhcG9sYXRpb25TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgcG9zaXRpb24gYXQgdGhlIGN1cnJlbnQgcmVuZGVyIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRJbnRlcnBvbGF0ZWRQb3NpdGlvbihjdXJyZW50VGltZTogbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSB8fCAhdGhpcy50YXJnZXRTdGF0ZSkge1xuICAgICAgLy8gTm8gaW50ZXJwb2xhdGlvbiBhdmFpbGFibGUgLSB1c2UgbGF0ZXN0IHN0YXRlIG9yIGV4dHJhcG9sYXRpb25cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFN0YXRlID0gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA+IDAgJiYgbGF0ZXN0U3RhdGUudmVsb2NpdHkpIHtcbiAgICAgICAgICBjb25zdCBleHRyYXBvbGF0aW9uVGltZSA9IChjdXJyZW50VGltZSAtIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSkgLyAxMDAwO1xuICAgICAgICAgIGNvbnN0IG1heFRpbWUgPSB0aGlzLm1heEV4dHJhcG9sYXRpb25UaW1lIC8gMTAwMDtcblxuICAgICAgICAgIGlmIChleHRyYXBvbGF0aW9uVGltZSA8IG1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhcG9sYXRlIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0U3RhdGUucG9zaXRpb24uY2xvbmUoKS5hZGQoXG4gICAgICAgICAgICAgIGxhdGVzdFN0YXRlLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZXh0cmFwb2xhdGlvblRpbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXRlc3RTdGF0ZS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZTtcbiAgICBsZXQgdCA9IGVsYXBzZWQgLyB0aGlzLmludGVycG9sYXRpb25EdXJhdGlvbjtcblxuICAgIC8vIENsYW1wIHQgYmV0d2VlbiAwIGFuZCAxXG4gICAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcblxuICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gY3VycmVudCBhbmQgdGFyZ2V0IHN0YXRlc1xuICAgIGNvbnN0IGludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBpbnRlcnBvbGF0ZWRQb3NpdGlvbi5sZXJwVmVjdG9ycyh0aGlzLmN1cnJlbnRTdGF0ZS5wb3NpdGlvbiwgdGhpcy50YXJnZXRTdGF0ZS5wb3NpdGlvbiwgdCk7XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgcm90YXRpb24gYXQgdGhlIGN1cnJlbnQgcmVuZGVyIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRJbnRlcnBvbGF0ZWRSb3RhdGlvbihjdXJyZW50VGltZTogbnVtYmVyKTogUXVhdGVybmlvbiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSB8fCAhdGhpcy50YXJnZXRTdGF0ZSkge1xuICAgICAgLy8gTm8gaW50ZXJwb2xhdGlvbiBhdmFpbGFibGUgLSB1c2UgbGF0ZXN0IHN0YXRlXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV0ucm90YXRpb24uY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZTtcbiAgICBsZXQgdCA9IGVsYXBzZWQgLyB0aGlzLmludGVycG9sYXRpb25EdXJhdGlvbjtcbiAgICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuXG4gICAgLy8gU3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciByb3RhdGlvbnNcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgaW50ZXJwb2xhdGVkUm90YXRpb24uY29weSh0aGlzLmN1cnJlbnRTdGF0ZS5yb3RhdGlvbik7XG4gICAgaW50ZXJwb2xhdGVkUm90YXRpb24uc2xlcnAodGhpcy50YXJnZXRTdGF0ZS5yb3RhdGlvbiwgdCk7XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkUm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgdHJhbnNmb3JtIChwb3NpdGlvbiBhbmQgcm90YXRpb24pIGF0IHRoZSBjdXJyZW50IHJlbmRlciB0aW1lXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB7IHBvc2l0aW9uOiBWZWN0b3IzOyByb3RhdGlvbjogUXVhdGVybmlvbiB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHRoaXMuZ2V0SW50ZXJwb2xhdGVkUG9zaXRpb24oY3VycmVudFRpbWUpLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0SW50ZXJwb2xhdGVkUm90YXRpb24oY3VycmVudFRpbWUpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3ZSdyZSBjdXJyZW50bHkgZXh0cmFwb2xhdGluZyAobm8gcmVjZW50IHNlcnZlciB1cGRhdGVzKVxuICAgKi9cbiAgcHVibGljIGlzRXh0cmFwb2xhdGluZyhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA+IDAgJiZcbiAgICAgICAgICAgKGN1cnJlbnRUaW1lIC0gdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lKSA8IHRoaXMubWF4RXh0cmFwb2xhdGlvblRpbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlciBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIHB1YmxpYyBnZXRCdWZmZXJTdGF0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnVmZmVyU2l6ZTogdGhpcy5idWZmZXIubGVuZ3RoLFxuICAgICAgbWF4QnVmZmVyU2l6ZTogdGhpcy5tYXhCdWZmZXJTaXplLFxuICAgICAgaW50ZXJwb2xhdGlvbkRlbGF5OiB0aGlzLmludGVycG9sYXRpb25EZWxheSxcbiAgICAgIGlzSW50ZXJwb2xhdGluZzogdGhpcy5jdXJyZW50U3RhdGUgIT09IG51bGwgJiYgdGhpcy50YXJnZXRTdGF0ZSAhPT0gbnVsbCxcbiAgICAgIGlzRXh0cmFwb2xhdGluZzogdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lID4gMCxcbiAgICAgIGxhdGVzdFRpbWVzdGFtcDogdGhpcy5idWZmZXIubGVuZ3RoID4gMCA/IHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyLmxlbmd0aCAtIDFdLnRpbWVzdGFtcCA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBpbnRlcnBvbGF0aW9uIGJ1ZmZlclxuICAgKi9cbiAgcHVibGljIGNsZWFyQnVmZmVyKCk6IHZvaWQge1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50U3RhdGUgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U3RhdGUgPSBudWxsO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyQnVmZmVyKCk7XG4gICAgdGhpcy5sYXN0VmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGFzdEFuZ3VsYXJWZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiQ29tcG9uZW50IiwiSW50ZXJwb2xhdGlvbkJ1ZmZlciIsImFkZFNlcnZlclN0YXRlIiwicG9zaXRpb24iLCJyb3RhdGlvbiIsInRpbWVzdGFtcCIsInNlcnZlclRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJuZXdTdGF0ZSIsImNsb25lIiwiYnVmZmVyIiwibGVuZ3RoIiwibGFzdFN0YXRlIiwidGltZURpZmYiLCJ2ZWxvY2l0eSIsInN1YiIsImRpdmlkZVNjYWxhciIsImFuZ2xlRGlmZiIsImFuZ2xlVG8iLCJhbmd1bGFyVmVsb2NpdHkiLCJwdXNoIiwibWF4QnVmZmVyU2l6ZSIsInNoaWZ0IiwidXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlIiwiY3VycmVudFRpbWUiLCJjdXJyZW50U3RhdGUiLCJyZW5kZXJUaW1lIiwiaW50ZXJwb2xhdGlvbkRlbGF5IiwiYmVmb3JlU3RhdGUiLCJhZnRlclN0YXRlIiwiaSIsInRhcmdldFN0YXRlIiwiaW50ZXJwb2xhdGlvblN0YXJ0VGltZSIsImludGVycG9sYXRpb25EdXJhdGlvbiIsImV4dHJhcG9sYXRpb25TdGFydFRpbWUiLCJsYXRlc3RTdGF0ZSIsImxhc3RWZWxvY2l0eSIsImNvcHkiLCJnZXRJbnRlcnBvbGF0ZWRQb3NpdGlvbiIsImV4dHJhcG9sYXRpb25UaW1lIiwibWF4VGltZSIsIm1heEV4dHJhcG9sYXRpb25UaW1lIiwiYWRkIiwibXVsdGlwbHlTY2FsYXIiLCJlbGFwc2VkIiwidCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJpbnRlcnBvbGF0ZWRQb3NpdGlvbiIsImxlcnBWZWN0b3JzIiwiZ2V0SW50ZXJwb2xhdGVkUm90YXRpb24iLCJpbnRlcnBvbGF0ZWRSb3RhdGlvbiIsInNsZXJwIiwiZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwiaXNFeHRyYXBvbGF0aW5nIiwiZ2V0QnVmZmVyU3RhdHMiLCJidWZmZXJTaXplIiwiaXNJbnRlcnBvbGF0aW5nIiwibGF0ZXN0VGltZXN0YW1wIiwiY2xlYXJCdWZmZXIiLCJyZXNldCIsInNldCIsImxhc3RBbmd1bGFyVmVsb2NpdHkiLCJlbmFibGVkIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Interpolation.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Movement.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Movement.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Movement: function() { return /* binding */ Movement; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Movement component for velocity and movement properties\n\n\nclass Movement extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    addForce(force) {\n        this.acceleration.add(force);\n    }\n    addImpulse(impulse) {\n        this.velocity.add(impulse);\n    }\n    jump() {\n        if (this.canJump && (this.isGrounded || this.canFly)) {\n            this.velocity.y = this.jumpForce;\n            this.isGrounded = false;\n        }\n    }\n    setMoveDirection(direction) {\n        let strength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n        this.moveDirection.copy(direction).normalize();\n        this.inputStrength = Math.max(0, Math.min(1, strength));\n    }\n    freeze(duration) {\n        const currentTime = Date.now();\n        this.isFrozen = true;\n        this.frozenUntil = currentTime + duration;\n    // console.log(`🧊 Player frozen for ${duration}ms until ${this.frozenUntil} (current: ${currentTime})`);\n    }\n    slow(duration) {\n        let speedMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n        const currentTime = Date.now();\n        this.isSlowed = true;\n        this.slowedUntil = currentTime + duration;\n        this.movementSpeedMultiplier = speedMultiplier;\n    // console.log(`🐌 Player slowed to ${speedMultiplier * 100}% speed for ${duration}ms until ${this.slowedUntil}`);\n    }\n    updateDebuffs() {\n        const currentTime = Date.now();\n        // Check frozen state\n        if (this.isFrozen && currentTime >= this.frozenUntil) {\n            this.isFrozen = false;\n            this.frozenUntil = 0;\n        }\n        // Check slowed state\n        if (this.isSlowed && currentTime >= this.slowedUntil) {\n            this.isSlowed = false;\n            this.slowedUntil = 0;\n            this.movementSpeedMultiplier = 1.0;\n        }\n    }\n    getEffectiveMaxSpeed() {\n        if (this.isFrozen) {\n            return 0; // Completely frozen\n        }\n        return this.maxSpeed * this.movementSpeedMultiplier;\n    }\n    startDash(direction, currentPosition, currentTime) {\n        // Check if already dashing\n        if (this.isDashing) {\n            return false;\n        }\n        // Find first available charge\n        const availableChargeIndex = this.dashCharges.findIndex((charge)=>charge.isAvailable);\n        if (availableChargeIndex === -1) {\n            return false; // No charges available\n        }\n        // Start the dash\n        this.isDashing = true;\n        this.dashDirection.copy(direction).normalize();\n        this.dashStartTime = currentTime;\n        this.dashStartPosition.copy(currentPosition);\n        // Consume the charge\n        this.dashCharges[availableChargeIndex].isAvailable = false;\n        this.dashCharges[availableChargeIndex].cooldownStartTime = currentTime;\n        // Set cooldown timer for this specific charge (6 seconds)\n        setTimeout(()=>{\n            this.dashCharges[availableChargeIndex].isAvailable = true;\n            this.dashCharges[availableChargeIndex].cooldownStartTime = null;\n        }, 6000); // 6 second cooldown\n        return true;\n    }\n    updateDash(currentTime) {\n        if (!this.isDashing) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.dashStartTime;\n        const progress = Math.min(elapsed / this.dashDuration, 1);\n        if (progress >= 1) {\n            // Dash complete\n            this.isDashing = false;\n            const finalPosition = this.dashStartPosition.clone().add(this.dashDirection.clone().multiplyScalar(this.dashDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad, same as old implementation)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.dashDirection.clone().multiplyScalar(this.dashDistance * easeOutQuad);\n        const newPosition = this.dashStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelDash() {\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n    }\n    stop() {\n        this.velocity.set(0, 0, 0);\n        this.acceleration.set(0, 0, 0);\n        this.moveDirection.set(0, 0, 0);\n        this.inputStrength = 0;\n    }\n    getSpeed() {\n        return this.velocity.length();\n    }\n    getHorizontalSpeed() {\n        return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);\n    }\n    isMoving() {\n        return this.getSpeed() > 0.01;\n    }\n    isMovingHorizontally() {\n        return this.getHorizontalSpeed() > 0.01;\n    }\n    isFalling() {\n        return this.velocity.y < -0.1;\n    }\n    isRising() {\n        return this.velocity.y > 0.1;\n    }\n    getAvailableDashCharges() {\n        return this.dashCharges.filter((charge)=>charge.isAvailable).length;\n    }\n    getDashChargeStatus() {\n        const currentTime = Date.now() / 1000;\n        return this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownRemaining: charge.cooldownStartTime ? Math.max(0, 6 - (currentTime - charge.cooldownStartTime)) : 0\n            }));\n    }\n    startCharge(direction, currentPosition, currentTime) {\n        // Check if already charging or dashing\n        if (this.isCharging || this.isDashing) {\n            return false;\n        }\n        // Start the charge\n        this.isCharging = true;\n        this.chargeDirection.copy(direction).normalize();\n        this.chargeStartTime = currentTime;\n        this.chargeStartPosition.copy(currentPosition);\n        return true;\n    }\n    updateCharge(currentTime) {\n        if (!this.isCharging) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.chargeStartTime;\n        const progress = Math.min(elapsed / this.chargeDuration, 1);\n        if (progress >= 1) {\n            // Charge complete\n            this.isCharging = false;\n            const finalPosition = this.chargeStartPosition.clone().add(this.chargeDirection.clone().multiplyScalar(this.chargeDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.chargeDirection.clone().multiplyScalar(this.chargeDistance * easeOutQuad);\n        const newPosition = this.chargeStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelCharge() {\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n    }\n    clampVelocity() {\n        // Get effective max speed (considering debuffs)\n        const effectiveMaxSpeed = this.getEffectiveMaxSpeed();\n        // Clamp horizontal velocity to effective max speed\n        const horizontalVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.velocity.x, 0, this.velocity.z);\n        const horizontalSpeed = horizontalVelocity.length();\n        if (horizontalSpeed > effectiveMaxSpeed) {\n            if (effectiveMaxSpeed === 0) {\n                // Completely frozen - stop all horizontal movement\n                this.velocity.x = 0;\n                this.velocity.z = 0;\n            } else {\n                horizontalVelocity.normalize().multiplyScalar(effectiveMaxSpeed);\n                this.velocity.x = horizontalVelocity.x;\n                this.velocity.z = horizontalVelocity.z;\n            }\n        }\n    }\n    applyFriction(deltaTime) {\n        if (!this.canMove) return;\n        // Apply friction to horizontal movement\n        const frictionForce = Math.pow(this.friction, deltaTime);\n        this.velocity.x *= frictionForce;\n        this.velocity.z *= frictionForce;\n        // Stop very small velocities to prevent jitter\n        if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;\n        if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;\n    }\n    applyGravity(deltaTime) {\n        if (!this.canFly) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.velocity) {\n            this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.velocity.set(0, 0, 0);\n        }\n        if (!this.acceleration) {\n            this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.acceleration.set(0, 0, 0);\n        }\n        if (!this.moveDirection) {\n            this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.moveDirection.set(0, 0, 0);\n        }\n        this.inputStrength = 0;\n        this.isGrounded = false;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        this.maxSpeed = 5.0;\n        this.friction = 0.8;\n        this.jumpForce = 20.0;\n        this.gravity = -12.5;\n        this.enabled = true;\n        // Reset debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Reset dash properties\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35;\n        this.dashDistance = 4;\n        this.dashStartPosition.set(0, 0, 0);\n        // Reset dash charges\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Reset charge properties\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35;\n        this.chargeDistance = 9;\n        this.chargeStartPosition.set(0, 0, 0);\n    }\n    clone() {\n        const clone = new Movement(this.maxSpeed, this.friction, this.jumpForce, this.gravity);\n        clone.velocity.copy(this.velocity);\n        clone.acceleration.copy(this.acceleration);\n        clone.moveDirection.copy(this.moveDirection);\n        clone.inputStrength = this.inputStrength;\n        clone.isGrounded = this.isGrounded;\n        clone.canMove = this.canMove;\n        clone.canJump = this.canJump;\n        clone.canFly = this.canFly;\n        // Clone debuff states\n        clone.isFrozen = this.isFrozen;\n        clone.frozenUntil = this.frozenUntil;\n        clone.isSlowed = this.isSlowed;\n        clone.slowedUntil = this.slowedUntil;\n        clone.movementSpeedMultiplier = this.movementSpeedMultiplier;\n        // Clone dash properties\n        clone.isDashing = this.isDashing;\n        clone.dashDirection.copy(this.dashDirection);\n        clone.dashStartTime = this.dashStartTime;\n        clone.dashDuration = this.dashDuration;\n        clone.dashDistance = this.dashDistance;\n        clone.dashStartPosition.copy(this.dashStartPosition);\n        // Clone dash charges\n        clone.maxDashCharges = this.maxDashCharges;\n        clone.dashCharges = this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownStartTime: charge.cooldownStartTime\n            }));\n        // Clone charge properties\n        clone.isCharging = this.isCharging;\n        clone.chargeDirection.copy(this.chargeDirection);\n        clone.chargeStartTime = this.chargeStartTime;\n        clone.chargeDuration = this.chargeDuration;\n        clone.chargeDistance = this.chargeDistance;\n        clone.chargeStartPosition.copy(this.chargeStartPosition);\n        return clone;\n    }\n    constructor(maxSpeed = 3.75, friction = 0.8, jumpForce = 20.0, gravity = -12.5){\n        super();\n        this.componentType = \"Movement\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.maxSpeed = maxSpeed;\n        this.friction = friction;\n        this.isGrounded = false;\n        this.jumpForce = jumpForce;\n        this.gravity = gravity;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        // Initialize debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.inputStrength = 0;\n        // Initialize dash properties\n        this.isDashing = false;\n        this.dashDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35; // 350ms dash duration (same as old implementation)\n        this.dashDistance = 4; // Increased from 3.125 for more noticeable dash\n        this.dashStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize multiple dash charges (3 charges, each with 6s cooldown)\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Initialize sword charge properties\n        this.isCharging = false;\n        this.chargeDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35; // 350ms charge duration\n        this.chargeDistance = 9; // Sword charge distance\n        this.chargeStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nMovement.componentType = \"Movement\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFBMEQ7QUFDVjtBQUNWO0FBRS9CLE1BQU1FLGlCQUFpQkQsOENBQVNBO0lBd0c5QkUsU0FBU0MsS0FBYyxFQUFRO1FBQ3BDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUNGO0lBQ3hCO0lBRU9HLFdBQVdDLE9BQWdCLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxRQUFRLENBQUNILEdBQUcsQ0FBQ0U7SUFDcEI7SUFFT0UsT0FBYTtRQUNsQixJQUFJLElBQUksQ0FBQ0MsT0FBTyxJQUFLLEtBQUksQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ3BELElBQUksQ0FBQ0osUUFBUSxDQUFDSyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1lBQ2hDLElBQUksQ0FBQ0gsVUFBVSxHQUFHO1FBQ3BCO0lBQ0Y7SUFFT0ksaUJBQWlCQyxTQUFrQixFQUFnQztZQUE5QkMsV0FBQUEsaUVBQW1CO1FBQzdELElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNILFdBQVdJLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR1A7SUFDL0M7SUFFT1EsT0FBT0MsUUFBZ0IsRUFBUTtRQUNwQyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO1FBQzVCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixjQUFjRDtJQUNqQyx5R0FBeUc7SUFDM0c7SUFFT00sS0FBS04sUUFBZ0IsRUFBdUM7WUFBckNPLGtCQUFBQSxpRUFBMEI7UUFDdEQsTUFBTU4sY0FBY0MsS0FBS0MsR0FBRztRQUM1QixJQUFJLENBQUNLLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR1IsY0FBY0Q7UUFD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QSxDQUFDLEdBQUcsR0FBRztRQUN2QyxJQUFJLENBQUNzQixhQUFhLEdBQUc7UUFFckIsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ3FCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNNLGFBQWEsR0FBRyxJQUFJakQseURBQU9BLENBQUMsR0FBRyxHQUFHO1FBQ3ZDLElBQUksQ0FBQ2tELGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNTLFlBQVksR0FBRyxNQUFNLG1EQUFtRDtRQUM3RSxJQUFJLENBQUNJLFlBQVksR0FBRyxHQUFHLGdEQUFnRDtRQUN2RSxJQUFJLENBQUNaLGlCQUFpQixHQUFHLElBQUluRCx5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFFM0Msc0VBQXNFO1FBQ3RFLElBQUksQ0FBQzRHLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUMvRCxXQUFXLEdBQUdnRSxNQUFNQyxJQUFJLENBQUM7WUFBRXZDLFFBQVEsSUFBSSxDQUFDcUMsY0FBYztRQUFDLEdBQUcsSUFBTztnQkFDcEU1RCxhQUFhO2dCQUNiSSxtQkFBbUI7WUFDckI7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDa0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUl2Rix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDekMsSUFBSSxDQUFDd0YsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0csY0FBYyxHQUFHLE1BQU0sd0JBQXdCO1FBQ3BELElBQUksQ0FBQ0MsY0FBYyxHQUFHLEdBQUcsd0JBQXdCO1FBQ2pELElBQUksQ0FBQ0gsbUJBQW1CLEdBQUcsSUFBSXpGLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztJQUMvQztBQXFXRjtBQTNjYUUsU0FDWThHLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQudHM/MThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb3ZlbWVudCBjb21wb25lbnQgZm9yIHZlbG9jaXR5IGFuZCBtb3ZlbWVudCBwcm9wZXJ0aWVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBNb3ZlbWVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgYWNjZWxlcmF0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgbWF4U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGZyaWN0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBpc0dyb3VuZGVkOiBib29sZWFuO1xuICBwdWJsaWMganVtcEZvcmNlOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgZmxhZ3NcbiAgcHVibGljIGNhbk1vdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBjYW5KdW1wOiBib29sZWFuO1xuICBwdWJsaWMgY2FuRmx5OiBib29sZWFuO1xuXG4gIC8vIERlYnVmZiBzdGF0ZXMgZm9yIFBWUFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcm96ZW5VbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgaXNTbG93ZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyBzbG93ZWRVbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgbW92ZW1lbnRTcGVlZE11bHRpcGxpZXI6IG51bWJlcjtcblxuICAvLyBJbnB1dC1iYXNlZCBtb3ZlbWVudFxuICBwdWJsaWMgbW92ZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGlucHV0U3RyZW5ndGg6IG51bWJlcjtcblxuICAvLyBEYXNoL1ZhdWx0IHN5c3RlbVxuICBwdWJsaWMgaXNEYXNoaW5nOiBib29sZWFuO1xuICBwdWJsaWMgZGFzaERpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGRhc2hTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGRhc2hEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgZGFzaERpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBkYXNoU3RhcnRQb3NpdGlvbjogVmVjdG9yMztcbiAgXG4gIC8vIE11bHRpcGxlIGRhc2ggY2hhcmdlcyBzeXN0ZW1cbiAgcHVibGljIGRhc2hDaGFyZ2VzOiBBcnJheTx7XG4gICAgaXNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgY29vbGRvd25TdGFydFRpbWU6IG51bWJlciB8IG51bGw7XG4gIH0+O1xuICBwdWJsaWMgbWF4RGFzaENoYXJnZXM6IG51bWJlcjtcblxuICAvLyBTd29yZCBDaGFyZ2UgYWJpbGl0eSBzeXN0ZW0gKHNlcGFyYXRlIGZyb20gZGFzaGVzKVxuICBwdWJsaWMgaXNDaGFyZ2luZzogYm9vbGVhbjtcbiAgcHVibGljIGNoYXJnZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGNoYXJnZVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgY2hhcmdlRHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGNoYXJnZURpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBjaGFyZ2VTdGFydFBvc2l0aW9uOiBWZWN0b3IzO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1heFNwZWVkOiBudW1iZXIgPSAzLjc1LFxuICAgIGZyaWN0aW9uOiBudW1iZXIgPSAwLjgsXG4gICAganVtcEZvcmNlOiBudW1iZXIgPSAyMC4wLFxuICAgIGdyYXZpdHk6IG51bWJlciA9IC0xMi41XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5tYXhTcGVlZCA9IG1heFNwZWVkO1xuICAgIHRoaXMuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBGb3JjZSA9IGp1bXBGb3JjZTtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICAgIFxuICAgIHRoaXMuY2FuTW92ZSA9IHRydWU7XG4gICAgdGhpcy5jYW5KdW1wID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkZseSA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgIFxuICAgIHRoaXMubW92ZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuaW5wdXRTdHJlbmd0aCA9IDA7XG5cbiAgICAvLyBJbml0aWFsaXplIGRhc2ggcHJvcGVydGllc1xuICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRhc2hEdXJhdGlvbiA9IDAuMzU7IC8vIDM1MG1zIGRhc2ggZHVyYXRpb24gKHNhbWUgYXMgb2xkIGltcGxlbWVudGF0aW9uKVxuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDsgLy8gSW5jcmVhc2VkIGZyb20gMy4xMjUgZm9yIG1vcmUgbm90aWNlYWJsZSBkYXNoXG4gICAgdGhpcy5kYXNoU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgbXVsdGlwbGUgZGFzaCBjaGFyZ2VzICgzIGNoYXJnZXMsIGVhY2ggd2l0aCA2cyBjb29sZG93bilcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIEluaXRpYWxpemUgc3dvcmQgY2hhcmdlIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTsgLy8gMzUwbXMgY2hhcmdlIGR1cmF0aW9uXG4gICAgdGhpcy5jaGFyZ2VEaXN0YW5jZSA9IDk7IC8vIFN3b3JkIGNoYXJnZSBkaXN0YW5jZVxuICAgIHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGFkZEZvcmNlKGZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24uYWRkKGZvcmNlKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRJbXB1bHNlKGltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LmFkZChpbXB1bHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBqdW1wKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbkp1bXAgJiYgKHRoaXMuaXNHcm91bmRlZCB8fCB0aGlzLmNhbkZseSkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuanVtcEZvcmNlO1xuICAgICAgdGhpcy5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldE1vdmVEaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzLCBzdHJlbmd0aDogbnVtYmVyID0gMS4wKTogdm9pZCB7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzdHJlbmd0aCkpO1xuICB9XG5cbiAgcHVibGljIGZyZWV6ZShkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSBjdXJyZW50VGltZSArIGR1cmF0aW9uO1xuICAgIC8vIGNvbnNvbGUubG9nKGDwn6eKIFBsYXllciBmcm96ZW4gZm9yICR7ZHVyYXRpb259bXMgdW50aWwgJHt0aGlzLmZyb3plblVudGlsfSAoY3VycmVudDogJHtjdXJyZW50VGltZX0pYCk7XG4gIH1cblxuICBwdWJsaWMgc2xvdyhkdXJhdGlvbjogbnVtYmVyLCBzcGVlZE11bHRpcGxpZXI6IG51bWJlciA9IDAuNSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzU2xvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbjtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gc3BlZWRNdWx0aXBsaWVyO1xuICAgIC8vIGNvbnNvbGUubG9nKGDwn5CMIFBsYXllciBzbG93ZWQgdG8gJHtzcGVlZE11bHRpcGxpZXIgKiAxMDB9JSBzcGVlZCBmb3IgJHtkdXJhdGlvbn1tcyB1bnRpbCAke3RoaXMuc2xvd2VkVW50aWx9YCk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGVidWZmcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZnJvemVuIHN0YXRlXG4gICAgaWYgKHRoaXMuaXNGcm96ZW4gJiYgY3VycmVudFRpbWUgPj0gdGhpcy5mcm96ZW5VbnRpbCkge1xuICAgICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgdGhpcy5mcm96ZW5VbnRpbCA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHNsb3dlZCBzdGF0ZVxuICAgIGlmICh0aGlzLmlzU2xvd2VkICYmIGN1cnJlbnRUaW1lID49IHRoaXMuc2xvd2VkVW50aWwpIHtcbiAgICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2xvd2VkVW50aWwgPSAwO1xuICAgICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDEuMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RWZmZWN0aXZlTWF4U3BlZWQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Zyb3plbikge1xuICAgICAgcmV0dXJuIDA7IC8vIENvbXBsZXRlbHkgZnJvemVuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1heFNwZWVkICogdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydERhc2goZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0Rhc2hpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGZpcnN0IGF2YWlsYWJsZSBjaGFyZ2VcbiAgICBjb25zdCBhdmFpbGFibGVDaGFyZ2VJbmRleCA9IHRoaXMuZGFzaENoYXJnZXMuZmluZEluZGV4KGNoYXJnZSA9PiBjaGFyZ2UuaXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVDaGFyZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gY2hhcmdlcyBhdmFpbGFibGVcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGFzaFxuICAgIHRoaXMuaXNEYXNoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY29weShjdXJyZW50UG9zaXRpb24pO1xuXG4gICAgLy8gQ29uc3VtZSB0aGUgY2hhcmdlXG4gICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5jb29sZG93blN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgLy8gU2V0IGNvb2xkb3duIHRpbWVyIGZvciB0aGlzIHNwZWNpZmljIGNoYXJnZSAoNiBzZWNvbmRzKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uY29vbGRvd25TdGFydFRpbWUgPSBudWxsO1xuICAgIH0sIDYwMDApOyAvLyA2IHNlY29uZCBjb29sZG93blxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGFzaChjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzRGFzaGluZykge1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uOiBudWxsIH07XG4gICAgfVxuXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuZGFzaER1cmF0aW9uLCAxKTtcblxuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAvLyBEYXNoIGNvbXBsZXRlXG4gICAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgZmluYWxQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuYWRkKHRoaXMuZGFzaERpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuZGFzaERpc3RhbmNlKSk7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiB0cnVlLCBuZXdQb3NpdGlvbjogZmluYWxQb3NpdGlvbiB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IHBvc2l0aW9uIHVzaW5nIGVhc2luZyAoZWFzZS1vdXQgcXVhZCwgc2FtZSBhcyBvbGQgaW1wbGVtZW50YXRpb24pXG4gICAgY29uc3QgZWFzZU91dFF1YWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAyKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmRhc2hEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmRhc2hEaXN0YW5jZSAqIGVhc2VPdXRRdWFkKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKS5hZGQoZGlzcGxhY2VtZW50KTtcblxuICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbiB9O1xuICB9XG5cbiAgcHVibGljIGNhbmNlbERhc2goKTogdm9pZCB7XG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuICB9XG5cbiAgcHVibGljIGdldFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkubGVuZ3RoKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SG9yaXpvbnRhbFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnZlbG9jaXR5LnggKiB0aGlzLnZlbG9jaXR5LnggKyB0aGlzLnZlbG9jaXR5LnogKiB0aGlzLnZlbG9jaXR5LnopO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldFNwZWVkKCkgPiAwLjAxO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nSG9yaXpvbnRhbGx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhvcml6b250YWxTcGVlZCgpID4gMC4wMTtcbiAgfVxuXG4gIHB1YmxpYyBpc0ZhbGxpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA8IC0wLjE7XG4gIH1cblxuICBwdWJsaWMgaXNSaXNpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA+IDAuMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdmFpbGFibGVEYXNoQ2hhcmdlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLmZpbHRlcihjaGFyZ2UgPT4gY2hhcmdlLmlzQXZhaWxhYmxlKS5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGFzaENoYXJnZVN0YXR1cygpOiBBcnJheTx7IGlzQXZhaWxhYmxlOiBib29sZWFuOyBjb29sZG93blJlbWFpbmluZzogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLm1hcChjaGFyZ2UgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiBjaGFyZ2UuaXNBdmFpbGFibGUsXG4gICAgICBjb29sZG93blJlbWFpbmluZzogY2hhcmdlLmNvb2xkb3duU3RhcnRUaW1lIFxuICAgICAgICA/IE1hdGgubWF4KDAsIDYgLSAoY3VycmVudFRpbWUgLSBjaGFyZ2UuY29vbGRvd25TdGFydFRpbWUpKVxuICAgICAgICA6IDBcbiAgICB9KSk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRDaGFyZ2UoZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGNoYXJnaW5nIG9yIGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0NoYXJnaW5nIHx8IHRoaXMuaXNEYXNoaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGNoYXJnZVxuICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkoY3VycmVudFBvc2l0aW9uKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUNoYXJnZShjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbjogbnVsbCB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuY2hhcmdlU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuY2hhcmdlRHVyYXRpb24sIDEpO1xuXG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgIC8vIENoYXJnZSBjb21wbGV0ZVxuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBmaW5hbFBvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgLmFkZCh0aGlzLmNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuY2hhcmdlRGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IHRydWUsIG5ld1Bvc2l0aW9uOiBmaW5hbFBvc2l0aW9uIH07XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb24gdXNpbmcgZWFzaW5nIChlYXNlLW91dCBxdWFkKVxuICAgIGNvbnN0IGVhc2VPdXRRdWFkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMik7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmNoYXJnZURpc3RhbmNlICogZWFzZU91dFF1YWQpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKCkuYWRkKGRpc3BsYWNlbWVudCk7XG5cbiAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb24gfTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxDaGFyZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbGFtcFZlbG9jaXR5KCk6IHZvaWQge1xuICAgIC8vIEdldCBlZmZlY3RpdmUgbWF4IHNwZWVkIChjb25zaWRlcmluZyBkZWJ1ZmZzKVxuICAgIGNvbnN0IGVmZmVjdGl2ZU1heFNwZWVkID0gdGhpcy5nZXRFZmZlY3RpdmVNYXhTcGVlZCgpO1xuICAgIFxuICAgIC8vIENsYW1wIGhvcml6b250YWwgdmVsb2NpdHkgdG8gZWZmZWN0aXZlIG1heCBzcGVlZFxuICAgIGNvbnN0IGhvcml6b250YWxWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKHRoaXMudmVsb2NpdHkueCwgMCwgdGhpcy52ZWxvY2l0eS56KTtcbiAgICBjb25zdCBob3Jpem9udGFsU3BlZWQgPSBob3Jpem9udGFsVmVsb2NpdHkubGVuZ3RoKCk7XG4gICAgXG4gICAgaWYgKGhvcml6b250YWxTcGVlZCA+IGVmZmVjdGl2ZU1heFNwZWVkKSB7XG4gICAgICBpZiAoZWZmZWN0aXZlTWF4U3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBmcm96ZW4gLSBzdG9wIGFsbCBob3Jpem9udGFsIG1vdmVtZW50XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3Jpem9udGFsVmVsb2NpdHkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZWZmZWN0aXZlTWF4U3BlZWQpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSBob3Jpem9udGFsVmVsb2NpdHkueDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS56ID0gaG9yaXpvbnRhbFZlbG9jaXR5Lno7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFwcGx5RnJpY3Rpb24oZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuTW92ZSkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgZnJpY3Rpb24gdG8gaG9yaXpvbnRhbCBtb3ZlbWVudFxuICAgIGNvbnN0IGZyaWN0aW9uRm9yY2UgPSBNYXRoLnBvdyh0aGlzLmZyaWN0aW9uLCBkZWx0YVRpbWUpO1xuICAgIHRoaXMudmVsb2NpdHkueCAqPSBmcmljdGlvbkZvcmNlO1xuICAgIHRoaXMudmVsb2NpdHkueiAqPSBmcmljdGlvbkZvcmNlO1xuXG4gICAgLy8gU3RvcCB2ZXJ5IHNtYWxsIHZlbG9jaXRpZXMgdG8gcHJldmVudCBqaXR0ZXJcbiAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eS54KSA8IDAuMDEpIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueikgPCAwLjAxKSB0aGlzLnZlbG9jaXR5LnogPSAwO1xuICB9XG5cbiAgcHVibGljIGFwcGx5R3Jhdml0eShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jYW5GbHkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSArPSB0aGlzLmdyYXZpdHkgKiBkZWx0YVRpbWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIC8vIEVuc3VyZSBWZWN0b3IzIG9iamVjdHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgaWYgKCF0aGlzLnZlbG9jaXR5KSB7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXRoaXMuYWNjZWxlcmF0aW9uKSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tb3ZlRGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gMDtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbk1vdmUgPSB0cnVlO1xuICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgdGhpcy5jYW5GbHkgPSBmYWxzZTtcbiAgICB0aGlzLm1heFNwZWVkID0gNS4wO1xuICAgIHRoaXMuZnJpY3Rpb24gPSAwLjg7XG4gICAgdGhpcy5qdW1wRm9yY2UgPSAyMC4wO1xuICAgIHRoaXMuZ3Jhdml0eSA9IC0xMi41O1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvLyBSZXNldCBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuXG4gICAgLy8gUmVzZXQgZGFzaCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kYXNoRHVyYXRpb24gPSAwLjM1O1xuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDtcbiAgICB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBSZXNldCBkYXNoIGNoYXJnZXNcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIFJlc2V0IGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTtcbiAgICB0aGlzLmNoYXJnZURpc3RhbmNlID0gOTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IE1vdmVtZW50IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBNb3ZlbWVudCh0aGlzLm1heFNwZWVkLCB0aGlzLmZyaWN0aW9uLCB0aGlzLmp1bXBGb3JjZSwgdGhpcy5ncmF2aXR5KTtcbiAgICBjbG9uZS52ZWxvY2l0eS5jb3B5KHRoaXMudmVsb2NpdHkpO1xuICAgIGNsb25lLmFjY2VsZXJhdGlvbi5jb3B5KHRoaXMuYWNjZWxlcmF0aW9uKTtcbiAgICBjbG9uZS5tb3ZlRGlyZWN0aW9uLmNvcHkodGhpcy5tb3ZlRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5pbnB1dFN0cmVuZ3RoID0gdGhpcy5pbnB1dFN0cmVuZ3RoO1xuICAgIGNsb25lLmlzR3JvdW5kZWQgPSB0aGlzLmlzR3JvdW5kZWQ7XG4gICAgY2xvbmUuY2FuTW92ZSA9IHRoaXMuY2FuTW92ZTtcbiAgICBjbG9uZS5jYW5KdW1wID0gdGhpcy5jYW5KdW1wO1xuICAgIGNsb25lLmNhbkZseSA9IHRoaXMuY2FuRmx5O1xuXG4gICAgLy8gQ2xvbmUgZGVidWZmIHN0YXRlc1xuICAgIGNsb25lLmlzRnJvemVuID0gdGhpcy5pc0Zyb3plbjtcbiAgICBjbG9uZS5mcm96ZW5VbnRpbCA9IHRoaXMuZnJvemVuVW50aWw7XG4gICAgY2xvbmUuaXNTbG93ZWQgPSB0aGlzLmlzU2xvd2VkO1xuICAgIGNsb25lLnNsb3dlZFVudGlsID0gdGhpcy5zbG93ZWRVbnRpbDtcbiAgICBjbG9uZS5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXI7XG5cbiAgICAvLyBDbG9uZSBkYXNoIHByb3BlcnRpZXNcbiAgICBjbG9uZS5pc0Rhc2hpbmcgPSB0aGlzLmlzRGFzaGluZztcbiAgICBjbG9uZS5kYXNoRGlyZWN0aW9uLmNvcHkodGhpcy5kYXNoRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5kYXNoU3RhcnRUaW1lID0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNsb25lLmRhc2hEdXJhdGlvbiA9IHRoaXMuZGFzaER1cmF0aW9uO1xuICAgIGNsb25lLmRhc2hEaXN0YW5jZSA9IHRoaXMuZGFzaERpc3RhbmNlO1xuICAgIGNsb25lLmRhc2hTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5kYXNoU3RhcnRQb3NpdGlvbik7XG4gICAgXG4gICAgLy8gQ2xvbmUgZGFzaCBjaGFyZ2VzXG4gICAgY2xvbmUubWF4RGFzaENoYXJnZXMgPSB0aGlzLm1heERhc2hDaGFyZ2VzO1xuICAgIGNsb25lLmRhc2hDaGFyZ2VzID0gdGhpcy5kYXNoQ2hhcmdlcy5tYXAoY2hhcmdlID0+ICh7XG4gICAgICBpc0F2YWlsYWJsZTogY2hhcmdlLmlzQXZhaWxhYmxlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IGNoYXJnZS5jb29sZG93blN0YXJ0VGltZVxuICAgIH0pKTtcblxuICAgIC8vIENsb25lIGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgY2xvbmUuaXNDaGFyZ2luZyA9IHRoaXMuaXNDaGFyZ2luZztcbiAgICBjbG9uZS5jaGFyZ2VEaXJlY3Rpb24uY29weSh0aGlzLmNoYXJnZURpcmVjdGlvbik7XG4gICAgY2xvbmUuY2hhcmdlU3RhcnRUaW1lID0gdGhpcy5jaGFyZ2VTdGFydFRpbWU7XG4gICAgY2xvbmUuY2hhcmdlRHVyYXRpb24gPSB0aGlzLmNoYXJnZUR1cmF0aW9uO1xuICAgIGNsb25lLmNoYXJnZURpc3RhbmNlID0gdGhpcy5jaGFyZ2VEaXN0YW5jZTtcbiAgICBjbG9uZS5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb21wb25lbnQiLCJNb3ZlbWVudCIsImFkZEZvcmNlIiwiZm9yY2UiLCJhY2NlbGVyYXRpb24iLCJhZGQiLCJhZGRJbXB1bHNlIiwiaW1wdWxzZSIsInZlbG9jaXR5IiwianVtcCIsImNhbkp1bXAiLCJpc0dyb3VuZGVkIiwiY2FuRmx5IiwieSIsImp1bXBGb3JjZSIsInNldE1vdmVEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJzdHJlbmd0aCIsIm1vdmVEaXJlY3Rpb24iLCJjb3B5Iiwibm9ybWFsaXplIiwiaW5wdXRTdHJlbmd0aCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmcmVlemUiLCJkdXJhdGlvbiIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImlzRnJvemVuIiwiZnJvemVuVW50aWwiLCJzbG93Iiwic3BlZWRNdWx0aXBsaWVyIiwiaXNTbG93ZWQiLCJzbG93ZWRVbnRpbCIsIm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyIiwidXBkYXRlRGVidWZmcyIsImdldEVmZmVjdGl2ZU1heFNwZWVkIiwibWF4U3BlZWQiLCJzdGFydERhc2giLCJjdXJyZW50UG9zaXRpb24iLCJpc0Rhc2hpbmciLCJhdmFpbGFibGVDaGFyZ2VJbmRleCIsImRhc2hDaGFyZ2VzIiwiZmluZEluZGV4IiwiY2hhcmdlIiwiaXNBdmFpbGFibGUiLCJkYXNoRGlyZWN0aW9uIiwiZGFzaFN0YXJ0VGltZSIsImRhc2hTdGFydFBvc2l0aW9uIiwiY29vbGRvd25TdGFydFRpbWUiLCJzZXRUaW1lb3V0IiwidXBkYXRlRGFzaCIsImlzQ29tcGxldGUiLCJuZXdQb3NpdGlvbiIsImVsYXBzZWQiLCJwcm9ncmVzcyIsImRhc2hEdXJhdGlvbiIsImZpbmFsUG9zaXRpb24iLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwiZGFzaERpc3RhbmNlIiwiZWFzZU91dFF1YWQiLCJwb3ciLCJkaXNwbGFjZW1lbnQiLCJjYW5jZWxEYXNoIiwic2V0Iiwic3RvcCIsImdldFNwZWVkIiwibGVuZ3RoIiwiZ2V0SG9yaXpvbnRhbFNwZWVkIiwic3FydCIsIngiLCJ6IiwiaXNNb3ZpbmciLCJpc01vdmluZ0hvcml6b250YWxseSIsImlzRmFsbGluZyIsImlzUmlzaW5nIiwiZ2V0QXZhaWxhYmxlRGFzaENoYXJnZXMiLCJmaWx0ZXIiLCJnZXREYXNoQ2hhcmdlU3RhdHVzIiwibWFwIiwiY29vbGRvd25SZW1haW5pbmciLCJzdGFydENoYXJnZSIsImlzQ2hhcmdpbmciLCJjaGFyZ2VEaXJlY3Rpb24iLCJjaGFyZ2VTdGFydFRpbWUiLCJjaGFyZ2VTdGFydFBvc2l0aW9uIiwidXBkYXRlQ2hhcmdlIiwiY2hhcmdlRHVyYXRpb24iLCJjaGFyZ2VEaXN0YW5jZSIsImNhbmNlbENoYXJnZSIsImNsYW1wVmVsb2NpdHkiLCJlZmZlY3RpdmVNYXhTcGVlZCIsImhvcml6b250YWxWZWxvY2l0eSIsImhvcml6b250YWxTcGVlZCIsImFwcGx5RnJpY3Rpb24iLCJkZWx0YVRpbWUiLCJjYW5Nb3ZlIiwiZnJpY3Rpb25Gb3JjZSIsImZyaWN0aW9uIiwiYWJzIiwiYXBwbHlHcmF2aXR5IiwiZ3Jhdml0eSIsInJlc2V0IiwiZW5hYmxlZCIsIm1heERhc2hDaGFyZ2VzIiwiQXJyYXkiLCJmcm9tIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Movement.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Projectile.ts":
/*!******************************************!*\
  !*** ./src/ecs/components/Projectile.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: function() { return /* binding */ Projectile; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Projectile component for bullets, spells, and other projectiles\n\n\nclass Projectile extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setDirection(direction) {\n        this.velocity.copy(direction).normalize().multiplyScalar(this.speed);\n    }\n    addGravity(gravity) {\n        this.gravity = gravity;\n    }\n    setPiercing(piercing) {\n        this.piercing = piercing;\n    }\n    setExplosive(radius) {\n        this.explosionRadius = radius;\n    }\n    setBouncing(maxBounces) {\n        this.maxBounces = maxBounces;\n    }\n    setMaxDistance(maxDistance) {\n        this.maxDistance = maxDistance;\n    }\n    setStartPosition(position) {\n        this.startPosition.copy(position);\n    }\n    setHoming(targetEntityId) {\n        let homingStrength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.8, maxTurnRate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Math.PI;\n        this.targetEntityId = targetEntityId;\n        this.homingStrength = Math.max(0, Math.min(1, homingStrength)); // Clamp between 0 and 1\n        this.maxTurnRate = maxTurnRate;\n    }\n    disableHoming() {\n        this.targetEntityId = null;\n        this.homingStrength = 0;\n    }\n    hasHitTarget(entityId) {\n        return this.hitTargets.has(entityId);\n    }\n    addHitTarget(entityId) {\n        this.hitTargets.add(entityId);\n    }\n    canHitTarget(entityId) {\n        // Can't hit owner\n        if (entityId === this.owner) return false;\n        // If piercing, can hit targets multiple times\n        if (this.piercing) return true;\n        // Otherwise, can only hit each target once\n        return !this.hasHitTarget(entityId);\n    }\n    isExpired() {\n        return this.lifetime >= this.maxLifetime || this.distanceTraveled >= this.maxDistance;\n    }\n    canBounce() {\n        return this.bounces < this.maxBounces;\n    }\n    bounce(normal) {\n        if (!this.canBounce()) return;\n        // Reflect velocity off the surface normal\n        const reflection = this.velocity.clone().reflect(normal);\n        this.velocity.copy(reflection);\n        this.bounces++;\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        // Track distance traveled\n        const distanceThisFrame = this.velocity.length() * deltaTime;\n        this.distanceTraveled += distanceThisFrame;\n        // Apply gravity if enabled\n        if (this.gravity !== 0) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    getPosition(transform) {\n        return transform.clone();\n    }\n    getPredictedPosition(transform, deltaTime) {\n        const predicted = transform.clone();\n        predicted.add(this.velocity.clone().multiplyScalar(deltaTime));\n        return predicted;\n    }\n    reset() {\n        this.velocity.set(0, 0, 0);\n        this.speed = 20;\n        this.damage = 10;\n        this.lifetime = 0;\n        this.maxLifetime = 5;\n        this.piercing = false;\n        this.hitTargets.clear();\n        this.explosionRadius = 0;\n        this.gravity = 0;\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = -1;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity;\n        this.startPosition.set(0, 0, 0);\n        this.targetEntityId = null;\n        this.homingStrength = 0;\n        this.maxTurnRate = Math.PI;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Projectile(this.speed, this.damage, this.maxLifetime, this.owner);\n        clone.velocity.copy(this.velocity);\n        clone.lifetime = this.lifetime;\n        clone.piercing = this.piercing;\n        clone.hitTargets = new Set(this.hitTargets);\n        clone.explosionRadius = this.explosionRadius;\n        clone.gravity = this.gravity;\n        clone.bounces = this.bounces;\n        clone.maxBounces = this.maxBounces;\n        clone.distanceTraveled = this.distanceTraveled;\n        clone.maxDistance = this.maxDistance;\n        clone.startPosition.copy(this.startPosition);\n        clone.targetEntityId = this.targetEntityId;\n        clone.homingStrength = this.homingStrength;\n        clone.maxTurnRate = this.maxTurnRate;\n        return clone;\n    }\n    constructor(speed = 20, damage = 10, maxLifetime = 5, owner = -1){\n        super();\n        this.componentType = \"Projectile\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.speed = speed;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = maxLifetime;\n        this.piercing = false;\n        this.hitTargets = new Set();\n        this.explosionRadius = 0;\n        this.gravity = 0; // Most projectiles ignore gravity\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = owner;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity; // Default to no distance limit\n        this.startPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize homing properties\n        this.targetEntityId = null;\n        this.homingStrength = 0; // Default to no homing\n        this.maxTurnRate = Math.PI; // Default to 180 degrees per second turn rate\n    }\n}\nProjectile.componentType = \"Projectile\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRS9CLE1BQU1FLG1CQUFtQkQsOENBQVNBO0lBc0RoQ0UsYUFBYUMsU0FBa0IsRUFBUTtRQUM1QyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixXQUFXRyxTQUFTLEdBQUdDLGNBQWMsQ0FBQyxJQUFJLENBQUNDLEtBQUs7SUFDckU7SUFFT0MsV0FBV0MsT0FBZSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVPQyxZQUFZQyxRQUFpQixFQUFRO1FBQzFDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNsQjtJQUVPQyxhQUFhQyxNQUFjLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO0lBQ3pCO0lBRU9FLFlBQVlDLFVBQWtCLEVBQVE7UUFDM0MsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBRU9DLGVBQWVDLFdBQW1CLEVBQVE7UUFDL0MsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3JCO0lBRU9DLGlCQUFpQkMsUUFBaUIsRUFBUTtRQUMvQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ2pCLElBQUksQ0FBQ2dCO0lBQzFCO0lBRU9FLFVBQVVDLGNBQXNCLEVBQXFFO1lBQW5FQyxpQkFBQUEsaUVBQXlCLEtBQUtDLGNBQUFBLGlFQUFzQkMsS0FBS0MsRUFBRTtRQUNsRyxJQUFJLENBQUNKLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxjQUFjLEdBQUdFLEtBQUtFLEdBQUcsQ0FBQyxHQUFHRixLQUFLRyxHQUFHLENBQUMsR0FBR0wsa0JBQWtCLHdCQUF3QjtRQUN4RixJQUFJLENBQUNDLFdBQVcsR0FBR0E7SUFDckI7SUFFT0ssZ0JBQXNCO1FBQzNCLElBQUksQ0FBQ1AsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxH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QUksQ0FBQ2hFLFFBQVEsR0FBRyxJQUFJTCx5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDbEMsSUFBSSxDQUFDUyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDc0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3JCLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDOUIsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ3NCLFVBQVUsR0FBRyxJQUFJZ0M7UUFDdEIsSUFBSSxDQUFDbkQsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0wsT0FBTyxHQUFHLEdBQUcsa0NBQWtDO1FBQ3BELElBQUksQ0FBQ21DLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQzVCLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNzQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDSSxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUN4QixXQUFXLEdBQUc2QyxVQUFVLCtCQUErQjtRQUM1RCxJQUFJLENBQUMxQyxhQUFhLEdBQUcsSUFBSXZCLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztRQUV2QywrQkFBK0I7UUFDL0IsSUFBSSxDQUFDeUIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEdBQUcsdUJBQXVCO1FBQ2hELElBQUksQ0FBQ0MsV0FBVyxHQUFHQyxLQUFLQyxFQUFFLEVBQUUsOENBQThDO0lBQzVFO0FBNElGO0FBaE1hM0IsV0FDWW1FLGdCQUFnQixhQUFjLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZS50cz83MDYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2plY3RpbGUgY29tcG9uZW50IGZvciBidWxsZXRzLCBzcGVsbHMsIGFuZCBvdGhlciBwcm9qZWN0aWxlc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgUHJvamVjdGlsZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdQcm9qZWN0aWxlJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Byb2plY3RpbGUnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB2ZWxvY2l0eTogVmVjdG9yMztcbiAgcHVibGljIHNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyBkYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGxpZmV0aW1lOiBudW1iZXI7XG4gIHB1YmxpYyBtYXhMaWZldGltZTogbnVtYmVyO1xuICBwdWJsaWMgcGllcmNpbmc6IGJvb2xlYW47XG4gIHB1YmxpYyBoaXRUYXJnZXRzOiBTZXQ8bnVtYmVyPjsgLy8gRW50aXR5IElEcyB0aGF0IGhhdmUgYmVlbiBoaXRcbiAgcHVibGljIGV4cGxvc2lvblJhZGl1czogbnVtYmVyO1xuICBwdWJsaWMgZ3Jhdml0eTogbnVtYmVyO1xuICBwdWJsaWMgYm91bmNlczogbnVtYmVyO1xuICBwdWJsaWMgbWF4Qm91bmNlczogbnVtYmVyO1xuICBwdWJsaWMgb3duZXI6IG51bWJlcjsgLy8gRW50aXR5IElEIG9mIHRoZSBvd25lclxuICBwdWJsaWMgZGlzdGFuY2VUcmF2ZWxlZDogbnVtYmVyOyAvLyBUcmFjayBkaXN0YW5jZSB0cmF2ZWxlZFxuICBwdWJsaWMgbWF4RGlzdGFuY2U6IG51bWJlcjsgLy8gTWF4aW11bSBkaXN0YW5jZSBiZWZvcmUgZXhwaXJpbmdcbiAgcHVibGljIHN0YXJ0UG9zaXRpb246IFZlY3RvcjM7IC8vIFN0YXJ0aW5nIHBvc2l0aW9uIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gIC8vIEhvbWluZyBwcm9wZXJ0aWVzXG4gIHB1YmxpYyB0YXJnZXRFbnRpdHlJZDogbnVtYmVyIHwgbnVsbDsgLy8gRW50aXR5IElEIHRvIGhvbWUgdG93YXJkc1xuICBwdWJsaWMgaG9taW5nU3RyZW5ndGg6IG51bWJlcjsgLy8gSG93IHN0cm9uZ2x5IGl0IGhvbWVzICgwLTEpXG4gIHB1YmxpYyBtYXhUdXJuUmF0ZTogbnVtYmVyOyAvLyBNYXhpbXVtIHJhZGlhbnMgcGVyIHNlY29uZCB0aGUgcHJvamVjdGlsZSBjYW4gdHVyblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNwZWVkOiBudW1iZXIgPSAyMCxcbiAgICBkYW1hZ2U6IG51bWJlciA9IDEwLFxuICAgIG1heExpZmV0aW1lOiBudW1iZXIgPSA1LFxuICAgIG93bmVyOiBudW1iZXIgPSAtMVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgdGhpcy5kYW1hZ2UgPSBkYW1hZ2U7XG4gICAgdGhpcy5saWZldGltZSA9IDA7XG4gICAgdGhpcy5tYXhMaWZldGltZSA9IG1heExpZmV0aW1lO1xuICAgIHRoaXMucGllcmNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmhpdFRhcmdldHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5leHBsb3Npb25SYWRpdXMgPSAwO1xuICAgIHRoaXMuZ3Jhdml0eSA9IDA7IC8vIE1vc3QgcHJvamVjdGlsZXMgaWdub3JlIGdyYXZpdHlcbiAgICB0aGlzLmJvdW5jZXMgPSAwO1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IDA7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5OyAvLyBEZWZhdWx0IHRvIG5vIGRpc3RhbmNlIGxpbWl0XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGhvbWluZyBwcm9wZXJ0aWVzXG4gICAgdGhpcy50YXJnZXRFbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5ob21pbmdTdHJlbmd0aCA9IDA7IC8vIERlZmF1bHQgdG8gbm8gaG9taW5nXG4gICAgdGhpcy5tYXhUdXJuUmF0ZSA9IE1hdGguUEk7IC8vIERlZmF1bHQgdG8gMTgwIGRlZ3JlZXMgcGVyIHNlY29uZCB0dXJuIHJhdGVcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zcGVlZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkR3Jhdml0eShncmF2aXR5OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICB9XG5cbiAgcHVibGljIHNldFBpZXJjaW5nKHBpZXJjaW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5waWVyY2luZyA9IHBpZXJjaW5nO1xuICB9XG5cbiAgcHVibGljIHNldEV4cGxvc2l2ZShyYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gcmFkaXVzO1xuICB9XG5cbiAgcHVibGljIHNldEJvdW5jaW5nKG1heEJvdW5jZXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IG1heEJvdW5jZXM7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF4RGlzdGFuY2UobWF4RGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTdGFydFBvc2l0aW9uKHBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICB9XG5cbiAgcHVibGljIHNldEhvbWluZyh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBob21pbmdTdHJlbmd0aDogbnVtYmVyID0gMC44LCBtYXhUdXJuUmF0ZTogbnVtYmVyID0gTWF0aC5QSSk6IHZvaWQge1xuICAgIHRoaXMudGFyZ2V0RW50aXR5SWQgPSB0YXJnZXRFbnRpdHlJZDtcbiAgICB0aGlzLmhvbWluZ1N0cmVuZ3RoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaG9taW5nU3RyZW5ndGgpKTsgLy8gQ2xhbXAgYmV0d2VlbiAwIGFuZCAxXG4gICAgdGhpcy5tYXhUdXJuUmF0ZSA9IG1heFR1cm5SYXRlO1xuICB9XG5cbiAgcHVibGljIGRpc2FibGVIb21pbmcoKTogdm9pZCB7XG4gICAgdGhpcy50YXJnZXRFbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5ob21pbmdTdHJlbmd0aCA9IDA7XG4gIH1cblxuICBwdWJsaWMgaGFzSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUYXJnZXRzLmhhcyhlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhpdFRhcmdldHMuYWRkKGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5IaXRUYXJnZXQoZW50aXR5SWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIENhbid0IGhpdCBvd25lclxuICAgIGlmIChlbnRpdHlJZCA9PT0gdGhpcy5vd25lcikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIElmIHBpZXJjaW5nLCBjYW4gaGl0IHRhcmdldHMgbXVsdGlwbGUgdGltZXNcbiAgICBpZiAodGhpcy5waWVyY2luZykgcmV0dXJuIHRydWU7XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlLCBjYW4gb25seSBoaXQgZWFjaCB0YXJnZXQgb25jZVxuICAgIHJldHVybiAhdGhpcy5oYXNIaXRUYXJnZXQoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGlzRXhwaXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5saWZldGltZSA+PSB0aGlzLm1heExpZmV0aW1lIHx8IHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCA+PSB0aGlzLm1heERpc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIGNhbkJvdW5jZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuY2VzIDwgdGhpcy5tYXhCb3VuY2VzO1xuICB9XG5cbiAgcHVibGljIGJvdW5jZShub3JtYWw6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuQm91bmNlKCkpIHJldHVybjtcbiAgICBcbiAgICAvLyBSZWZsZWN0IHZlbG9jaXR5IG9mZiB0aGUgc3VyZmFjZSBub3JtYWxcbiAgICBjb25zdCByZWZsZWN0aW9uID0gdGhpcy52ZWxvY2l0eS5jbG9uZSgpLnJlZmxlY3Qobm9ybWFsKTtcbiAgICB0aGlzLnZlbG9jaXR5LmNvcHkocmVmbGVjdGlvbik7XG4gICAgdGhpcy5ib3VuY2VzKys7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5saWZldGltZSArPSBkZWx0YVRpbWU7XG4gICAgXG4gICAgLy8gVHJhY2sgZGlzdGFuY2UgdHJhdmVsZWRcbiAgICBjb25zdCBkaXN0YW5jZVRoaXNGcmFtZSA9IHRoaXMudmVsb2NpdHkubGVuZ3RoKCkgKiBkZWx0YVRpbWU7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGVkICs9IGRpc3RhbmNlVGhpc0ZyYW1lO1xuICAgIFxuICAgIC8vIEFwcGx5IGdyYXZpdHkgaWYgZW5hYmxlZFxuICAgIGlmICh0aGlzLmdyYXZpdHkgIT09IDApIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSArPSB0aGlzLmdyYXZpdHkgKiBkZWx0YVRpbWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFBvc2l0aW9uKHRyYW5zZm9ybTogVmVjdG9yMyk6IFZlY3RvcjMge1xuICAgIHJldHVybiB0cmFuc2Zvcm0uY2xvbmUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQcmVkaWN0ZWRQb3NpdGlvbih0cmFuc2Zvcm06IFZlY3RvcjMsIGRlbHRhVGltZTogbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgY29uc3QgcHJlZGljdGVkID0gdHJhbnNmb3JtLmNsb25lKCk7XG4gICAgcHJlZGljdGVkLmFkZCh0aGlzLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lKSk7XG4gICAgcmV0dXJuIHByZWRpY3RlZDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLnNwZWVkID0gMjA7XG4gICAgdGhpcy5kYW1hZ2UgPSAxMDtcbiAgICB0aGlzLmxpZmV0aW1lID0gMDtcbiAgICB0aGlzLm1heExpZmV0aW1lID0gNTtcbiAgICB0aGlzLnBpZXJjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5oaXRUYXJnZXRzLmNsZWFyKCk7XG4gICAgdGhpcy5leHBsb3Npb25SYWRpdXMgPSAwO1xuICAgIHRoaXMuZ3Jhdml0eSA9IDA7XG4gICAgdGhpcy5ib3VuY2VzID0gMDtcbiAgICB0aGlzLm1heEJvdW5jZXMgPSAwO1xuICAgIHRoaXMub3duZXIgPSAtMTtcbiAgICB0aGlzLmRpc3RhbmNlVHJhdmVsZWQgPSAwO1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMudGFyZ2V0RW50aXR5SWQgPSBudWxsO1xuICAgIHRoaXMuaG9taW5nU3RyZW5ndGggPSAwO1xuICAgIHRoaXMubWF4VHVyblJhdGUgPSBNYXRoLlBJO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogUHJvamVjdGlsZSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUHJvamVjdGlsZSh0aGlzLnNwZWVkLCB0aGlzLmRhbWFnZSwgdGhpcy5tYXhMaWZldGltZSwgdGhpcy5vd25lcik7XG4gICAgY2xvbmUudmVsb2NpdHkuY29weSh0aGlzLnZlbG9jaXR5KTtcbiAgICBjbG9uZS5saWZldGltZSA9IHRoaXMubGlmZXRpbWU7XG4gICAgY2xvbmUucGllcmNpbmcgPSB0aGlzLnBpZXJjaW5nO1xuICAgIGNsb25lLmhpdFRhcmdldHMgPSBuZXcgU2V0KHRoaXMuaGl0VGFyZ2V0cyk7XG4gICAgY2xvbmUuZXhwbG9zaW9uUmFkaXVzID0gdGhpcy5leHBsb3Npb25SYWRpdXM7XG4gICAgY2xvbmUuZ3Jhdml0eSA9IHRoaXMuZ3Jhdml0eTtcbiAgICBjbG9uZS5ib3VuY2VzID0gdGhpcy5ib3VuY2VzO1xuICAgIGNsb25lLm1heEJvdW5jZXMgPSB0aGlzLm1heEJvdW5jZXM7XG4gICAgY2xvbmUuZGlzdGFuY2VUcmF2ZWxlZCA9IHRoaXMuZGlzdGFuY2VUcmF2ZWxlZDtcbiAgICBjbG9uZS5tYXhEaXN0YW5jZSA9IHRoaXMubWF4RGlzdGFuY2U7XG4gICAgY2xvbmUuc3RhcnRQb3NpdGlvbi5jb3B5KHRoaXMuc3RhcnRQb3NpdGlvbik7XG4gICAgY2xvbmUudGFyZ2V0RW50aXR5SWQgPSB0aGlzLnRhcmdldEVudGl0eUlkO1xuICAgIGNsb25lLmhvbWluZ1N0cmVuZ3RoID0gdGhpcy5ob21pbmdTdHJlbmd0aDtcbiAgICBjbG9uZS5tYXhUdXJuUmF0ZSA9IHRoaXMubWF4VHVyblJhdGU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbXBvbmVudCIsIlByb2plY3RpbGUiLCJzZXREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJ2ZWxvY2l0eSIsImNvcHkiLCJub3JtYWxpemUiLCJtdWx0aXBseVNjYWxhciIsInNwZWVkIiwiYWRkR3Jhdml0eSIsImdyYXZpdHkiLCJzZXRQaWVyY2luZyIsInBpZXJjaW5nIiwic2V0RXhwbG9zaXZlIiwicmFkaXVzIiwiZXhwbG9zaW9uUmFkaXVzIiwic2V0Qm91bmNpbmciLCJtYXhCb3VuY2VzIiwic2V0TWF4RGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsInNldFN0YXJ0UG9zaXRpb24iLCJwb3NpdGlvbiIsInN0YXJ0UG9zaXRpb24iLCJzZXRIb21pbmciLCJ0YXJnZXRFbnRpdHlJZCIsImhvbWluZ1N0cmVuZ3RoIiwibWF4VHVyblJhdGUiLCJNYXRoIiwiUEkiLCJtYXgiLCJtaW4iLCJkaXNhYmxlSG9taW5nIiwiaGFzSGl0VGFyZ2V0IiwiZW50aXR5SWQiLCJoaXRUYXJnZXRzIiwiaGFzIiwiYWRkSGl0VGFyZ2V0IiwiYWRkIiwiY2FuSGl0VGFyZ2V0Iiwib3duZXIiLCJpc0V4cGlyZWQiLCJsaWZldGltZSIsIm1heExpZmV0aW1lIiwiZGlzdGFuY2VUcmF2ZWxlZCIsImNhbkJvdW5jZSIsImJvdW5jZXMiLCJib3VuY2UiLCJub3JtYWwiLCJyZWZsZWN0aW9uIiwiY2xvbmUiLCJyZWZsZWN0IiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiZGlzdGFuY2VUaGlzRnJhbWUiLCJsZW5ndGgiLCJ5IiwiZ2V0UG9zaXRpb24iLCJ0cmFuc2Zvcm0iLCJnZXRQcmVkaWN0ZWRQb3NpdGlvbiIsInByZWRpY3RlZCIsInJlc2V0Iiwic2V0IiwiZGFtYWdlIiwiY2xlYXIiLCJJbmZpbml0eSIsImVuYWJsZWQiLCJTZXQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Projectile.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Renderer.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Renderer.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Renderer component for 3D rendering data\n\n\nclass Renderer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setGeometry(geometry) {\n        if (this.geometry && this.geometry !== geometry) {\n            this.geometry.dispose();\n        }\n        this.geometry = geometry;\n        this.needsUpdate = true;\n    }\n    setMaterial(material) {\n        if (this.material && this.material !== material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n        }\n        this.material = material;\n        this.needsUpdate = true;\n    }\n    createMesh() {\n        if (!this.geometry || !this.material) {\n            return null;\n        }\n        if (this.mesh) {\n            this.disposeMesh();\n        }\n        this.mesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, this.material);\n        this.mesh.castShadow = this.castShadow;\n        this.mesh.receiveShadow = this.receiveShadow;\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        this.needsUpdate = false;\n        return this.mesh;\n    }\n    updateMesh() {\n        if (!this.mesh) return;\n        // Handle shadow properties for both Mesh and Group\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = this.castShadow;\n            this.mesh.receiveShadow = this.receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            // Apply shadow properties to all meshes in the group\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = this.castShadow;\n                    child.receiveShadow = this.receiveShadow;\n                }\n            });\n        }\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        if (this.needsUpdate && this.geometry && this.material && this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.geometry = this.geometry;\n            this.mesh.material = this.material;\n            this.needsUpdate = false;\n        }\n    }\n    setVisible(visible) {\n        this.visible = visible;\n        if (this.mesh) {\n            this.mesh.visible = visible;\n        }\n    }\n    setCastShadow(castShadow) {\n        this.castShadow = castShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = castShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = castShadow;\n                }\n            });\n        }\n    }\n    setReceiveShadow(receiveShadow) {\n        this.receiveShadow = receiveShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.receiveShadow = receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.receiveShadow = receiveShadow;\n                }\n            });\n        }\n    }\n    // Animation methods\n    setupAnimations(animations) {\n        if (!this.mesh) return;\n        this.animations = animations;\n        if (animations.length > 0) {\n            this.animationMixer = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(this.mesh);\n        }\n    }\n    playAnimation(name) {\n        let loop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, fadeTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n        if (!this.animationMixer) return null;\n        const clip = this.animations.find((clip)=>clip.name === name);\n        if (!clip) return null;\n        // Stop current animation\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n        }\n        // Start new animation\n        const action = this.animationMixer.clipAction(clip);\n        action.setLoop(loop ? _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat : _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopOnce, loop ? Infinity : 1);\n        action.fadeIn(fadeTime);\n        action.play();\n        this.currentAnimation = action;\n        return action;\n    }\n    stopAnimation() {\n        let fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n            this.currentAnimation = null;\n        }\n    }\n    updateAnimations(deltaTime) {\n        if (this.animationMixer) {\n            this.animationMixer.update(deltaTime);\n        }\n    }\n    // Instancing methods\n    setupInstancing(instancedMesh, instanceId) {\n        this.isInstanced = true;\n        this.instancedMesh = instancedMesh;\n        this.instanceId = instanceId;\n    }\n    updateInstanceMatrix(matrix) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    setInstanceVisible(visible) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            // For instanced meshes, we can hide instances by scaling them to 0\n            const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            this.instancedMesh.getMatrixAt(this.instanceId, matrix);\n            if (!visible) {\n                matrix.scale(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\n            }\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    disposeMesh() {\n        if (this.mesh) {\n            if (this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            this.mesh = null;\n        }\n    }\n    dispose() {\n        this.disposeMesh();\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n            this.material = null;\n        }\n        if (this.animationMixer) {\n            this.animationMixer.stopAllAction();\n            this.animationMixer = null;\n        }\n        this.animations = [];\n        this.currentAnimation = null;\n        this.instancedMesh = null;\n    }\n    reset() {\n        this.dispose();\n        this.castShadow = true;\n        this.receiveShadow = true;\n        this.frustumCulled = true;\n        this.visible = true;\n        this.renderOrder = 0;\n        this.needsUpdate = true;\n        this.isInstanced = false;\n        this.instanceId = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Renderer({\n            castShadow: this.castShadow,\n            receiveShadow: this.receiveShadow,\n            frustumCulled: this.frustumCulled,\n            visible: this.visible,\n            renderOrder: this.renderOrder\n        });\n        // Note: We don't clone the actual geometry/material/mesh as they should be shared\n        // The cloned component will need to have its geometry and material set separately\n        return clone;\n    }\n    constructor(options = {}){\n        super();\n        this.componentType = \"Renderer\" // Instance identifier\n        ;\n        this.mesh = null;\n        this.geometry = null;\n        this.material = null;\n        // Animation properties\n        this.animationMixer = null;\n        this.animations = [];\n        this.currentAnimation = null;\n        // Instancing support\n        this.isInstanced = false;\n        this.instancedMesh = null;\n        this.instanceId = -1;\n        var _options_castShadow;\n        this.castShadow = (_options_castShadow = options.castShadow) !== null && _options_castShadow !== void 0 ? _options_castShadow : true;\n        var _options_receiveShadow;\n        this.receiveShadow = (_options_receiveShadow = options.receiveShadow) !== null && _options_receiveShadow !== void 0 ? _options_receiveShadow : true;\n        var _options_frustumCulled;\n        this.frustumCulled = (_options_frustumCulled = options.frustumCulled) !== null && _options_frustumCulled !== void 0 ? _options_frustumCulled : true;\n        var _options_visible;\n        this.visible = (_options_visible = options.visible) !== null && _options_visible !== void 0 ? _options_visible : true;\n        var _options_renderOrder;\n        this.renderOrder = (_options_renderOrder = options.renderOrder) !== null && _options_renderOrder !== void 0 ? _options_renderOrder : 0;\n        this.needsUpdate = true;\n    }\n}\nRenderer.componentType = \"Renderer\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQ0FBMkM7QUFDMEk7QUFDL0k7QUFVL0IsTUFBTVEsaUJBQWlCRCw4Q0FBU0E7SUFrQzlCRSxZQUFZQyxRQUF3QixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUtBLFVBQVU7WUFDL0MsSUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQU87UUFDdkI7UUFDQSxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxXQUFXLEdBQUc7SUFDckI7SUFFT0MsWUFBWUMsUUFBK0IsRUFBUTtRQUN4RCxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLQSxVQUFVO1lBQy9DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDQSxRQUFRLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVAsT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0csUUFBUSxDQUFDSCxPQUFPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixXQUFXLEdBQUc7SUFDckI7SUFFT08sYUFBMEI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNNLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ0MsV0FBVztRQUNsQjtRQUVBLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlwQixzREFBSUEsQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRSxJQUFJLENBQUNJLFFBQVE7UUFDakQsSUFBSSxDQUFDTSxJQUFJLENBQUNFLFVBQVUs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LENBQUFBLHlCQUFBQSxRQUFRakQsYUFBYSxjQUFyQmlELG9DQUFBQSx5QkFBeUI7WUFDL0JBO1FBQWYsSUFBSSxDQUFDaEQsT0FBTyxHQUFHZ0QsQ0FBQUEsbUJBQUFBLFFBQVFoRCxPQUFPLGNBQWZnRCw4QkFBQUEsbUJBQW1CO1lBQ2ZBO1FBQW5CLElBQUksQ0FBQy9DLFdBQVcsR0FBRytDLENBQUFBLHVCQUFBQSxRQUFRL0MsV0FBVyxjQUFuQitDLGtDQUFBQSx1QkFBdUI7UUFDMUMsSUFBSSxDQUFDN0QsV0FBVyxHQUFHO0lBQ3JCO0FBK09GO0FBL1FhSixTQUNZa0UsZ0JBQWdCLFdBQVksMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cz9lMjc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlcmVyIGNvbXBvbmVudCBmb3IgM0QgcmVuZGVyaW5nIGRhdGFcbmltcG9ydCB7IE1lc2gsIEdyb3VwLCBCdWZmZXJHZW9tZXRyeSwgTWF0ZXJpYWwsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25BY3Rpb24sIEluc3RhbmNlZE1lc2gsIExvb3BSZXBlYXQsIExvb3BPbmNlLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyT3B0aW9ucyB7XG4gIGNhc3RTaGFkb3c/OiBib29sZWFuO1xuICByZWNlaXZlU2hhZG93PzogYm9vbGVhbjtcbiAgZnJ1c3R1bUN1bGxlZD86IGJvb2xlYW47XG4gIHZpc2libGU/OiBib29sZWFuO1xuICByZW5kZXJPcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgbWVzaDogTWVzaCB8IEdyb3VwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnZW9tZXRyeTogQnVmZmVyR2VvbWV0cnkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbCB8IE1hdGVyaWFsW10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhc3RTaGFkb3c6IGJvb2xlYW47XG4gIHB1YmxpYyByZWNlaXZlU2hhZG93OiBib29sZWFuO1xuICBwdWJsaWMgZnJ1c3R1bUN1bGxlZDogYm9vbGVhbjtcbiAgcHVibGljIHZpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJPcmRlcjogbnVtYmVyO1xuICBwdWJsaWMgbmVlZHNVcGRhdGU6IGJvb2xlYW47XG5cbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgcHVibGljIGFuaW1hdGlvbk1peGVyOiBBbmltYXRpb25NaXhlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgYW5pbWF0aW9uczogQW5pbWF0aW9uQ2xpcFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50QW5pbWF0aW9uOiBBbmltYXRpb25BY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvLyBJbnN0YW5jaW5nIHN1cHBvcnRcbiAgcHVibGljIGlzSW5zdGFuY2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBpbnN0YW5jZUlkOiBudW1iZXIgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IG9wdGlvbnMuY2FzdFNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IG9wdGlvbnMucmVjZWl2ZVNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IG9wdGlvbnMuZnJ1c3R1bUN1bGxlZCA/PyB0cnVlO1xuICAgIHRoaXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSBvcHRpb25zLnJlbmRlck9yZGVyID8/IDA7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0R2VvbWV0cnkoZ2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF0ZXJpYWwobWF0ZXJpYWw6IE1hdGVyaWFsIHwgTWF0ZXJpYWxbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICYmIHRoaXMubWF0ZXJpYWwgIT09IG1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNZXNoKCk6IE1lc2ggfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMubWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgICB0aGlzLm1lc2gucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICB0aGlzLm1lc2guZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICB0aGlzLm1lc2gucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1lc2g7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlTWVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIHNoYWRvdyBwcm9wZXJ0aWVzIGZvciBib3RoIE1lc2ggYW5kIEdyb3VwXG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgICAgdGhpcy5tZXNoLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lc2ggaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgLy8gQXBwbHkgc2hhZG93IHByb3BlcnRpZXMgdG8gYWxsIG1lc2hlcyBpbiB0aGUgZ3JvdXBcbiAgICAgIHRoaXMubWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5tZXNoLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdGhpcy5tZXNoLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIGlmICh0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5tYXRlcmlhbCAmJiB0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICB0aGlzLm1lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldENhc3RTaGFkb3coY2FzdFNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFJlY2VpdmVTaGFkb3cocmVjZWl2ZVNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9uIG1ldGhvZHNcbiAgcHVibGljIHNldHVwQW5pbWF0aW9ucyhhbmltYXRpb25zOiBBbmltYXRpb25DbGlwW10pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHRoaXMubWVzaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHBsYXlBbmltYXRpb24obmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuID0gdHJ1ZSwgZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IEFuaW1hdGlvbkFjdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25NaXhlcikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjbGlwID0gdGhpcy5hbmltYXRpb25zLmZpbmQoY2xpcCA9PiBjbGlwLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghY2xpcCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLmZhZGVPdXQoZmFkZVRpbWUpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGlvbk1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG4gICAgYWN0aW9uLnNldExvb3AobG9vcCA/IExvb3BSZXBlYXQgOiBMb29wT25jZSwgbG9vcCA/IEluZmluaXR5IDogMSk7XG4gICAgYWN0aW9uLmZhZGVJbihmYWRlVGltZSk7XG4gICAgYWN0aW9uLnBsYXkoKTtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcHVibGljIHN0b3BBbmltYXRpb24oZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5mYWRlT3V0KGZhZGVUaW1lKTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbnMoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnN0YW5jaW5nIG1ldGhvZHNcbiAgcHVibGljIHNldHVwSW5zdGFuY2luZyhpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoLCBpbnN0YW5jZUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RhbmNlZE1lc2ggPSBpbnN0YW5jZWRNZXNoO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSW5zdGFuY2VNYXRyaXgobWF0cml4OiBNYXRyaXg0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdGhpcy5pbnN0YW5jZWRNZXNoICYmIHRoaXMuaW5zdGFuY2VJZCA+PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB0aGlzLmluc3RhbmNlZE1lc2ggJiYgdGhpcy5pbnN0YW5jZUlkID49IDApIHtcbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgbWVzaGVzLCB3ZSBjYW4gaGlkZSBpbnN0YW5jZXMgYnkgc2NhbGluZyB0aGVtIHRvIDBcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgXG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgbWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KHRoaXMuaW5zdGFuY2VJZCwgbWF0cml4KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2VNZXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGlmICh0aGlzLm1lc2gucGFyZW50KSB7XG4gICAgICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcblxuICAgIGlmICh0aGlzLmdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2VkTWVzaCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gLTE7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBSZW5kZXJlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgY2FzdFNoYWRvdzogdGhpcy5jYXN0U2hhZG93LFxuICAgICAgcmVjZWl2ZVNoYWRvdzogdGhpcy5yZWNlaXZlU2hhZG93LFxuICAgICAgZnJ1c3R1bUN1bGxlZDogdGhpcy5mcnVzdHVtQ3VsbGVkLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgcmVuZGVyT3JkZXI6IHRoaXMucmVuZGVyT3JkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9uZSB0aGUgYWN0dWFsIGdlb21ldHJ5L21hdGVyaWFsL21lc2ggYXMgdGhleSBzaG91bGQgYmUgc2hhcmVkXG4gICAgLy8gVGhlIGNsb25lZCBjb21wb25lbnQgd2lsbCBuZWVkIHRvIGhhdmUgaXRzIGdlb21ldHJ5IGFuZCBtYXRlcmlhbCBzZXQgc2VwYXJhdGVseVxuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJHcm91cCIsIkFuaW1hdGlvbk1peGVyIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJDb21wb25lbnQiLCJSZW5kZXJlciIsInNldEdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibmVlZHNVcGRhdGUiLCJzZXRNYXRlcmlhbCIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNyZWF0ZU1lc2giLCJtZXNoIiwiZGlzcG9zZU1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ2aXNpYmxlIiwicmVuZGVyT3JkZXIiLCJ1cGRhdGVNZXNoIiwidHJhdmVyc2UiLCJjaGlsZCIsInNldFZpc2libGUiLCJzZXRDYXN0U2hhZG93Iiwic2V0UmVjZWl2ZVNoYWRvdyIsInNldHVwQW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJsZW5ndGgiLCJhbmltYXRpb25NaXhlciIsInBsYXlBbmltYXRpb24iLCJuYW1lIiwibG9vcCIsImZhZGVUaW1lIiwiY2xpcCIsImZpbmQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmFkZU91dCIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzZXRMb29wIiwiSW5maW5pdHkiLCJmYWRlSW4iLCJwbGF5Iiwic3RvcEFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbnMiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJzZXR1cEluc3RhbmNpbmciLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VJZCIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4Iiwic2V0SW5zdGFuY2VWaXNpYmxlIiwiZ2V0TWF0cml4QXQiLCJzY2FsZSIsInBhcmVudCIsInJlbW92ZSIsInN0b3BBbGxBY3Rpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Renderer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Shield.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Shield.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shield: function() { return /* binding */ Shield; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n\nclass Shield extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /**\n   * Absorb damage with the shield. Returns the amount of damage that passed through.\n   */ absorbDamage(damage) {\n        if (this.currentShield <= 0) {\n            return damage; // No shield left, all damage passes through\n        }\n        const damageAbsorbed = Math.min(damage, this.currentShield);\n        this.currentShield -= damageAbsorbed;\n        this.lastDamageTime = Date.now();\n        this.isRegenerating = false;\n        // Return the damage that wasn't absorbed\n        return damage - damageAbsorbed;\n    }\n    /**\n   * Update shield regeneration based on delta time\n   */ update(deltaTime) {\n        if (this.currentShield >= this.maxShield) {\n            this.isRegenerating = false;\n            return;\n        }\n        const timeSinceLastDamage = (Date.now() - this.lastDamageTime) / 1000;\n        if (timeSinceLastDamage >= this.regenDelay) {\n            if (!this.isRegenerating) {\n                this.isRegenerating = true;\n            }\n            const regenAmount = this.regenRate * deltaTime;\n            this.currentShield = Math.min(this.maxShield, this.currentShield + regenAmount);\n        }\n    }\n    /**\n   * Get shield percentage (0-1)\n   */ getShieldPercentage() {\n        return this.maxShield > 0 ? this.currentShield / this.maxShield : 0;\n    }\n    /**\n   * Check if shield is at full capacity\n   */ isFullShield() {\n        return this.currentShield >= this.maxShield;\n    }\n    /**\n   * Check if shield is completely depleted\n   */ isShieldDepleted() {\n        return this.currentShield <= 0;\n    }\n    /**\n   * Instantly restore shield to full (for testing or special abilities)\n   */ restoreShield() {\n        this.currentShield = this.maxShield;\n        this.isRegenerating = false;\n    }\n    /**\n   * Set shield values (useful for multiplayer sync)\n   */ setShield(current, max) {\n        this.currentShield = Math.max(0, Math.min(max, current));\n        this.maxShield = max;\n    }\n    /**\n   * Reset shield to initial state (required by Component interface)\n   */ reset() {\n        this.currentShield = this.maxShield;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n        this.enabled = true;\n    }\n    constructor(maxShield = 200, regenRate = 20, regenDelay = 5){\n        super();\n        this.componentType = \"Shield\" // Instance identifier\n        ;\n        this.maxShield = maxShield;\n        this.currentShield = maxShield;\n        this.regenRate = regenRate;\n        this.regenDelay = regenDelay;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n    }\n}\nShield.componentType = \"Shield\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFL0IsTUFBTUMsZUFBZUQsOENBQVNBO0lBb0JuQzs7R0FFQyxHQUNELGFBQW9CRyxNQUFjLEVBQVU7UUFDMUMsSUFBSSxJQUFJLENBQUNDLGFBQWEsSUFBSSxHQUFHO1lBQzNCLE9BQU9ELFFBQVEsNENBQTRDO1FBQzdEO1FBRUEsTUFBTUUsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUNKLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1FBQzFELElBQUksQ0FBQ0EsYUFBYSxJQUFJQztRQUN0QixJQUFJLENBQUNHLGNBQWMsR0FBR0MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUV0Qix5Q0FBeUM7UUFDekMsT0FBT1IsU0FBU0U7SUFDbEI7SUFFQTs7R0FFQyxHQUNELE9BQWNRLFNBQWlCLEVBQVE7UUFDckMsSUFBSSxJQUFJLENBQUNULGFBQWEsSUFBSSxJQUFJLENBQUNVLFNBQVMsRUFBRTtZQUN4QyxJQUFJLENBQUNILGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTUksc0JBQXNCLENBQUNOLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNGLGNBQWMsSUFBSTtRQUVqRSxJQUFJTyx1QkFBdUIsSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0wsY0FBYyxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRztZQUN4QjtZQUVBLE1BQU1NLGNBQWMsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1lBQ3JDLElBQUksQ0FBQ1QsYUFBYSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxTQUFTLEVBQUUsSUFBSSxDQUFDVixhQUFhLEdBQUdhO1FBQ3JFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUFxQztRQUNuQyxPQUFPLElBQUksQ0FBQ0gsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTLEdBQUc7SUFDcEU7SUFFQTs7R0FFQyxHQUNELGVBQStCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVixhQUFhLElBQUksSUFBSSxDQUFDVSxTQUFTO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxtQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUNWLGFBQWEsSUFBSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsZ0JBQTZCO1FBQzNCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ1UsU0FBUztRQUNuQyxJQUFJLENBQUNILGNBQWMsR0FBRztJQUN4QjtJQUVBOztHQUVDLEdBQ0QsVUFBaUJhLE9BQWUsRUFBRUMsR0FBVyxFQUFRO1FBQ25ELElBQUksQ0FBQ3JCLGFBQWEsR0FBR0UsS0FBS21CLEdBQUcsQ0FBQyxHQUFHbkIsS0FBS0MsR0FBRyxDQUFDa0IsS0FBS0Q7UUFDL0MsSUFBSSxDQUFDVixTQUFTLEdBQUdXO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxRQUFxQjtRQUNuQixJQUFJLENBQUNyQixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTO1FBQ25DLElBQUksQ0FBQ04sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2dCLE9BQU8sR0FBRztJQUNqQjtJQTdGQUMsWUFBWWQsWUFBb0IsR0FBRyxFQUFFSSxZQUFvQixFQUFFLEVBQUVGLGFBQXFCLENBQUMsQ0FBRTtRQUNuRixLQUFLO2FBVFNhLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFVOUQsSUFBSSxDQUFDZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHVTtRQUNyQixJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ1IsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3hCO0FBc0ZGO0FBeEdhVixPQUNZNEIsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHM/MmM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgU2hpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1NoaWVsZCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdTaGllbGQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBtYXhTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIGN1cnJlbnRTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuUmF0ZTogbnVtYmVyOyAvLyBTaGllbGQgcmVnZW5lcmF0ZWQgcGVyIHNlY29uZFxuICBwdWJsaWMgcmVnZW5EZWxheTogbnVtYmVyOyAvLyBTZWNvbmRzIGJlZm9yZSByZWdlbiBzdGFydHNcbiAgcHVibGljIGxhc3REYW1hZ2VUaW1lOiBudW1iZXI7IC8vIFRpbWVzdGFtcCBvZiBsYXN0IGRhbWFnZSB0YWtlblxuICBwdWJsaWMgaXNSZWdlbmVyYXRpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWF4U2hpZWxkOiBudW1iZXIgPSAyMDAsIHJlZ2VuUmF0ZTogbnVtYmVyID0gMjAsIHJlZ2VuRGVsYXk6IG51bWJlciA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4U2hpZWxkO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IG1heFNoaWVsZDtcbiAgICB0aGlzLnJlZ2VuUmF0ZSA9IHJlZ2VuUmF0ZTtcbiAgICB0aGlzLnJlZ2VuRGVsYXkgPSByZWdlbkRlbGF5O1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnNvcmIgZGFtYWdlIHdpdGggdGhlIHNoaWVsZC4gUmV0dXJucyB0aGUgYW1vdW50IG9mIGRhbWFnZSB0aGF0IHBhc3NlZCB0aHJvdWdoLlxuICAgKi9cbiAgcHVibGljIGFic29yYkRhbWFnZShkYW1hZ2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA8PSAwKSB7XG4gICAgICByZXR1cm4gZGFtYWdlOyAvLyBObyBzaGllbGQgbGVmdCwgYWxsIGRhbWFnZSBwYXNzZXMgdGhyb3VnaFxuICAgIH1cblxuICAgIGNvbnN0IGRhbWFnZUFic29yYmVkID0gTWF0aC5taW4oZGFtYWdlLCB0aGlzLmN1cnJlbnRTaGllbGQpO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCAtPSBkYW1hZ2VBYnNvcmJlZDtcbiAgICB0aGlzLmxhc3REYW1hZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhbWFnZSB0aGF0IHdhc24ndCBhYnNvcmJlZFxuICAgIHJldHVybiBkYW1hZ2UgLSBkYW1hZ2VBYnNvcmJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2hpZWxkIHJlZ2VuZXJhdGlvbiBiYXNlZCBvbiBkZWx0YSB0aW1lXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA+PSB0aGlzLm1heFNoaWVsZCkge1xuICAgICAgdGhpcy5pc1JlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdERhbWFnZVRpbWUpIC8gMTAwMDtcbiAgICBcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuRGVsYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlZ2VuZXJhdGluZykge1xuICAgICAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVnZW5BbW91bnQgPSB0aGlzLnJlZ2VuUmF0ZSAqIGRlbHRhVGltZTtcbiAgICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWluKHRoaXMubWF4U2hpZWxkLCB0aGlzLmN1cnJlbnRTaGllbGQgKyByZWdlbkFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzaGllbGQgcGVyY2VudGFnZSAoMC0xKVxuICAgKi9cbiAgcHVibGljIGdldFNoaWVsZFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTaGllbGQgPiAwID8gdGhpcy5jdXJyZW50U2hpZWxkIC8gdGhpcy5tYXhTaGllbGQgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNoaWVsZCBpcyBhdCBmdWxsIGNhcGFjaXR5XG4gICAqL1xuICBwdWJsaWMgaXNGdWxsU2hpZWxkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPj0gdGhpcy5tYXhTaGllbGQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2hpZWxkIGlzIGNvbXBsZXRlbHkgZGVwbGV0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NoaWVsZERlcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50bHkgcmVzdG9yZSBzaGllbGQgdG8gZnVsbCAoZm9yIHRlc3Rpbmcgb3Igc3BlY2lhbCBhYmlsaXRpZXMpXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZVNoaWVsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTaGllbGQgPSB0aGlzLm1heFNoaWVsZDtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNoaWVsZCB2YWx1ZXMgKHVzZWZ1bCBmb3IgbXVsdGlwbGF5ZXIgc3luYylcbiAgICovXG4gIHB1YmxpYyBzZXRTaGllbGQoY3VycmVudDogbnVtYmVyLCBtYXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgY3VycmVudCkpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHNoaWVsZCB0byBpbml0aWFsIHN0YXRlIChyZXF1aXJlZCBieSBDb21wb25lbnQgaW50ZXJmYWNlKVxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IHRoaXMubWF4U2hpZWxkO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiYWJzb3JiRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFNoaWVsZCIsImRhbWFnZUFic29yYmVkIiwiTWF0aCIsIm1pbiIsImxhc3REYW1hZ2VUaW1lIiwiRGF0ZSIsIm5vdyIsImlzUmVnZW5lcmF0aW5nIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwibWF4U2hpZWxkIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuRGVsYXkiLCJyZWdlbkFtb3VudCIsInJlZ2VuUmF0ZSIsImdldFNoaWVsZFBlcmNlbnRhZ2UiLCJpc0Z1bGxTaGllbGQiLCJpc1NoaWVsZERlcGxldGVkIiwicmVzdG9yZVNoaWVsZCIsInNldFNoaWVsZCIsImN1cnJlbnQiLCJtYXgiLCJyZXNldCIsImVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Shield.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/SummonedUnit.ts":
/*!********************************************!*\
  !*** ./src/ecs/components/SummonedUnit.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SummonedUnit: function() { return /* binding */ SummonedUnit; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// SummonedUnit component for PVP tower minions\n\nclass SummonedUnit extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    isExpired(currentTime) {\n        return this.isDead || currentTime - this.summonTime >= this.lifetime;\n    }\n    getDisplayName() {\n        return \"Unit (\".concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.unitId = \"\";\n        this.attackRange = 4;\n        this.attackDamage = 15;\n        this.attackCooldown = 1.0;\n        this.lastAttackTime = 0;\n        this.maxHealth = 500;\n        this.moveSpeed = 2.5;\n        this.targetPosition = null;\n        this.currentTarget = null;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.summonTime = Date.now() / 1000;\n        this.lifetime = 120;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new SummonedUnit(this.ownerId, this.unitId, this.targetPosition);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.maxHealth = this.maxHealth;\n        clone.moveSpeed = this.moveSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.summonTime = this.summonTime;\n        clone.lifetime = this.lifetime;\n        return clone;\n    }\n    constructor(ownerId = \"\", unitId = \"\", targetPosition = null){\n        super();\n        this.componentType = \"SummonedUnit\";\n        this.ownerId = ownerId;\n        this.unitId = unitId;\n        // Combat configuration\n        this.attackRange = 4; // 4 unit attack range as specified\n        this.attackDamage = 15; // 15 damage per hit as specified\n        this.attackCooldown = 1.0; // 1 second between attacks\n        this.lastAttackTime = 0;\n        this.maxHealth = 500; // 500 HP as specified\n        // Movement configuration\n        this.moveSpeed = 2.5; // Moderate movement speed\n        this.targetPosition = targetPosition;\n        this.currentTarget = null;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        // Summon properties\n        this.summonTime = Date.now() / 1000; // Current time in seconds\n        this.lifetime = 120; // 2 minutes lifetime\n    }\n}\nSummonedUnit.componentType = \"SummonedUnit\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQ0FBK0M7QUFDVDtBQUUvQixNQUFNQyxxQkFBcUJELDhDQUFTQTtJQWlFbENFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLFVBQVVoQixXQUFtQixFQUFXO1FBQzdDLE9BQU8sSUFBSSxDQUFDRSxNQUFNLElBQUksY0FBZSxJQUFJLENBQUNlLFVBQVUsSUFBSyxJQUFJLENBQUNDLFFBQVE7SUFDeEU7SUFFT0MsaUJBQXlCO1FBQzlCLE9BQU8sU0FBc0IsT0FB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QUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ2EsU0FBUyxHQUFHO1FBRWpCLG9CQUFvQjtRQUNwQixJQUFJLENBQUNFLFVBQVUsR0FBR1csS0FBS0MsR0FBRyxLQUFLLE1BQU0sMEJBQTBCO1FBQy9ELElBQUksQ0FBQ1gsUUFBUSxHQUFHLEtBQUsscUJBQXFCO0lBQzVDO0FBbUZGO0FBbEphcEIsYUFDWW1DLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvU3VtbW9uZWRVbml0LnRzPzVjOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3VtbW9uZWRVbml0IGNvbXBvbmVudCBmb3IgUFZQIHRvd2VyIG1pbmlvbnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBTdW1tb25lZFVuaXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnU3VtbW9uZWRVbml0JztcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnU3VtbW9uZWRVbml0JztcblxuICAvLyBPd25lcnNoaXAgYW5kIGlkZW50aWZpY2F0aW9uXG4gIHB1YmxpYyBvd25lcklkOiBzdHJpbmc7IC8vIFBsYXllciBJRCB3aG8gb3ducyB0aGlzIHVuaXRcbiAgcHVibGljIHVuaXRJZDogc3RyaW5nOyAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyB1bml0XG5cbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgbWF4SGVhbHRoOiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgcHJvcGVydGllc1xuICBwdWJsaWMgbW92ZVNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyB0YXJnZXRQb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0gfCBudWxsOyAvLyBQb3NpdGlvbiB0byBtb3ZlIHRvd2FyZHNcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldCAodW5pdCBvciB0b3dlcilcbiAgcHVibGljIGxhc3RUYXJnZXRTZWFyY2hUaW1lOiBudW1iZXI7XG4gIHB1YmxpYyB0YXJnZXRTZWFyY2hDb29sZG93bjogbnVtYmVyOyAvLyBIb3cgb2Z0ZW4gdG8gc2VhcmNoIGZvciB0YXJnZXRzXG5cbiAgLy8gU3RhdGVcbiAgcHVibGljIGlzQWN0aXZlOiBib29sZWFuO1xuICBwdWJsaWMgaXNEZWFkOiBib29sZWFuO1xuICBwdWJsaWMgZGVhdGhUaW1lOiBudW1iZXI7XG5cbiAgLy8gU3VtbW9uIHByb3BlcnRpZXNcbiAgcHVibGljIHN1bW1vblRpbWU6IG51bWJlcjsgLy8gV2hlbiB0aGlzIHVuaXQgd2FzIHN1bW1vbmVkXG4gIHB1YmxpYyBsaWZldGltZTogbnVtYmVyOyAvLyBIb3cgbG9uZyB0aGlzIHVuaXQgbGl2ZXMgKGluIHNlY29uZHMpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdW5pdElkOiBzdHJpbmcgPSAnJyxcbiAgICB0YXJnZXRQb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0gfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vd25lcklkID0gb3duZXJJZDtcbiAgICB0aGlzLnVuaXRJZCA9IHVuaXRJZDtcblxuICAgIC8vIENvbWJhdCBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IDQ7IC8vIDQgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxNTsgLy8gMTUgZGFtYWdlIHBlciBoaXQgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDEuMDsgLy8gMSBzZWNvbmQgYmV0d2VlbiBhdHRhY2tzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tYXhIZWFsdGggPSA1MDA7IC8vIDUwMCBIUCBhcyBzcGVjaWZpZWRcblxuICAgIC8vIE1vdmVtZW50IGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLm1vdmVTcGVlZCA9IDIuNTsgLy8gTW9kZXJhdGUgbW92ZW1lbnQgc3BlZWRcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb247XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41OyAvLyBTZWFyY2ggZm9yIHRhcmdldHMgZXZlcnkgMC41IHNlY29uZHNcblxuICAgIC8vIFN0YXRlXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG5cbiAgICAvLyBTdW1tb24gcHJvcGVydGllc1xuICAgIHRoaXMuc3VtbW9uVGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDdXJyZW50IHRpbWUgaW4gc2Vjb25kc1xuICAgIHRoaXMubGlmZXRpbWUgPSAxMjA7IC8vIDIgbWludXRlcyBsaWZldGltZVxuICB9XG5cbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaXNEZWFkIHx8ICF0aGlzLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEF0dGFja1RpbWUpID49IHRoaXMuYXR0YWNrQ29vbGRvd247XG4gIH1cblxuICBwdWJsaWMgcGVyZm9ybUF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHVibGljIGNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lKSA+PSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVRhcmdldFNlYXJjaChjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHVibGljIHNldFRhcmdldCh0YXJnZXRFbnRpdHlJZDogbnVtYmVyIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldEVudGl0eUlkO1xuICB9XG5cbiAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jbGVhclRhcmdldCgpO1xuICB9XG5cbiAgcHVibGljIGlzRXhwaXJlZChjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWFkIHx8IChjdXJyZW50VGltZSAtIHRoaXMuc3VtbW9uVGltZSkgPj0gdGhpcy5saWZldGltZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVW5pdCAoJHt0aGlzLm93bmVySWR9KWA7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5vd25lcklkID0gJyc7XG4gICAgdGhpcy51bml0SWQgPSAnJztcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gNDtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IDE1O1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSAxLjA7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tYXhIZWFsdGggPSA1MDA7XG4gICAgdGhpcy5tb3ZlU3BlZWQgPSAyLjU7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41O1xuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMuc3VtbW9uVGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHRoaXMubGlmZXRpbWUgPSAxMjA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBTdW1tb25lZFVuaXQge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFN1bW1vbmVkVW5pdCh0aGlzLm93bmVySWQsIHRoaXMudW5pdElkLCB0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICBjbG9uZS5hdHRhY2tSYW5nZSA9IHRoaXMuYXR0YWNrUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrRGFtYWdlID0gdGhpcy5hdHRhY2tEYW1hZ2U7XG4gICAgY2xvbmUuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmF0dGFja0Nvb2xkb3duO1xuICAgIGNsb25lLmxhc3RBdHRhY2tUaW1lID0gdGhpcy5sYXN0QXR0YWNrVGltZTtcbiAgICBjbG9uZS5tYXhIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICBjbG9uZS5tb3ZlU3BlZWQgPSB0aGlzLm1vdmVTcGVlZDtcbiAgICBjbG9uZS5jdXJyZW50VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgIGNsb25lLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZTtcbiAgICBjbG9uZS50YXJnZXRTZWFyY2hDb29sZG93biA9IHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd247XG4gICAgY2xvbmUuaXNBY3RpdmUgPSB0aGlzLmlzQWN0aXZlO1xuICAgIGNsb25lLmlzRGVhZCA9IHRoaXMuaXNEZWFkO1xuICAgIGNsb25lLmRlYXRoVGltZSA9IHRoaXMuZGVhdGhUaW1lO1xuICAgIGNsb25lLnN1bW1vblRpbWUgPSB0aGlzLnN1bW1vblRpbWU7XG4gICAgY2xvbmUubGlmZXRpbWUgPSB0aGlzLmxpZmV0aW1lO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIlN1bW1vbmVkVW5pdCIsImNhbkF0dGFjayIsImN1cnJlbnRUaW1lIiwiaXNBY3RpdmUiLCJpc0RlYWQiLCJjdXJyZW50VGFyZ2V0IiwibGFzdEF0dGFja1RpbWUiLCJhdHRhY2tDb29sZG93biIsInBlcmZvcm1BdHRhY2siLCJjYW5TZWFyY2hGb3JUYXJnZXRzIiwibGFzdFRhcmdldFNlYXJjaFRpbWUiLCJ0YXJnZXRTZWFyY2hDb29sZG93biIsInVwZGF0ZVRhcmdldFNlYXJjaCIsInNldFRhcmdldCIsInRhcmdldEVudGl0eUlkIiwiY2xlYXJUYXJnZXQiLCJkaWUiLCJkZWF0aFRpbWUiLCJpc0V4cGlyZWQiLCJzdW1tb25UaW1lIiwibGlmZXRpbWUiLCJnZXREaXNwbGF5TmFtZSIsIm93bmVySWQiLCJyZXNldCIsInVuaXRJZCIsImF0dGFja1JhbmdlIiwiYXR0YWNrRGFtYWdlIiwibWF4SGVhbHRoIiwibW92ZVNwZWVkIiwidGFyZ2V0UG9zaXRpb24iLCJEYXRlIiwibm93IiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Tower.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Tower.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: function() { return /* binding */ Tower; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Tower component for PVP home base towers\n\nclass Tower extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    getDisplayName() {\n        return \"Tower \".concat(this.towerIndex + 1, \" (Owner: \").concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.towerIndex = 0;\n        this.attackRange = 10;\n        this.attackDamage = 25;\n        this.attackCooldown = 1.5;\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20;\n        this.currentTarget = null;\n        this.targetSearchRange = 9;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Tower(this.ownerId, this.towerIndex);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.projectileSpeed = this.projectileSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.targetSearchRange = this.targetSearchRange;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        return clone;\n    }\n    constructor(ownerId = \"\", towerIndex = 0){\n        super();\n        this.componentType = \"Tower\";\n        this.ownerId = ownerId;\n        this.towerIndex = towerIndex;\n        // Combat configuration\n        this.attackRange = 10; // 10 unit attack range as specified\n        this.attackDamage = 100; // 25 damage per arrow as requested\n        this.attackCooldown = 1.5; // 1.5 seconds between shots\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20; // Speed of tower arrows\n        // Targeting configuration\n        this.currentTarget = null;\n        this.targetSearchRange = this.attackRange + 1; // Search slightly beyond attack range\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n    }\n}\nTower.componentType = \"Tower\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEyQztBQUNMO0FBRS9CLE1BQU1DLGNBQWNELDhDQUFTQTtJQXNEM0JFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLGlCQUF5QjtRQUM5QixPQUFPLFNBQXdDLE9BQS9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEdBQUUsYUFBd0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztJQUM5RDtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNuQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDb0IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZixvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDUyxPQUFPLEdBQUc7SUFDakI7SUFFT0MsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUkzQixNQUFNLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUNELFVBQVU7UUFDckRRLE1BQU1MLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENLLE1BQU1KLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdENJLE1BQU1wQixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDb0IsTUFBTXJCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNxQixNQUFNSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzVDRyxNQUFNdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NCLE1BQU1GLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hERSxNQUFNakIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERpQixNQUFNaEIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERnQixNQUFNeEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUM5QndCLE1BQU12QixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzFCdUIsTUFBTVYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxPQUFPVTtJQUNUO0lBbkdBQyxZQUNFUixVQUFrQixFQUFFLEVBQ3BCRCxhQUFxQixDQUFDLENBQ3RCO1FBQ0EsS0FBSzthQTVCU1UsZ0JBQWdCO1FBOEI5QixJQUFJLENBQUNULE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFFbEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUksb0NBQW9DO1FBQzNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUssbUNBQW1DO1FBQzVELElBQUksQ0FBQ2hCLGNBQWMsR0FBRyxLQUFLLDRCQUE0QjtRQUN2RCxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSx3QkFBd0I7UUFFbkQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ25CLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUNILFdBQVcsR0FBRyxHQUFHLHNDQUFzQztRQUNyRixJQUFJLENBQUNaLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSyx1Q0FBdUM7UUFFeEUsUUFBUTtRQUNSLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7SUFDbkI7QUEwRUY7QUE5SGFqQixNQUNZNkIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cz9iNmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIGNvbXBvbmVudCBmb3IgUFZQIGhvbWUgYmFzZSB0b3dlcnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUb3dlcic7XG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Rvd2VyJztcbiAgXG4gIC8vIFRvd2VyIG93bmVyc2hpcCBhbmQgaWRlbnRpZmljYXRpb25cbiAgcHVibGljIG93bmVySWQ6IHN0cmluZzsgLy8gUGxheWVyIElEIHdobyBvd25zIHRoaXMgdG93ZXJcbiAgcHVibGljIHRvd2VySW5kZXg6IG51bWJlcjsgLy8gVG93ZXIgaW5kZXggKDAgZm9yIGZpcnN0IHBsYXllciwgMSBmb3Igc2Vjb25kLCBldGMuKVxuICBcbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcHJvamVjdGlsZVNwZWVkOiBudW1iZXI7XG4gIFxuICAvLyBUYXJnZXRpbmdcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldFxuICBwdWJsaWMgdGFyZ2V0U2VhcmNoUmFuZ2U6IG51bWJlcjsgLy8gUmFuZ2UgdG8gc2VhcmNoIGZvciBuZXcgdGFyZ2V0c1xuICBwdWJsaWMgbGFzdFRhcmdldFNlYXJjaFRpbWU6IG51bWJlcjtcbiAgcHVibGljIHRhcmdldFNlYXJjaENvb2xkb3duOiBudW1iZXI7IC8vIEhvdyBvZnRlbiB0byBzZWFyY2ggZm9yIHRhcmdldHNcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdG93ZXJJbmRleDogbnVtYmVyID0gMFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy50b3dlckluZGV4ID0gdG93ZXJJbmRleDtcbiAgICBcbiAgICAvLyBDb21iYXQgY29uZmlndXJhdGlvblxuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSAxMDsgLy8gMTAgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxMDA7IC8vIDI1IGRhbWFnZSBwZXIgYXJyb3cgYXMgcmVxdWVzdGVkXG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDEuNTsgLy8gMS41IHNlY29uZHMgYmV0d2VlbiBzaG90c1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMucHJvamVjdGlsZVNwZWVkID0gMjA7IC8vIFNwZWVkIG9mIHRvd2VyIGFycm93c1xuICAgIFxuICAgIC8vIFRhcmdldGluZyBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaFJhbmdlID0gdGhpcy5hdHRhY2tSYW5nZSArIDE7IC8vIFNlYXJjaCBzbGlnaHRseSBiZXlvbmQgYXR0YWNrIHJhbmdlXG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hDb29sZG93biA9IDAuNTsgLy8gU2VhcmNoIGZvciB0YXJnZXRzIGV2ZXJ5IDAuNSBzZWNvbmRzXG4gICAgXG4gICAgLy8gU3RhdGVcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgfVxuICBcbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaXNEZWFkIHx8ICF0aGlzLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEF0dGFja1RpbWUpID49IHRoaXMuYXR0YWNrQ29vbGRvd247XG4gIH1cbiAgXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBjYW5TZWFyY2hGb3JUYXJnZXRzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSkgPj0gdGhpcy50YXJnZXRTZWFyY2hDb29sZG93bjtcbiAgfVxuICBcbiAgcHVibGljIHVwZGF0ZVRhcmdldFNlYXJjaChjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VGFyZ2V0KHRhcmdldEVudGl0eUlkOiBudW1iZXIgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0RW50aXR5SWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyBjbGVhclRhcmdldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICB9XG4gIFxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jbGVhclRhcmdldCgpO1xuICB9XG4gIFxuICBwdWJsaWMgZ2V0RGlzcGxheU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYFRvd2VyICR7dGhpcy50b3dlckluZGV4ICsgMX0gKE93bmVyOiAke3RoaXMub3duZXJJZH0pYDtcbiAgfVxuICBcbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMub3duZXJJZCA9ICcnO1xuICAgIHRoaXMudG93ZXJJbmRleCA9IDA7XG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IDEwO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gMjU7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDEuNTtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLnByb2plY3RpbGVTcGVlZCA9IDIwO1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hSYW5nZSA9IDk7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IDA7XG4gICAgdGhpcy50YXJnZXRTZWFyY2hDb29sZG93biA9IDAuNTtcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG4gIFxuICBwdWJsaWMgY2xvbmUoKTogVG93ZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFRvd2VyKHRoaXMub3duZXJJZCwgdGhpcy50b3dlckluZGV4KTtcbiAgICBjbG9uZS5hdHRhY2tSYW5nZSA9IHRoaXMuYXR0YWNrUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrRGFtYWdlID0gdGhpcy5hdHRhY2tEYW1hZ2U7XG4gICAgY2xvbmUuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmF0dGFja0Nvb2xkb3duO1xuICAgIGNsb25lLmxhc3RBdHRhY2tUaW1lID0gdGhpcy5sYXN0QXR0YWNrVGltZTtcbiAgICBjbG9uZS5wcm9qZWN0aWxlU3BlZWQgPSB0aGlzLnByb2plY3RpbGVTcGVlZDtcbiAgICBjbG9uZS5jdXJyZW50VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgIGNsb25lLnRhcmdldFNlYXJjaFJhbmdlID0gdGhpcy50YXJnZXRTZWFyY2hSYW5nZTtcbiAgICBjbG9uZS5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWU7XG4gICAgY2xvbmUudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICAgIGNsb25lLmlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZTtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDb21wb25lbnQiLCJUb3dlciIsImNhbkF0dGFjayIsImN1cnJlbnRUaW1lIiwiaXNBY3RpdmUiLCJpc0RlYWQiLCJjdXJyZW50VGFyZ2V0IiwibGFzdEF0dGFja1RpbWUiLCJhdHRhY2tDb29sZG93biIsInBlcmZvcm1BdHRhY2siLCJjYW5TZWFyY2hGb3JUYXJnZXRzIiwibGFzdFRhcmdldFNlYXJjaFRpbWUiLCJ0YXJnZXRTZWFyY2hDb29sZG93biIsInVwZGF0ZVRhcmdldFNlYXJjaCIsInNldFRhcmdldCIsInRhcmdldEVudGl0eUlkIiwiY2xlYXJUYXJnZXQiLCJkaWUiLCJkZWF0aFRpbWUiLCJnZXREaXNwbGF5TmFtZSIsInRvd2VySW5kZXgiLCJvd25lcklkIiwicmVzZXQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0RhbWFnZSIsInByb2plY3RpbGVTcGVlZCIsInRhcmdldFNlYXJjaFJhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Tower.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Transform.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/Transform.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Transform component for position, rotation, and scale\n\n\nclass Transform extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    translate(x, y, z) {\n        this.position.x += x;\n        this.position.y += y;\n        this.position.z += z;\n        this.markMatrixDirty();\n    }\n    rotate(x, y, z) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    lookAt(target) {\n        let up = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.lookAt(this.position, target, up);\n        this.quaternion.setFromRotationMatrix(matrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.markMatrixDirty();\n    }\n    getForward() {\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    getRight() {\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    getUp() {\n        const up = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n    getWorldPosition() {\n        this.updateWorldMatrix();\n        const worldPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldPosition.setFromMatrixPosition(this.worldMatrix);\n        return worldPosition;\n    }\n    getWorldRotation() {\n        this.updateWorldMatrix();\n        const worldQuaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        worldQuaternion.setFromRotationMatrix(this.worldMatrix);\n        return worldQuaternion;\n    }\n    getWorldScale() {\n        this.updateWorldMatrix();\n        const worldScale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldScale.setFromMatrixScale(this.worldMatrix);\n        return worldScale;\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixNeedsUpdate = false;\n    }\n    updateWorldMatrix() {\n        if (this.matrixNeedsUpdate) {\n            this.updateMatrix();\n        }\n        if (this.parent) {\n            this.parent.updateWorldMatrix();\n            this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.matrix);\n        } else {\n            this.worldMatrix.copy(this.matrix);\n        }\n    }\n    addChild(child) {\n        if (child.parent) {\n            child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.children.push(child);\n    }\n    removeChild(child) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n            child.parent = null;\n        }\n    }\n    removeFromParent() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    }\n    updateQuaternion() {\n        this.quaternion.setFromEuler(this.rotation);\n    }\n    markMatrixDirty() {\n        this.matrixNeedsUpdate = true;\n        // Mark all children as dirty too\n        for (const child of this.children){\n            child.markMatrixDirty();\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.position) {\n            this.position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.position.set(0, 0, 0);\n        }\n        if (!this.rotation) {\n            this.rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0);\n        } else {\n            this.rotation.set(0, 0, 0);\n        }\n        if (!this.scale) {\n            this.scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        } else {\n            this.scale.set(1, 1, 1);\n        }\n        if (!this.quaternion) {\n            this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        } else {\n            this.quaternion.set(0, 0, 0, 1);\n        }\n        if (!this.matrix) {\n            this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.matrix.identity();\n        }\n        if (!this.worldMatrix) {\n            this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.worldMatrix.identity();\n        }\n        this.matrixNeedsUpdate = true;\n        // Clear parent-child relationships\n        this.removeFromParent();\n        while(this.children.length > 0){\n            this.removeChild(this.children[0]);\n        }\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Transform(this.position, this.rotation, this.scale);\n        clone.quaternion.copy(this.quaternion);\n        return clone;\n    }\n    constructor(position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0), scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)){\n        super();\n        this.componentType = \"Transform\" // Instance identifier\n        ;\n        this.matrixNeedsUpdate = true;\n        // Parent-child relationships\n        this.parent = null;\n        this.children = [];\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.updateQuaternion();\n    }\n}\nTransform.componentType = \"Transform\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0RBQXdEO0FBQ29CO0FBQ3RDO0FBRS9CLE1BQU1LLGtCQUFrQkQsOENBQVNBO0lBa0MvQkUsWUFBWUMsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT0MsWUFBWU4sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNLLFFBQVEsQ0FBQ0gsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT0ksU0FBU1QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNyRCxJQUFJLENBQUNRLEtBQUssQ0FBQ04sR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUNyQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT00sVUFBVVgsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN0RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0QsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT08sT0FBT1osQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNuRCxJQUFJLENBQUNLLFFBQVEsQ0FBQ1AsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNPLFFBQVEsQ0FBQ04sQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJQTtRQUNuQixJQUFJ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QkFBZ0IsWUFBYSxzQkFBc0I7O2FBUzVEcEIsb0JBQW9CO1FBRTNCLDZCQUE2QjthQUN0QkMsU0FBMkI7YUFDM0JNLFdBQXdCLEVBQUU7UUFTL0IsSUFBSSxDQUFDMUMsUUFBUSxHQUFHQSxTQUFTcUQsS0FBSztRQUM5QixJQUFJLENBQUNqRCxRQUFRLEdBQUdBLFNBQVNpRCxLQUFLO1FBQzlCLElBQUksQ0FBQzlDLEtBQUssR0FBR0EsTUFBTThDLEtBQUs7UUFDeEIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHLElBQUl0Qiw0REFBVUE7UUFDaEMsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlwQix5REFBT0E7UUFDekIsSUFBSSxDQUFDa0MsV0FBVyxHQUFHLElBQUlsQyx5REFBT0E7UUFFOUIsSUFBSSxDQUFDWSxnQkFBZ0I7SUFDdkI7QUE0TEY7QUE1TmFWLFVBQ1k0RCxnQkFBZ0IsWUFBYSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybS50cz9mY2JhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zZm9ybSBjb21wb25lbnQgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5kIHNjYWxlXG5pbXBvcnQgeyBWZWN0b3IzLCBFdWxlciwgUXVhdGVybmlvbiwgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1RyYW5zZm9ybSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUcmFuc2Zvcm0nOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHVibGljIHJvdGF0aW9uOiBFdWxlcjtcbiAgcHVibGljIHNjYWxlOiBWZWN0b3IzO1xuICBwdWJsaWMgcXVhdGVybmlvbjogUXVhdGVybmlvbjtcblxuICAvLyBDYWNoZWQgbWF0cmljZXMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBtYXRyaXg6IE1hdHJpeDQ7XG4gIHB1YmxpYyB3b3JsZE1hdHJpeDogTWF0cml4NDtcbiAgcHVibGljIG1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBQYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICBwdWJsaWMgcGFyZW50OiBUcmFuc2Zvcm0gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBUcmFuc2Zvcm1bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgcm90YXRpb246IEV1bGVyID0gbmV3IEV1bGVyKDAsIDAsIDApLFxuICAgIHNjYWxlOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSlcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUuY2xvbmUoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRSb3RhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy51cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTY2FsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zY2FsZS5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2xhdGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24ueCArPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSArPSB5O1xuICAgIHRoaXMucG9zaXRpb24ueiArPSB6O1xuICAgIHRoaXMubWFya01hdHJpeERpcnR5KCk7XG4gIH1cblxuICBwdWJsaWMgcm90YXRlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJvdGF0aW9uLnggKz0geDtcbiAgICB0aGlzLnJvdGF0aW9uLnkgKz0geTtcbiAgICB0aGlzLnJvdGF0aW9uLnogKz0gejtcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGxvb2tBdCh0YXJnZXQ6IFZlY3RvcjMsIHVwOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCkpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIG1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB1cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGdldEZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldFJpZ2h0KCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgcmlnaHQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldFVwKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgdXAuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHVwO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUG9zaXRpb24oKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUm90YXRpb24oKTogUXVhdGVybmlvbiB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgd29ybGRRdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICByZXR1cm4gd29ybGRRdWF0ZXJuaW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkU2NhbGUoKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFNjYWxlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdHJpeE5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICAgIHRoaXMud29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChjaGlsZDogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVhdGVybmlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMucm90YXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrTWF0cml4RGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gTWFyayBhbGwgY2hpbGRyZW4gYXMgZGlydHkgdG9vXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5tYXJrTWF0cml4RGlydHkoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5yb3RhdGlvbikge1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLndvcmxkTWF0cml4KSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JsZE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogVHJhbnNmb3JtIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbiwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgY2xvbmUucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkV1bGVyIiwiUXVhdGVybmlvbiIsIk1hdHJpeDQiLCJDb21wb25lbnQiLCJUcmFuc2Zvcm0iLCJzZXRQb3NpdGlvbiIsIngiLCJ5IiwieiIsInBvc2l0aW9uIiwic2V0IiwibWFya01hdHJpeERpcnR5Iiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsInVwZGF0ZVF1YXRlcm5pb24iLCJzZXRTY2FsZSIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwibG9va0F0IiwidGFyZ2V0IiwidXAiLCJtYXRyaXgiLCJxdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4Iiwic2V0RnJvbVF1YXRlcm5pb24iLCJnZXRGb3J3YXJkIiwiZm9yd2FyZCIsImFwcGx5UXVhdGVybmlvbiIsImdldFJpZ2h0IiwicmlnaHQiLCJnZXRVcCIsImdldFdvcmxkUG9zaXRpb24iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIndvcmxkUG9zaXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJ3b3JsZE1hdHJpeCIsImdldFdvcmxkUm90YXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJnZXRXb3JsZFNjYWxlIiwid29ybGRTY2FsZSIsInNldEZyb21NYXRyaXhTY2FsZSIsInVwZGF0ZU1hdHJpeCIsImNvbXBvc2UiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInBhcmVudCIsIm11bHRpcGx5TWF0cmljZXMiLCJjb3B5IiwiYWRkQ2hpbGQiLCJjaGlsZCIsInJlbW92ZUNoaWxkIiwiY2hpbGRyZW4iLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRnJvbVBhcmVudCIsInNldEZyb21FdWxlciIsInJlc2V0IiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Transform.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CameraSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CameraSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSystem: function() { return /* binding */ CameraSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/MathUtils */ \"(app-pages-browser)/./src/utils/MathUtils.ts\");\n// Camera system for third-person camera controls\n\n\n\n\nclass CameraSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setTarget(entity) {\n        this.target = entity;\n    }\n    setConfig(config) {\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.spherical.radius = this.config.distance;\n    }\n    update(entities, deltaTime) {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) return;\n        // Handle mouse input for camera rotation\n        this.handleMouseInput();\n        // Update target position\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        // Calculate camera position based on spherical coordinates\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        // Smooth camera movement\n        this.currentPosition.lerp(this.targetPosition, this.config.smoothing);\n        this.currentLookAt.lerp(this.targetLookAt, this.config.smoothing);\n        // Update camera\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    handleMouseInput() {\n        const mouseDelta = this.inputManager.getMouseDelta();\n        // Only rotate camera when right mouse button is held down\n        if ((mouseDelta.x !== 0 || mouseDelta.y !== 0) && this.isRightMouseDown) {\n            // Update spherical coordinates based on mouse movement\n            this.spherical.theta -= mouseDelta.x * this.config.mouseSensitivity;\n            this.spherical.phi -= mouseDelta.y * this.config.mouseSensitivity; // Inverted Y for natural camera feel\n            // Clamp phi to prevent camera flipping\n            this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.phi, this.config.minPolarAngle, this.config.maxPolarAngle);\n            // Normalize theta\n            this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(this.spherical.theta);\n        }\n    }\n    setupEventListeners() {\n        // Mouse button events for camera rotation\n        this.inputManager.on(\"mouseDown\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = true;\n            }\n        });\n        this.inputManager.on(\"mouseUp\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = false;\n            }\n        });\n        // Mouse wheel for zoom - only add listener once\n        if (!this.wheelListenerAdded) {\n            this.inputManager.on(\"wheel\", (param)=>{\n                let { deltaY } = param;\n                this.spherical.radius += deltaY * 0.01;\n                this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.radius, 2, this.config.maxDistance);\n            });\n            this.wheelListenerAdded = true;\n        }\n    }\n    setupInitialPosition() {\n        this.currentPosition.setFromSpherical(this.spherical);\n        this.currentLookAt.set(0, this.config.height, 0);\n        this.targetPosition.copy(this.currentPosition);\n        this.targetLookAt.copy(this.currentLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    // Utility methods\n    getCameraDirection() {\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        return direction;\n    }\n    getCameraRight() {\n        const direction = this.getCameraDirection();\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        right.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n        right.normalize();\n        return right;\n    }\n    getCameraForward() {\n        const right = this.getCameraRight();\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        forward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), right);\n        forward.normalize();\n        return forward;\n    }\n    getDistance() {\n        return this.spherical.radius;\n    }\n    setDistance(distance) {\n        this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(distance, 2, this.config.maxDistance);\n    }\n    getHorizontalAngle() {\n        return this.spherical.theta;\n    }\n    getVerticalAngle() {\n        return this.spherical.phi;\n    }\n    setAngles(horizontal, vertical) {\n        this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(horizontal);\n        this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(vertical, this.config.minPolarAngle, this.config.maxPolarAngle);\n    }\n    resetCamera() {\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3;\n        this.spherical.theta = 0;\n        this.setupInitialPosition();\n    }\n    snapToTarget() {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform || !targetTransform.position) return;\n        // Safety check: ensure position is properly initialized\n        if (targetTransform.position.x === undefined || targetTransform.position.y === undefined || targetTransform.position.z === undefined) {\n            return;\n        }\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        this.currentPosition.copy(this.targetPosition);\n        this.currentLookAt.copy(this.targetLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    getCamera() {\n        return this.camera;\n    }\n    constructor(camera, inputManager, config){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform\n        ];\n        this.target = null;\n        // Camera configuration\n        this.config = {\n            distance: 10,\n            height: 5,\n            mouseSensitivity: 0.005,\n            smoothing: 0.1,\n            minPolarAngle: Math.PI / 3.5,\n            maxPolarAngle: Math.PI / 2.5,\n            maxDistance: 11.5\n        };\n        // Camera state\n        this.spherical = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Spherical(10, Math.PI / 3, 0);\n        this.targetPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.targetLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Mouse state for camera rotation\n        this.isRightMouseDown = false;\n        this.wheelListenerAdded = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.priority = 900; // Run late, after movement\n        if (config) {\n            this.config = {\n                ...this.config,\n                ...config\n            };\n        }\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3; // Start at 60 degrees\n        this.spherical.theta = 0;\n        this.setupEventListeners();\n        this.setupInitialPosition();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NhbWVyYVN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlEQUFpRDtBQUM2QjtBQUN4QztBQUVpQjtBQUVUO0FBWXZDLE1BQU1LLHFCQUFxQkgsK0NBQU1BO0lBOEMvQkksVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNoQjtJQUVPRSxVQUFVQyxNQUE2QixFQUFRO1FBQ3BELElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07WUFBRSxHQUFHQSxNQUFNO1FBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtJQUM5QztJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNSLE1BQU0sRUFBRTtRQUVsQixNQUFNUyxrQkFBa0IsSUFBSSxDQUFDVCxNQUFNLENBQUNVLFlBQVksQ0FBQ2YsZ0VBQVNBO1FBQzFELElBQUksQ0FBQ2MsaUJBQWlCO1FBRXRCLHlDQUF5QztRQUN6QyxJQUFJLENBQUNFLGdCQUFnQjtRQUVyQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksQ0FBQ0osZ0JBQWdCSyxRQUFRO1FBQy9DLElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxDQUFDLElBQUksSUFBSSxDQUFDYixNQUFNLENBQUNjLE1BQU07UUFFekMsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNmLFNBQVM7UUFDbkQsSUFBSSxDQUFDYyxjQUFjLENBQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFlBQVk7UUFFekMseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1EsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDSixjQUFjLEVBQUUsSUFB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QyxRQUFRLEdBQUcsS0FBSywyQkFBMkI7UUFFaEQsSUFBSXJFLFFBQVE7WUFDVixJQUFJLENBQUNBLE1BQU0sR0FBRztnQkFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtnQkFBRSxHQUFHQSxNQUFNO1lBQUM7UUFDNUM7UUFFQSxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxRQUFRO1FBQzVDLElBQUksQ0FBQ0YsU0FBUyxDQUFDOEIsR0FBRyxHQUFHOEIsS0FBS0MsRUFBRSxHQUFHLEdBQUcsc0JBQXNCO1FBQ3hELElBQUksQ0FBQzdELFNBQVMsQ0FBQzRCLEtBQUssR0FBRztRQUV2QixJQUFJLENBQUNPLG1CQUFtQjtRQUN4QixJQUFJLENBQUNNLG9CQUFvQjtJQUMzQjtBQWdMRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9DYW1lcmFTeXN0ZW0udHM/Y2RmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYW1lcmEgc3lzdGVtIGZvciB0aGlyZC1wZXJzb24gY2FtZXJhIGNvbnRyb2xzXG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSwgU3BoZXJpY2FsLCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgSW5wdXRNYW5hZ2VyIH0gZnJvbSAnQC9jb3JlL0lucHV0TWFuYWdlcic7XG5pbXBvcnQgeyBNYXRoVXRpbHMgfSBmcm9tICdAL3V0aWxzL01hdGhVdGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FtZXJhQ29uZmlnIHtcbiAgZGlzdGFuY2U6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIG1vdXNlU2Vuc2l0aXZpdHk6IG51bWJlcjtcbiAgc21vb3RoaW5nOiBudW1iZXI7XG4gIG1pblBvbGFyQW5nbGU6IG51bWJlcjtcbiAgbWF4UG9sYXJBbmdsZTogbnVtYmVyO1xuICBtYXhEaXN0YW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FtZXJhU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm1dO1xuICBwcml2YXRlIGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmE7XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgdGFyZ2V0OiBFbnRpdHkgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIENhbWVyYSBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgY29uZmlnOiBDYW1lcmFDb25maWcgPSB7XG4gICAgZGlzdGFuY2U6IDEwLFxuICAgIGhlaWdodDogNSxcbiAgICBtb3VzZVNlbnNpdGl2aXR5OiAwLjAwNSwgLy8gSW5jcmVhc2VkIGZvciBiZXR0ZXIgcmVzcG9uc2l2ZW5lc3NcbiAgICBzbW9vdGhpbmc6IDAuMSxcbiAgICBtaW5Qb2xhckFuZ2xlOiBNYXRoLlBJIC8gMy41LCAvLyBQcmV2ZW50IGNhbWVyYSBmcm9tIGdvaW5nIGFib3ZlIGhvcml6b25cbiAgICBtYXhQb2xhckFuZ2xlOiBNYXRoLlBJIC8gMi41LCAvLyBQcmV2ZW50IGNhbWVyYSBmcm9tIGxvb2tpbmcgdW5kZXJuZWF0aCB0aGUgbWFwXG4gICAgbWF4RGlzdGFuY2U6IDExLjUsXG4gIH07XG5cbiAgLy8gQ2FtZXJhIHN0YXRlXG4gIHByaXZhdGUgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgxMCwgTWF0aC5QSSAvIDMsIDApO1xuICBwcml2YXRlIHRhcmdldFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBjdXJyZW50UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGN1cnJlbnRMb29rQXQgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIHRhcmdldExvb2tBdCA9IG5ldyBWZWN0b3IzKCk7XG4gIFxuICAvLyBNb3VzZSBzdGF0ZSBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gIHByaXZhdGUgaXNSaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICBwcml2YXRlIHdoZWVsTGlzdGVuZXJBZGRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmEsIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyLCBjb25maWc/OiBQYXJ0aWFsPENhbWVyYUNvbmZpZz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xuICAgIHRoaXMucHJpb3JpdHkgPSA5MDA7IC8vIFJ1biBsYXRlLCBhZnRlciBtb3ZlbWVudFxuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoLlBJIC8gMzsgLy8gU3RhcnQgYXQgNjAgZGVncmVlc1xuICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhID0gMDtcblxuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRUYXJnZXQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICB0aGlzLnRhcmdldCA9IGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb25maWcoY29uZmlnOiBQYXJ0aWFsPENhbWVyYUNvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IHRoaXMuY29uZmlnLmRpc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0pIHJldHVybjtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBpbnB1dCBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gICAgdGhpcy5oYW5kbGVNb3VzZUlucHV0KCk7XG5cbiAgICAvLyBVcGRhdGUgdGFyZ2V0IHBvc2l0aW9uXG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGFyZ2V0TG9va0F0LnkgKz0gdGhpcy5jb25maWcuaGVpZ2h0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGNhbWVyYSBwb3NpdGlvbiBiYXNlZCBvbiBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnNldEZyb21TcGhlcmljYWwodGhpcy5zcGhlcmljYWwpO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uYWRkKHRoaXMudGFyZ2V0TG9va0F0KTtcblxuICAgIC8vIFNtb290aCBjYW1lcmEgbW92ZW1lbnRcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5sZXJwKHRoaXMudGFyZ2V0UG9zaXRpb24sIHRoaXMuY29uZmlnLnNtb290aGluZyk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LmxlcnAodGhpcy50YXJnZXRMb29rQXQsIHRoaXMuY29uZmlnLnNtb290aGluZyk7XG5cbiAgICAvLyBVcGRhdGUgY2FtZXJhXG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy5jYW1lcmEubG9va0F0KHRoaXMuY3VycmVudExvb2tBdCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1vdXNlSW5wdXQoKTogdm9pZCB7XG4gICAgY29uc3QgbW91c2VEZWx0YSA9IHRoaXMuaW5wdXRNYW5hZ2VyLmdldE1vdXNlRGVsdGEoKTtcbiAgICBcbiAgICAvLyBPbmx5IHJvdGF0ZSBjYW1lcmEgd2hlbiByaWdodCBtb3VzZSBidXR0b24gaXMgaGVsZCBkb3duXG4gICAgaWYgKChtb3VzZURlbHRhLnggIT09IDAgfHwgbW91c2VEZWx0YS55ICE9PSAwKSAmJiB0aGlzLmlzUmlnaHRNb3VzZURvd24pIHtcbiAgICAgIC8vIFVwZGF0ZSBzcGhlcmljYWwgY29vcmRpbmF0ZXMgYmFzZWQgb24gbW91c2UgbW92ZW1lbnRcbiAgICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhIC09IG1vdXNlRGVsdGEueCAqIHRoaXMuY29uZmlnLm1vdXNlU2Vuc2l0aXZpdHk7XG4gICAgICB0aGlzLnNwaGVyaWNhbC5waGkgLT0gbW91c2VEZWx0YS55ICogdGhpcy5jb25maWcubW91c2VTZW5zaXRpdml0eTsgLy8gSW52ZXJ0ZWQgWSBmb3IgbmF0dXJhbCBjYW1lcmEgZmVlbFxuXG4gICAgICAvLyBDbGFtcCBwaGkgdG8gcHJldmVudCBjYW1lcmEgZmxpcHBpbmdcbiAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSA9IE1hdGhVdGlscy5jbGFtcChcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucGhpLFxuICAgICAgICB0aGlzLmNvbmZpZy5taW5Qb2xhckFuZ2xlLFxuICAgICAgICB0aGlzLmNvbmZpZy5tYXhQb2xhckFuZ2xlXG4gICAgICApO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhldGFcbiAgICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhID0gTWF0aFV0aWxzLm5vcm1hbGl6ZUFuZ2xlKHRoaXMuc3BoZXJpY2FsLnRoZXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgLy8gTW91c2UgYnV0dG9uIGV2ZW50cyBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ21vdXNlRG93bicsICh7IGJ1dHRvbiB9KSA9PiB7XG4gICAgICBpZiAoYnV0dG9uID09PSAyKSB7IC8vIFJpZ2h0IG1vdXNlIGJ1dHRvblxuICAgICAgICB0aGlzLmlzUmlnaHRNb3VzZURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ21vdXNlVXAnLCAoeyBidXR0b24gfSkgPT4ge1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMikgeyAvLyBSaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgdGhpcy5pc1JpZ2h0TW91c2VEb3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNb3VzZSB3aGVlbCBmb3Igem9vbSAtIG9ubHkgYWRkIGxpc3RlbmVyIG9uY2VcbiAgICBpZiAoIXRoaXMud2hlZWxMaXN0ZW5lckFkZGVkKSB7XG4gICAgICB0aGlzLmlucHV0TWFuYWdlci5vbignd2hlZWwnLCAoeyBkZWx0YVkgfSkgPT4ge1xuICAgICAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgKz0gZGVsdGFZICogMC4wMTtcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gTWF0aFV0aWxzLmNsYW1wKHRoaXMuc3BoZXJpY2FsLnJhZGl1cywgMiwgdGhpcy5jb25maWcubWF4RGlzdGFuY2UpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLndoZWVsTGlzdGVuZXJBZGRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEluaXRpYWxQb3NpdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLmN1cnJlbnRMb29rQXQuc2V0KDAsIHRoaXMuY29uZmlnLmhlaWdodCwgMCk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5jb3B5KHRoaXMuY3VycmVudFBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC5jb3B5KHRoaXMuY3VycmVudExvb2tBdCk7XG4gICAgXG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy5jYW1lcmEubG9va0F0KHRoaXMuY3VycmVudExvb2tBdCk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHVibGljIGdldENhbWVyYURpcmVjdGlvbigpOiBWZWN0b3IzIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmFSaWdodCgpOiBWZWN0b3IzIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldENhbWVyYURpcmVjdGlvbigpO1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYUZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmdldENhbWVyYVJpZ2h0KCk7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgZm9yd2FyZC5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoMCwgMSwgMCksIHJpZ2h0KTtcbiAgICBmb3J3YXJkLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldERpc3RhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnJhZGl1cztcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXN0YW5jZShkaXN0YW5jZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gTWF0aFV0aWxzLmNsYW1wKGRpc3RhbmNlLCAyLCB0aGlzLmNvbmZpZy5tYXhEaXN0YW5jZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SG9yaXpvbnRhbEFuZ2xlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnRoZXRhO1xuICB9XG5cbiAgcHVibGljIGdldFZlcnRpY2FsQW5nbGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zcGhlcmljYWwucGhpO1xuICB9XG5cbiAgcHVibGljIHNldEFuZ2xlcyhob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IE1hdGhVdGlscy5ub3JtYWxpemVBbmdsZShob3Jpem9udGFsKTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICB2ZXJ0aWNhbCxcbiAgICAgIHRoaXMuY29uZmlnLm1pblBvbGFyQW5nbGUsXG4gICAgICB0aGlzLmNvbmZpZy5tYXhQb2xhckFuZ2xlXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldENhbWVyYSgpOiB2b2lkIHtcbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoLlBJIC8gMztcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IDA7XG4gICAgdGhpcy5zZXR1cEluaXRpYWxQb3NpdGlvbigpO1xuICB9XG5cbiAgcHVibGljIHNuYXBUb1RhcmdldCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0aGlzLnRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXRhcmdldFRyYW5zZm9ybSB8fCAhdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKSByZXR1cm47XG5cbiAgICAvLyBTYWZldHkgY2hlY2s6IGVuc3VyZSBwb3NpdGlvbiBpcyBwcm9wZXJseSBpbml0aWFsaXplZFxuICAgIGlmICh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24ueCA9PT0gdW5kZWZpbmVkIHx8IFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24ueSA9PT0gdW5kZWZpbmVkIHx8IFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24ueiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGFyZ2V0TG9va0F0LnkgKz0gdGhpcy5jb25maWcuaGVpZ2h0O1xuXG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLmFkZCh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5jb3B5KHRoaXMudGFyZ2V0UG9zaXRpb24pO1xuICAgIHRoaXMuY3VycmVudExvb2tBdC5jb3B5KHRoaXMudGFyZ2V0TG9va0F0KTtcblxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYSgpOiBQZXJzcGVjdGl2ZUNhbWVyYSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU3BoZXJpY2FsIiwiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIk1hdGhVdGlscyIsIkNhbWVyYVN5c3RlbSIsInNldFRhcmdldCIsImVudGl0eSIsInRhcmdldCIsInNldENvbmZpZyIsImNvbmZpZyIsInNwaGVyaWNhbCIsInJhZGl1cyIsImRpc3RhbmNlIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJ0YXJnZXRUcmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoYW5kbGVNb3VzZUlucHV0IiwidGFyZ2V0TG9va0F0IiwiY29weSIsInBvc2l0aW9uIiwieSIsImhlaWdodCIsInRhcmdldFBvc2l0aW9uIiwic2V0RnJvbVNwaGVyaWNhbCIsImFkZCIsImN1cnJlbnRQb3NpdGlvbiIsImxlcnAiLCJzbW9vdGhpbmciLCJjdXJyZW50TG9va0F0IiwiY2FtZXJhIiwibG9va0F0IiwibW91c2VEZWx0YSIsImlucHV0TWFuYWdlciIsImdldE1vdXNlRGVsdGEiLCJ4IiwiaXNSaWdodE1vdXNlRG93biIsInRoZXRhIiwibW91c2VTZW5zaXRpdml0eSIsInBoaSIsImNsYW1wIiwibWluUG9sYXJBbmdsZSIsIm1heFBvbGFyQW5nbGUiLCJub3JtYWxpemVBbmdsZSIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJvbiIsImJ1dHRvbiIsIndoZWVsTGlzdGVuZXJBZGRlZCIsImRlbHRhWSIsIm1heERpc3RhbmNlIiwic2V0dXBJbml0aWFsUG9zaXRpb24iLCJzZXQiLCJnZXRDYW1lcmFEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJnZXRXb3JsZERpcmVjdGlvbiIsImdldENhbWVyYVJpZ2h0IiwicmlnaHQiLCJjcm9zc1ZlY3RvcnMiLCJub3JtYWxpemUiLCJnZXRDYW1lcmFGb3J3YXJkIiwiZm9yd2FyZCIsImdldERpc3RhbmNlIiwic2V0RGlzdGFuY2UiLCJnZXRIb3Jpem9udGFsQW5nbGUiLCJnZXRWZXJ0aWNhbEFuZ2xlIiwic2V0QW5nbGVzIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwicmVzZXRDYW1lcmEiLCJNYXRoIiwiUEkiLCJzbmFwVG9UYXJnZXQiLCJ1bmRlZmluZWQiLCJ6IiwiZ2V0Q2FtZXJhIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CameraSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CollisionSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/CollisionSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionSystem: function() { return /* binding */ CollisionSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/SpatialHash */ \"(app-pages-browser)/./src/utils/SpatialHash.ts\");\n// Collision system for efficient collision detection and response\n\n\n\n\n\n\nclass CollisionSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for trigger detection and broad phase\n        this.updateSpatialHash(entities);\n        this.detectCollisions(entities);\n        this.processCollisionCallbacks();\n        // Also resolve collisions in update() to ensure immediate response\n        this.resolveCollisions();\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics collision response\n        this.resolveCollisions();\n    }\n    updateSpatialHash(entities) {\n        // Update spatial hash with current entity positions\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) {\n                this.spatialHash.remove(entity);\n                continue;\n            }\n            // Update collider bounds\n            collider.updateBounds(transform.getWorldPosition());\n            // Update spatial hash\n            this.spatialHash.update(entity, collider.bounds);\n        }\n    }\n    detectCollisions(entities) {\n        this.collisionPairs.length = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        const processedPairs = new Set();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) continue;\n            // Query spatial hash for potential collisions\n            const candidates = this.spatialHash.query(collider.bounds);\n            for (const candidate of candidates){\n                const otherEntity = candidate.entity;\n                // Skip self\n                if (entity.id === otherEntity.id) continue;\n                // Create unique pair key (smaller ID first)\n                const pairKey = entity.id < otherEntity.id ? \"\".concat(entity.id, \"-\").concat(otherEntity.id) : \"\".concat(otherEntity.id, \"-\").concat(entity.id);\n                // Skip if already processed this pair\n                if (processedPairs.has(pairKey)) continue;\n                processedPairs.add(pairKey);\n                const otherTransform = otherEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const otherCollider = otherEntity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n                if (!(otherTransform === null || otherTransform === void 0 ? void 0 : otherTransform.enabled) || !(otherCollider === null || otherCollider === void 0 ? void 0 : otherCollider.enabled)) continue;\n                // Check if colliders can collide\n                if (!collider.canCollideWith(otherCollider)) continue;\n                this.collisionChecks++;\n                // Precise collision detection\n                if (collider.intersects(otherCollider, transform.getWorldPosition(), otherTransform.getWorldPosition())) {\n                    this.actualCollisions++;\n                    // Debug logging for pillar collisions\n                    if (collider.layer === 2 && otherCollider.layer === 16 || collider.layer === 16 && otherCollider.layer === 2) {}\n                    const pair = {\n                        entityA: entity,\n                        entityB: otherEntity,\n                        colliderA: collider,\n                        colliderB: otherCollider\n                    };\n                    this.collisionPairs.push(pair);\n                }\n            }\n        }\n    }\n    processCollisionCallbacks() {\n        const currentCollisions = new Map();\n        // Process current collisions\n        for (const pair of this.collisionPairs){\n            const pairKey = pair.entityA.id < pair.entityB.id ? \"\".concat(pair.entityA.id, \"-\").concat(pair.entityB.id) : \"\".concat(pair.entityB.id, \"-\").concat(pair.entityA.id);\n            currentCollisions.set(pairKey, pair);\n            // Check if this is a new collision\n            if (!this.activeCollisions.has(pairKey)) {\n                // New collision - trigger enter events\n                this.triggerCollisionEnter(pair);\n            } else {\n                // Ongoing collision - trigger stay events\n                this.triggerCollisionStay(pair);\n            }\n        }\n        // Check for collisions that ended\n        this.activeCollisions.forEach((pair, pairKey)=>{\n            if (!currentCollisions.has(pairKey)) {\n                // Collision ended - trigger exit events\n                this.triggerCollisionExit(pair);\n            }\n        });\n        // Update active collisions\n        this.activeCollisions = currentCollisions;\n    }\n    triggerCollisionEnter(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerEnter, _pair_colliderA, _pair_colliderB_onTriggerEnter, _pair_colliderB;\n            (_pair_colliderA_onTriggerEnter = (_pair_colliderA = pair.colliderA).onTriggerEnter) === null || _pair_colliderA_onTriggerEnter === void 0 ? void 0 : _pair_colliderA_onTriggerEnter.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerEnter = (_pair_colliderB = pair.colliderB).onTriggerEnter) === null || _pair_colliderB_onTriggerEnter === void 0 ? void 0 : _pair_colliderB_onTriggerEnter.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionEnter, _pair_colliderA1, _pair_colliderB_onCollisionEnter, _pair_colliderB1;\n            (_pair_colliderA_onCollisionEnter = (_pair_colliderA1 = pair.colliderA).onCollisionEnter) === null || _pair_colliderA_onCollisionEnter === void 0 ? void 0 : _pair_colliderA_onCollisionEnter.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionEnter = (_pair_colliderB1 = pair.colliderB).onCollisionEnter) === null || _pair_colliderB_onCollisionEnter === void 0 ? void 0 : _pair_colliderB_onCollisionEnter.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionStay(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerStay, _pair_colliderA, _pair_colliderB_onTriggerStay, _pair_colliderB;\n            (_pair_colliderA_onTriggerStay = (_pair_colliderA = pair.colliderA).onTriggerStay) === null || _pair_colliderA_onTriggerStay === void 0 ? void 0 : _pair_colliderA_onTriggerStay.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerStay = (_pair_colliderB = pair.colliderB).onTriggerStay) === null || _pair_colliderB_onTriggerStay === void 0 ? void 0 : _pair_colliderB_onTriggerStay.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionStay, _pair_colliderA1, _pair_colliderB_onCollisionStay, _pair_colliderB1;\n            (_pair_colliderA_onCollisionStay = (_pair_colliderA1 = pair.colliderA).onCollisionStay) === null || _pair_colliderA_onCollisionStay === void 0 ? void 0 : _pair_colliderA_onCollisionStay.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionStay = (_pair_colliderB1 = pair.colliderB).onCollisionStay) === null || _pair_colliderB_onCollisionStay === void 0 ? void 0 : _pair_colliderB_onCollisionStay.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionExit(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerExit, _pair_colliderA, _pair_colliderB_onTriggerExit, _pair_colliderB;\n            (_pair_colliderA_onTriggerExit = (_pair_colliderA = pair.colliderA).onTriggerExit) === null || _pair_colliderA_onTriggerExit === void 0 ? void 0 : _pair_colliderA_onTriggerExit.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerExit = (_pair_colliderB = pair.colliderB).onTriggerExit) === null || _pair_colliderB_onTriggerExit === void 0 ? void 0 : _pair_colliderB_onTriggerExit.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionExit, _pair_colliderA1, _pair_colliderB_onCollisionExit, _pair_colliderB1;\n            (_pair_colliderA_onCollisionExit = (_pair_colliderA1 = pair.colliderA).onCollisionExit) === null || _pair_colliderA_onCollisionExit === void 0 ? void 0 : _pair_colliderA_onCollisionExit.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionExit = (_pair_colliderB1 = pair.colliderB).onCollisionExit) === null || _pair_colliderB_onCollisionExit === void 0 ? void 0 : _pair_colliderB_onCollisionExit.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    resolveCollisions() {\n        // Resolve physical collisions (non-trigger)\n        for (const pair of this.collisionPairs){\n            if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n                continue; // Skip triggers\n            }\n            this.resolveCollision(pair);\n        }\n    }\n    resolveCollision(pair) {\n        const transformA = pair.entityA.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const transformB = pair.entityB.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const posA = transformA.getWorldPosition();\n        const posB = transformB.getWorldPosition();\n        // Calculate separation vector with safety checks\n        if (!posA || !posA.clone || !posB || !posB.clone) {\n            return;\n        }\n        const separation = posA.clone().sub(posB);\n        const distance = separation.length();\n        if (distance === 0) {\n            // Objects are at exact same position, separate along Y axis\n            separation.set(0, 1, 0);\n        } else {\n            separation.normalize();\n        }\n        // Calculate required separation distance\n        let requiredSeparation = 0;\n        if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"sphere\") {\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"cylinder\") {\n            // Player (sphere) vs Pillar (cylinder) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"cylinder\" && pair.colliderB.type === \"sphere\") {\n            // Pillar (cylinder) vs Player (sphere) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else {\n            // For other shapes, use a simple approximation\n            const radiusA = this.getApproximateRadius(pair.colliderA);\n            const radiusB = this.getApproximateRadius(pair.colliderB);\n            requiredSeparation = radiusA + radiusB;\n        }\n        const overlap = requiredSeparation - distance;\n        if (overlap > 0) {\n            // Debug logging for pillar collisions\n            if (pair.colliderA.layer === 2 && pair.colliderB.layer === 16 || pair.colliderA.layer === 16 && pair.colliderB.layer === 2) {}\n            // For static objects (like pillars), apply stronger separation to prevent penetration\n            let separationMultiplier = 1.0;\n            if (pair.colliderA.isStatic || pair.colliderB.isStatic) {\n                separationMultiplier = 1.1; // 10% extra separation for static objects\n            }\n            // Separate objects - use enhanced separation for static objects\n            const separationVector = separation.multiplyScalar(overlap * separationMultiplier);\n            // Check if entities have Movement components for intelligent separation distribution\n            const movementA = pair.entityA.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            const movementB = pair.entityB.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Determine separation distribution based on Movement components and static status\n            let separationFactorA = 0.5; // Default: split separation equally\n            let separationFactorB = 0.5;\n            if (pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // A is static, B moves - B takes all separation\n                separationFactorA = 0;\n                separationFactorB = 1;\n            } else if (!pair.colliderA.isStatic && pair.colliderB.isStatic) {\n                // B is static, A moves - A takes all separation\n                separationFactorA = 1;\n                separationFactorB = 0;\n            } else if (!pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // Both non-static - check for PVP scenario (both players)\n                const isPlayerA = pair.colliderA.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER;\n                const isPlayerB = pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER || pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.ENEMY;\n                if (isPlayerA && isPlayerB) {\n                    // PVP collision: check canMove property for fair collision resolution\n                    const canMoveA = movementA ? movementA.canMove : false;\n                    const canMoveB = movementB ? movementB.canMove : false;\n                    if (canMoveA && canMoveB) {\n                        // Both players can move - equal distribution for fair gameplay\n                        separationFactorA = 0.5;\n                        separationFactorB = 0.5;\n                    } else if (canMoveA && !canMoveB) {\n                        // Only A can move (local player), B is position-synced (remote player)\n                        separationFactorA = 1.0;\n                        separationFactorB = 0.0;\n                    } else if (!canMoveA && canMoveB) {\n                        // Only B can move (local player), A is position-synced (remote player)\n                        separationFactorA = 0.0;\n                        separationFactorB = 1.0;\n                    } else {\n                        // Neither can move - no separation (shouldn't happen in PVP)\n                        separationFactorA = 0.0;\n                        separationFactorB = 0.0;\n                    }\n                } else {\n                    // Non-PVP collision - distribute based on Movement components\n                    if (movementA && !movementB) {\n                        // A has Movement, B doesn't\n                        separationFactorA = 0.8;\n                        separationFactorB = 0.2;\n                    } else if (!movementA && movementB) {\n                        // B has Movement, A doesn't\n                        separationFactorA = 0.2;\n                        separationFactorB = 0.8;\n                    }\n                // If both have Movement or neither has Movement, use equal distribution (0.5, 0.5)\n                }\n            }\n            // Apply separation with calculated factors\n            if (separationFactorA > 0 && separationVector && separationVector.clone) {\n                const separationA = separationVector.clone().multiplyScalar(separationFactorA);\n                transformA.translate(separationA.x, separationA.y, separationA.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementA && pair.colliderB.isStatic && movementA.velocity && movementA.velocity.clone && separation && separation.clone) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementA.velocity.clone().projectOnVector(separation.clone().negate());\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementA.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n            if (separationFactorB > 0) {\n                const separationB = separationVector.clone().multiplyScalar(-separationFactorB);\n                transformB.translate(separationB.x, separationB.y, separationB.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementB && pair.colliderA.isStatic) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementB.velocity.clone().projectOnVector(separation);\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementB.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n        }\n    }\n    getApproximateRadius(collider) {\n        switch(collider.type){\n            case \"sphere\":\n                return collider.radius;\n            case \"box\":\n                return Math.max(collider.size.x, collider.size.y, collider.size.z) * 0.5;\n            case \"capsule\":\n            case \"cylinder\":\n                return Math.max(collider.radius, collider.height * 0.5);\n            default:\n                return 0.5;\n        }\n    }\n    // Utility methods for other systems\n    queryColliders(bounds) {\n        const entries = this.spatialHash.query(bounds);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersRadius(center, radius) {\n        const entries = this.spatialHash.queryRadius(center, radius);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersPoint(point) {\n        const entries = this.spatialHash.queryPoint(point);\n        return entries.map((entry)=>entry.entity);\n    }\n    getCollidersInLayer(layer, bounds) {\n        const candidates = bounds ? this.spatialHash.query(bounds) : Array.from(this.spatialHash[\"entityCells\"].keys()).map((id)=>{\n            const entries = this.spatialHash.query(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3().setFromCenterAndSize(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1000, 1000, 1000)));\n            return entries.find((e)=>e.entity.id === id);\n        }).filter(Boolean);\n        return candidates.filter((entry)=>{\n            const collider = entry.entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            return collider && collider.layer === layer;\n        }).map((entry)=>entry.entity);\n    }\n    // Performance and debugging\n    getPerformanceStats() {\n        return {\n            collisionChecks: this.collisionChecks,\n            actualCollisions: this.actualCollisions,\n            activeCollisions: this.activeCollisions.size,\n            spatialHashStats: this.spatialHash.getStats()\n        };\n    }\n    onEntityRemoved(entity) {\n        // Clean up spatial hash when entity is removed\n        this.spatialHash.remove(entity);\n        // Remove from active collisions\n        const keysToRemove = [];\n        this.activeCollisions.forEach((pair, key)=>{\n            if (pair.entityA.id === entity.id || pair.entityB.id === entity.id) {\n                keysToRemove.push(key);\n            }\n        });\n        for (const key of keysToRemove){\n            this.activeCollisions.delete(key);\n        }\n    }\n    onDisable() {\n        this.spatialHash.clear();\n        this.activeCollisions.clear();\n        this.collisionPairs.length = 0;\n    }\n    constructor(cellSize = 5){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider\n        ];\n        this.collisionPairs = [];\n        this.activeCollisions = new Map() // Track ongoing collisions\n        ;\n        // Performance tracking\n        this.lastUpdateTime = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        this.priority = 15; // Run before movement but after input\n        this.spatialHash = new _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__.SpatialHash(cellSize);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBQ1o7QUFDVDtBQUVVO0FBQ0Y7QUFDZ0I7QUFDbkI7QUFTM0MsTUFBTVEsd0JBQXdCTixzREFBYUE7SUFpQnpDTyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDhEQUE4RDtRQUM5RCxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtRQUN2QixJQUFJLENBQUNHLGdCQUFnQixDQUFDSDtRQUN0QixJQUFJLENBQUNJLHlCQUF5QjtRQUM5QixtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDeEI7SUFFT0MsWUFBWU4sUUFBa0IsRUFBRU8sY0FBc0IsRUFBUTtRQUNuRSw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDRixpQkFBaUI7SUFDeEI7SUFFUUgsa0JBQWtCRixRQUFrQixFQUFRO1FBQ2xELG9EQUFvRDtRQUNwRCxLQUFLLE1BQU1RLFVBQVVSLFNBQVU7WUFDN0IsTUFBTVMsWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixXQUFXSCxPQUFPRSxZQUFZLENBQUNmLDhEQUFRQTtZQUU3QyxJQUFJLENBQUNjLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUNOO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCRyxTQUFTSSxZQUFZLENBQUNOLFVBQVVPLGdCQUFnQjtZQUVoRCxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDSCxXQUFXLENBQUNkLE1BQU0sQ0FBQ1MsUUFBUUcsU0FBU00sTUFBTTtRQUNqRDtJQUNGO0lBRVFkLGlCQUFpQkgsUUFBa0IsRUFBUTtRQUNqRCxJQUFJLENBQUNrQixjQUFjLENBQUNDLE1BQU0sR0FBRztRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FB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RixNQUFNLENBQUNEO1FBQy9CO0lBQ0Y7SUFFT0UsWUFBa0I7UUFDdkIsSUFBSSxDQUFDckgsV0FBVyxDQUFDc0gsS0FBSztRQUN0QixJQUFJLENBQUNyRixnQkFBZ0IsQ0FBQ3FGLEtBQUs7UUFDM0IsSUFBSSxDQUFDakgsY0FBYyxDQUFDQyxNQUFNLEdBQUc7SUFDL0I7SUF2WkFpSCxZQUFZQyxXQUFtQixDQUFDLENBQUU7UUFDaEMsS0FBSzthQVhTQyxxQkFBcUI7WUFBQzdJLGdFQUFTQTtZQUFFRSw4REFBUUE7U0FBQzthQUVsRHVCLGlCQUFrQyxFQUFFO2FBQ3BDNEIsbUJBQW1CLElBQUlGLE1BQThCLDJCQUEyQjs7UUFFeEYsdUJBQXVCO2FBQ2YyRixpQkFBaUI7YUFDakJuSCxrQkFBa0I7YUFDbEJDLG1CQUFtQjtRQUl6QixJQUFJLENBQUNtSCxRQUFRLEdBQUcsSUFBSSxzQ0FBc0M7UUFDMUQsSUFBSSxDQUFDM0gsV0FBVyxHQUFHLElBQUloQiwyREFBV0EsQ0FBQ3dJO0lBQ3JDO0FBb1pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cz9jOWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbGxpc2lvbiBzeXN0ZW0gZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxuaW1wb3J0IHsgVmVjdG9yMywgQm94MyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBTcGF0aWFsSGFzaCB9IGZyb20gJ0AvdXRpbHMvU3BhdGlhbEhhc2gnO1xuXG5pbnRlcmZhY2UgQ29sbGlzaW9uUGFpciB7XG4gIGVudGl0eUE6IEVudGl0eTtcbiAgZW50aXR5QjogRW50aXR5O1xuICBjb2xsaWRlckE6IENvbGxpZGVyO1xuICBjb2xsaWRlckI6IENvbGxpZGVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBDb2xsaWRlcl07XG4gIHByaXZhdGUgc3BhdGlhbEhhc2g6IFNwYXRpYWxIYXNoO1xuICBwcml2YXRlIGNvbGxpc2lvblBhaXJzOiBDb2xsaXNpb25QYWlyW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7IC8vIFRyYWNrIG9uZ29pbmcgY29sbGlzaW9uc1xuICBcbiAgLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgY29sbGlzaW9uQ2hlY2tzID0gMDtcbiAgcHJpdmF0ZSBhY3R1YWxDb2xsaXNpb25zID0gMDtcblxuICBjb25zdHJ1Y3RvcihjZWxsU2l6ZTogbnVtYmVyID0gNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDE1OyAvLyBSdW4gYmVmb3JlIG1vdmVtZW50IGJ1dCBhZnRlciBpbnB1dFxuICAgIHRoaXMuc3BhdGlhbEhhc2ggPSBuZXcgU3BhdGlhbEhhc2goY2VsbFNpemUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB0cmlnZ2VyIGRldGVjdGlvbiBhbmQgYnJvYWQgcGhhc2VcbiAgICB0aGlzLnVwZGF0ZVNwYXRpYWxIYXNoKGVudGl0aWVzKTtcbiAgICB0aGlzLmRldGVjdENvbGxpc2lvbnMoZW50aXRpZXMpO1xuICAgIHRoaXMucHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcygpO1xuICAgIC8vIEFsc28gcmVzb2x2ZSBjb2xsaXNpb25zIGluIHVwZGF0ZSgpIHRvIGVuc3VyZSBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzIGNvbGxpc2lvbiByZXNwb25zZVxuICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3BhdGlhbEhhc2goZW50aXRpZXM6IEVudGl0eVtdKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaCB3aXRoIGN1cnJlbnQgZW50aXR5IHBvc2l0aW9uc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWNvbGxpZGVyLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xsaWRlciBib3VuZHNcbiAgICAgIGNvbGxpZGVyLnVwZGF0ZUJvdW5kcyh0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaFxuICAgICAgdGhpcy5zcGF0aWFsSGFzaC51cGRhdGUoZW50aXR5LCBjb2xsaWRlci5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0Q29sbGlzaW9ucyhlbnRpdGllczogRW50aXR5W10pOiB2b2lkIHtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb2xsaXNpb25DaGVja3MgPSAwO1xuICAgIHRoaXMuYWN0dWFsQ29sbGlzaW9ucyA9IDA7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRQYWlycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhY29sbGlkZXIuZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFF1ZXJ5IHNwYXRpYWwgaGFzaCBmb3IgcG90ZW50aWFsIGNvbGxpc2lvbnNcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KGNvbGxpZGVyLmJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJFbnRpdHkgPSBjYW5kaWRhdGUuZW50aXR5O1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IG90aGVyRW50aXR5LmlkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDcmVhdGUgdW5pcXVlIHBhaXIga2V5IChzbWFsbGVyIElEIGZpcnN0KVxuICAgICAgICBjb25zdCBwYWlyS2V5ID0gZW50aXR5LmlkIDwgb3RoZXJFbnRpdHkuaWQgPyBcbiAgICAgICAgICBgJHtlbnRpdHkuaWR9LSR7b3RoZXJFbnRpdHkuaWR9YCA6IFxuICAgICAgICAgIGAke290aGVyRW50aXR5LmlkfS0ke2VudGl0eS5pZH1gO1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBwYWlyXG4gICAgICAgIGlmIChwcm9jZXNzZWRQYWlycy5oYXMocGFpcktleSkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9jZXNzZWRQYWlycy5hZGQocGFpcktleSk7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJUcmFuc2Zvcm0gPSBvdGhlckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDb2xsaWRlciA9IG90aGVyRW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgICAgaWYgKCFvdGhlclRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhb3RoZXJDb2xsaWRlcj8uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgY29sbGlkZXJzIGNhbiBjb2xsaWRlXG4gICAgICAgIGlmICghY29sbGlkZXIuY2FuQ29sbGlkZVdpdGgob3RoZXJDb2xsaWRlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ2hlY2tzKys7XG5cbiAgICAgICAgLy8gUHJlY2lzZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIGlmIChjb2xsaWRlci5pbnRlcnNlY3RzKG90aGVyQ29sbGlkZXIsIHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCksIG90aGVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKSkpIHtcbiAgICAgICAgICB0aGlzLmFjdHVhbENvbGxpc2lvbnMrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgICAgIGlmICgoY29sbGlkZXIubGF5ZXIgPT09IDIgJiYgb3RoZXJDb2xsaWRlci5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgICAgICAoY29sbGlkZXIubGF5ZXIgPT09IDE2ICYmIG90aGVyQ29sbGlkZXIubGF5ZXIgPT09IDIpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhaXI6IENvbGxpc2lvblBhaXIgPSB7XG4gICAgICAgICAgICBlbnRpdHlBOiBlbnRpdHksXG4gICAgICAgICAgICBlbnRpdHlCOiBvdGhlckVudGl0eSxcbiAgICAgICAgICAgIGNvbGxpZGVyQTogY29sbGlkZXIsXG4gICAgICAgICAgICBjb2xsaWRlckI6IG90aGVyQ29sbGlkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7XG5cbiAgICAvLyBQcm9jZXNzIGN1cnJlbnQgY29sbGlzaW9uc1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLmNvbGxpc2lvblBhaXJzKSB7XG4gICAgICBjb25zdCBwYWlyS2V5ID0gcGFpci5lbnRpdHlBLmlkIDwgcGFpci5lbnRpdHlCLmlkID8gXG4gICAgICAgIGAke3BhaXIuZW50aXR5QS5pZH0tJHtwYWlyLmVudGl0eUIuaWR9YCA6IFxuICAgICAgICBgJHtwYWlyLmVudGl0eUIuaWR9LSR7cGFpci5lbnRpdHlBLmlkfWA7XG5cbiAgICAgIGN1cnJlbnRDb2xsaXNpb25zLnNldChwYWlyS2V5LCBwYWlyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5hY3RpdmVDb2xsaXNpb25zLmhhcyhwYWlyS2V5KSkge1xuICAgICAgICAvLyBOZXcgY29sbGlzaW9uIC0gdHJpZ2dlciBlbnRlciBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmdvaW5nIGNvbGxpc2lvbiAtIHRyaWdnZXIgc3RheSBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uU3RheShwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB0aGF0IGVuZGVkXG4gICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmZvckVhY2goKHBhaXIsIHBhaXJLZXkpID0+IHtcbiAgICAgIGlmICghY3VycmVudENvbGxpc2lvbnMuaGFzKHBhaXJLZXkpKSB7XG4gICAgICAgIC8vIENvbGxpc2lvbiBlbmRlZCAtIHRyaWdnZXIgZXhpdCBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRXhpdChwYWlyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucyA9IGN1cnJlbnRDb2xsaXNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25UcmlnZ2VyRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckVudGVyPy4ocGFpci5jb2xsaWRlckEsIHBhaXIuZW50aXR5QSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbGxpc2lvbiBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25TdGF5KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25TdGF5Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvblN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25FeGl0KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25FeGl0Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvbkV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb25zKCk6IHZvaWQge1xuICAgIC8vIFJlc29sdmUgcGh5c2ljYWwgY29sbGlzaW9ucyAobm9uLXRyaWdnZXIpXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuY29sbGlzaW9uUGFpcnMpIHtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRyaWdnZXJzXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwYWlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb24ocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybUEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IHRyYW5zZm9ybUIgPSBwYWlyLmVudGl0eUIuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuXG4gICAgY29uc3QgcG9zQSA9IHRyYW5zZm9ybUEuZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBvc0IgPSB0cmFuc2Zvcm1CLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgIC8vIENhbGN1bGF0ZSBzZXBhcmF0aW9uIHZlY3RvciB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICBpZiAoIXBvc0EgfHwgIXBvc0EuY2xvbmUgfHwgIXBvc0IgfHwgIXBvc0IuY2xvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VwYXJhdGlvbiA9IHBvc0EuY2xvbmUoKS5zdWIocG9zQik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzZXBhcmF0aW9uLmxlbmd0aCgpO1xuXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAvLyBPYmplY3RzIGFyZSBhdCBleGFjdCBzYW1lIHBvc2l0aW9uLCBzZXBhcmF0ZSBhbG9uZyBZIGF4aXNcbiAgICAgIHNlcGFyYXRpb24uc2V0KDAsIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXBhcmF0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBzZXBhcmF0aW9uIGRpc3RhbmNlXG4gICAgbGV0IHJlcXVpcmVkU2VwYXJhdGlvbiA9IDA7XG4gICAgXG4gICAgaWYgKHBhaXIuY29sbGlkZXJBLnR5cGUgPT09ICdzcGhlcmUnICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnc3BoZXJlJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnY3lsaW5kZXInKSB7XG4gICAgICAvLyBQbGF5ZXIgKHNwaGVyZSkgdnMgUGlsbGFyIChjeWxpbmRlcikgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnY3lsaW5kZXInICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICAvLyBQaWxsYXIgKGN5bGluZGVyKSB2cyBQbGF5ZXIgKHNwaGVyZSkgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdGhlciBzaGFwZXMsIHVzZSBhIHNpbXBsZSBhcHByb3hpbWF0aW9uXG4gICAgICBjb25zdCByYWRpdXNBID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQSk7XG4gICAgICBjb25zdCByYWRpdXNCID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQik7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGFwID0gcmVxdWlyZWRTZXBhcmF0aW9uIC0gZGlzdGFuY2U7XG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgaWYgKChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMiAmJiBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgIChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMTYgJiYgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IDIpKSB7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBzdGF0aWMgb2JqZWN0cyAobGlrZSBwaWxsYXJzKSwgYXBwbHkgc3Ryb25nZXIgc2VwYXJhdGlvbiB0byBwcmV2ZW50IHBlbmV0cmF0aW9uXG4gICAgICBsZXQgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjA7XG4gICAgICBpZiAocGFpci5jb2xsaWRlckEuaXNTdGF0aWMgfHwgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjE7IC8vIDEwJSBleHRyYSBzZXBhcmF0aW9uIGZvciBzdGF0aWMgb2JqZWN0c1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXBhcmF0ZSBvYmplY3RzIC0gdXNlIGVuaGFuY2VkIHNlcGFyYXRpb24gZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICBjb25zdCBzZXBhcmF0aW9uVmVjdG9yID0gc2VwYXJhdGlvbi5tdWx0aXBseVNjYWxhcihvdmVybGFwICogc2VwYXJhdGlvbk11bHRpcGxpZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdGllcyBoYXZlIE1vdmVtZW50IGNvbXBvbmVudHMgZm9yIGludGVsbGlnZW50IHNlcGFyYXRpb24gZGlzdHJpYnV0aW9uXG4gICAgICBjb25zdCBtb3ZlbWVudEEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGNvbnN0IG1vdmVtZW50QiA9IHBhaXIuZW50aXR5Qi5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgc2VwYXJhdGlvbiBkaXN0cmlidXRpb24gYmFzZWQgb24gTW92ZW1lbnQgY29tcG9uZW50cyBhbmQgc3RhdGljIHN0YXR1c1xuICAgICAgbGV0IHNlcGFyYXRpb25GYWN0b3JBID0gMC41OyAvLyBEZWZhdWx0OiBzcGxpdCBzZXBhcmF0aW9uIGVxdWFsbHlcbiAgICAgIGxldCBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuNTtcbiAgICAgIFxuICAgICAgaWYgKHBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmICFwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBBIGlzIHN0YXRpYywgQiBtb3ZlcyAtIEIgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBCIGlzIHN0YXRpYywgQSBtb3ZlcyAtIEEgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAxO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiAhcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gQm90aCBub24tc3RhdGljIC0gY2hlY2sgZm9yIFBWUCBzY2VuYXJpbyAoYm90aCBwbGF5ZXJzKVxuICAgICAgICBjb25zdCBpc1BsYXllckEgPSBwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSO1xuICAgICAgICBjb25zdCBpc1BsYXllckIgPSBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHx8IHBhaXIuY29sbGlkZXJCLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1BsYXllckEgJiYgaXNQbGF5ZXJCKSB7XG4gICAgICAgICAgLy8gUFZQIGNvbGxpc2lvbjogY2hlY2sgY2FuTW92ZSBwcm9wZXJ0eSBmb3IgZmFpciBjb2xsaXNpb24gcmVzb2x1dGlvblxuICAgICAgICAgIGNvbnN0IGNhbk1vdmVBID0gbW92ZW1lbnRBID8gbW92ZW1lbnRBLmNhbk1vdmUgOiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjYW5Nb3ZlQiA9IG1vdmVtZW50QiA/IG1vdmVtZW50Qi5jYW5Nb3ZlIDogZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBsYXllcnMgY2FuIG1vdmUgLSBlcXVhbCBkaXN0cmlidXRpb24gZm9yIGZhaXIgZ2FtZXBsYXlcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC41O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5Nb3ZlQSAmJiAhY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgQSBjYW4gbW92ZSAobG9jYWwgcGxheWVyKSwgQiBpcyBwb3NpdGlvbi1zeW5jZWQgKHJlbW90ZSBwbGF5ZXIpXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDEuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC4wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBPbmx5IEIgY2FuIG1vdmUgKGxvY2FsIHBsYXllciksIEEgaXMgcG9zaXRpb24tc3luY2VkIChyZW1vdGUgcGxheWVyKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDEuMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVpdGhlciBjYW4gbW92ZSAtIG5vIHNlcGFyYXRpb24gKHNob3VsZG4ndCBoYXBwZW4gaW4gUFZQKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLVBWUCBjb2xsaXNpb24gLSBkaXN0cmlidXRlIGJhc2VkIG9uIE1vdmVtZW50IGNvbXBvbmVudHNcbiAgICAgICAgICBpZiAobW92ZW1lbnRBICYmICFtb3ZlbWVudEIpIHtcbiAgICAgICAgICAgIC8vIEEgaGFzIE1vdmVtZW50LCBCIGRvZXNuJ3RcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC44O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjI7XG4gICAgICAgICAgfSBlbHNlIGlmICghbW92ZW1lbnRBICYmIG1vdmVtZW50Qikge1xuICAgICAgICAgICAgLy8gQiBoYXMgTW92ZW1lbnQsIEEgZG9lc24ndFxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjI7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYm90aCBoYXZlIE1vdmVtZW50IG9yIG5laXRoZXIgaGFzIE1vdmVtZW50LCB1c2UgZXF1YWwgZGlzdHJpYnV0aW9uICgwLjUsIDAuNSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBzZXBhcmF0aW9uIHdpdGggY2FsY3VsYXRlZCBmYWN0b3JzXG4gICAgICBpZiAoc2VwYXJhdGlvbkZhY3RvckEgPiAwICYmIHNlcGFyYXRpb25WZWN0b3IgJiYgc2VwYXJhdGlvblZlY3Rvci5jbG9uZSkge1xuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQSA9IHNlcGFyYXRpb25WZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzZXBhcmF0aW9uRmFjdG9yQSk7XG4gICAgICAgIHRyYW5zZm9ybUEudHJhbnNsYXRlKHNlcGFyYXRpb25BLngsIHNlcGFyYXRpb25BLnksIHNlcGFyYXRpb25BLnopO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBzdG9wIG1vdmVtZW50IHZlbG9jaXR5IGZvciBwbGF5ZXIgd2hlbiBoaXR0aW5nIHN0YXRpYyBvYmplY3RzXG4gICAgICAgIGlmIChtb3ZlbWVudEEgJiYgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMgJiYgbW92ZW1lbnRBLnZlbG9jaXR5ICYmIG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSAmJiBzZXBhcmF0aW9uICYmIHNlcGFyYXRpb24uY2xvbmUpIHtcbiAgICAgICAgICAvLyBQcm9qZWN0IHZlbG9jaXR5IHRvIHJlbW92ZSBjb21wb25lbnQgdG93YXJkcyB0aGUgc3RhdGljIG9iamVjdFxuICAgICAgICAgIGNvbnN0IHZlbG9jaXR5VG93YXJkc1N0YXRpYyA9IG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSgpLnByb2plY3RPblZlY3RvcihzZXBhcmF0aW9uLmNsb25lKCkubmVnYXRlKCkpO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEEudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzZXBhcmF0aW9uRmFjdG9yQiA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbkIgPSBzZXBhcmF0aW9uVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLXNlcGFyYXRpb25GYWN0b3JCKTtcbiAgICAgICAgdHJhbnNmb3JtQi50cmFuc2xhdGUoc2VwYXJhdGlvbkIueCwgc2VwYXJhdGlvbkIueSwgc2VwYXJhdGlvbkIueik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHN0b3AgbW92ZW1lbnQgdmVsb2NpdHkgZm9yIHBsYXllciB3aGVuIGhpdHRpbmcgc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKG1vdmVtZW50QiAmJiBwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYykge1xuICAgICAgICAgIC8vIFByb2plY3QgdmVsb2NpdHkgdG8gcmVtb3ZlIGNvbXBvbmVudCB0b3dhcmRzIHRoZSBzdGF0aWMgb2JqZWN0XG4gICAgICAgICAgY29uc3QgdmVsb2NpdHlUb3dhcmRzU3RhdGljID0gbW92ZW1lbnRCLnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHNlcGFyYXRpb24pO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEIudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcHByb3hpbWF0ZVJhZGl1cyhjb2xsaWRlcjogQ29sbGlkZXIpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoY29sbGlkZXIudHlwZSkge1xuICAgICAgY2FzZSAnc3BoZXJlJzpcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyLnJhZGl1cztcbiAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjb2xsaWRlci5zaXplLngsIGNvbGxpZGVyLnNpemUueSwgY29sbGlkZXIuc2l6ZS56KSAqIDAuNTtcbiAgICAgIGNhc2UgJ2NhcHN1bGUnOlxuICAgICAgY2FzZSAnY3lsaW5kZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sbGlkZXIucmFkaXVzLCBjb2xsaWRlci5oZWlnaHQgKiAwLjUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG90aGVyIHN5c3RlbXNcbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzKGJvdW5kczogQm94Myk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShib3VuZHMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUmFkaXVzKGNlbnRlcjogVmVjdG9yMywgcmFkaXVzOiBudW1iZXIpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlSYWRpdXMoY2VudGVyLCByYWRpdXMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUG9pbnQocG9pbnQ6IFZlY3RvcjMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlQb2ludChwb2ludCk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sbGlkZXJzSW5MYXllcihsYXllcjogQ29sbGlzaW9uTGF5ZXIsIGJvdW5kcz86IEJveDMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGJvdW5kcyA/IHRoaXMuc3BhdGlhbEhhc2gucXVlcnkoYm91bmRzKSA6IEFycmF5LmZyb20odGhpcy5zcGF0aWFsSGFzaFsnZW50aXR5Q2VsbHMnXS5rZXlzKCkpLm1hcChpZCA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShuZXcgQm94MygpLnNldEZyb21DZW50ZXJBbmRTaXplKG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKDEwMDAsIDEwMDAsIDEwMDApKSk7XG4gICAgICByZXR1cm4gZW50cmllcy5maW5kKGUgPT4gZS5lbnRpdHkuaWQgPT09IGlkKTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgYW55W107XG5cbiAgICByZXR1cm4gY2FuZGlkYXRlc1xuICAgICAgLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50cnkuZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIHJldHVybiBjb2xsaWRlciAmJiBjb2xsaWRlci5sYXllciA9PT0gbGF5ZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgLy8gUGVyZm9ybWFuY2UgYW5kIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7XG4gICAgY29sbGlzaW9uQ2hlY2tzOiBudW1iZXI7XG4gICAgYWN0dWFsQ29sbGlzaW9uczogbnVtYmVyO1xuICAgIGFjdGl2ZUNvbGxpc2lvbnM6IG51bWJlcjtcbiAgICBzcGF0aWFsSGFzaFN0YXRzOiBhbnk7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xsaXNpb25DaGVja3M6IHRoaXMuY29sbGlzaW9uQ2hlY2tzLFxuICAgICAgYWN0dWFsQ29sbGlzaW9uczogdGhpcy5hY3R1YWxDb2xsaXNpb25zLFxuICAgICAgYWN0aXZlQ29sbGlzaW9uczogdGhpcy5hY3RpdmVDb2xsaXNpb25zLnNpemUsXG4gICAgICBzcGF0aWFsSGFzaFN0YXRzOiB0aGlzLnNwYXRpYWxIYXNoLmdldFN0YXRzKClcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIHNwYXRpYWwgaGFzaCB3aGVuIGVudGl0eSBpcyByZW1vdmVkXG4gICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIGNvbnN0IGtleXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuZm9yRWFjaCgocGFpciwga2V5KSA9PiB7XG4gICAgICBpZiAocGFpci5lbnRpdHlBLmlkID09PSBlbnRpdHkuaWQgfHwgcGFpci5lbnRpdHlCLmlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuc3BhdGlhbEhhc2guY2xlYXIoKTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJTcGF0aWFsSGFzaCIsIkNvbGxpc2lvblN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidXBkYXRlU3BhdGlhbEhhc2giLCJkZXRlY3RDb2xsaXNpb25zIiwicHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcyIsInJlc29sdmVDb2xsaXNpb25zIiwiZml4ZWRVcGRhdGUiLCJmaXhlZERlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsImNvbGxpZGVyIiwiZW5hYmxlZCIsInNwYXRpYWxIYXNoIiwicmVtb3ZlIiwidXBkYXRlQm91bmRzIiwiZ2V0V29ybGRQb3NpdGlvbiIsImJvdW5kcyIsImNvbGxpc2lvblBhaXJzIiwibGVuZ3RoIiwiY29sbGlzaW9uQ2hlY2tzIiwiYWN0dWFsQ29sbGlzaW9ucyIsInByb2Nlc3NlZFBhaXJzIiwiU2V0IiwiY2FuZGlkYXRlcyIsInF1ZXJ5IiwiY2FuZGlkYXRlIiwib3RoZXJFbnRpdHkiLCJpZCIsInBhaXJLZXkiLCJoYXMiLCJhZGQiLCJvdGhlclRyYW5zZm9ybSIsIm90aGVyQ29sbGlkZXIiLCJjYW5Db2xsaWRlV2l0aCIsImludGVyc2VjdHMiLCJsYXllciIsInBhaXIiLCJlbnRpdHlBIiwiZW50aXR5QiIsImNvbGxpZGVyQSIsImNvbGxpZGVyQiIsInB1c2giLCJjdXJyZW50Q29sbGlzaW9ucyIsIk1hcCIsInNldCIsImFjdGl2ZUNvbGxpc2lvbnMiLCJ0cmlnZ2VyQ29sbGlzaW9uRW50ZXIiLCJ0cmlnZ2VyQ29sbGlzaW9uU3RheSIsImZvckVhY2giLCJ0cmlnZ2VyQ29sbGlzaW9uRXhpdCIsImlzVHJpZ2dlciIsIm9uVHJpZ2dlckVudGVyIiwib25Db2xsaXNpb25FbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvbkNvbGxpc2lvblN0YXkiLCJvblRyaWdnZXJFeGl0Iiwib25Db2xsaXNpb25FeGl0IiwicmVzb2x2ZUNvbGxpc2lvbiIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwicG9zQSIsInBvc0IiLCJjbG9uZSIsInNlcGFyYXRpb24iLCJzdWIiLCJkaXN0YW5jZSIsIm5vcm1hbGl6ZSIsInJlcXVpcmVkU2VwYXJhdGlvbiIsInR5cGUiLCJyYWRpdXMiLCJyYWRpdXNBIiwiZ2V0QXBwcm94aW1hdGVSYWRpdXMiLCJyYWRpdXNCIiwib3ZlcmxhcCIsInNlcGFyYXRpb25NdWx0aXBsaWVyIiwiaXNTdGF0aWMiLCJzZXBhcmF0aW9uVmVjdG9yIiwibXVsdGlwbHlTY2FsYXIiLCJtb3ZlbWVudEEiLCJtb3ZlbWVudEIiLCJzZXBhcmF0aW9uRmFjdG9yQSIsInNlcGFyYXRpb25GYWN0b3JCIiwiaXNQbGF5ZXJBIiwiUExBWUVSIiwiaXNQbGF5ZXJCIiwiRU5FTVkiLCJjYW5Nb3ZlQSIsImNhbk1vdmUiLCJjYW5Nb3ZlQiIsInNlcGFyYXRpb25BIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwidmVsb2NpdHkiLCJ2ZWxvY2l0eVRvd2FyZHNTdGF0aWMiLCJwcm9qZWN0T25WZWN0b3IiLCJuZWdhdGUiLCJzZXBhcmF0aW9uQiIsIk1hdGgiLCJtYXgiLCJzaXplIiwiaGVpZ2h0IiwicXVlcnlDb2xsaWRlcnMiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJxdWVyeUNvbGxpZGVyc1JhZGl1cyIsImNlbnRlciIsInF1ZXJ5UmFkaXVzIiwicXVlcnlDb2xsaWRlcnNQb2ludCIsInBvaW50IiwicXVlcnlQb2ludCIsImdldENvbGxpZGVyc0luTGF5ZXIiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJmaW5kIiwiZSIsImZpbHRlciIsIkJvb2xlYW4iLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwic3BhdGlhbEhhc2hTdGF0cyIsImdldFN0YXRzIiwib25FbnRpdHlSZW1vdmVkIiwia2V5c1RvUmVtb3ZlIiwia2V5IiwiZGVsZXRlIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsImNlbGxTaXplIiwicmVxdWlyZWRDb21wb25lbnRzIiwibGFzdFVwZGF0ZVRpbWUiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CollisionSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CombatSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CombatSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CombatSystem: function() { return /* binding */ CombatSystem; }\n/* harmony export */ });\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/core/DamageCalculator */ \"(app-pages-browser)/./src/core/DamageCalculator.ts\");\n/* harmony import */ var _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/DamageNumberManager */ \"(app-pages-browser)/./src/utils/DamageNumberManager.ts\");\n// Combat system for handling damage, healing, and combat mechanics\n\n\n\n\n\n\n\n\n\nclass CombatSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_0__.System {\n    // Throttled logging to reduce spam\n    shouldLogDamage() {\n        const now = Date.now();\n        if (now - this.lastDamageLogTime > this.damageLogThrottle) {\n            this.lastDamageLogTime = now;\n            return true;\n        }\n        return false;\n    }\n    // Set callback for routing enemy damage to multiplayer server\n    setEnemyDamageCallback(callback) {\n        this.onEnemyDamageCallback = callback;\n    }\n    // Set callback for routing player damage to multiplayer server (PVP)\n    setPlayerDamageCallback(callback) {\n        this.onPlayerDamageCallback = callback;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000;\n        // Update health components (regeneration, invulnerability timers)\n        this.updateHealthComponents(entities, deltaTime, currentTime);\n        // Process damage queue\n        this.processDamageQueue(currentTime);\n        // Process heal queue\n        this.processHealQueue(currentTime);\n        // Handle death and respawn\n        this.handleDeathAndRespawn(entities, currentTime);\n        // Cleanup old damage numbers\n        this.damageNumberManager.cleanup();\n        // Clear processed queues\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n    }\n    updateHealthComponents(entities, deltaTime, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            // Skip if required Health component is missing\n            if (!health || !health.enabled) continue;\n            // Update health component (handles regeneration and invulnerability)\n            health.update(deltaTime, currentTime);\n            // Update shield component if it exists\n            const shield = entity.getComponent(_ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__.Shield);\n            if (shield) {\n                shield.update(deltaTime);\n            }\n            // Update freeze status for enemies\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (enemy) {\n                enemy.updateFreezeStatus(currentTime);\n            }\n        }\n    }\n    processDamageQueue(currentTime) {\n        for (const damageEvent of this.damageQueue){\n            this.applyDamage(damageEvent, currentTime);\n        }\n    }\n    processHealQueue(currentTime) {\n        for (const healEvent of this.healQueue){\n            this.applyHealing(healEvent, currentTime);\n        }\n    }\n    applyDamage(damageEvent, currentTime) {\n        const { target, damage: baseDamage, source, damageType } = damageEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        // Debug: Log all damage events for charge damage\n        if (damageType === \"charge\") {\n            const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            const summonedUnitComponent = target.getComponent(SummonedUnit);\n            const summonedUnit = summonedUnitComponent ? summonedUnitComponent : null;\n            const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : summonedUnit ? \"SummonedUnit(\".concat(summonedUnit.getDisplayName(), \")\") : \"Player(\".concat(target.id, \")\");\n        }\n        // Check if target is an enemy - if so, route damage through multiplayer\n        const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy && this.onEnemyDamageCallback) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route enemy damage through multiplayer server instead of applying locally\n            // console.log(`🌐 Routing ${actualDamage} damage to enemy ${target.id} through multiplayer server`);\n            this.onEnemyDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            // Log for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            return; // Don't apply damage locally for enemies\n        }\n        // Check if target is a summoned unit - treat like enemy (apply damage locally)\n        const summonedUnitComponent = target.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            // Cast to proper type\n            const summonedUnit = summonedUnitComponent;\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Apply damage locally (pass entity so Health can use Shield component)\n            const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n            if (damageDealt) {\n                this.totalDamageDealt += actualDamage;\n                // Create damage number at target position\n                const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n                if (transform) {\n                    const position = transform.getWorldPosition();\n                    // Only create damage number if position is valid\n                    if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                        // Offset slightly above the target\n                        position.y += 2;\n                        this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType || \"melee\");\n                    }\n                }\n                // Log for debugging (throttled to reduce spam)\n                if (this.shouldLogDamage()) {\n                    const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                    const targetName = summonedUnit.getDisplayName();\n                    const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                // console.log(`⚔️ ${sourceName} dealt ${actualDamage}${critText} ${damageType || 'damage'} to ${targetName} (${health.currentHealth}/${health.maxHealth} HP)`);\n                }\n                // Check if target died\n                if (health.isDead) {\n                    this.handleEntityDeath(target, source, currentTime);\n                }\n                // Trigger damage effects\n                this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n            }\n            return; // Damage applied locally for summoned units\n        }\n        // Check if target is a player in PVP mode - if so, route damage through multiplayer\n        // Also prevent self-damage in PVP (source hitting themselves)\n        if (!enemy && this.onPlayerDamageCallback && source && source.id !== target.id) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            // Route player damage through multiplayer server for PVP (let receiver handle shields)\n            if (this.shouldLogDamage()) {\n            // console.log(`⚔️ Routing ${damageResult.damage} PVP ${damageType || 'damage'} to player ${target.id} through multiplayer server`);\n            }\n            this.onPlayerDamageCallback(target.id.toString(), damageResult.damage, damageType); // Send damage, let receiver handle shields\n            // Create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    position.y += 1.5;\n                    // Add slight position offset for delayed damage (like sabres right hit) to prevent overlap\n                    if (damageType === \"sabres_right\") {\n                        position.x += 0.3; // Slight offset to the right for the right sabre\n                    }\n                    this.damageNumberManager.addDamageNumber(damageResult.damage, damageResult.isCritical, position, damageType || \"pvp\");\n                } else {\n                // console.warn('⚠️ Skipping PVP damage number creation - invalid position:', position);\n                }\n            }\n            // Log for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Player \".concat(source.id) : \"Unknown\";\n                const targetName = \"Player \".concat(target.id);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            // console.log(`⚔️ ${sourceName} dealt ${damageResult.damage}${critText} PVP ${damageType || 'damage'} to ${targetName} (routed to server)`);\n            }\n            return; // Don't apply damage locally for PVP players\n        }\n        // For non-enemies and non-summoned units (like players in non-PVP mode), apply damage locally as before\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n        const actualDamage = damageResult.damage;\n        // Apply damage (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    // Offset slightly above the target\n                    position.y += 3;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                } else {\n                // console.warn('⚠️ Skipping damage number creation - invalid position:', position);\n                }\n            }\n            // Log damage for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                const targetName = this.getEntityDisplayName(target);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            // console.log(`💥 ${sourceName} dealt ${actualDamage}${critText} ${damageType || 'damage'} to ${targetName} (${health.currentHealth}/${health.maxHealth} HP)`);\n            }\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n    }\n    applyHealing(healEvent, currentTime) {\n        const { target, amount, source } = healEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Apply healing\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            // Log healing for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            // console.log(`💚 ${sourceName} healed ${targetName} for ${amount} HP (${health.currentHealth}/${health.maxHealth} HP)`);\n            // Trigger healing effects\n            this.triggerHealingEffects(target, amount, source);\n        }\n    }\n    handleEntityDeath(entity, killer, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            enemy.die(currentTime || Date.now() / 1000);\n            this.enemiesKilled++;\n            // console.log(`💀 ${enemy.getDisplayName()} has been defeated!`);\n            // Award experience to killer if it's a player\n            if (killer) {\n                this.awardExperience(killer, enemy.experienceReward);\n            }\n            // Trigger death effects\n            this.triggerDeathEffects(entity, killer);\n        }\n        // Handle SummonedUnit death\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        const summonedUnitComponent = entity.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            const summonedUnit = summonedUnitComponent;\n            summonedUnit.die(currentTime || Date.now() / 1000);\n            // console.log(`💀 ${summonedUnit.getDisplayName()} has been defeated!`);\n            // Trigger death effects for summoned units\n            this.triggerDeathEffects(entity, killer);\n        }\n        this.deadEntities.push(entity);\n    }\n    handleDeathAndRespawn(entities, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (!health || !enemy) continue;\n            // Handle respawn for enemies\n            if (enemy.isDead && enemy.canRespawnNow(currentTime)) {\n                this.respawnEnemy(entity, enemy, health);\n            }\n        }\n    }\n    respawnEnemy(entity, enemy, health) {\n        // Respawn the enemy\n        enemy.respawn();\n        health.revive();\n        // console.log(`🔄 ${enemy.getDisplayName()} has respawned!`);\n        // Trigger respawn effects\n        this.triggerRespawnEffects(entity);\n    }\n    triggerDamageEffects(target, damage, source, damageType, isCritical) {\n        // This can be extended to trigger particle effects, screen shake, etc.\n        // For now, we'll just handle basic effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            // Could trigger damage number popup, blood effects, etc.\n            // For now, just log the position where damage occurred\n            const critText = isCritical ? \" (CRITICAL)\" : \"\";\n        // console.log(`🎯 Damage effect${critText} at position:`, transform.position);\n        }\n        // Handle special projectile effects\n        if (damageType === \"projectile\" && source) {\n            var _sourceRenderer_mesh_userData, _sourceRenderer_mesh;\n            const sourceRenderer = source.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            if (sourceRenderer === null || sourceRenderer === void 0 ? void 0 : (_sourceRenderer_mesh = sourceRenderer.mesh) === null || _sourceRenderer_mesh === void 0 ? void 0 : (_sourceRenderer_mesh_userData = _sourceRenderer_mesh.userData) === null || _sourceRenderer_mesh_userData === void 0 ? void 0 : _sourceRenderer_mesh_userData.isBarrageArrow) {\n                // console.log(`🏹 Barrage arrow hit detected, applying slow effect to target ${target.id}`);\n                const targetMovement = target.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n                if (targetMovement) {\n                    targetMovement.slow(5000, 0.5); // 5 seconds, 50% speed\n                // console.log(`🐌 Applied 50% slow for 5 seconds to target ${target.id}`);\n                }\n            }\n        }\n    }\n    triggerHealingEffects(target, amount, source) {\n        // This can be extended to trigger healing particle effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(`✨ Healing effect at position:`, transform.position);\n        }\n    }\n    triggerDeathEffects(entity, killer) {\n        // This can be extended to trigger death animations, loot drops, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(`💀 Death effect at position:`, transform.position);\n        }\n    }\n    triggerRespawnEffects(entity) {\n        // This can be extended to trigger respawn animations, effects, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(`🌟 Respawn effect at position:`, transform.position);\n        }\n    }\n    awardExperience(entity, experience) {\n    // This would integrate with a progression system\n    // console.log(`⭐ Entity ${entity.id} gained ${experience} experience!`);\n    }\n    getEntityDisplayName(entity) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            return enemy.getDisplayName();\n        }\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        const summonedUnitComponent = entity.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            const summonedUnit = summonedUnitComponent;\n            return summonedUnit.getDisplayName();\n        }\n        // Could check for other components that provide names\n        return \"Entity \".concat(entity.id);\n    }\n    // Public API for other systems to queue damage and healing\n    queueDamage(target, damage, source, damageType) {\n        this.damageQueue.push({\n            target,\n            damage,\n            source,\n            damageType,\n            timestamp: Date.now() / 1000\n        });\n    }\n    queueHealing(target, amount, source) {\n        this.healQueue.push({\n            target,\n            amount,\n            source,\n            timestamp: Date.now() / 1000\n        });\n    }\n    // Immediate damage/healing (bypasses queue)\n    dealDamageImmediate(target, damage, source, damageType) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        // Calculate actual damage with critical hit mechanics\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n        const actualDamage = damageResult.damage;\n        const currentTime = Date.now() / 1000;\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Offset slightly above the target\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n        return damageDealt;\n    }\n    healImmediate(target, amount, source) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            this.triggerHealingEffects(target, amount, source);\n        }\n        return healingDone;\n    }\n    // Utility methods\n    isEntityDead(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.isDead : false;\n    }\n    getEntityHealthRatio(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.getHealthRatio() : 0;\n    }\n    canEntityTakeDamage(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? !health.isDead && !health.isInvulnerable : false;\n    }\n    // Statistics and debugging\n    getCombatStats() {\n        return {\n            totalDamageDealt: this.totalDamageDealt,\n            totalHealingDone: this.totalHealingDone,\n            enemiesKilled: this.enemiesKilled,\n            queuedDamageEvents: this.damageQueue.length,\n            queuedHealEvents: this.healQueue.length\n        };\n    }\n    resetStats() {\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n    }\n    // Damage numbers management\n    getDamageNumbers() {\n        return this.damageNumberManager.getDamageNumbers();\n    }\n    removeDamageNumber(id) {\n        this.damageNumberManager.removeDamageNumber(id);\n    }\n    onDisable() {\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n        this.damageNumberManager.clear();\n        this.resetStats();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health\n        ];\n        this.damageQueue = [];\n        this.healQueue = [];\n        this.deadEntities = [];\n        // Combat statistics\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n        // Log throttling to reduce spam\n        this.lastDamageLogTime = 0;\n        this.damageLogThrottle = 100 // Only log every 100ms\n        ;\n        this.world = world;\n        this.damageNumberManager = new _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__.DamageNumberManager();\n        this.priority = 25; // Run after collision detection\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQW1FO0FBQzdCO0FBRVc7QUFDQTtBQUNGO0FBQ1E7QUFDRjtBQUNBO0FBRW1CO0FBQ047QUFpQjNELE1BQU1TLHFCQUFxQlQsK0NBQU1BO0lBOEJ0QyxtQ0FBbUM7SUFDM0JVLGtCQUEyQjtRQUNqQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLElBQUlBLE1BQU0sSUFBSSxDQUFDRSxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQixFQUFFO1lBQ3pELElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdGO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDhEQUE4RDtJQUN2REksdUJBQXVCQyxRQUFtRCxFQUFRO1FBQ3ZGLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRUEscUVBQXFFO0lBQzlERSx3QkFBd0JGLFFBQXlFLEVBQVE7UUFDOUcsSUFBSSxDQUFDRyxzQkFBc0IsR0FBR0g7SUFDaEM7SUFFT0ksT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxNQUFNQyxjQUFjWCxLQUFLRCxHQUFHLEtBQUs7UUFFakMsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ2Esc0JBQXNCLENBQUNILFVBQVVDLFdBQVdDO1FBRWpELHVCQUF1QjtRQUN2QixJQUFJLENBQUNFLGtCQUFrQixDQUFDRjtRQUV4QixxQkFBcUI7UUFDckIsSUFBSSxDQUFDRyxnQkFBZ0IsQ0FBQ0g7UUFFdEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0kscUJBQXFCLENBQUNOLFVBQVVFO1FBRXJDLDZCQUE2QjtRQUM3QixJQUFJLENBQUNLLG1CQUFtQixDQUFDQyxPQUFPO1FBRWhDLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxN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bUJBQW1CLENBQUN5RixnQkFBZ0I7SUFDbEQ7SUFFT0MsbUJBQW1COUQsRUFBVSxFQUFRO1FBQzFDLElBQUksQ0FBQzVCLG1CQUFtQixDQUFDMEYsa0JBQWtCLENBQUM5RDtJQUM5QztJQUVPK0QsWUFBa0I7UUFDdkIsSUFBSSxDQUFDekYsV0FBVyxDQUFDQyxNQUFNLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxTQUFTLENBQUNELE1BQU0sR0FBRztRQUN4QixJQUFJLENBQUNFLFlBQVksQ0FBQ0YsTUFBTSxHQUFHO1FBQzNCLElBQUksQ0FBQ0gsbUJBQW1CLENBQUM0RixLQUFLO1FBQzlCLElBQUksQ0FBQ0osVUFBVTtJQUNqQjtJQXRrQkFLLFlBQVlDLEtBQVksQ0FBRTtRQUN4QixLQUFLO2FBdkJTQyxxQkFBcUI7WUFBQzFILDBEQUFNQTtTQUFDO2FBRXJDNkIsY0FBNkIsRUFBRTthQUMvQkUsWUFBeUIsRUFBRTthQUMzQkMsZUFBeUIsRUFBRTtRQUduQyxvQkFBb0I7YUFDWnVDLG1CQUFtQjthQUNuQlUsbUJBQW1CO2FBQ25CSSxnQkFBZ0I7UUFReEIsZ0NBQWdDO2FBQ3hCekUsb0JBQW9CO2FBQ3BCQyxvQkFBb0IsSUFBSyx1QkFBdUI7O1FBSXRELElBQUksQ0FBQzRHLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUM5RixtQkFBbUIsR0FBRyxJQUFJcEIsMkVBQW1CQTtRQUNsRCxJQUFJLENBQUNvSCxRQUFRLEdBQUcsSUFBSSxnQ0FBZ0M7SUFDdEQ7QUFra0JGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cz9hNjBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbWJhdCBzeXN0ZW0gZm9yIGhhbmRsaW5nIGRhbWFnZSwgaGVhbGluZywgYW5kIGNvbWJhdCBtZWNoYW5pY3NcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgSGVhbHRoIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9IZWFsdGgnO1xuaW1wb3J0IHsgU2hpZWxkIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9TaGllbGQnO1xuaW1wb3J0IHsgRW5lbXkgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0VuZW15JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tICdAL2Vjcy9Xb3JsZCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVEYW1hZ2UsIERhbWFnZVJlc3VsdCB9IGZyb20gJ0AvY29yZS9EYW1hZ2VDYWxjdWxhdG9yJztcbmltcG9ydCB7IERhbWFnZU51bWJlck1hbmFnZXIgfSBmcm9tICdAL3V0aWxzL0RhbWFnZU51bWJlck1hbmFnZXInO1xuXG5pbnRlcmZhY2UgRGFtYWdlRXZlbnQge1xuICB0YXJnZXQ6IEVudGl0eTtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIHNvdXJjZT86IEVudGl0eTtcbiAgZGFtYWdlVHlwZT86IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBIZWFsRXZlbnQge1xuICB0YXJnZXQ6IEVudGl0eTtcbiAgYW1vdW50OiBudW1iZXI7XG4gIHNvdXJjZT86IEVudGl0eTtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDb21iYXRTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW0hlYWx0aF07XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIGRhbWFnZVF1ZXVlOiBEYW1hZ2VFdmVudFtdID0gW107XG4gIHByaXZhdGUgaGVhbFF1ZXVlOiBIZWFsRXZlbnRbXSA9IFtdO1xuICBwcml2YXRlIGRlYWRFbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgcHJpdmF0ZSBkYW1hZ2VOdW1iZXJNYW5hZ2VyOiBEYW1hZ2VOdW1iZXJNYW5hZ2VyO1xuICBcbiAgLy8gQ29tYmF0IHN0YXRpc3RpY3NcbiAgcHJpdmF0ZSB0b3RhbERhbWFnZURlYWx0ID0gMDtcbiAgcHJpdmF0ZSB0b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgcHJpdmF0ZSBlbmVtaWVzS2lsbGVkID0gMDtcblxuICAvLyBNdWx0aXBsYXllciBkYW1hZ2UgY2FsbGJhY2sgZm9yIHJvdXRpbmcgZW5lbXkgZGFtYWdlIHRvIHNlcnZlclxuICBwcml2YXRlIG9uRW5lbXlEYW1hZ2VDYWxsYmFjaz86IChlbmVteUlkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkO1xuICBcbiAgLy8gUFZQIGRhbWFnZSBjYWxsYmFjayBmb3Igcm91dGluZyBwbGF5ZXIgZGFtYWdlIHRvIHNlcnZlclxuICBwcml2YXRlIG9uUGxheWVyRGFtYWdlQ2FsbGJhY2s/OiAocGxheWVySWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIsIGRhbWFnZVR5cGU/OiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLy8gTG9nIHRocm90dGxpbmcgdG8gcmVkdWNlIHNwYW1cbiAgcHJpdmF0ZSBsYXN0RGFtYWdlTG9nVGltZSA9IDA7XG4gIHByaXZhdGUgZGFtYWdlTG9nVGhyb3R0bGUgPSAxMDA7IC8vIE9ubHkgbG9nIGV2ZXJ5IDEwMG1zXG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyID0gbmV3IERhbWFnZU51bWJlck1hbmFnZXIoKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMjU7IC8vIFJ1biBhZnRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gIH1cblxuICAvLyBUaHJvdHRsZWQgbG9nZ2luZyB0byByZWR1Y2Ugc3BhbVxuICBwcml2YXRlIHNob3VsZExvZ0RhbWFnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSB0aGlzLmxhc3REYW1hZ2VMb2dUaW1lID4gdGhpcy5kYW1hZ2VMb2dUaHJvdHRsZSkge1xuICAgICAgdGhpcy5sYXN0RGFtYWdlTG9nVGltZSA9IG5vdztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBTZXQgY2FsbGJhY2sgZm9yIHJvdXRpbmcgZW5lbXkgZGFtYWdlIHRvIG11bHRpcGxheWVyIHNlcnZlclxuICBwdWJsaWMgc2V0RW5lbXlEYW1hZ2VDYWxsYmFjayhjYWxsYmFjazogKGVuZW15SWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRW5lbXlEYW1hZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICAvLyBTZXQgY2FsbGJhY2sgZm9yIHJvdXRpbmcgcGxheWVyIGRhbWFnZSB0byBtdWx0aXBsYXllciBzZXJ2ZXIgKFBWUClcbiAgcHVibGljIHNldFBsYXllckRhbWFnZUNhbGxiYWNrKGNhbGxiYWNrOiAocGxheWVySWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIsIGRhbWFnZVR5cGU/OiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGNvbXBvbmVudHMgKHJlZ2VuZXJhdGlvbiwgaW52dWxuZXJhYmlsaXR5IHRpbWVycylcbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbXBvbmVudHMoZW50aXRpZXMsIGRlbHRhVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgLy8gUHJvY2VzcyBkYW1hZ2UgcXVldWVcbiAgICB0aGlzLnByb2Nlc3NEYW1hZ2VRdWV1ZShjdXJyZW50VGltZSk7XG5cbiAgICAvLyBQcm9jZXNzIGhlYWwgcXVldWVcbiAgICB0aGlzLnByb2Nlc3NIZWFsUXVldWUoY3VycmVudFRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIGRlYXRoIGFuZCByZXNwYXduXG4gICAgdGhpcy5oYW5kbGVEZWF0aEFuZFJlc3Bhd24oZW50aXRpZXMsIGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIENsZWFudXAgb2xkIGRhbWFnZSBudW1iZXJzXG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmNsZWFudXAoKTtcblxuICAgIC8vIENsZWFyIHByb2Nlc3NlZCBxdWV1ZXNcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVIZWFsdGhDb21wb25lbnRzKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGlmIHJlcXVpcmVkIEhlYWx0aCBjb21wb25lbnQgaXMgbWlzc2luZ1xuICAgICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSBjb250aW51ZTtcblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBjb21wb25lbnQgKGhhbmRsZXMgcmVnZW5lcmF0aW9uIGFuZCBpbnZ1bG5lcmFiaWxpdHkpXG4gICAgICBoZWFsdGgudXBkYXRlKGRlbHRhVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICAvLyBVcGRhdGUgc2hpZWxkIGNvbXBvbmVudCBpZiBpdCBleGlzdHNcbiAgICAgIGNvbnN0IHNoaWVsZCA9IGVudGl0eS5nZXRDb21wb25lbnQoU2hpZWxkKTtcbiAgICAgIGlmIChzaGllbGQpIHtcbiAgICAgICAgc2hpZWxkLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZnJlZXplIHN0YXR1cyBmb3IgZW5lbWllc1xuICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgIGlmIChlbmVteSkge1xuICAgICAgICBlbmVteS51cGRhdGVGcmVlemVTdGF0dXMoY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0RhbWFnZVF1ZXVlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGRhbWFnZUV2ZW50IG9mIHRoaXMuZGFtYWdlUXVldWUpIHtcbiAgICAgIHRoaXMuYXBwbHlEYW1hZ2UoZGFtYWdlRXZlbnQsIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NIZWFsUXVldWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgaGVhbEV2ZW50IG9mIHRoaXMuaGVhbFF1ZXVlKSB7XG4gICAgICB0aGlzLmFwcGx5SGVhbGluZyhoZWFsRXZlbnQsIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFwcGx5RGFtYWdlKGRhbWFnZUV2ZW50OiBEYW1hZ2VFdmVudCwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHsgdGFyZ2V0LCBkYW1hZ2U6IGJhc2VEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSB9ID0gZGFtYWdlRXZlbnQ7XG5cbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm47XG5cbiAgICAvLyBJbXBvcnQgU3VtbW9uZWRVbml0IGNvbXBvbmVudCBkeW5hbWljYWxseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgY29uc3QgU3VtbW9uZWRVbml0ID0gcmVxdWlyZSgnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnKS5TdW1tb25lZFVuaXQ7XG5cbiAgICAvLyBEZWJ1ZzogTG9nIGFsbCBkYW1hZ2UgZXZlbnRzIGZvciBjaGFyZ2UgZGFtYWdlXG4gICAgaWYgKGRhbWFnZVR5cGUgPT09ICdjaGFyZ2UnKSB7XG4gICAgICBjb25zdCBlbmVteSA9IHRhcmdldC5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gc3VtbW9uZWRVbml0Q29tcG9uZW50ID8gc3VtbW9uZWRVbml0Q29tcG9uZW50IGFzIHR5cGVvZiBTdW1tb25lZFVuaXQucHJvdG90eXBlIDogbnVsbDtcbiAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBzdW1tb25lZFVuaXQgPyBgU3VtbW9uZWRVbml0KCR7c3VtbW9uZWRVbml0LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7dGFyZ2V0LmlkfSlgO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbiBlbmVteSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15ICYmIHRoaXMub25FbmVteURhbWFnZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcblxuICAgICAgLy8gUm91dGUgZW5lbXkgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyIGluc3RlYWQgb2YgYXBwbHlpbmcgbG9jYWxseVxuICAgICAgLy8gY29uc29sZS5sb2coYPCfjJAgUm91dGluZyAke2FjdHVhbERhbWFnZX0gZGFtYWdlIHRvIGVuZW15ICR7dGFyZ2V0LmlkfSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlcmApO1xuICAgICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGFjdHVhbERhbWFnZSk7XG5cbiAgICAgIC8vIFN0aWxsIGNyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuXG4gICAgICByZXR1cm47IC8vIERvbid0IGFwcGx5IGRhbWFnZSBsb2NhbGx5IGZvciBlbmVtaWVzXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGEgc3VtbW9uZWQgdW5pdCAtIHRyZWF0IGxpa2UgZW5lbXkgKGFwcGx5IGRhbWFnZSBsb2NhbGx5KVxuICAgIGNvbnN0IHN1bW1vbmVkVW5pdENvbXBvbmVudCA9IHRhcmdldC5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0Q29tcG9uZW50KSB7XG4gICAgICAvLyBDYXN0IHRvIHByb3BlciB0eXBlXG4gICAgICBjb25zdCBzdW1tb25lZFVuaXQgPSBzdW1tb25lZFVuaXRDb21wb25lbnQgYXMgdHlwZW9mIFN1bW1vbmVkVW5pdC5wcm90b3R5cGU7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZGFtYWdlIHdpdGggY3JpdGljYWwgaGl0IG1lY2hhbmljc1xuICAgICAgY29uc3QgZGFtYWdlUmVzdWx0OiBEYW1hZ2VSZXN1bHQgPSBjYWxjdWxhdGVEYW1hZ2UoYmFzZURhbWFnZSk7XG4gICAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgICAvLyBBcHBseSBkYW1hZ2UgbG9jYWxseSAocGFzcyBlbnRpdHkgc28gSGVhbHRoIGNhbiB1c2UgU2hpZWxkIGNvbXBvbmVudClcbiAgICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcblxuICAgICAgaWYgKGRhbWFnZURlYWx0KSB7XG4gICAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGRhbWFnZSBudW1iZXIgYXQgdGFyZ2V0IHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBkYW1hZ2UgbnVtYmVyIGlmIHBvc2l0aW9uIGlzIHZhbGlkXG4gICAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBPZmZzZXQgc2xpZ2h0bHkgYWJvdmUgdGhlIHRhcmdldFxuICAgICAgICAgICAgcG9zaXRpb24ueSArPSAyO1xuICAgICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgIGRhbWFnZVR5cGUgfHwgJ21lbGVlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZyAodGhyb3R0bGVkIHRvIHJlZHVjZSBzcGFtKVxuICAgICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHN1bW1vbmVkVW5pdC5nZXREaXNwbGF5TmFtZSgpO1xuICAgICAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGDimpTvuI8gJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgZGllZFxuICAgICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaWdnZXIgZGFtYWdlIGVmZmVjdHNcbiAgICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gRGFtYWdlIGFwcGxpZWQgbG9jYWxseSBmb3Igc3VtbW9uZWQgdW5pdHNcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBwbGF5ZXIgaW4gUFZQIG1vZGUgLSBpZiBzbywgcm91dGUgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXJcbiAgICAvLyBBbHNvIHByZXZlbnQgc2VsZi1kYW1hZ2UgaW4gUFZQIChzb3VyY2UgaGl0dGluZyB0aGVtc2VsdmVzKVxuICAgIGlmICghZW5lbXkgJiYgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrICYmIHNvdXJjZSAmJiBzb3VyY2UuaWQgIT09IHRhcmdldC5pZCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkYW1hZ2Ugd2l0aCBjcml0aWNhbCBoaXQgbWVjaGFuaWNzXG4gICAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcblxuICAgICAgLy8gUm91dGUgcGxheWVyIGRhbWFnZSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlciBmb3IgUFZQIChsZXQgcmVjZWl2ZXIgaGFuZGxlIHNoaWVsZHMpXG4gICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg4pqU77iPIFJvdXRpbmcgJHtkYW1hZ2VSZXN1bHQuZGFtYWdlfSBQVlAgJHtkYW1hZ2VUeXBlIHx8ICdkYW1hZ2UnfSB0byBwbGF5ZXIgJHt0YXJnZXQuaWR9IHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyYCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGRhbWFnZVJlc3VsdC5kYW1hZ2UsIGRhbWFnZVR5cGUpOyAvLyBTZW5kIGRhbWFnZSwgbGV0IHJlY2VpdmVyIGhhbmRsZSBzaGllbGRzXG5cbiAgICAgIC8vIENyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueSArPSAxLjU7XG5cbiAgICAgICAgICAvLyBBZGQgc2xpZ2h0IHBvc2l0aW9uIG9mZnNldCBmb3IgZGVsYXllZCBkYW1hZ2UgKGxpa2Ugc2FicmVzIHJpZ2h0IGhpdCkgdG8gcHJldmVudCBvdmVybGFwXG4gICAgICAgICAgaWYgKGRhbWFnZVR5cGUgPT09ICdzYWJyZXNfcmlnaHQnKSB7XG4gICAgICAgICAgICBwb3NpdGlvbi54ICs9IDAuMzsgLy8gU2xpZ2h0IG9mZnNldCB0byB0aGUgcmlnaHQgZm9yIHRoZSByaWdodCBzYWJyZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5hZGREYW1hZ2VOdW1iZXIoXG4gICAgICAgICAgICBkYW1hZ2VSZXN1bHQuZGFtYWdlLCAvLyBTaG93IHRoZSBmdWxsIGRhbWFnZSBpbiBkYW1hZ2UgbnVtYmVyc1xuICAgICAgICAgICAgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGRhbWFnZVR5cGUgfHwgJ3B2cCdcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFNraXBwaW5nIFBWUCBkYW1hZ2UgbnVtYmVyIGNyZWF0aW9uIC0gaW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmcgKHRocm90dGxlZCB0byByZWR1Y2Ugc3BhbSlcbiAgICAgIGlmICh0aGlzLnNob3VsZExvZ0RhbWFnZSgpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgUGxheWVyICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSBgUGxheWVyICR7dGFyZ2V0LmlkfWA7XG4gICAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg4pqU77iPICR7c291cmNlTmFtZX0gZGVhbHQgJHtkYW1hZ2VSZXN1bHQuZGFtYWdlfSR7Y3JpdFRleHR9IFBWUCAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKHJvdXRlZCB0byBzZXJ2ZXIpYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgYXBwbHkgZGFtYWdlIGxvY2FsbHkgZm9yIFBWUCBwbGF5ZXJzXG4gICAgfVxuXG4gICAgLy8gRm9yIG5vbi1lbmVtaWVzIGFuZCBub24tc3VtbW9uZWQgdW5pdHMgKGxpa2UgcGxheWVycyBpbiBub24tUFZQIG1vZGUpLCBhcHBseSBkYW1hZ2UgbG9jYWxseSBhcyBiZWZvcmVcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgLy8gQXBwbHkgZGFtYWdlIChwYXNzIGVudGl0eSBzbyBIZWFsdGggY2FuIHVzZSBTaGllbGQgY29tcG9uZW50KVxuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcblxuICAgIGlmIChkYW1hZ2VEZWFsdCkge1xuICAgICAgdGhpcy50b3RhbERhbWFnZURlYWx0ICs9IGFjdHVhbERhbWFnZTtcblxuICAgICAgLy8gQ3JlYXRlIGRhbWFnZSBudW1iZXIgYXQgdGFyZ2V0IHBvc2l0aW9uXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgZGFtYWdlIG51bWJlciBpZiBwb3NpdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAocG9zaXRpb24gJiYgcG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBPZmZzZXQgc2xpZ2h0bHkgYWJvdmUgdGhlIHRhcmdldFxuICAgICAgICAgIHBvc2l0aW9uLnkgKz0gMztcbiAgICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgICAgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGRhbWFnZVR5cGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFNraXBwaW5nIGRhbWFnZSBudW1iZXIgY3JlYXRpb24gLSBpbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2cgZGFtYWdlIGZvciBkZWJ1Z2dpbmcgKHRocm90dGxlZCB0byByZWR1Y2Ugc3BhbSlcbiAgICAgIGlmICh0aGlzLnNob3VsZExvZ0RhbWFnZSgpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0aGlzLmdldEVudGl0eURpc3BsYXlOYW1lKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+SpSAke3NvdXJjZU5hbWV9IGRlYWx0ICR7YWN0dWFsRGFtYWdlfSR7Y3JpdFRleHR9ICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAoJHtoZWFsdGguY3VycmVudEhlYWx0aH0vJHtoZWFsdGgubWF4SGVhbHRofSBIUClgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGRpZWRcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlciBkYW1hZ2UgZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBseUhlYWxpbmcoaGVhbEV2ZW50OiBIZWFsRXZlbnQsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRhcmdldCwgYW1vdW50LCBzb3VyY2UgfSA9IGhlYWxFdmVudDtcbiAgICBcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm47XG5cbiAgICAvLyBBcHBseSBoZWFsaW5nXG4gICAgY29uc3QgaGVhbGluZ0RvbmUgPSBoZWFsdGguaGVhbChhbW91bnQpO1xuICAgIFxuICAgIGlmIChoZWFsaW5nRG9uZSkge1xuICAgICAgdGhpcy50b3RhbEhlYWxpbmdEb25lICs9IGFtb3VudDtcbiAgICAgIFxuICAgICAgLy8gTG9nIGhlYWxpbmcgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBFbnRpdHkgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSB0aGlzLmdldEVudGl0eURpc3BsYXlOYW1lKHRhcmdldCk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SmiAke3NvdXJjZU5hbWV9IGhlYWxlZCAke3RhcmdldE5hbWV9IGZvciAke2Ftb3VudH0gSFAgKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG5cbiAgICAgIC8vIFRyaWdnZXIgaGVhbGluZyBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUVudGl0eURlYXRoKGVudGl0eTogRW50aXR5LCBraWxsZXI/OiBFbnRpdHksIGN1cnJlbnRUaW1lPzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcblxuICAgIGlmIChlbmVteSkge1xuICAgICAgZW5lbXkuZGllKGN1cnJlbnRUaW1lIHx8IERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIHRoaXMuZW5lbWllc0tpbGxlZCsrO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SgCAke2VuZW15LmdldERpc3BsYXlOYW1lKCl9IGhhcyBiZWVuIGRlZmVhdGVkIWApO1xuXG4gICAgICAvLyBBd2FyZCBleHBlcmllbmNlIHRvIGtpbGxlciBpZiBpdCdzIGEgcGxheWVyXG4gICAgICBpZiAoa2lsbGVyKSB7XG4gICAgICAgIHRoaXMuYXdhcmRFeHBlcmllbmNlKGtpbGxlciwgZW5lbXkuZXhwZXJpZW5jZVJld2FyZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgZGVhdGggZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VyRGVhdGhFZmZlY3RzKGVudGl0eSwga2lsbGVyKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgU3VtbW9uZWRVbml0IGRlYXRoXG4gICAgY29uc3QgU3VtbW9uZWRVbml0ID0gcmVxdWlyZSgnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnKS5TdW1tb25lZFVuaXQ7XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gZW50aXR5LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgIGlmIChzdW1tb25lZFVuaXRDb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IHN1bW1vbmVkVW5pdCA9IHN1bW1vbmVkVW5pdENvbXBvbmVudCBhcyB0eXBlb2YgU3VtbW9uZWRVbml0LnByb3RvdHlwZTtcbiAgICAgIHN1bW1vbmVkVW5pdC5kaWUoY3VycmVudFRpbWUgfHwgRGF0ZS5ub3coKSAvIDEwMDApO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SgCAke3N1bW1vbmVkVW5pdC5nZXREaXNwbGF5TmFtZSgpfSBoYXMgYmVlbiBkZWZlYXRlZCFgKTtcblxuICAgICAgLy8gVHJpZ2dlciBkZWF0aCBlZmZlY3RzIGZvciBzdW1tb25lZCB1bml0c1xuICAgICAgdGhpcy50cmlnZ2VyRGVhdGhFZmZlY3RzKGVudGl0eSwga2lsbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlYWRFbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZURlYXRoQW5kUmVzcGF3bihlbnRpdGllczogRW50aXR5W10sIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgIFxuICAgICAgaWYgKCFoZWFsdGggfHwgIWVuZW15KSBjb250aW51ZTtcblxuICAgICAgLy8gSGFuZGxlIHJlc3Bhd24gZm9yIGVuZW1pZXNcbiAgICAgIGlmIChlbmVteS5pc0RlYWQgJiYgZW5lbXkuY2FuUmVzcGF3bk5vdyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5yZXNwYXduRW5lbXkoZW50aXR5LCBlbmVteSwgaGVhbHRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc3Bhd25FbmVteShlbnRpdHk6IEVudGl0eSwgZW5lbXk6IEVuZW15LCBoZWFsdGg6IEhlYWx0aCk6IHZvaWQge1xuICAgIC8vIFJlc3Bhd24gdGhlIGVuZW15XG4gICAgZW5lbXkucmVzcGF3bigpO1xuICAgIGhlYWx0aC5yZXZpdmUoKTtcbiAgICBcbiAgICAvLyBjb25zb2xlLmxvZyhg8J+UhCAke2VuZW15LmdldERpc3BsYXlOYW1lKCl9IGhhcyByZXNwYXduZWQhYCk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciByZXNwYXduIGVmZmVjdHNcbiAgICB0aGlzLnRyaWdnZXJSZXNwYXduRWZmZWN0cyhlbnRpdHkpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQ6IEVudGl0eSwgZGFtYWdlOiBudW1iZXIsIHNvdXJjZT86IEVudGl0eSwgZGFtYWdlVHlwZT86IHN0cmluZywgaXNDcml0aWNhbD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIHBhcnRpY2xlIGVmZmVjdHMsIHNjcmVlbiBzaGFrZSwgZXRjLlxuICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgaGFuZGxlIGJhc2ljIGVmZmVjdHNcbiAgICBcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgLy8gQ291bGQgdHJpZ2dlciBkYW1hZ2UgbnVtYmVyIHBvcHVwLCBibG9vZCBlZmZlY3RzLCBldGMuXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGxvZyB0aGUgcG9zaXRpb24gd2hlcmUgZGFtYWdlIG9jY3VycmVkXG4gICAgICBjb25zdCBjcml0VGV4dCA9IGlzQ3JpdGljYWwgPyAnIChDUklUSUNBTCknIDogJyc7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+OryBEYW1hZ2UgZWZmZWN0JHtjcml0VGV4dH0gYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BlY2lhbCBwcm9qZWN0aWxlIGVmZmVjdHNcbiAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ3Byb2plY3RpbGUnICYmIHNvdXJjZSkge1xuICAgICAgY29uc3Qgc291cmNlUmVuZGVyZXIgPSBzb3VyY2UuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICAgIGlmIChzb3VyY2VSZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LmlzQmFycmFnZUFycm93KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn4+5IEJhcnJhZ2UgYXJyb3cgaGl0IGRldGVjdGVkLCBhcHBseWluZyBzbG93IGVmZmVjdCB0byB0YXJnZXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIGNvbnN0IHRhcmdldE1vdmVtZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICAgIGlmICh0YXJnZXRNb3ZlbWVudCkge1xuICAgICAgICAgIHRhcmdldE1vdmVtZW50LnNsb3coNTAwMCwgMC41KTsgLy8gNSBzZWNvbmRzLCA1MCUgc3BlZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+QjCBBcHBsaWVkIDUwJSBzbG93IGZvciA1IHNlY29uZHMgdG8gdGFyZ2V0ICR7dGFyZ2V0LmlkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VySGVhbGluZ0VmZmVjdHModGFyZ2V0OiBFbnRpdHksIGFtb3VudDogbnVtYmVyLCBzb3VyY2U/OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIGhlYWxpbmcgcGFydGljbGUgZWZmZWN0c1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg4pyoIEhlYWxpbmcgZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyRGVhdGhFZmZlY3RzKGVudGl0eTogRW50aXR5LCBraWxsZXI/OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIGRlYXRoIGFuaW1hdGlvbnMsIGxvb3QgZHJvcHMsIGV0Yy5cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgLy8gY29uc29sZS5sb2coYPCfkoAgRGVhdGggZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyUmVzcGF3bkVmZmVjdHMoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICAvLyBUaGlzIGNhbiBiZSBleHRlbmRlZCB0byB0cmlnZ2VyIHJlc3Bhd24gYW5pbWF0aW9ucywgZWZmZWN0cywgZXRjLlxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+MnyBSZXNwYXduIGVmZmVjdCBhdCBwb3NpdGlvbjpgLCB0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXdhcmRFeHBlcmllbmNlKGVudGl0eTogRW50aXR5LCBleHBlcmllbmNlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGEgcHJvZ3Jlc3Npb24gc3lzdGVtXG4gICAgLy8gY29uc29sZS5sb2coYOKtkCBFbnRpdHkgJHtlbnRpdHkuaWR9IGdhaW5lZCAke2V4cGVyaWVuY2V9IGV4cGVyaWVuY2UhYCk7XG4gIH1cblxuICBwcml2YXRlIGdldEVudGl0eURpc3BsYXlOYW1lKGVudGl0eTogRW50aXR5KTogc3RyaW5nIHtcbiAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgIGlmIChlbmVteSkge1xuICAgICAgcmV0dXJuIGVuZW15LmdldERpc3BsYXlOYW1lKCk7XG4gICAgfVxuXG4gICAgLy8gSW1wb3J0IFN1bW1vbmVkVW5pdCBjb21wb25lbnQgZHluYW1pY2FsbHkgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgIGNvbnN0IFN1bW1vbmVkVW5pdCA9IHJlcXVpcmUoJ0AvZWNzL2NvbXBvbmVudHMvU3VtbW9uZWRVbml0JykuU3VtbW9uZWRVbml0O1xuICAgIGNvbnN0IHN1bW1vbmVkVW5pdENvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0Q29tcG9uZW50KSB7XG4gICAgICBjb25zdCBzdW1tb25lZFVuaXQgPSBzdW1tb25lZFVuaXRDb21wb25lbnQgYXMgdHlwZW9mIFN1bW1vbmVkVW5pdC5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gc3VtbW9uZWRVbml0LmdldERpc3BsYXlOYW1lKCk7XG4gICAgfVxuXG4gICAgLy8gQ291bGQgY2hlY2sgZm9yIG90aGVyIGNvbXBvbmVudHMgdGhhdCBwcm92aWRlIG5hbWVzXG4gICAgcmV0dXJuIGBFbnRpdHkgJHtlbnRpdHkuaWR9YDtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIG90aGVyIHN5c3RlbXMgdG8gcXVldWUgZGFtYWdlIGFuZCBoZWFsaW5nXG4gIHB1YmxpYyBxdWV1ZURhbWFnZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLnB1c2goe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGFtYWdlLFxuICAgICAgc291cmNlLFxuICAgICAgZGFtYWdlVHlwZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBxdWV1ZUhlYWxpbmcoXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIGFtb3VudDogbnVtYmVyLCBcbiAgICBzb3VyY2U/OiBFbnRpdHlcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5oZWFsUXVldWUucHVzaCh7XG4gICAgICB0YXJnZXQsXG4gICAgICBhbW91bnQsXG4gICAgICBzb3VyY2UsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCkgLyAxMDAwXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbW1lZGlhdGUgZGFtYWdlL2hlYWxpbmcgKGJ5cGFzc2VzIHF1ZXVlKVxuICBwdWJsaWMgZGVhbERhbWFnZUltbWVkaWF0ZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShkYW1hZ2UpO1xuICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYW1hZ2VEZWFsdDtcbiAgfVxuXG4gIHB1YmxpYyBoZWFsSW1tZWRpYXRlKFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBhbW91bnQ6IG51bWJlciwgXG4gICAgc291cmNlPzogRW50aXR5XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWxpbmdEb25lO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBpc0VudGl0eURlYWQoZW50aXR5OiBFbnRpdHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgcmV0dXJuIGhlYWx0aCA/IGhlYWx0aC5pc0RlYWQgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFbnRpdHlIZWFsdGhSYXRpbyhlbnRpdHk6IEVudGl0eSk6IG51bWJlciB7XG4gICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIHJldHVybiBoZWFsdGggPyBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSA6IDA7XG4gIH1cblxuICBwdWJsaWMgY2FuRW50aXR5VGFrZURhbWFnZShlbnRpdHk6IEVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICByZXR1cm4gaGVhbHRoID8gKCFoZWFsdGguaXNEZWFkICYmICFoZWFsdGguaXNJbnZ1bG5lcmFibGUpIDogZmFsc2U7XG4gIH1cblxuICAvLyBTdGF0aXN0aWNzIGFuZCBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldENvbWJhdFN0YXRzKCk6IHtcbiAgICB0b3RhbERhbWFnZURlYWx0OiBudW1iZXI7XG4gICAgdG90YWxIZWFsaW5nRG9uZTogbnVtYmVyO1xuICAgIGVuZW1pZXNLaWxsZWQ6IG51bWJlcjtcbiAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IG51bWJlcjtcbiAgICBxdWV1ZWRIZWFsRXZlbnRzOiBudW1iZXI7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbERhbWFnZURlYWx0OiB0aGlzLnRvdGFsRGFtYWdlRGVhbHQsXG4gICAgICB0b3RhbEhlYWxpbmdEb25lOiB0aGlzLnRvdGFsSGVhbGluZ0RvbmUsXG4gICAgICBlbmVtaWVzS2lsbGVkOiB0aGlzLmVuZW1pZXNLaWxsZWQsXG4gICAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IHRoaXMuZGFtYWdlUXVldWUubGVuZ3RoLFxuICAgICAgcXVldWVkSGVhbEV2ZW50czogdGhpcy5oZWFsUXVldWUubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gICAgdGhpcy50b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgICB0aGlzLmVuZW1pZXNLaWxsZWQgPSAwO1xuICB9XG5cbiAgLy8gRGFtYWdlIG51bWJlcnMgbWFuYWdlbWVudFxuICBwdWJsaWMgZ2V0RGFtYWdlTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmdldERhbWFnZU51bWJlcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVEYW1hZ2VOdW1iZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5yZW1vdmVEYW1hZ2VOdW1iZXIoaWQpO1xuICB9XG5cbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRTdGF0cygpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU3lzdGVtIiwiSGVhbHRoIiwiU2hpZWxkIiwiRW5lbXkiLCJUcmFuc2Zvcm0iLCJSZW5kZXJlciIsIk1vdmVtZW50IiwiY2FsY3VsYXRlRGFtYWdlIiwiRGFtYWdlTnVtYmVyTWFuYWdlciIsIkNvbWJhdFN5c3RlbSIsInNob3VsZExvZ0RhbWFnZSIsIm5vdyIsIkRhdGUiLCJsYXN0RGFtYWdlTG9nVGltZSIsImRhbWFnZUxvZ1Rocm90dGxlIiwic2V0RW5lbXlEYW1hZ2VDYWxsYmFjayIsImNhbGxiYWNrIiwib25FbmVteURhbWFnZUNhbGxiYWNrIiwic2V0UGxheWVyRGFtYWdlQ2FsbGJhY2siLCJvblBsYXllckRhbWFnZUNhbGxiYWNrIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsInVwZGF0ZUhlYWx0aENvbXBvbmVudHMiLCJwcm9jZXNzRGFtYWdlUXVldWUiLCJwcm9jZXNzSGVhbFF1ZXVlIiwiaGFuZGxlRGVhdGhBbmRSZXNwYXduIiwiZGFtYWdlTnVtYmVyTWFuYWdlciIsImNsZWFudXAiLCJkYW1hZ2VRdWV1ZSIsImxlbmd0aCIsImhlYWxRdWV1ZSIsImRlYWRFbnRpdGllcyIsImVudGl0eSIsImhlYWx0aCIsImdldENvbXBvbmVudCIsImVuYWJsZWQiLCJzaGllbGQiLCJlbmVteSIsInVwZGF0ZUZyZWV6ZVN0YXR1cyIsImRhbWFnZUV2ZW50IiwiYXBwbHlEYW1hZ2UiLCJoZWFsRXZlbnQiLCJhcHBseUhlYWxpbmciLCJ0YXJnZXQiLCJkYW1hZ2UiLCJiYXNlRGFtYWdlIiwic291cmNlIiwiZGFtYWdlVHlwZSIsIlN1bW1vbmVkVW5pdCIsInJlcXVpcmUiLCJzdW1tb25lZFVuaXRDb21wb25lbnQiLCJzdW1tb25lZFVuaXQiLCJlbnRpdHlUeXBlIiwiZ2V0RGlzcGxheU5hbWUiLCJpZCIsImRhbWFnZVJlc3VsdCIsImFjdHVhbERhbWFnZSIsInRvU3RyaW5nIiwidHJhbnNmb3JtIiwicG9zaXRpb24iLCJnZXRXb3JsZFBvc2l0aW9uIiwieSIsImFkZERhbWFnZU51bWJlciIsImlzQ3JpdGljYWwiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImdldEVudGl0eURpc3BsYXlOYW1lIiwiY3JpdFRleHQiLCJkYW1hZ2VEZWFsdCIsInRha2VEYW1hZ2UiLCJ0b3RhbERhbWFnZURlYWx0IiwieCIsInVuZGVmaW5lZCIsInoiLCJpc0RlYWQiLCJoYW5kbGVFbnRpdHlEZWF0aCIsInRyaWdnZXJEYW1hZ2VFZmZlY3RzIiwiYW1vdW50IiwiaGVhbGluZ0RvbmUiLCJoZWFsIiwidG90YWxIZWFsaW5nRG9uZSIsInRyaWdnZXJIZWFsaW5nRWZmZWN0cyIsImtpbGxlciIsImRpZSIsImVuZW1pZXNLaWxsZWQiLCJhd2FyZEV4cGVyaWVuY2UiLCJleHBlcmllbmNlUmV3YXJkIiwidHJpZ2dlckRlYXRoRWZmZWN0cyIsInB1c2giLCJjYW5SZXNwYXduTm93IiwicmVzcGF3bkVuZW15IiwicmVzcGF3biIsInJldml2ZSIsInRyaWdnZXJSZXNwYXduRWZmZWN0cyIsInNvdXJjZVJlbmRlcmVyIiwibWVzaCIsInVzZXJEYXRhIiwiaXNCYXJyYWdlQXJyb3ciLCJ0YXJnZXRNb3ZlbWVudCIsInNsb3ciLCJleHBlcmllbmNlIiwicXVldWVEYW1hZ2UiLCJ0aW1lc3RhbXAiLCJxdWV1ZUhlYWxpbmciLCJkZWFsRGFtYWdlSW1tZWRpYXRlIiwiaGVhbEltbWVkaWF0ZSIsImlzRW50aXR5RGVhZCIsImdldEVudGl0eUhlYWx0aFJhdGlvIiwiZ2V0SGVhbHRoUmF0aW8iLCJjYW5FbnRpdHlUYWtlRGFtYWdlIiwiaXNJbnZ1bG5lcmFibGUiLCJnZXRDb21iYXRTdGF0cyIsInF1ZXVlZERhbWFnZUV2ZW50cyIsInF1ZXVlZEhlYWxFdmVudHMiLCJyZXNldFN0YXRzIiwiZ2V0RGFtYWdlTnVtYmVycyIsInJlbW92ZURhbWFnZU51bWJlciIsIm9uRGlzYWJsZSIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJ3b3JsZCIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CombatSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ControlSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/ControlSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlSystem: function() { return /* binding */ ControlSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _CombatSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CombatSystem */ \"(app-pages-browser)/./src/systems/CombatSystem.ts\");\n/* harmony import */ var _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/dragon/weapons */ \"(app-pages-browser)/./src/components/dragon/weapons.ts\");\n/* harmony import */ var _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/weapons/DeflectBarrier */ \"(app-pages-browser)/./src/components/weapons/DeflectBarrier.ts\");\n/* harmony import */ var _components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/weapons/FrostNovaManager */ \"(app-pages-browser)/./src/components/weapons/FrostNovaManager.tsx\");\n/* harmony import */ var _components_weapons_StunManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/weapons/StunManager */ \"(app-pages-browser)/./src/components/weapons/StunManager.tsx\");\n/* harmony import */ var _components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/projectiles/CobraShotManager */ \"(app-pages-browser)/./src/components/projectiles/CobraShotManager.tsx\");\n/* harmony import */ var _components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/components/projectiles/ViperStingManager */ \"(app-pages-browser)/./src/components/projectiles/ViperStingManager.tsx\");\n// Control system for player input handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ControlSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setPlayer(entity) {\n        this.playerEntity = entity;\n    }\n    update(entities, deltaTime) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerTransform || !playerMovement) return;\n        // Update debuff states first\n        if (typeof playerMovement.updateDebuffs === \"function\") {\n            playerMovement.updateDebuffs();\n        }\n        // Clean up expired Sunder stacks periodically\n        this.cleanupSunderStacks();\n        // Handle weapon switching\n        this.handleWeaponSwitching();\n        // Handle dash movement first (overrides regular movement)\n        this.handleDashMovement(playerMovement, playerTransform);\n        // Handle charge movement (overrides regular movement)\n        this.handleChargeMovement(playerMovement, playerTransform);\n        // Handle player movement input (only if not dashing, charging, frozen, or skyfalling)\n        if (!playerMovement.isDashing && !playerMovement.isCharging && !playerMovement.isFrozen && !this.isSkyfalling) {\n            this.handleMovementInput(playerMovement);\n        }\n        // Handle combat input\n        this.handleCombatInput(playerTransform);\n        // Update deflect barrier position if active\n        this.updateDeflectBarrier(playerTransform);\n    }\n    handleMovementInput(movement) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!playerTransform) return;\n        // Check for double-tap dashes first (before processing regular movement)\n        this.checkForDashInput(movement, playerTransform);\n        // Get input direction\n        const inputDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let hasInput = false;\n        // WASD movement\n        if (this.inputManager.isKeyPressed(\"w\")) {\n            inputDirection.z -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"s\")) {\n            inputDirection.z += 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"a\")) {\n            inputDirection.x -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"d\")) {\n            inputDirection.x += 1;\n            hasInput = true;\n        }\n        // Normalize diagonal movement\n        if (inputDirection.length() > 0) {\n            inputDirection.normalize();\n        }\n        // Convert input to world space based on camera orientation\n        if (hasInput) {\n            const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(cameraDirection);\n            // Get camera's right vector\n            const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n            // Get camera's forward vector (projected on XZ plane)\n            const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n            // Transform input direction to world space\n            const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            worldDirection.addScaledVector(cameraRight, inputDirection.x);\n            worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n            worldDirection.normalize();\n            movement.setMoveDirection(worldDirection, 1.0);\n        } else {\n            movement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n        }\n        // Handle jumping\n        if (this.inputManager.isKeyPressed(\" \")) {\n            movement.jump();\n        }\n    }\n    handleWeaponSwitching() {\n        const currentTime = Date.now() / 1000;\n        // Prevent rapid weapon switching\n        if (currentTime - this.lastWeaponSwitchTime < this.weaponSwitchCooldown) {\n            return;\n        }\n        // Handle weapon switching with number keys\n        if (this.inputManager.isKeyPressed(\"1\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.DIVINITY; // Default sword subclass\n                this.fireRate = this.swordFireRate; // Use sword-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to sword\n            }\n        } else if (this.inputManager.isKeyPressed(\"2\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL; // Default bow subclass\n                this.fireRate = 0.225; // Bow fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"3\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.CHAOS; // Default scythe subclass\n                this.fireRate = this.scytheFireRate; // Use scythe fire rate (0.5s)\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"4\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.FROST; // Default sabres subclass\n                this.fireRate = this.sabresFireRate; // Use sabres-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        }\n    }\n    handleCombatInput(playerTransform) {\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            this.handleBowInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            this.handleScytheInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            this.handleSwordInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            this.handleSabresInput(playerTransform);\n        }\n    }\n    handleBowInput(playerTransform) {\n        // Handle Viper Sting ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isViperStingCharging && !this.isCharging) {\n            this.performViperSting(playerTransform);\n        }\n        // Handle Barrage ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\")) {\n            if (!this.isBarrageCharging && !this.isCharging && !this.isViperStingCharging) {\n                this.performBarrage(playerTransform);\n            }\n        }\n        // Handle Cobra Shot ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\")) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.performCobraShot(playerTransform);\n            }\n        }\n        // Handle bow charging and firing\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n            }\n            // Increase charge progress (could be time-based)\n            if (!this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.chargeProgress = Math.min(this.chargeProgress + 0.0125, 1.0); // BOW CHARGE SPEED\n            }\n        } else if (this.isCharging) {\n            // Check if any ability is charging - if so, cancel the regular bow shot\n            if (this.isViperStingCharging || this.isBarrageCharging || this.isCobraShotCharging) {\n                this.isCharging = false;\n                this.chargeProgress = 0;\n                return;\n            }\n            // Store charge progress before resetting for visual effects\n            const finalChargeProgress = this.chargeProgress;\n            // Release the bow\n            this.fireProjectile(playerTransform);\n            this.isCharging = false;\n            this.chargeProgress = 0;\n            // Trigger visual effects callback with the stored charge progress\n            this.triggerBowReleaseEffects(finalChargeProgress);\n        }\n    }\n    handleScytheInput(playerTransform) {\n        // Handle scythe left click for EntropicBolt\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\"⚡ Started charging scythe (spinning)\");\n            }\n            // Increase charge progress continuously for spinning animation (no cap)\n            this.chargeProgress += 0.03; // Continuously increase for spinning\n            // Fire EntropicBolt projectiles continuously while spinning\n            this.fireEntropicBoltProjectile(playerTransform);\n        } else if (this.isCharging) {\n            // Stop spinning when mouse is released\n            this.isCharging = false;\n            this.chargeProgress = 0;\n        }\n        // Handle CrossentropyBolt ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isCharging) {\n            this.fireCrossentropyBoltAbility(playerTransform);\n        }\n        // Handle Reanimate ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isCharging) {\n            this.performReanimateAbility(playerTransform);\n        }\n        // Handle Frost Nova ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isCharging) {\n            this.performFrostNovaAbility(playerTransform);\n        }\n    }\n    fireProjectile(playerTransform) {\n        // Rate limiting - prevent spam clicking\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.fireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction (same as camera direction since dragon faces camera)\n        // This ensures arrows fire outward from where the dragon is facing\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation to account for restricted camera bounds\n        // Since camera can't look down much due to bounds, we add a fixed downward angle\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        // Create a rotation matrix to apply the downward angle around the camera's right axis\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Perfect shot timing constants\n        const perfectShotMinThreshold = 0.7; // 85% charge\n        const perfectShotMaxThreshold = 0.98; // 95% charge\n        const isPerfectShot = this.chargeProgress >= perfectShotMinThreshold && this.chargeProgress <= perfectShotMaxThreshold;\n        // Check if bow is fully charged for special projectile\n        if (this.chargeProgress >= 1.0) {\n            this.createChargedArrowProjectile(playerTransform.position.clone(), direction);\n        } else if (isPerfectShot) {\n            this.createPerfectShotProjectile(playerTransform.position.clone(), direction);\n        } else {\n            // Debug: Log the firing angle to verify it's changing with camera rotation\n            const angle = Math.atan2(direction.x, direction.z);\n            this.createProjectile(playerTransform.position.clone(), direction);\n        }\n    }\n    fireEntropicBoltProjectile(playerTransform) {\n        // Rate limiting - use new scythe rate (0.35 seconds)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.scytheFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        const spinStatus = this.isCharging ? \" (SPINNING)\" : \"\";\n        this.createEntropicBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    fireCrossentropyBoltAbility(playerTransform) {\n        // Rate limiting - use CrossentropyBolt rate (1 per second)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCrossentropyTime < this.crossentropyFireRate) {\n            return;\n        }\n        this.lastCrossentropyTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        this.createCrossentropyBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    createProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create projectile using the ProjectileSystem with current weapon config\n        const projectileConfig = {\n            speed: 25,\n            damage: 10,\n            lifetime: 3,\n            maxDistance: 25,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createProjectile(this.world, spawnPosition, direction, this.playerEntity.id, projectileConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"regular_arrow\", spawnPosition, direction, projectileConfig);\n        }\n    }\n    createEntropicBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Check if player has enough mana (15 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastEntropicBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(10);\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create EntropicBolt projectile using the new method\n        const entropicConfig = {\n            speed: 20,\n            damage: 20,\n            lifetime: 2,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createEntropicBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, entropicConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"entropic_bolt\", spawnPosition, direction, entropicConfig);\n        }\n    }\n    createCrossentropyBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(40);\n            console.log(\"⚔️ Consumed 40 mana for Crossentropy Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create CrossentropyBolt projectile using the existing method\n        const crossentropyConfig = {\n            speed: 15,\n            damage: 90,\n            lifetime: 2.5,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createCrossentropyBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, crossentropyConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"crossentropy_bolt\", spawnPosition, direction, crossentropyConfig);\n        }\n    }\n    performReanimateAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Rate limiting - prevent spam casting (1 second cooldown)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastReanimateTime < 1.0) {\n            return;\n        }\n        this.lastReanimateTime = currentTime;\n        // Check if player has enough mana (20 mana cost - doubled from 10)\n        const gameUI = window.gameUI;\n        const currentMana = gameUI ? gameUI.getCurrentMana() : 0;\n        if (gameUI && !gameUI.canCastReanimate()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(20);\n            const manaAfter = gameUI.getCurrentMana();\n        }\n        // Always trigger the visual effect first, regardless of healing success\n        this.triggerReanimateEffect(playerTransform);\n        // Get player's health component and heal for 30 HP \n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const didHeal = healthComponent.heal(30); // REANIMATE HEAL AMOUNT\n            if (didHeal) {\n            // console.log(`🩸 Reanimate healed player for 30 HP. Current health: ${healthComponent.currentHealth}/${healthComponent.maxHealth}`);\n            } else {\n            // console.log('🩸 Reanimate cast successfully but player already at full health');\n            }\n        }\n    }\n    triggerReanimateEffect(playerTransform) {\n        // Trigger the visual healing effect\n        if (this.onReanimateCallback) {\n            this.onReanimateCallback();\n        }\n        const playerPosition = playerTransform.position;\n    }\n    performFrostNovaAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFrostNovaTime < this.frostNovaFireRate) {\n            return;\n        }\n        // Check if player has enough mana (50 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastFrostNova()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(50);\n        }\n        this.lastFrostNovaTime = currentTime;\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger Frost Nova callback for visual effects\n        if (this.onFrostNovaCallback) {\n            this.onFrostNovaCallback(playerPosition, direction);\n        }\n        // Find all enemies within 5 unit radius and freeze them\n        this.freezeEnemiesInRadius(playerPosition, 6.0, currentTime);\n        // Trigger global frost nova visual effect\n        (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.triggerGlobalFrostNova)(playerPosition);\n    }\n    performCobraShot(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCobraShotTime < this.cobraShotFireRate) {\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCobraShot()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isCobraShotCharging = true;\n        this.cobraShotChargeProgress = 0;\n        this.lastCobraShotTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 750; // 0.75 second charge time (between Viper Sting and Barrage)\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.cobraShotChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.cobraShotChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCobraShot(playerTransform);\n                this.isCobraShotCharging = false;\n                this.cobraShotChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCobraShot(playerTransform) {\n        // Get player position and direction (same as other projectiles)\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level like Viper Sting\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Cobra Shot damage is handled by CobraShotManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage (similar to Viper Sting)\n        // Trigger Cobra Shot callback for visual effects\n        if (this.onCobraShotCallback) {\n            this.onCobraShotCallback(spawnPosition, direction);\n        }\n        // Trigger global cobra shot with proper positioning (handles local visual effects and damage)\n        (0,_components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_13__.triggerGlobalCobraShot)(spawnPosition, direction);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"cobra_shot_projectile\", spawnPosition, direction, {\n                speed: 20,\n                damage: 29,\n                lifetime: 8,\n                venomDuration: 6\n            });\n        }\n    }\n    freezeEnemiesInRadius(centerPosition, radius, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        let frozenCount = 0;\n        let damagedPlayers = 0;\n        // Get local socket ID to prevent self-targeting\n        const localSocketId = window.localSocketId;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            // Skip self (local player entity)\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const entityPosition = entityTransform.position;\n            const distance = centerPosition.distanceTo(entityPosition);\n            // Check if entity is within freeze radius\n            if (distance <= radius) {\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                if (enemy) {\n                    // This is an enemy - freeze it (single player mode)\n                    enemy.freeze(6.0, currentTime);\n                    frozenCount++;\n                    // Add frozen visual effect for this enemy\n                    (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.addGlobalFrozenEnemy)(entity.id.toString(), entityPosition);\n                } else {\n                    // This is likely another player in PVP mode - deal damage and freeze\n                    // CRITICAL FIX: First check if this entity represents the local player\n                    const serverPlayerEntities = window.serverPlayerEntities;\n                    let targetPlayerId = null;\n                    if (serverPlayerEntities && serverPlayerEntities.current) {\n                        serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                            if (localEntityId === entity.id) {\n                                targetPlayerId = playerId;\n                            }\n                        });\n                    }\n                    // NEVER damage or debuff ourselves\n                    if (targetPlayerId && targetPlayerId === localSocketId) {\n                        console.log(\"⚠️ Skipping Frost Nova on local player \".concat(localSocketId));\n                        return; // Skip this entity completely\n                    }\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity && targetPlayerId) {\n                        const frostNovaDamage = 50; // Frost Nova damage\n                        combatSystem.queueDamage(entity, frostNovaDamage, this.playerEntity, \"frost_nova\");\n                        damagedPlayers++;\n                        // Broadcast freeze effect to the target player so they get frozen on their end\n                        if (this.onDebuffCallback) {\n                            console.log(\"\\uD83C\\uDFAF Broadcasting freeze effect to player \".concat(targetPlayerId, \" (NOT local player \").concat(localSocketId, \")\"));\n                            this.onDebuffCallback(entity.id, \"frozen\", 6000, entityPosition);\n                        }\n                    }\n                }\n            }\n        });\n        if (frozenCount > 0) {\n        // console.log(`❄️ Frost Nova froze ${frozenCount} enemies within ${radius} unit radius`);\n        }\n        if (damagedPlayers > 0) {\n        // console.log(`❄️ Frost Nova damaged ${damagedPlayers} players within ${radius} unit radius`);\n        }\n    }\n    createChargedArrowProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create charged arrow projectile - more powerful than regular arrows\n        const chargedArrowConfig = {\n            speed: 35,\n            damage: 50,\n            lifetime: 2,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, chargedArrowConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"charged_arrow\", spawnPosition, direction, chargedArrowConfig);\n        }\n    }\n    createPerfectShotProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create perfect shot projectile - enhanced charged arrow with special effects\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, {\n            speed: 40,\n            damage: 75,\n            lifetime: 6,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        });\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"perfect_shot\", spawnPosition, direction, {\n                speed: 40,\n                damage: 75,\n                lifetime: 6,\n                piercing: true,\n                subclass: this.currentSubclass,\n                level: this.currentLevel,\n                opacity: 1.0\n            });\n        }\n    }\n    // Methods to configure weapon for testing\n    setWeaponSubclass(subclass) {\n        this.currentSubclass = subclass;\n    }\n    // Method to set bow release callback\n    setBowReleaseCallback(callback) {\n        this.onBowReleaseCallback = callback;\n    }\n    setDivineStormCallback(callback) {\n        this.onDivineStormCallback = callback;\n    }\n    setProjectileCreatedCallback(callback) {\n        this.onProjectileCreatedCallback = callback;\n    }\n    setViperStingCallback(callback) {\n        this.onViperStingCallback = callback;\n    }\n    setBarrageCallback(callback) {\n        this.onBarrageCallback = callback;\n    }\n    setReanimateCallback(callback) {\n        this.onReanimateCallback = callback;\n    }\n    setFrostNovaCallback(callback) {\n        this.onFrostNovaCallback = callback;\n    }\n    setCobraShotCallback(callback) {\n        this.onCobraShotCallback = callback;\n    }\n    setChargeCallback(callback) {\n        this.onChargeCallback = callback;\n    }\n    setDeflectCallback(callback) {\n        this.onDeflectCallback = callback;\n    }\n    setSkyfallCallback(callback) {\n        this.onSkyfallCallback = callback;\n    }\n    setBackstabCallback(callback) {\n        this.onBackstabCallback = callback;\n    }\n    setSunderCallback(callback) {\n        this.onSunderCallback = callback;\n    }\n    setDebuffCallback(callback) {\n        this.onDebuffCallback = callback;\n    }\n    // Method to trigger bow release effects\n    triggerBowReleaseEffects(finalChargeProgress) {\n        if (this.onBowReleaseCallback) {\n            // Check if this was a perfect shot\n            const perfectShotMinThreshold = 0.75; // 85% charge\n            const perfectShotMaxThreshold = 0.98; // 95% charge\n            const isPerfectShot = finalChargeProgress >= perfectShotMinThreshold && finalChargeProgress <= perfectShotMaxThreshold;\n            this.onBowReleaseCallback(finalChargeProgress, isPerfectShot);\n        }\n    }\n    setWeaponLevel(level) {\n        this.currentLevel = level;\n    }\n    getCurrentWeaponConfig() {\n        return {\n            weapon: this.currentWeapon,\n            subclass: this.currentSubclass,\n            level: this.currentLevel\n        };\n    }\n    // Getters for weapon state (for UI/rendering)\n    getCurrentWeapon() {\n        return this.currentWeapon;\n    }\n    getCurrentSubclass() {\n        return this.currentSubclass;\n    }\n    isWeaponCharging() {\n        return this.isCharging;\n    }\n    getChargeProgress() {\n        return this.chargeProgress;\n    }\n    isViperStingChargingActive() {\n        return this.isViperStingCharging;\n    }\n    getViperStingChargeProgress() {\n        return this.viperStingChargeProgress;\n    }\n    isBarrageChargingActive() {\n        return this.isBarrageCharging;\n    }\n    getBarrageChargeProgress() {\n        return this.barrageChargeProgress;\n    }\n    isCobraShotChargingActive() {\n        return this.isCobraShotCharging;\n    }\n    getCobraShotChargeProgress() {\n        return this.cobraShotChargeProgress;\n    }\n    isWeaponSwinging() {\n        return this.isSwinging;\n    }\n    // Sword-specific getters\n    getSwordComboStep() {\n        return this.swordComboStep;\n    }\n    isDivineStormActive() {\n        return this.isDivineStorming;\n    }\n    isChargeActive() {\n        return this.isSwordCharging;\n    }\n    isDeflectActive() {\n        return this.isDeflecting;\n    }\n    isSkyfallActive() {\n        return this.isSkyfalling;\n    }\n    isBackstabActive() {\n        return this.isBackstabbing;\n    }\n    isSunderActive() {\n        return this.isSundering;\n    }\n    handleSwordInput(playerTransform) {\n        // Handle sword melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isDivineStorming && !this.isSwordCharging && !this.isDeflecting) {\n            this.performSwordMeleeAttack(playerTransform);\n        }\n        // Handle Divine Storm ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting) {\n            this.performDivineStorm(playerTransform);\n        }\n        // Handle Charge ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwordCharging && !this.isDivineStorming && !this.isSwinging && !this.isDeflecting) {\n            this.performCharge(playerTransform);\n        }\n        // Handle Deflect ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeflecting && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging) {\n            this.performDeflect(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    performSwordMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sword-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.swordFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        // Set swinging state - completion will be handled by sword component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    // Called by sword component when swing animation completes\n    onSwordSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        // Reset swinging state\n        this.isSwinging = false;\n        // Advance combo step for next attack\n        this.swordComboStep = this.swordComboStep % 3 + 1;\n    }\n    handleSabresInput(playerTransform) {\n        // Handle left click for dual sabre attack\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performSabresMeleeAttack(playerTransform);\n        }\n        // Handle Q key for Backstab ability\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performBackstab(playerTransform);\n        }\n        // Handle E key for Sunder ability\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performSunder(playerTransform);\n        }\n        // Handle R key for Skyfall ability (switched from E)\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isSkyfalling && !this.isSundering) {\n            this.performSkyfall(playerTransform);\n        }\n        // Update Skyfall state if active\n        if (this.isSkyfalling) {\n            this.updateSkyfallMovement(playerTransform);\n        }\n        // Update Backstab state if active\n        if (this.isBackstabbing) {\n            this.updateBackstabState(playerTransform);\n        }\n        // Update Sunder state if active\n        if (this.isSundering) {\n            this.updateSunderState(playerTransform);\n        }\n    }\n    performSabresMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sabres-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.sabresFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        console.log(\"⚔️ Sabres dual attack initiated\");\n        // Set swinging state - completion will be handled by sabres component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (dual attack)\n        this.performSabresMeleeDamage(playerTransform);\n    }\n    // Called by sabres component when swing animation completes\n    onSabresSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\"⚔️ Sabres dual swing completed\");\n        // Reset swinging state\n        this.isSwinging = false;\n    }\n    performSabresMeleeDamage(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Get all entities that could be damaged\n        const allEntities = this.world.getAllEntities();\n        const potentialTargets = allEntities.filter((entity)=>entity.hasComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health) && entity.hasComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform) && entity !== this.playerEntity);\n        // SABRES DAMAGE\n        const attackRange = 3.8; // Slightly longer range than sword\n        const attackAngle = Math.PI / 2; // 60 degree cone (wider than sword)\n        const leftSabreDamage = 19;\n        const rightSabreDamage = 23;\n        // Get camera direction for attack direction\n        const attackDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(attackDirection);\n        attackDirection.normalize();\n        let hitCount = 0;\n        for (const target of potentialTargets){\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!targetTransform || !targetHealth || targetHealth.isDead) continue;\n            // Calculate direction to target\n            const directionToTarget = targetTransform.position.clone().sub(playerTransform.position);\n            const distanceToTarget = directionToTarget.length();\n            // Check if target is within range\n            if (distanceToTarget > attackRange) continue;\n            // Check if target is within attack cone\n            directionToTarget.normalize();\n            const dotProduct = attackDirection.dot(directionToTarget);\n            const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dotProduct)));\n            if (angleToTarget > attackAngle / 2) continue;\n            // Target is within range and cone - apply damage from both sabres\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                // Left sabre hit (immediate)\n                combatSystem.queueDamage(target, leftSabreDamage, this.playerEntity || undefined);\n                // Right sabre hit (with small delay)\n                setTimeout(()=>{\n                    if (!targetHealth.isDead) {\n                        combatSystem.queueDamage(target, rightSabreDamage, this.playerEntity || undefined);\n                    }\n                }, 100); // 100ms delay between sabre hits\n                hitCount++;\n            }\n        }\n    }\n    // Skyfall ability implementation\n    performSkyfall(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSkyfallTime < this.skyfallCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSkyfall()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(40);\n        // Start Skyfall\n        this.isSkyfalling = true;\n        this.skyfallPhase = \"ascending\";\n        this.skyfallStartTime = currentTime;\n        this.lastSkyfallTime = currentTime;\n        this.skyfallStartPosition.copy(playerTransform.position);\n        // Set target height (double jump height)\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            this.skyfallOriginalGravity = playerMovement.gravity;\n            this.skyfallTargetHeight = playerTransform.position.y + playerMovement.jumpForce * 1.4; // Reduced height by 30% (was 2x, now 1.4x)\n            // Apply upward velocity\n            playerMovement.velocity.y = playerMovement.jumpForce * 2; // Stronger initial velocity\n            playerMovement.gravity = 0; // Disable gravity during ascent\n        // Don't disable canMove as it prevents all physics updates including gravity\n        // Instead we'll control horizontal movement in the ControlSystem\n        }\n        // Trigger callback for multiplayer/visual effects\n        if (this.onSkyfallCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onSkyfallCallback(playerTransform.position, direction);\n        }\n    }\n    updateSkyfallMovement(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerMovement) return;\n        const elapsedTime = currentTime - this.skyfallStartTime;\n        switch(this.skyfallPhase){\n            case \"ascending\":\n                // Check if we've reached target height or started falling\n                if (playerTransform.position.y >= this.skyfallTargetHeight || playerMovement.velocity.y <= 0) {\n                    this.skyfallPhase = \"descending\";\n                    playerMovement.velocity.y = 0; // Stop at peak\n                    playerMovement.gravity = this.skyfallOriginalGravity * 30; // Faster descent\n                }\n                break;\n            case \"descending\":\n                // Check if we've landed (close to original height or on ground)\n                if (playerTransform.position.y <= this.skyfallStartPosition.y + 0.5) {\n                    this.skyfallPhase = \"landing\";\n                    this.performSkyfallLanding(playerTransform);\n                }\n                break;\n            case \"landing\":\n                // Landing phase complete\n                this.completeSkyfallAbility(playerTransform);\n                break;\n        }\n        // Safety timeout (if something goes wrong, end after 5 seconds)\n        if (elapsedTime > 4.0) {\n            this.completeSkyfallAbility(playerTransform);\n        }\n    }\n    performSkyfallLanding(playerTransform) {\n        // Deal damage to enemies in landing area\n        const allEntities = this.world.getAllEntities();\n        const landingPosition = playerTransform.position;\n        const damageRadius = 4.0; // 4 unit radius\n        const skyfallDamage = 125; // 125 damage as requested\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check distance to landing position\n            const distanceToLanding = landingPosition.distanceTo(targetTransform.position);\n            if (distanceToLanding <= damageRadius) {\n                // Apply Skyfall damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem) {\n                    combatSystem.queueDamage(entity, skyfallDamage, this.playerEntity || undefined);\n                    hitCount++;\n                }\n            }\n        }\n    }\n    completeSkyfallAbility(playerTransform) {\n        var _this_playerEntity;\n        // Reset all Skyfall states\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        // Restore player movement\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            playerMovement.gravity = this.skyfallOriginalGravity;\n            playerMovement.velocity.y = 0; // Stop any remaining vertical movement\n        }\n    }\n    updateBackstabState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.backstabStartTime;\n        // Check if backstab animation duration has elapsed\n        if (elapsedTime >= this.backstabDuration) {\n            this.isBackstabbing = false;\n        }\n    }\n    // Sunder ability implementation\n    performSunder(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSunderTime < this.sunderCooldown) {\n            return;\n        }\n        // Check energy cost (35 energy)\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSunder()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(35);\n        // Set cooldown\n        this.lastSunderTime = currentTime;\n        // Start sunder animation (same as backstab)\n        this.isSundering = true;\n        this.sunderStartTime = currentTime;\n        // Perform sunder damage with stacking logic\n        this.performSunderDamage(playerTransform);\n    }\n    updateSunderState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.sunderStartTime;\n        // Check if sunder animation duration has elapsed\n        if (elapsedTime >= this.sunderDuration) {\n            this.isSundering = false;\n        }\n    }\n    performSunderDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const sunderRange = 3.5; // Same range as backstab\n        let hitCount = 0;\n        const currentTime = Date.now() / 1000;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > sunderRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 4); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Apply Sunder stacks and calculate damage\n            const { damage, stackCount, isStunned } = this.applySunderStack(entity.id, currentTime);\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"sunder\");\n                // Apply stun effect if at 3 stacks\n                if (isStunned) {\n                    const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                    if (enemy) {\n                        enemy.freeze(4.0, currentTime); // 4 second stun (using freeze mechanics for movement)\n                        // Add visual stun effect (different from freeze)\n                        (0,_components_weapons_StunManager__WEBPACK_IMPORTED_MODULE_12__.addGlobalStunnedEnemy)(entity.id.toString(), targetTransform.position);\n                    }\n                    // Broadcast stun effect for PVP (using new 'stunned' type)\n                    // CRITICAL FIX: Check if we're about to target ourselves before broadcasting debuff\n                    if (this.onDebuffCallback) {\n                        const localSocketId = window.localSocketId;\n                        const serverPlayerEntities = window.serverPlayerEntities;\n                        let targetPlayerId = null;\n                        if (serverPlayerEntities && serverPlayerEntities.current) {\n                            serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                                if (localEntityId === entity.id) {\n                                    targetPlayerId = playerId;\n                                }\n                            });\n                        }\n                        // NEVER broadcast debuff to ourselves\n                        if (targetPlayerId && targetPlayerId !== localSocketId) {\n                            console.log(\"\\uD83C\\uDFAF Broadcasting stun effect to player \".concat(targetPlayerId, \" (NOT local player \").concat(localSocketId, \")\"));\n                            this.onDebuffCallback(entity.id, \"stunned\", 4000, targetTransform.position);\n                        } else {\n                            console.log(\"⚠️ Skipping stun broadcast - would target local player \".concat(localSocketId, \" or invalid target \").concat(targetPlayerId));\n                        }\n                    }\n                }\n                hitCount++;\n            }\n            // Trigger callback for multiplayer/visual effects\n            if (this.onSunderCallback) {\n                this.onSunderCallback(playerTransform.position, playerDirection, damage, stackCount);\n            }\n        }\n    }\n    applySunderStack(entityId, currentTime) {\n        const stackDuration = 10.0; // 10 seconds\n        let currentStacks = this.sunderStacks.get(entityId);\n        // Clean up expired stacks or initialize new entry\n        if (!currentStacks || currentTime - currentStacks.lastApplied > stackDuration) {\n            currentStacks = {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            };\n        }\n        // Calculate damage based on current stack count (before adding new stack)\n        const baseDamages = [\n            60,\n            70,\n            80,\n            90\n        ]; // 0, 1, 2, 3 stacks\n        const damage = baseDamages[Math.min(currentStacks.stacks, 3)];\n        let isStunned = false;\n        let newStackCount = currentStacks.stacks;\n        // Apply new stack\n        if (currentStacks.stacks < 3) {\n            newStackCount = currentStacks.stacks + 1;\n            this.sunderStacks.set(entityId, {\n                stacks: newStackCount,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        } else {\n            // At 3 stacks, apply stun and reset to 0 stacks\n            isStunned = true;\n            newStackCount = 0;\n            this.sunderStacks.set(entityId, {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        }\n        return {\n            damage,\n            stackCount: newStackCount,\n            isStunned\n        };\n    }\n    // Clean up expired Sunder stacks periodically\n    cleanupSunderStacks() {\n        const currentTime = Date.now() / 1000;\n        const stackDuration = 10.0;\n        // Convert to array to avoid iteration issues\n        const entries = Array.from(this.sunderStacks.entries());\n        for (const [entityId, stackData] of entries){\n            if (currentTime - stackData.lastApplied > stackDuration) {\n                this.sunderStacks.delete(entityId);\n            }\n        }\n    }\n    resetAllAbilityStates() {\n        // Reset all ability states when switching weapons\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.isBackstabbing = false;\n        this.isSundering = false;\n        this.isDivineStorming = false;\n        this.isSwordCharging = false;\n        this.isDeflecting = false;\n        // Clear Sunder stacks when switching weapons\n        this.sunderStacks.clear();\n    }\n    // Backstab ability implementation\n    performBackstab(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastBackstabTime < this.backstabCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastBackstab()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(60);\n        // Set cooldown\n        this.lastBackstabTime = currentTime;\n        // Start backstab animation\n        this.isBackstabbing = true;\n        this.backstabStartTime = currentTime;\n        // Trigger callback for multiplayer/visual effects\n        if (this.onBackstabCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onBackstabCallback(playerTransform.position, direction, 75, false); // Base damage, not backstab by default\n        }\n        // Perform backstab damage\n        this.performBackstabDamage(playerTransform);\n    }\n    performBackstabDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const backstabRange = 4.25; // Sabre melee range\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > backstabRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 3); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Determine if this is a backstab (attacking from behind the target)\n            let isBackstab = false;\n            let damage = 75; // Base damage\n            // For PVP players, check if we're behind them\n            const pvpPlayers = window.pvpPlayers;\n            const localSocketId = window.localSocketId;\n            if (pvpPlayers && localSocketId) {\n                // Find the target player in PVP players map\n                let targetPlayer = null;\n                for (const [playerId, player] of pvpPlayers){\n                    if (playerId !== localSocketId) {\n                        const playerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(player.position.x, player.position.y, player.position.z);\n                        if (playerPos.distanceTo(targetTransform.position) < 0.5) {\n                            targetPlayer = player;\n                            break;\n                        }\n                    }\n                }\n                if (targetPlayer) {\n                    // Calculate target's facing direction from their rotation\n                    const targetFacingDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(targetPlayer.rotation.y), 0, Math.cos(targetPlayer.rotation.y)).normalize();\n                    // Vector from target to attacker\n                    const attackerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(playerPosition, targetTransform.position).normalize();\n                    // Check if attacker is behind target (dot product < 0 means opposite direction)\n                    const behindDotProduct = targetFacingDirection.dot(attackerDirection);\n                    isBackstab = behindDotProduct < -0.3; // 70 degree cone behind target\n                    if (isBackstab) {\n                        damage = 175; // Backstab damage\n                    }\n                }\n            }\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"backstab\");\n                hitCount++;\n            }\n        }\n    }\n    performMeleeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Melee attack parameters - increased for PVP combat\n        const meleeRange = 4.5; // Increased attack range for PVP\n        const meleeAngle = Math.PI / 2; // 120 degree cone (60 degrees each side)\n        // Base damage values based on combo step - works for all subclasses\n        let baseDamage = 45; // Base sword damage\n        // Combo damage scaling\n        switch(this.swordComboStep){\n            case 1:\n                baseDamage = 40;\n                break;\n            case 2:\n                baseDamage = 45;\n                break;\n            case 3:\n                baseDamage = 55;\n                break; // Finisher does more damage\n        }\n        // Get combat system to apply damage\n        const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n        // Track enemies hit for rage generation\n        let enemiesHit = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            // Check if entity has enemy component and health\n            const enemyTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const enemyHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!enemyTransform || !enemyHealth || entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const enemyPosition = enemyTransform.position;\n            const toEnemy = enemyPosition.clone().sub(playerPosition);\n            const distance = toEnemy.length();\n            // Debug logging for PVP hit detection\n            // Check if enemy is within range\n            if (distance <= meleeRange) {\n                // Check if enemy is within attack cone\n                toEnemy.normalize();\n                const angle = direction.angleTo(toEnemy);\n                const angleDegrees = angle * 180 / Math.PI;\n                const maxAngleDegrees = meleeAngle / 2 * 180 / Math.PI;\n                if (angle <= meleeAngle / 2) {\n                    // Enemy is within attack cone - deal damage through combat system\n                    if (combatSystem && this.playerEntity) {\n                        // Queue damage through combat system (which will route to multiplayer for enemies)\n                        combatSystem.queueDamage(entity, baseDamage, this.playerEntity, \"melee\");\n                        enemiesHit++;\n                    }\n                }\n            }\n        });\n        // Generate rage only if we hit enemies (5 rage per hit, max 5 per swing)\n        if (enemiesHit > 0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const rageToGain = Math.min(enemiesHit * 5, 5); // 5 rage per hit, max 5 per swing\n                gameUI.gainRage(rageToGain);\n            }\n        }\n    }\n    checkForDashInput(movement, transform) {\n        // Check for double-tap on movement keys\n        const dashDirections = [\n            {\n                key: \"w\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)\n            },\n            {\n                key: \"s\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n            },\n            {\n                key: \"a\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0)\n            },\n            {\n                key: \"d\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0)\n            } // Right\n        ];\n        for (const { key, direction } of dashDirections){\n            if (this.inputManager.checkDoubleTap(key)) {\n                // Debug: Log the double tap detection\n                const debugInfo = this.inputManager.getDoubleTapDebugInfo(key);\n                // Convert input direction to world space based on camera orientation\n                const worldDirection = this.getWorldSpaceDirection(direction);\n                // Attempt to start dash\n                const currentTime = Date.now() / 1000; // Convert to seconds\n                const dashStarted = movement.startDash(worldDirection, transform.position, currentTime);\n                if (dashStarted) {\n                    // Reset the double-tap state to prevent multiple dashes\n                    this.inputManager.resetDoubleTap(key);\n                }\n                break; // Only process one dash per frame\n            }\n        }\n    }\n    handleDashMovement(movement, transform) {\n        if (!movement.isDashing) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        const dashResult = movement.updateDash(currentTime);\n        if (dashResult.newPosition) {\n            // Apply bounds checking (similar to old implementation)\n            const MAX_DASH_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = dashResult.newPosition.length();\n            if (distanceFromOrigin <= MAX_DASH_BOUNDS) {\n                transform.position.copy(dashResult.newPosition);\n            } else {\n                // Cancel dash if it would move too far from origin\n                // console.warn(`Dash cancelled: would move too far from origin (${distanceFromOrigin.toFixed(2)} > ${MAX_DASH_BOUNDS})`);\n                movement.cancelDash();\n            }\n        }\n    }\n    handleChargeMovement(movement, transform) {\n        if (!movement.isCharging) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        // Check if charge was stopped by collision\n        if (this.chargeStoppedByCollision) {\n            movement.cancelCharge();\n            return;\n        }\n        const chargeResult = movement.updateCharge(currentTime);\n        if (chargeResult.newPosition) {\n            // Apply bounds checking\n            const MAX_CHARGE_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = chargeResult.newPosition.length();\n            // Check for pillar collision\n            const pillarCollision = this.checkPillarCollision(chargeResult.newPosition);\n            if (distanceFromOrigin > MAX_CHARGE_BOUNDS) {\n                // Cancel charge if it would move too far from origin\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (pillarCollision.hasCollision) {\n                // Cancel charge if it would collide with a pillar\n                console.warn(\"Charge cancelled: would collide with pillar at [\".concat(pillarCollision.pillarCenter.toArray().join(\", \"), \"]\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (!this.chargeStoppedByCollision) {\n                // Only update position if not stopped by collision\n                transform.position.copy(chargeResult.newPosition);\n            }\n        }\n        if (chargeResult.isComplete || this.chargeStoppedByCollision) {\n            console.log(\"⚔️ Charge movement completed\");\n            // Notify sword component that charge is complete\n            this.onChargeComplete();\n        }\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    getWorldSpaceDirection(inputDirection) {\n        // Get camera direction vectors\n        const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(cameraDirection);\n        // Get camera's right vector\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Get camera's forward vector (projected on XZ plane)\n        const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n        // Transform input direction to world space\n        const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldDirection.addScaledVector(cameraRight, inputDirection.x);\n        worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n        worldDirection.normalize();\n        return worldDirection;\n    }\n    performDivineStorm(playerTransform) {\n        // Check if player has enough rage (minimum 20 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDivineStorm()) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDivineStormTime < this.divineStormCooldown) {\n            return;\n        }\n        // Get current rage amount and consume ALL rage\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40; // Fallback to 40 if gameUI not available\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 20\n        }\n        // Calculate extended duration: base 4 seconds + 1 second per 10 rage consumed\n        const baseStormDuration = 1000; // 4 seconds base\n        const bonusDuration = Math.floor(currentRage / 10) * 500; // 1 second per 10 rage\n        const totalDivineStormDuration = baseStormDuration + bonusDuration;\n        this.isDivineStorming = true;\n        this.lastDivineStormTime = currentTime;\n        // Trigger Divine Storm callback for multiplayer\n        if (this.onDivineStormCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDivineStormCallback(playerTransform.position.clone(), direction, totalDivineStormDuration);\n        }\n        // Divine Storm lasts for calculated duration\n        setTimeout(()=>{\n            this.isDivineStorming = false;\n        }, totalDivineStormDuration);\n    }\n    performCharge(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastChargeTime < this.chargeCooldown) {\n            return;\n        }\n        this.isSwordCharging = true;\n        this.lastChargeTime = currentTime;\n        // Reset collision tracking for new charge\n        this.chargeStoppedByCollision = false;\n        // Trigger Charge callback for multiplayer\n        if (this.onChargeCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onChargeCallback(playerTransform.position.clone(), direction);\n        }\n        // Gain rage for using charge ability (+20 rage)\n        const gameUI = window.gameUI;\n        if (gameUI) {\n            gameUI.gainRage(20);\n        }\n        // Start the charge movement using the separate charge system\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                // Get charge direction from camera\n                const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(direction);\n                direction.y = 0; // Keep movement horizontal\n                direction.normalize();\n                // Start charge with 10.5 distance (separate from dash system)\n                const chargeStarted = playerMovement.startCharge(direction, playerTransform.position, currentTime);\n                if (chargeStarted) {\n                    // Schedule charge damage detection during movement\n                    this.scheduleChargeDamage(playerTransform, direction, currentTime);\n                }\n            }\n        }\n    }\n    // Schedule damage detection during charge movement\n    scheduleChargeDamage(playerTransform, chargeDirection, startTime) {\n        const chargeDuration = 0.6;\n        const damageCheckInterval = 50; // Check for damage every 50ms for better collision detection\n        const chargeDamage = 40; // High damage for charge ability\n        const chargeRadius = 2.5; // Damage radius around player during charge\n        // Reset charge hit tracking\n        this.chargeHitEntities.clear();\n        this.chargeStoppedByCollision = false;\n        const damageInterval = setInterval(()=>{\n            const currentTime = Date.now() / 1000;\n            // Stop if charge is complete, cancelled, or stopped by collision\n            if (!this.isSwordCharging || currentTime - startTime > chargeDuration || this.chargeStoppedByCollision) {\n                clearInterval(damageInterval);\n                return;\n            }\n            // Get all entities in the world to check for damage\n            const allEntities = this.world.getAllEntities();\n            const playerPosition = playerTransform.position;\n            let hitSomething = false;\n            // Debug: Log all entities in the world during charge\n            // ENHANCED: Also check against server player positions directly as a fallback\n            // This ensures we don't miss collisions due to entity sync issues\n            const serverPlayers = window.pvpPlayers || new Map();\n            const localSocketId = window.localSocketId;\n            serverPlayers.forEach((serverPlayer, playerId)=>{\n                // Skip self\n                if (playerId === localSocketId) return;\n                // Skip already hit players (use hash of player ID for tracking)\n                const playerIdHash = playerId.length * 1000 + playerId.charCodeAt(0);\n                if (this.chargeHitEntities.has(playerIdHash)) return;\n                const serverPlayerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(serverPlayer.position.x, serverPlayer.position.y, serverPlayer.position.z);\n                const distance = playerPosition.distanceTo(serverPlayerPos);\n                const stopDistance = 0.9 + 1.0; // Player collision radius + buffer\n                if (distance <= stopDistance && serverPlayer.health > 0) {\n                    this.chargeHitEntities.add(playerIdHash);\n                    hitSomething = true;\n                    // Apply damage through PVP system if available\n                    if (this.onProjectileCreatedCallback) {\n                        this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                            damage: chargeDamage,\n                            targetId: playerId,\n                            hitPosition: {\n                                x: serverPlayerPos.x,\n                                y: serverPlayerPos.y,\n                                z: serverPlayerPos.z\n                            }\n                        });\n                    }\n                }\n            });\n            allEntities.forEach((entity)=>{\n                var _this_playerEntity;\n                // Skip self\n                if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n                // Skip already hit entities\n                if (this.chargeHitEntities.has(entity.id)) return;\n                // Check if entity has transform and health (could be enemy or player)\n                const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n                const entityCollider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n                // Debug: Log entity details\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n                const entityPosition = entityTransform.position;\n                const distance = playerPosition.distanceTo(entityPosition);\n                // Check if entity is within charge damage radius\n                // In PVP, we want to stop just before hitting the enemy, not overlap with them\n                const stopDistance = entityCollider ? entityCollider.radius + 1.0 : chargeRadius; // Stop 1 unit away from enemy edge\n                // Debug: Log position and distance information\n                if (distance <= stopDistance) {\n                    // Mark as hit to prevent multiple hits\n                    this.chargeHitEntities.add(entity.id);\n                    hitSomething = true;\n                    // Apply damage through combat system\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        combatSystem.queueDamage(entity, chargeDamage, this.playerEntity, \"charge\");\n                        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                        const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                        // Broadcast charge attack for PVP (includes damage and animation)\n                        if (this.onProjectileCreatedCallback) {\n                            this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                                damage: chargeDamage,\n                                targetId: entity.id,\n                                hitPosition: {\n                                    x: entityPosition.x,\n                                    y: entityPosition.y,\n                                    z: entityPosition.z\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            // In PVP mode, stop charge when hitting something\n            if (hitSomething) {\n                this.chargeStoppedByCollision = true;\n                // Stop the charge movement immediately\n                if (this.playerEntity) {\n                    const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                    if (playerMovement) {\n                        playerMovement.cancelCharge();\n                    }\n                }\n                // Clear the damage interval immediately to prevent further hits\n                clearInterval(damageInterval);\n                // Trigger charge completion\n                this.onChargeComplete();\n            }\n        }, damageCheckInterval);\n    }\n    // Called by sword component when Charge completes\n    onChargeComplete() {\n        this.isSwordCharging = false;\n    }\n    performDeflect(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeflectTime < this.deflectCooldown) {\n            return;\n        }\n        this.isDeflecting = true;\n        this.lastDeflectTime = currentTime;\n        // Trigger Deflect callback for multiplayer\n        if (this.onDeflectCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDeflectCallback(playerTransform.position.clone(), direction);\n        }\n        // Set up deflect barrier that blocks damage and reflects projectiles\n        this.setupDeflectBarrier(playerTransform);\n        // Auto-complete deflect after duration\n        setTimeout(()=>{\n            this.onDeflectComplete();\n        }, this.deflectDuration * 1000);\n    }\n    performViperSting(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastViperStingTime < this.viperStingFireRate) {\n            return;\n        }\n        // Check if player has enough energy (60 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastViperSting()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(60);\n        }\n        this.isViperStingCharging = true;\n        this.viperStingChargeProgress = 0;\n        this.lastViperStingTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.viperStingChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.viperStingChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireViperSting(playerTransform);\n                this.isViperStingCharging = false;\n                this.viperStingChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireViperSting(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Viper Sting damage is handled by ViperStingManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage\n        // Trigger Viper Sting callback for visual effects\n        if (this.onViperStingCallback) {\n            this.onViperStingCallback(playerPosition, direction);\n        }\n        // Trigger the global Viper Sting manager for visual effects\n        const success = (0,_components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_14__.triggerGlobalViperSting)();\n        if (success) {\n        // console.log('🐍 Viper Sting visual effects successfully triggered!');\n        }\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"viper_sting_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 61,\n                lifetime: 5,\n                isReturning: false\n            });\n        }\n    }\n    performBarrage(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastBarrageTime < this.barrageFireRate) {\n            console.log(\"⏰ Barrage on cooldown for \".concat((this.barrageFireRate - (currentTime - this.lastBarrageTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastBarrage()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isBarrageCharging = true;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 500; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.barrageChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.barrageChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireBarrage(playerTransform);\n                this.isBarrageCharging = false;\n                this.barrageChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireBarrage(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        // Apply same downward compensation as projectile system\n        const compensationAngle = Math.PI / 6; // 30 degrees\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Create 5 arrows: center (0°), left (15°, 30°), right (-15°, -30°) using proper ECS projectiles\n        const angles = [\n            0,\n            Math.PI / 12,\n            -Math.PI / 12,\n            Math.PI / 6,\n            -Math.PI / 6\n        ]; // 0°, 15°, -15°, 30°, -30°\n        angles.forEach((angle)=>{\n            // Rotate the base direction by the specified angle around the Y axis\n            const projectileDirection = direction.clone();\n            const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationY(angle);\n            projectileDirection.applyMatrix4(rotationMatrix);\n            projectileDirection.normalize();\n            // Offset spawn position slightly forward to avoid collision with player\n            const spawnPosition = playerPosition.clone();\n            spawnPosition.add(projectileDirection.clone().multiplyScalar(1)); // 1 unit forward\n            // Create proper ECS projectile entity\n            const projectileConfig = {\n                speed: 22,\n                damage: 30,\n                lifetime: 8,\n                maxDistance: 25,\n                piercing: false,\n                subclass: this.currentSubclass,\n                level: 1,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, spawnPosition, projectileDirection, this.playerEntity.id, projectileConfig);\n            // Mark as barrage arrow for visual identification\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__.Renderer);\n            if (renderer === null || renderer === void 0 ? void 0 : renderer.mesh) {\n                renderer.mesh.userData.isBarrageArrow = true;\n                renderer.mesh.userData.isRegularArrow = false; // Override regular arrow marking\n            }\n            // Broadcast projectile creation to other players\n            if (this.onProjectileCreatedCallback) {\n                this.onProjectileCreatedCallback(\"barrage_projectile\", spawnPosition, projectileDirection, projectileConfig);\n            }\n        });\n        // Trigger Barrage callback for additional visual effects if needed\n        if (this.onBarrageCallback) {\n            this.onBarrageCallback(playerPosition, direction);\n        }\n    }\n    setupDeflectBarrier(playerTransform) {\n        // Activate the deflect barrier\n        const playerPosition = playerTransform.getWorldPosition();\n        const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n        if (this.playerEntity) {\n            const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (movement && movement.inputStrength > 0.1) {\n                // Player is actively moving - use movement direction (same as DragonRenderer)\n                const moveDir = movement.moveDirection;\n                if (moveDir.length() > 0.1) {\n                    const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                    playerRotation.y = moveAngle;\n                }\n            } else {\n                // Not moving - use camera direction (same as DragonRenderer fallback)\n                const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(cameraDirection);\n                playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n            }\n        }\n        this.deflectBarrier.activate(playerPosition, playerRotation, this.playerEntity || undefined);\n    }\n    updateDeflectBarrier(playerTransform) {\n        // Update deflect barrier position if it's active\n        if (this.deflectBarrier.isBarrierActive()) {\n            const playerPosition = playerTransform.getWorldPosition();\n            const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n            if (this.playerEntity) {\n                const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                if (movement && movement.inputStrength > 0.1) {\n                    // Player is actively moving - use movement direction (same as DragonRenderer)\n                    const moveDir = movement.moveDirection;\n                    if (moveDir.length() > 0.1) {\n                        const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                        playerRotation.y = moveAngle;\n                    }\n                } else {\n                    // Not moving - use camera direction (same as DragonRenderer fallback)\n                    const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    this.camera.getWorldDirection(cameraDirection);\n                    playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n                }\n            }\n            // Update barrier position to follow player\n            this.deflectBarrier.updatePosition(playerPosition, playerRotation);\n        }\n    }\n    // Called by sword component when Deflect completes\n    onDeflectComplete() {\n        this.isDeflecting = false;\n        this.deflectBarrier.deactivate();\n    }\n    // Public methods to get cooldown information for UI\n    getWeaponSwitchCooldown() {\n        const currentTime = Date.now() / 1000;\n        return {\n            current: Math.max(0, this.weaponSwitchCooldown - (currentTime - this.lastWeaponSwitchTime)),\n            max: this.weaponSwitchCooldown\n        };\n    }\n    getAbilityCooldowns() {\n        const currentTime = Date.now() / 1000;\n        const cooldowns = {};\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deflectCooldown - (currentTime - this.lastDeflectTime)),\n                max: this.deflectCooldown,\n                isActive: this.isDeflecting\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.chargeCooldown - (currentTime - this.lastChargeTime)),\n                max: this.chargeCooldown,\n                isActive: this.isSwordCharging\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.divineStormCooldown - (currentTime - this.lastDivineStormTime)),\n                max: this.divineStormCooldown,\n                isActive: this.isDivineStorming\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.barrageFireRate - (currentTime - this.lastBarrageTime)),\n                max: this.barrageFireRate,\n                isActive: this.isBarrageCharging\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)),\n                max: this.cobraShotFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.viperStingFireRate - (currentTime - this.lastViperStingTime)),\n                max: this.viperStingFireRate,\n                isActive: this.isViperStingCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, 1.0 - (currentTime - this.lastReanimateTime)),\n                max: 1.0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)),\n                max: this.frostNovaFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.crossentropyFireRate - (currentTime - this.lastCrossentropyTime)),\n                max: this.crossentropyFireRate,\n                isActive: false\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.backstabCooldown - (currentTime - this.lastBackstabTime)),\n                max: this.backstabCooldown,\n                isActive: this.isBackstabbing\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.sunderCooldown - (currentTime - this.lastSunderTime)),\n                max: this.sunderCooldown,\n                isActive: this.isSundering\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.skyfallCooldown - (currentTime - this.lastSkyfallTime)),\n                max: this.skyfallCooldown,\n                isActive: this.isSkyfalling\n            };\n        }\n        return cooldowns;\n    }\n    constructor(camera, inputManager, world, projectileSystem){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        this.playerEntity = null;\n        // Rate limiting for projectile firing\n        this.lastFireTime = 0;\n        this.lastCrossentropyTime = 0 // Separate tracking for CrossentropyBolt\n        ;\n        this.lastReanimateTime = 0 // Separate tracking for Reanimate ability\n        ;\n        this.lastViperStingTime = 0;\n        this.lastFrostNovaTime = 0 // Separate tracking for Frost Nova ability\n        ;\n        this.lastCobraShotTime = 0 // Separate tracking for Cobra Shot ability\n        ;\n        this.fireRate = 0.2 // Default for bow\n        ;\n        this.swordFireRate = 0.9 // Rate for sword attacks\n        ;\n        this.sabresFireRate = 0.6 // Sabres dual attack rate (600ms between attacks)\n        ;\n        this.scytheFireRate = 0.375 // EntropicBolt rate (0.33s cooldown)\n        ;\n        this.crossentropyFireRate = 2 // CrossentropyBolt rate (1 per second)\n        ;\n        this.viperStingFireRate = 2.5 // Viper Sting rate (2 seconds cooldown)\n        ;\n        this.frostNovaFireRate = 12.0 // Frost Nova rate (12 seconds cooldown)\n        ;\n        this.cobraShotFireRate = 2.5 // Cobra Shot rate (2 seconds cooldown)\n        ;\n        // Current weapon configuration\n        this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW // Default weapon\n        ;\n        this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL // Default for bow\n        ;\n        this.currentLevel = 1;\n        // Weapon-specific states\n        this.isCharging = false;\n        this.chargeProgress = 0;\n        this.isSwinging = false;\n        // Viper Sting charging state\n        this.isViperStingCharging = false;\n        this.viperStingChargeProgress = 0;\n        // Barrage charging state\n        this.isBarrageCharging = false;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = 0;\n        this.barrageFireRate = 5.0 // 5 second cooldown (keeping as requested)\n        ;\n        // Cobra Shot charging state\n        this.isCobraShotCharging = false;\n        this.cobraShotChargeProgress = 0;\n        // Sword-specific states\n        this.swordComboStep = 1;\n        this.lastSwordAttackTime = 0;\n        this.swordComboResetTime = 1 // Reset combo after 1 seconds\n        ;\n        // Divine Storm ability state\n        this.isDivineStorming = false;\n        this.lastDivineStormTime = 0;\n        this.divineStormCooldown = 8.0 // 8 second cooldown\n        ;\n        // Charge ability state\n        this.isSwordCharging = false;\n        this.lastChargeTime = 0;\n        this.chargeCooldown = 8.0 // 8 second cooldown\n        ;\n        // Deflect ability state\n        this.isDeflecting = false;\n        this.lastDeflectTime = 0;\n        this.deflectCooldown = 6.0 // 8 second cooldown\n        ;\n        this.deflectDuration = 3.0 // 3 second duration\n        ;\n        // Skyfall ability state (Sabres)\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.lastSkyfallTime = 0;\n        this.skyfallCooldown = 5.0 // 4 second cooldown\n        ;\n        this.skyfallStartTime = 0;\n        this.skyfallStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.skyfallTargetHeight = 0;\n        this.skyfallOriginalGravity = 0;\n        // Backstab ability state (Sabres)\n        this.lastBackstabTime = 0;\n        this.backstabCooldown = 1.5 // 2 second cooldown\n        ;\n        this.isBackstabbing = false;\n        this.backstabStartTime = 0;\n        this.backstabDuration = 1.0 // Total animation duration (0.3 + 0.4 + 0.3 seconds)\n        ;\n        // Sunder ability state (Sabres)\n        this.lastSunderTime = 0;\n        this.sunderCooldown = 1.125 // 1.5 second cooldown\n        ;\n        this.isSundering = false;\n        this.sunderStartTime = 0;\n        this.sunderDuration = 1.0 // Same animation duration as backstab\n        ;\n        // Sunder stack tracking - Map of entity ID to stack data\n        this.sunderStacks = new Map();\n        this.lastWeaponSwitchTime = 0;\n        this.weaponSwitchCooldown = 1.5 // 200ms cooldown to prevent rapid switching\n        ;\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Track charge hit entities to prevent multiple hits and enable collision stopping\n        this.chargeHitEntities = new Set();\n        this.chargeStoppedByCollision = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.world = world;\n        this.projectileSystem = projectileSystem;\n        this.deflectBarrier = new _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__.DeflectBarrier(world);\n        this.priority = 5; // Run early for input handling\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUEyQztBQUNjO0FBR25CO0FBRWlCO0FBQ0Y7QUFDSjtBQUNGO0FBQ007QUFDQTtBQUlQO0FBQzJCO0FBQ0o7QUFDZ0M7QUFDNUI7QUFDVTtBQUNFO0FBRTlFLE1BQU1rQixzQkFBc0JoQiwrQ0FBTUE7SUF5SmhDaUIsVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsWUFBWSxHQUFHRDtJQUN0QjtJQUVPRSxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNILFlBQVksRUFBRTtRQUV4QixNQUFNSSxrQkFBa0IsSUFBSSxDQUFDSixZQUFZLENBQUNLLFlBQVksQ0FBQ3ZCLGdFQUFTQTtRQUNoRSxNQUFNd0IsaUJBQWlCLElBQUksQ0FBQ04sWUFBWSxDQUFDSyxZQUFZLENBQUN0Qiw4REFBUUE7UUFFOUQsSUFBSSxDQUFDcUIsbUJBQW1CLENBQUNFLGdCQUFnQjtRQUV6Qyw2QkFBNkI7UUFDN0IsSUFBSSxPQUFPQSxlQUFlQyxhQUFhLEtBQUssWUFBWTtZQUN0REQsZUFBZUMsYUFBYTtRQUM5QjtRQUVBLDhDQUE4QztRQUM5QyxJQUFJLENBQUNDLG1CQUFtQjtRQUV4QiwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDQyxxQkFBcUI7UUFFMUIsMERBQTBEO1FBQzFELElBQUksQ0FBQ0Msa0JBQWtCLENBQUNKLGdCQUFnQkY7UUFFeEMsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ08sb0JBQW9CLENBQUNMLGdCQUFnQkY7UUFFMUMsc0ZBQXNGO1FBQ3RGLElBQUksQ0FBQ0UsZUFBZU0sU0FBUyxJQUFJLENBQUNOLGVBQWVPLFVBQVUsSUFBSSxDQUFDUCxlQUFlUSxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUM3RyxJQUFJLENBQUNDLG1C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SXBFLG1GQUFtRjthQUMzRXNCLG9CQUFvQixJQUFJMEQ7YUFDeEJsRywyQkFBMkI7UUEzN0RqQyxJQUFJLENBQUNuVyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUCxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ21GLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN3QixnQkFBZ0IsR0FBR0E7UUFDeEIsSUFBSSxDQUFDc1YsY0FBYyxHQUFHLElBQUlqZSwrRUFBY0EsQ0FBQ21IO1FBQ3pDLElBQUksQ0FBQzBYLFFBQVEsR0FBRyxHQUFHLCtCQUErQjtJQUNwRDtBQTY3RUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ29udHJvbFN5c3RlbS50cz8yYzI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnRyb2wgc3lzdGVtIGZvciBwbGF5ZXIgaW5wdXQgaGFuZGxpbmdcbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDQgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcbmltcG9ydCB7IENvbGxpZGVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBJbnB1dE1hbmFnZXIgfSBmcm9tICdAL2NvcmUvSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5pbXBvcnQgeyBDb21iYXRTeXN0ZW0gfSBmcm9tICcuL0NvbWJhdFN5c3RlbSc7XG5pbXBvcnQgeyBXZWFwb25TdWJjbGFzcywgV2VhcG9uVHlwZSB9IGZyb20gJ0AvY29tcG9uZW50cy9kcmFnb24vd2VhcG9ucyc7XG5pbXBvcnQgeyBEZWZsZWN0QmFycmllciB9IGZyb20gJ0AvY29tcG9uZW50cy93ZWFwb25zL0RlZmxlY3RCYXJyaWVyJztcbmltcG9ydCB7IHRyaWdnZXJHbG9iYWxGcm9zdE5vdmEsIGFkZEdsb2JhbEZyb3plbkVuZW15IH0gZnJvbSAnQC9jb21wb25lbnRzL3dlYXBvbnMvRnJvc3ROb3ZhTWFuYWdlcic7XG5pbXBvcnQgeyBhZGRHbG9iYWxTdHVubmVkRW5lbXkgfSBmcm9tICdAL2NvbXBvbmVudHMvd2VhcG9ucy9TdHVuTWFuYWdlcic7XG5pbXBvcnQgeyB0cmlnZ2VyR2xvYmFsQ29icmFTaG90IH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0NvYnJhU2hvdE1hbmFnZXInO1xuaW1wb3J0IHsgdHJpZ2dlckdsb2JhbFZpcGVyU3RpbmcgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvVmlwZXJTdGluZ01hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgQ29udHJvbFN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBNb3ZlbWVudF07XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FtZXJhOiBQZXJzcGVjdGl2ZUNhbWVyYTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbTtcbiAgcHJpdmF0ZSBwbGF5ZXJFbnRpdHk6IEVudGl0eSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJvdyByZWxlYXNlIGVmZmVjdHNcbiAgcHJpdmF0ZSBvbkJvd1JlbGVhc2VDYWxsYmFjaz86IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIERpdmluZSBTdG9ybSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EaXZpbmVTdG9ybUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgcHJvamVjdGlsZSBjcmVhdGlvblxuICBwcml2YXRlIG9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaz86IChwcm9qZWN0aWxlVHlwZTogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBjb25maWc6IGFueSkgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBWaXBlciBTdGluZyBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25WaXBlclN0aW5nQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBCYXJyYWdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkJhcnJhZ2VDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIFJlYW5pbWF0ZSBoZWFsaW5nIGVmZmVjdFxuICBwcml2YXRlIG9uUmVhbmltYXRlQ2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEZyb3N0IE5vdmEgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uRnJvc3ROb3ZhQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBDb2JyYSBTaG90IGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNvYnJhU2hvdENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgQ2hhcmdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNoYXJnZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgRGVmbGVjdCBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EZWZsZWN0Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgZGVidWZmIGVmZmVjdHMgaW4gUFZQXG4gIHByaXZhdGUgb25EZWJ1ZmZDYWxsYmFjaz86ICh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnIHwgJ3N0dW5uZWQnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBTa3lmYWxsIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblNreWZhbGxDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEJhY2tzdGFiIGFiaWxpdHlcbiAgcHJpdmF0ZSBvbkJhY2tzdGFiQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZGFtYWdlOiBudW1iZXIsIGlzQmFja3N0YWI6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgU3VuZGVyIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblN1bmRlckNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGRhbWFnZTogbnVtYmVyLCBzdGFja0NvdW50OiBudW1iZXIpID0+IHZvaWQ7XG4gIFxuICAvLyBSYXRlIGxpbWl0aW5nIGZvciBwcm9qZWN0aWxlIGZpcmluZ1xuICBwcml2YXRlIGxhc3RGaXJlVGltZSA9IDA7XG4gIHByaXZhdGUgbGFzdENyb3NzZW50cm9weVRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICBwcml2YXRlIGxhc3RSZWFuaW1hdGVUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIFJlYW5pbWF0ZSBhYmlsaXR5XG4gIHByaXZhdGUgbGFzdFZpcGVyU3RpbmdUaW1lID0gMDtcbiAgcHJpdmF0ZSBsYXN0RnJvc3ROb3ZhVGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBGcm9zdCBOb3ZhIGFiaWxpdHlcbiAgcHJpdmF0ZSBsYXN0Q29icmFTaG90VGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBDb2JyYSBTaG90IGFiaWxpdHlcbiAgcHJpdmF0ZSBmaXJlUmF0ZSA9IDAuMjsgLy8gRGVmYXVsdCBmb3IgYm93XG4gIHByaXZhdGUgc3dvcmRGaXJlUmF0ZSA9IDAuOTsgLy8gUmF0ZSBmb3Igc3dvcmQgYXR0YWNrc1xuICBwcml2YXRlIHNhYnJlc0ZpcmVSYXRlID0gMC42OyAvLyBTYWJyZXMgZHVhbCBhdHRhY2sgcmF0ZSAoNjAwbXMgYmV0d2VlbiBhdHRhY2tzKVxuICBwcml2YXRlIHNjeXRoZUZpcmVSYXRlID0gMC4zNzU7IC8vIEVudHJvcGljQm9sdCByYXRlICgwLjMzcyBjb29sZG93bilcbiAgcHJpdmF0ZSBjcm9zc2VudHJvcHlGaXJlUmF0ZSA9IDI7IC8vIENyb3NzZW50cm9weUJvbHQgcmF0ZSAoMSBwZXIgc2Vjb25kKVxuICBwcml2YXRlIHZpcGVyU3RpbmdGaXJlUmF0ZSA9IDIuNTsgLy8gVmlwZXIgU3RpbmcgcmF0ZSAoMiBzZWNvbmRzIGNvb2xkb3duKVxuICBwcml2YXRlIGZyb3N0Tm92YUZpcmVSYXRlID0gMTIuMDsgLy8gRnJvc3QgTm92YSByYXRlICgxMiBzZWNvbmRzIGNvb2xkb3duKVxuICBwcml2YXRlIGNvYnJhU2hvdEZpcmVSYXRlID0gMi41OyAvLyBDb2JyYSBTaG90IHJhdGUgKDIgc2Vjb25kcyBjb29sZG93bilcbiAgXG4gIC8vIEN1cnJlbnQgd2VhcG9uIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBjdXJyZW50V2VhcG9uOiBXZWFwb25UeXBlID0gV2VhcG9uVHlwZS5CT1c7IC8vIERlZmF1bHQgd2VhcG9uXG4gIHByaXZhdGUgY3VycmVudFN1YmNsYXNzOiBXZWFwb25TdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkVMRU1FTlRBTDsgLy8gRGVmYXVsdCBmb3IgYm93XG4gIHByaXZhdGUgY3VycmVudExldmVsID0gMTtcbiAgXG4gIC8vIFdlYXBvbi1zcGVjaWZpYyBzdGF0ZXNcbiAgcHJpdmF0ZSBpc0NoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBwcml2YXRlIGlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgXG4gIC8vIFZpcGVyIFN0aW5nIGNoYXJnaW5nIHN0YXRlXG4gIHByaXZhdGUgaXNWaXBlclN0aW5nQ2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSB2aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBcbiAgLy8gQmFycmFnZSBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzQmFycmFnZUNoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgcHJpdmF0ZSBsYXN0QmFycmFnZVRpbWUgPSAwO1xuICBwcml2YXRlIGJhcnJhZ2VGaXJlUmF0ZSA9IDUuMDsgLy8gNSBzZWNvbmQgY29vbGRvd24gKGtlZXBpbmcgYXMgcmVxdWVzdGVkKVxuICBcbiAgLy8gQ29icmEgU2hvdCBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzQ29icmFTaG90Q2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIFxuICAvLyBTd29yZC1zcGVjaWZpYyBzdGF0ZXNcbiAgcHJpdmF0ZSBzd29yZENvbWJvU3RlcDogMSB8IDIgfCAzID0gMTtcbiAgcHJpdmF0ZSBsYXN0U3dvcmRBdHRhY2tUaW1lID0gMDtcbiAgcHJpdmF0ZSBzd29yZENvbWJvUmVzZXRUaW1lID0gMTsgLy8gUmVzZXQgY29tYm8gYWZ0ZXIgMSBzZWNvbmRzXG4gIFxuICAvLyBEaXZpbmUgU3Rvcm0gYWJpbGl0eSBzdGF0ZVxuICBwcml2YXRlIGlzRGl2aW5lU3Rvcm1pbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0RGl2aW5lU3Rvcm1UaW1lID0gMDtcbiAgcHJpdmF0ZSBkaXZpbmVTdG9ybUNvb2xkb3duID0gOC4wOyAvLyA4IHNlY29uZCBjb29sZG93blxuICBcbiAgLy8gQ2hhcmdlIGFiaWxpdHkgc3RhdGVcbiAgcHJpdmF0ZSBpc1N3b3JkQ2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0Q2hhcmdlVGltZSA9IDA7XG4gIHByaXZhdGUgY2hhcmdlQ29vbGRvd24gPSA4LjA7IC8vIDggc2Vjb25kIGNvb2xkb3duXG4gIFxuICAvLyBEZWZsZWN0IGFiaWxpdHkgc3RhdGVcbiAgcHJpdmF0ZSBpc0RlZmxlY3RpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0RGVmbGVjdFRpbWUgPSAwO1xuICBwcml2YXRlIGRlZmxlY3RDb29sZG93biA9IDYuMDsgLy8gOCBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBkZWZsZWN0RHVyYXRpb24gPSAzLjA7IC8vIDMgc2Vjb25kIGR1cmF0aW9uXG4gIHByaXZhdGUgZGVmbGVjdEJhcnJpZXI6IERlZmxlY3RCYXJyaWVyO1xuICBcbiAgLy8gU2t5ZmFsbCBhYmlsaXR5IHN0YXRlIChTYWJyZXMpXG4gIHByaXZhdGUgaXNTa3lmYWxsaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgc2t5ZmFsbFBoYXNlOiAnbm9uZScgfCAnYXNjZW5kaW5nJyB8ICdkZXNjZW5kaW5nJyB8ICdsYW5kaW5nJyA9ICdub25lJztcbiAgcHJpdmF0ZSBsYXN0U2t5ZmFsbFRpbWUgPSAwO1xuICBwcml2YXRlIHNreWZhbGxDb29sZG93biA9IDUuMDsgLy8gNCBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBza3lmYWxsU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBza3lmYWxsU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgc2t5ZmFsbFRhcmdldEhlaWdodCA9IDA7XG4gIHByaXZhdGUgc2t5ZmFsbE9yaWdpbmFsR3Jhdml0eSA9IDA7XG4gIFxuICAvLyBCYWNrc3RhYiBhYmlsaXR5IHN0YXRlIChTYWJyZXMpXG4gIHByaXZhdGUgbGFzdEJhY2tzdGFiVGltZSA9IDA7XG4gIHByaXZhdGUgYmFja3N0YWJDb29sZG93biA9IDEuNTsgLy8gMiBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBpc0JhY2tzdGFiYmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGJhY2tzdGFiU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBiYWNrc3RhYkR1cmF0aW9uID0gMS4wOyAvLyBUb3RhbCBhbmltYXRpb24gZHVyYXRpb24gKDAuMyArIDAuNCArIDAuMyBzZWNvbmRzKVxuICBcbiAgLy8gU3VuZGVyIGFiaWxpdHkgc3RhdGUgKFNhYnJlcylcbiAgcHJpdmF0ZSBsYXN0U3VuZGVyVGltZSA9IDA7XG4gIHByaXZhdGUgc3VuZGVyQ29vbGRvd24gPSAxLjEyNTsgLy8gMS41IHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGlzU3VuZGVyaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgc3VuZGVyU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBzdW5kZXJEdXJhdGlvbiA9IDEuMDsgLy8gU2FtZSBhbmltYXRpb24gZHVyYXRpb24gYXMgYmFja3N0YWJcbiAgXG4gIC8vIFN1bmRlciBzdGFjayB0cmFja2luZyAtIE1hcCBvZiBlbnRpdHkgSUQgdG8gc3RhY2sgZGF0YVxuICBwcml2YXRlIHN1bmRlclN0YWNrcyA9IG5ldyBNYXA8bnVtYmVyLCB7IHN0YWNrczogbnVtYmVyOyBsYXN0QXBwbGllZDogbnVtYmVyOyBkdXJhdGlvbjogbnVtYmVyIH0+KCk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmEsIFxuICAgIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyLCBcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0gPSBwcm9qZWN0aWxlU3lzdGVtO1xuICAgIHRoaXMuZGVmbGVjdEJhcnJpZXIgPSBuZXcgRGVmbGVjdEJhcnJpZXIod29ybGQpO1xuICAgIHRoaXMucHJpb3JpdHkgPSA1OyAvLyBSdW4gZWFybHkgZm9yIGlucHV0IGhhbmRsaW5nXG4gIH1cblxuICBwdWJsaWMgc2V0UGxheWVyKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgdGhpcy5wbGF5ZXJFbnRpdHkgPSBlbnRpdHk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG5cbiAgICBjb25zdCBwbGF5ZXJUcmFuc2Zvcm0gPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgXG4gICAgaWYgKCFwbGF5ZXJUcmFuc2Zvcm0gfHwgIXBsYXllck1vdmVtZW50KSByZXR1cm47XG5cbiAgICAvLyBVcGRhdGUgZGVidWZmIHN0YXRlcyBmaXJzdFxuICAgIGlmICh0eXBlb2YgcGxheWVyTW92ZW1lbnQudXBkYXRlRGVidWZmcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGxheWVyTW92ZW1lbnQudXBkYXRlRGVidWZmcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBleHBpcmVkIFN1bmRlciBzdGFja3MgcGVyaW9kaWNhbGx5XG4gICAgdGhpcy5jbGVhbnVwU3VuZGVyU3RhY2tzKCk7XG5cbiAgICAvLyBIYW5kbGUgd2VhcG9uIHN3aXRjaGluZ1xuICAgIHRoaXMuaGFuZGxlV2VhcG9uU3dpdGNoaW5nKCk7XG5cbiAgICAvLyBIYW5kbGUgZGFzaCBtb3ZlbWVudCBmaXJzdCAob3ZlcnJpZGVzIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5oYW5kbGVEYXNoTW92ZW1lbnQocGxheWVyTW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhcmdlIG1vdmVtZW50IChvdmVycmlkZXMgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmhhbmRsZUNoYXJnZU1vdmVtZW50KHBsYXllck1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gSGFuZGxlIHBsYXllciBtb3ZlbWVudCBpbnB1dCAob25seSBpZiBub3QgZGFzaGluZywgY2hhcmdpbmcsIGZyb3plbiwgb3Igc2t5ZmFsbGluZylcbiAgICBpZiAoIXBsYXllck1vdmVtZW50LmlzRGFzaGluZyAmJiAhcGxheWVyTW92ZW1lbnQuaXNDaGFyZ2luZyAmJiAhcGxheWVyTW92ZW1lbnQuaXNGcm96ZW4gJiYgIXRoaXMuaXNTa3lmYWxsaW5nKSB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVtZW50SW5wdXQocGxheWVyTW92ZW1lbnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgY29tYmF0IGlucHV0XG4gICAgdGhpcy5oYW5kbGVDb21iYXRJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBkZWZsZWN0IGJhcnJpZXIgcG9zaXRpb24gaWYgYWN0aXZlXG4gICAgdGhpcy51cGRhdGVEZWZsZWN0QmFycmllcihwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNb3ZlbWVudElucHV0KG1vdmVtZW50OiBNb3ZlbWVudCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcblxuICAgIGNvbnN0IHBsYXllclRyYW5zZm9ybSA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghcGxheWVyVHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICAvLyBDaGVjayBmb3IgZG91YmxlLXRhcCBkYXNoZXMgZmlyc3QgKGJlZm9yZSBwcm9jZXNzaW5nIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5jaGVja0ZvckRhc2hJbnB1dChtb3ZlbWVudCwgcGxheWVyVHJhbnNmb3JtKTtcblxuICAgIC8vIEdldCBpbnB1dCBkaXJlY3Rpb25cbiAgICBjb25zdCBpbnB1dERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIGxldCBoYXNJbnB1dCA9IGZhbHNlO1xuXG4gICAgLy8gV0FTRCBtb3ZlbWVudFxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3cnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueiAtPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdzJykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnogKz0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnYScpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi54IC09IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2QnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueCArPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBkaWFnb25hbCBtb3ZlbWVudFxuICAgIGlmIChpbnB1dERpcmVjdGlvbi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgaW5wdXQgdG8gd29ybGQgc3BhY2UgYmFzZWQgb24gY2FtZXJhIG9yaWVudGF0aW9uXG4gICAgaWYgKGhhc0lucHV0KSB7XG4gICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbWVyYSdzIHJpZ2h0IHZlY3RvclxuICAgICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGNhbWVyYURpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FtZXJhJ3MgZm9yd2FyZCB2ZWN0b3IgKHByb2plY3RlZCBvbiBYWiBwbGFuZSlcbiAgICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY2FtZXJhRm9yd2FyZC5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoMCwgMSwgMCksIGNhbWVyYVJpZ2h0KS5ub3JtYWxpemUoKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIGlucHV0IGRpcmVjdGlvbiB0byB3b3JsZCBzcGFjZVxuICAgICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYVJpZ2h0LCBpbnB1dERpcmVjdGlvbi54KTtcbiAgICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFGb3J3YXJkLCAtaW5wdXREaXJlY3Rpb24ueik7XG4gICAgICB3b3JsZERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgICAgbW92ZW1lbnQuc2V0TW92ZURpcmVjdGlvbih3b3JsZERpcmVjdGlvbiwgMS4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZW1lbnQuc2V0TW92ZURpcmVjdGlvbihuZXcgVmVjdG9yMygwLCAwLCAwKSwgMCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGp1bXBpbmdcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCcgJykpIHsgLy8gU3BhY2ViYXJcbiAgICAgIG1vdmVtZW50Lmp1bXAoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxhc3RXZWFwb25Td2l0Y2hUaW1lID0gMDtcbiAgcHJpdmF0ZSB3ZWFwb25Td2l0Y2hDb29sZG93biA9IDEuNTsgLy8gMjAwbXMgY29vbGRvd24gdG8gcHJldmVudCByYXBpZCBzd2l0Y2hpbmdcblxuICBwcml2YXRlIGhhbmRsZVdlYXBvblN3aXRjaGluZygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIFByZXZlbnQgcmFwaWQgd2VhcG9uIHN3aXRjaGluZ1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPCB0aGlzLndlYXBvblN3aXRjaENvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHdlYXBvbiBzd2l0Y2hpbmcgd2l0aCBudW1iZXIga2V5c1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzEnKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOyAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNXT1JEO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkRJVklOSVRZOyAvLyBEZWZhdWx0IHN3b3JkIHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSB0aGlzLnN3b3JkRmlyZVJhdGU7IC8vIFVzZSBzd29yZC1zcGVjaWZpYyBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gMTsgLy8gUmVzZXQgY29tYm8gd2hlbiBzd2l0Y2hpbmcgdG8gc3dvcmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnMicpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLkJPVykge1xuICAgICAgICB0aGlzLnJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOyAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLkJPVztcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5FTEVNRU5UQUw7IC8vIERlZmF1bHQgYm93IHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSAwLjIyNTsgLy8gQm93IGZpcmUgcmF0ZVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzMnKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5TQ1lUSEUpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5TQ1lUSEU7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuQ0hBT1M7IC8vIERlZmF1bHQgc2N5dGhlIHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSB0aGlzLnNjeXRoZUZpcmVSYXRlOyAvLyBVc2Ugc2N5dGhlIGZpcmUgcmF0ZSAoMC41cylcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCc0JykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU0FCUkVTKSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxBYmlsaXR5U3RhdGVzKCk7IC8vIFJlc2V0IGFsbCBhYmlsaXR5IHN0YXRlcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgICAgIHRoaXMuY3VycmVudFdlYXBvbiA9IFdlYXBvblR5cGUuU0FCUkVTO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkZST1NUOyAvLyBEZWZhdWx0IHNhYnJlcyBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zYWJyZXNGaXJlUmF0ZTsgLy8gVXNlIHNhYnJlcy1zcGVjaWZpYyBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ29tYmF0SW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLkJPVykge1xuICAgICAgdGhpcy5oYW5kbGVCb3dJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNDWVRIRSkge1xuICAgICAgdGhpcy5oYW5kbGVTY3l0aGVJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNXT1JEKSB7XG4gICAgICB0aGlzLmhhbmRsZVN3b3JkSW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQUJSRVMpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2FicmVzSW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUJvd0lucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIFZpcGVyIFN0aW5nIGFiaWxpdHkgd2l0aCAnUicga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncicpICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nICYmICF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIEJhcnJhZ2UgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykpIHtcblxuICAgICAgaWYgKCF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQ29icmEgU2hvdCBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSkge1xuXG4gICAgICBpZiAoIXRoaXMuaXNDaGFyZ2luZyAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgYm93IGNoYXJnaW5nIGFuZCBmaXJpbmdcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkpIHsgLy8gTGVmdCBtb3VzZSBidXR0b24gaGVsZFxuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmlzQ2hhcmdpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcblxuICAgICAgfVxuICAgICAgLy8gSW5jcmVhc2UgY2hhcmdlIHByb2dyZXNzIChjb3VsZCBiZSB0aW1lLWJhc2VkKVxuICAgICAgaWYgKCF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nICYmICF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IE1hdGgubWluKHRoaXMuY2hhcmdlUHJvZ3Jlc3MgKyAwLjAxMjUsIDEuMCk7IC8vIEJPVyBDSEFSR0UgU1BFRURcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgLy8gQ2hlY2sgaWYgYW55IGFiaWxpdHkgaXMgY2hhcmdpbmcgLSBpZiBzbywgY2FuY2VsIHRoZSByZWd1bGFyIGJvdyBzaG90XG4gICAgICBpZiAodGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyB8fCB0aGlzLmlzQmFycmFnZUNoYXJnaW5nIHx8IHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RvcmUgY2hhcmdlIHByb2dyZXNzIGJlZm9yZSByZXNldHRpbmcgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgICBjb25zdCBmaW5hbENoYXJnZVByb2dyZXNzID0gdGhpcy5jaGFyZ2VQcm9ncmVzcztcbiAgICAgIFxuICAgICAgLy8gUmVsZWFzZSB0aGUgYm93XG4gICAgICB0aGlzLmZpcmVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIHZpc3VhbCBlZmZlY3RzIGNhbGxiYWNrIHdpdGggdGhlIHN0b3JlZCBjaGFyZ2UgcHJvZ3Jlc3NcbiAgICAgIHRoaXMudHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzKGZpbmFsQ2hhcmdlUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlU2N5dGhlSW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgc2N5dGhlIGxlZnQgY2xpY2sgZm9yIEVudHJvcGljQm9sdFxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSkgeyAvLyBMZWZ0IG1vdXNlIGJ1dHRvbiBoZWxkXG4gICAgICBpZiAoIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmlzQ2hhcmdpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBTdGFydGVkIGNoYXJnaW5nIHNjeXRoZSAoc3Bpbm5pbmcpJyk7XG4gICAgICB9XG4gICAgICAvLyBJbmNyZWFzZSBjaGFyZ2UgcHJvZ3Jlc3MgY29udGludW91c2x5IGZvciBzcGlubmluZyBhbmltYXRpb24gKG5vIGNhcClcbiAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgKz0gMC4wMzsgLy8gQ29udGludW91c2x5IGluY3JlYXNlIGZvciBzcGlubmluZ1xuICAgICAgXG4gICAgICAvLyBGaXJlIEVudHJvcGljQm9sdCBwcm9qZWN0aWxlcyBjb250aW51b3VzbHkgd2hpbGUgc3Bpbm5pbmdcbiAgICAgIHRoaXMuZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgLy8gU3RvcCBzcGlubmluZyB3aGVuIG1vdXNlIGlzIHJlbGVhc2VkXG4gICAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQ3Jvc3NlbnRyb3B5Qm9sdCBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLmZpcmVDcm9zc2VudHJvcHlCb2x0QWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgUmVhbmltYXRlIGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybVJlYW5pbWF0ZUFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIEZyb3N0IE5vdmEgYWJpbGl0eSB3aXRoICdFJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdlJykgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtRnJvc3ROb3ZhQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmlyZVByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNsaWNraW5nXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuZmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBHZXQgZHJhZ29uJ3MgZmFjaW5nIGRpcmVjdGlvbiAoc2FtZSBhcyBjYW1lcmEgZGlyZWN0aW9uIHNpbmNlIGRyYWdvbiBmYWNlcyBjYW1lcmEpXG4gICAgLy8gVGhpcyBlbnN1cmVzIGFycm93cyBmaXJlIG91dHdhcmQgZnJvbSB3aGVyZSB0aGUgZHJhZ29uIGlzIGZhY2luZ1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIHRvIGFjY291bnQgZm9yIHJlc3RyaWN0ZWQgY2FtZXJhIGJvdW5kc1xuICAgIC8vIFNpbmNlIGNhbWVyYSBjYW4ndCBsb29rIGRvd24gbXVjaCBkdWUgdG8gYm91bmRzLCB3ZSBhZGQgYSBmaXhlZCBkb3dud2FyZCBhbmdsZVxuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXMgZG93bndhcmQgY29tcGVuc2F0aW9uXG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcm90YXRpb24gbWF0cml4IHRvIGFwcGx5IHRoZSBkb3dud2FyZCBhbmdsZSBhcm91bmQgdGhlIGNhbWVyYSdzIHJpZ2h0IGF4aXNcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBQZXJmZWN0IHNob3QgdGltaW5nIGNvbnN0YW50c1xuICAgIGNvbnN0IHBlcmZlY3RTaG90TWluVGhyZXNob2xkID0gMC43OyAvLyA4NSUgY2hhcmdlXG4gICAgY29uc3QgcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQgPSAwLjk4OyAvLyA5NSUgY2hhcmdlXG4gICAgY29uc3QgaXNQZXJmZWN0U2hvdCA9IHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPj0gcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgJiYgdGhpcy5jaGFyZ2VQcm9ncmVzcyA8PSBwZXJmZWN0U2hvdE1heFRocmVzaG9sZDtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBib3cgaXMgZnVsbHkgY2hhcmdlZCBmb3Igc3BlY2lhbCBwcm9qZWN0aWxlXG4gICAgaWYgKHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICB0aGlzLmNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChpc1BlcmZlY3RTaG90KSB7XG4gICAgICB0aGlzLmNyZWF0ZVBlcmZlY3RTaG90UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVidWc6IExvZyB0aGUgZmlyaW5nIGFuZ2xlIHRvIHZlcmlmeSBpdCdzIGNoYW5naW5nIHdpdGggY2FtZXJhIHJvdGF0aW9uXG4gICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56KTtcbiAgICAgIHRoaXMuY3JlYXRlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZpcmVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHVzZSBuZXcgc2N5dGhlIHJhdGUgKDAuMzUgc2Vjb25kcylcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5zY3l0aGVGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIEdldCBkcmFnb24ncyBmYWNpbmcgZGlyZWN0aW9uXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gKHNhbWUgYXMgYm93IHByb2plY3RpbGVzKVxuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXMgZG93bndhcmQgY29tcGVuc2F0aW9uXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCBzcGluU3RhdHVzID0gdGhpcy5pc0NoYXJnaW5nID8gJyAoU1BJTk5JTkcpJyA6ICcnO1xuICAgIFxuICAgIHRoaXMuY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUNyb3NzZW50cm9weUJvbHRBYmlsaXR5KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHVzZSBDcm9zc2VudHJvcHlCb2x0IHJhdGUgKDEgcGVyIHNlY29uZClcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENyb3NzZW50cm9weVRpbWUgPCB0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdENyb3NzZW50cm9weVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBHZXQgZHJhZ29uJ3MgZmFjaW5nIGRpcmVjdGlvblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgYW5nbGUgY29tcGVuc2F0aW9uIChzYW1lIGFzIGJvdyBwcm9qZWN0aWxlcylcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICBcbiAgICB0aGlzLmNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSB2YWxpZCB0YXJnZXRzIGluIHRoZSB3b3JsZCBiZWZvcmUgY3JlYXRpbmcgcHJvamVjdGlsZXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBjb25zdCB2YWxpZFRhcmdldHMgPSBwb3RlbnRpYWxUYXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gXG4gICAgICB0YXJnZXQuaWQgIT09IHRoaXMucGxheWVyRW50aXR5IS5pZCAmJiAvLyBOb3QgdGhlIHBsYXllciBpdHNlbGZcbiAgICAgICF0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk/LmlzRGVhZCAvLyBOb3QgZGVhZFxuICAgICk7XG4gICAgXG4gICAgLy8gSW4gbXVsdGlwbGF5ZXIgbW9kZSwgb25seSBjcmVhdGUgcHJvamVjdGlsZXMgaWYgdGhlcmUgYXJlIHZhbGlkIHRhcmdldHMgb3IgaWYgd2UgbmVlZCB0byBicm9hZGNhc3QgdG8gb3RoZXIgcGxheWVyc1xuICAgIGNvbnN0IGhhc1ZhbGlkVGFyZ2V0cyA9IHZhbGlkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNob3VsZEJyb2FkY2FzdCA9IHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrICE9PSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKCFoYXNWYWxpZFRhcmdldHMgJiYgIXNob3VsZEJyb2FkY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC43NTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIHByb2plY3RpbGUgdXNpbmcgdGhlIFByb2plY3RpbGVTeXN0ZW0gd2l0aCBjdXJyZW50IHdlYXBvbiBjb25maWdcbiAgICBjb25zdCBwcm9qZWN0aWxlQ29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDI1LFxuICAgICAgZGFtYWdlOiAxMCwgLy8gQXJyb3cgZGFtYWdlIHNob3VsZCBiZSAxMFxuICAgICAgbGlmZXRpbWU6IDMsXG4gICAgICBtYXhEaXN0YW5jZTogMjUsIC8vIExpbWl0IGJvdyBhcnJvd3MgdG8gMjUgdW5pdHMgZGlzdGFuY2VcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgcHJvamVjdGlsZUNvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3JlZ3VsYXJfYXJyb3cnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIHByb2plY3RpbGVDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgdmFsaWQgdGFyZ2V0cyBpbiB0aGUgd29ybGQgYmVmb3JlIGNyZWF0aW5nIHByb2plY3RpbGVzXG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBIZWFsdGgsIENvbGxpZGVyXSk7XG4gICAgY29uc3QgdmFsaWRUYXJnZXRzID0gcG90ZW50aWFsVGFyZ2V0cy5maWx0ZXIodGFyZ2V0ID0+IFxuICAgICAgdGFyZ2V0LmlkICE9PSB0aGlzLnBsYXllckVudGl0eSEuaWQgJiYgLy8gTm90IHRoZSBwbGF5ZXIgaXRzZWxmXG4gICAgICAhdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpPy5pc0RlYWQgLy8gTm90IGRlYWRcbiAgICApO1xuICAgIFxuICAgIC8vIEluIG11bHRpcGxheWVyIG1vZGUsIG9ubHkgY3JlYXRlIHByb2plY3RpbGVzIGlmIHRoZXJlIGFyZSB2YWxpZCB0YXJnZXRzIG9yIGlmIHdlIG5lZWQgdG8gYnJvYWRjYXN0IHRvIG90aGVyIHBsYXllcnNcbiAgICBjb25zdCBoYXNWYWxpZFRhcmdldHMgPSB2YWxpZFRhcmdldHMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBzaG91bGRCcm9hZGNhc3QgPSB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayAhPT0gdW5kZWZpbmVkO1xuICAgIFxuICAgIGlmICghaGFzVmFsaWRUYXJnZXRzICYmICFzaG91bGRCcm9hZGNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMTUgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RFbnRyb3BpY0JvbHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoMTApO1xuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIEVudHJvcGljQm9sdCBwcm9qZWN0aWxlIHVzaW5nIHRoZSBuZXcgbWV0aG9kXG4gICAgY29uc3QgZW50cm9waWNDb25maWcgPSB7XG4gICAgICBzcGVlZDogMjAsIC8vIEZhc3RlciB0aGFuIENyb3NzZW50cm9weUJvbHRcbiAgICAgIGRhbWFnZTogMjAsIC8vIEVudHJvcGljQm9sdCBkYW1hZ2VcbiAgICAgIGxpZmV0aW1lOiAyLCAvLyBTaG9ydGVyIGxpZmV0aW1lXG4gICAgICBwaWVyY2luZzogZmFsc2UsIC8vIE5vbi1waWVyY2luZyBzbyBwcm9qZWN0aWxlIGdldHMgZGVzdHJveWVkIG9uIGhpdFxuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gTm8gZXhwbG9zaW9uIGVmZmVjdFxuICAgICAgZXhwbG9zaW9uUmFkaXVzOiAwLCAvLyBObyBleHBsb3Npb24gcmFkaXVzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGVudHJvcGljQ29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnZW50cm9waWNfYm9sdCcsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgZW50cm9waWNDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICg0MCBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdENyb3NzZW50cm9weUJvbHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoNDApO1xuICAgICAgY29uc29sZS5sb2coJ+KalO+4jyBDb25zdW1lZCA0MCBtYW5hIGZvciBDcm9zc2VudHJvcHkgQm9sdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSB1c2luZyB0aGUgZXhpc3RpbmcgbWV0aG9kXG4gICAgY29uc3QgY3Jvc3NlbnRyb3B5Q29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDE1LCAvLyBTbG93ZXIgdGhhbiBFbnRyb3BpY0JvbHRcbiAgICAgIGRhbWFnZTogOTAsIC8vIEhpZ2hlciBkYW1hZ2UgZm9yIFIgYWJpbGl0eVxuICAgICAgbGlmZXRpbWU6IDIuNSwgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgICBwaWVyY2luZzogZmFsc2UsIC8vIFxuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gRGlzYWJsZWQgZXhwbG9zaW9uIGVmZmVjdCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIGV4cGxvc2lvblJhZGl1czogMCwgLy8gTm8gZXhwbG9zaW9uIHJhZGl1c1xuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgY3Jvc3NlbnRyb3B5Q29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY3Jvc3NlbnRyb3B5X2JvbHQnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGNyb3NzZW50cm9weUNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtUmVhbmltYXRlQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNhc3RpbmcgKDEgc2Vjb25kIGNvb2xkb3duKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVhbmltYXRlVGltZSA8IDEuMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RSZWFuaW1hdGVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMjAgbWFuYSBjb3N0IC0gZG91YmxlZCBmcm9tIDEwKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgY29uc3QgY3VycmVudE1hbmEgPSBnYW1lVUkgPyBnYW1lVUkuZ2V0Q3VycmVudE1hbmEoKSA6IDA7XG4gICAgXG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RSZWFuaW1hdGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBjb25zdCBtYW5hQmVmb3JlID0gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCk7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoMjApO1xuICAgICAgY29uc3QgbWFuYUFmdGVyID0gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFsd2F5cyB0cmlnZ2VyIHRoZSB2aXN1YWwgZWZmZWN0IGZpcnN0LCByZWdhcmRsZXNzIG9mIGhlYWxpbmcgc3VjY2Vzc1xuICAgIHRoaXMudHJpZ2dlclJlYW5pbWF0ZUVmZmVjdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIncyBoZWFsdGggY29tcG9uZW50IGFuZCBoZWFsIGZvciAzMCBIUCBcbiAgICBjb25zdCBoZWFsdGhDb21wb25lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoaGVhbHRoQ29tcG9uZW50KSB7XG4gICAgICBjb25zdCBkaWRIZWFsID0gaGVhbHRoQ29tcG9uZW50LmhlYWwoMzApOyAvLyBSRUFOSU1BVEUgSEVBTCBBTU9VTlRcbiAgICAgIGlmIChkaWRIZWFsKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn6m4IFJlYW5pbWF0ZSBoZWFsZWQgcGxheWVyIGZvciAzMCBIUC4gQ3VycmVudCBoZWFsdGg6ICR7aGVhbHRoQ29tcG9uZW50LmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoQ29tcG9uZW50Lm1heEhlYWx0aH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCfwn6m4IFJlYW5pbWF0ZSBjYXN0IHN1Y2Nlc3NmdWxseSBidXQgcGxheWVyIGFscmVhZHkgYXQgZnVsbCBoZWFsdGgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZWFuaW1hdGVFZmZlY3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBUcmlnZ2VyIHRoZSB2aXN1YWwgaGVhbGluZyBlZmZlY3RcbiAgICBcbiAgICBpZiAodGhpcy5vblJlYW5pbWF0ZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUmVhbmltYXRlQ2FsbGJhY2soKTtcbiAgICB9IFxuICAgIFxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRnJvc3ROb3ZhQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSA8IHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoNTAgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RGcm9zdE5vdmEoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoNTApO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmxhc3RGcm9zdE5vdmFUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBGcm9zdCBOb3ZhIGNhbGxiYWNrIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uRnJvc3ROb3ZhQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Gcm9zdE5vdmFDYWxsYmFjayhwbGF5ZXJQb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluZCBhbGwgZW5lbWllcyB3aXRoaW4gNSB1bml0IHJhZGl1cyBhbmQgZnJlZXplIHRoZW1cbiAgICB0aGlzLmZyZWV6ZUVuZW1pZXNJblJhZGl1cyhwbGF5ZXJQb3NpdGlvbiwgNi4wLCBjdXJyZW50VGltZSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBnbG9iYWwgZnJvc3Qgbm92YSB2aXN1YWwgZWZmZWN0XG4gICAgdHJpZ2dlckdsb2JhbEZyb3N0Tm92YShwbGF5ZXJQb3NpdGlvbik7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1Db2JyYVNob3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENvYnJhU2hvdFRpbWUgPCB0aGlzLmNvYnJhU2hvdEZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg0MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0Q29icmFTaG90KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDQwKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdENvYnJhU2hvdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBjaGFyZ2luZyBhbmltYXRpb25cbiAgICBjb25zdCBjaGFyZ2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gNzUwOyAvLyAwLjc1IHNlY29uZCBjaGFyZ2UgdGltZSAoYmV0d2VlbiBWaXBlciBTdGluZyBhbmQgQmFycmFnZSlcbiAgICBcbiAgICBjb25zdCBjaGFyZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gY2hhcmdlU3RhcnRUaW1lO1xuICAgICAgdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyBjaGFyZ2VEdXJhdGlvbiwgMS4wKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVDb2JyYVNob3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiAoc2FtZSBhcyBvdGhlciBwcm9qZWN0aWxlcylcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAwLjgyNTsgLy8gU2hvb3QgZnJvbSBjaGVzdCBsZXZlbCBsaWtlIFZpcGVyIFN0aW5nXG4gICAgXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBzYW1lIGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiBhcyBvdGhlciBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXMgZG93bndhcmQgY29tcGVuc2F0aW9uXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSByb3RhdGlvbiBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgdG8gdGlsdCB0aGUgZGlyZWN0aW9uIGRvd253YXJkXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gT2Zmc2V0IHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBsYXllclBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIFxuICAgIC8vIE5vdGU6IENvYnJhIFNob3QgZGFtYWdlIGlzIGhhbmRsZWQgYnkgQ29icmFTaG90TWFuYWdlciwgbm90IEVDUyBwcm9qZWN0aWxlc1xuICAgIC8vIFRoaXMgcHJldmVudHMgZHVwbGljYXRlIHByb2plY3RpbGVzIGFuZCBkYW1hZ2UgKHNpbWlsYXIgdG8gVmlwZXIgU3RpbmcpXG4gICAgXG4gICAgLy8gVHJpZ2dlciBDb2JyYSBTaG90IGNhbGxiYWNrIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uQ29icmFTaG90Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Db2JyYVNob3RDYWxsYmFjayhzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdsb2JhbCBjb2JyYSBzaG90IHdpdGggcHJvcGVyIHBvc2l0aW9uaW5nIChoYW5kbGVzIGxvY2FsIHZpc3VhbCBlZmZlY3RzIGFuZCBkYW1hZ2UpXG4gICAgdHJpZ2dlckdsb2JhbENvYnJhU2hvdChzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdjb2JyYV9zaG90X3Byb2plY3RpbGUnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIHtcbiAgICAgICAgc3BlZWQ6IDIwLCAvLyBDb25zaXN0ZW50IHNwZWVkIGZvciBQVlBcbiAgICAgICAgZGFtYWdlOiAyOSwgLy8gVXNlIGNvbnNpc3RlbnQgZGFtYWdlIHZhbHVlXG4gICAgICAgIGxpZmV0aW1lOiA4LFxuICAgICAgICB2ZW5vbUR1cmF0aW9uOiA2XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZyZWV6ZUVuZW1pZXNJblJhZGl1cyhjZW50ZXJQb3NpdGlvbjogVmVjdG9yMywgcmFkaXVzOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZFxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGxldCBmcm96ZW5Db3VudCA9IDA7XG4gICAgbGV0IGRhbWFnZWRQbGF5ZXJzID0gMDtcbiAgICBcbiAgICAvLyBHZXQgbG9jYWwgc29ja2V0IElEIHRvIHByZXZlbnQgc2VsZi10YXJnZXRpbmdcbiAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgZW50aXR5VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgZW50aXR5SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIWVudGl0eVRyYW5zZm9ybSB8fCAhZW50aXR5SGVhbHRoIHx8IGVudGl0eUhlYWx0aC5pc0RlYWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBzZWxmIChsb2NhbCBwbGF5ZXIgZW50aXR5KVxuICAgICAgaWYgKGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVudGl0eVBvc2l0aW9uID0gZW50aXR5VHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjZW50ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKGVudGl0eVBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGlzIHdpdGhpbiBmcmVlemUgcmFkaXVzXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZW5lbXkpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVuZW15IC0gZnJlZXplIGl0IChzaW5nbGUgcGxheWVyIG1vZGUpXG4gICAgICAgICAgZW5lbXkuZnJlZXplKDYuMCwgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGZyb3plbkNvdW50Kys7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIGZyb3plbiB2aXN1YWwgZWZmZWN0IGZvciB0aGlzIGVuZW15XG4gICAgICAgICAgYWRkR2xvYmFsRnJvemVuRW5lbXkoZW50aXR5LmlkLnRvU3RyaW5nKCksIGVudGl0eVBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGxpa2VseSBhbm90aGVyIHBsYXllciBpbiBQVlAgbW9kZSAtIGRlYWwgZGFtYWdlIGFuZCBmcmVlemVcbiAgICAgICAgICAvLyBDUklUSUNBTCBGSVg6IEZpcnN0IGNoZWNrIGlmIHRoaXMgZW50aXR5IHJlcHJlc2VudHMgdGhlIGxvY2FsIHBsYXllclxuICAgICAgICAgIGNvbnN0IHNlcnZlclBsYXllckVudGl0aWVzID0gKHdpbmRvdyBhcyBhbnkpLnNlcnZlclBsYXllckVudGl0aWVzO1xuICAgICAgICAgIGxldCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHNlcnZlclBsYXllckVudGl0aWVzICYmIHNlcnZlclBsYXllckVudGl0aWVzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHNlcnZlclBsYXllckVudGl0aWVzLmN1cnJlbnQuZm9yRWFjaCgobG9jYWxFbnRpdHlJZDogbnVtYmVyLCBwbGF5ZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChsb2NhbEVudGl0eUlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJJZCA9IHBsYXllcklkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTkVWRVIgZGFtYWdlIG9yIGRlYnVmZiBvdXJzZWx2ZXNcbiAgICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQgJiYgdGFyZ2V0UGxheWVySWQgPT09IGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDimqDvuI8gU2tpcHBpbmcgRnJvc3QgTm92YSBvbiBsb2NhbCBwbGF5ZXIgJHtsb2NhbFNvY2tldElkfWApO1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBTa2lwIHRoaXMgZW50aXR5IGNvbXBsZXRlbHlcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgICAgICBpZiAoY29tYmF0U3lzdGVtICYmIHRoaXMucGxheWVyRW50aXR5ICYmIHRhcmdldFBsYXllcklkKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9zdE5vdmFEYW1hZ2UgPSA1MDsgLy8gRnJvc3QgTm92YSBkYW1hZ2VcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIGZyb3N0Tm92YURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHksICdmcm9zdF9ub3ZhJyk7XG4gICAgICAgICAgICBkYW1hZ2VkUGxheWVycysrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBCcm9hZGNhc3QgZnJlZXplIGVmZmVjdCB0byB0aGUgdGFyZ2V0IHBsYXllciBzbyB0aGV5IGdldCBmcm96ZW4gb24gdGhlaXIgZW5kXG4gICAgICAgICAgICBpZiAodGhpcy5vbkRlYnVmZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIEJyb2FkY2FzdGluZyBmcmVlemUgZWZmZWN0IHRvIHBsYXllciAke3RhcmdldFBsYXllcklkfSAoTk9UIGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9KWApO1xuICAgICAgICAgICAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2soZW50aXR5LmlkLCAnZnJvemVuJywgNjAwMCwgZW50aXR5UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChmcm96ZW5Db3VudCA+IDApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDinYTvuI8gRnJvc3QgTm92YSBmcm96ZSAke2Zyb3plbkNvdW50fSBlbmVtaWVzIHdpdGhpbiAke3JhZGl1c30gdW5pdCByYWRpdXNgKTtcbiAgICB9XG4gICAgaWYgKGRhbWFnZWRQbGF5ZXJzID4gMCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYOKdhO+4jyBGcm9zdCBOb3ZhIGRhbWFnZWQgJHtkYW1hZ2VkUGxheWVyc30gcGxheWVycyB3aXRoaW4gJHtyYWRpdXN9IHVuaXQgcmFkaXVzYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDAuNTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIGNoYXJnZWQgYXJyb3cgcHJvamVjdGlsZSAtIG1vcmUgcG93ZXJmdWwgdGhhbiByZWd1bGFyIGFycm93c1xuICAgIGNvbnN0IGNoYXJnZWRBcnJvd0NvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAzNSwgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3MgKDI1KVxuICAgICAgZGFtYWdlOiA1MCwgLy8gTXVjaCBoaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3MgKDEwKVxuICAgICAgbGlmZXRpbWU6IDIsIC8vIExvbmdlciBsaWZldGltZSB0aGFuIHJlZ3VsYXIgYXJyb3dzICgzKVxuICAgICAgcGllcmNpbmc6IHRydWUsIC8vIENoYXJnZWQgYXJyb3dzIGNhbiBwaWVyY2UgdGhyb3VnaCBlbmVtaWVzXG4gICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24sIGJ1dCBjb3VsZCBhZGQgc3BlY2lhbCBlZmZlY3RzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGNoYXJnZWRBcnJvd0NvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2NoYXJnZWRfYXJyb3cnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGNoYXJnZWRBcnJvd0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC41OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgcGVyZmVjdCBzaG90IHByb2plY3RpbGUgLSBlbmhhbmNlZCBjaGFyZ2VkIGFycm93IHdpdGggc3BlY2lhbCBlZmZlY3RzXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAge1xuICAgICAgICBzcGVlZDogNDAsIC8vIEZhc3RlciB0aGFuIHJlZ3VsYXIgY2hhcmdlZCBhcnJvd3MgKDM1KVxuICAgICAgICBkYW1hZ2U6IDc1LCAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBjaGFyZ2VkIGFycm93cyAoNTApXG4gICAgICAgIGxpZmV0aW1lOiA2LCAvLyBMb25nZXIgbGlmZXRpbWUgdGhhbiByZWd1bGFyIGNoYXJnZWQgYXJyb3dzICg1KVxuICAgICAgICBwaWVyY2luZzogdHJ1ZSwgLy8gUGVyZmVjdCBzaG90cyBjYW4gcGllcmNlIHRocm91Z2ggZW5lbWllc1xuICAgICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24sIGJ1dCBoYXMgc3BlY2lhbCB2aXN1YWwgZWZmZWN0c1xuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygncGVyZmVjdF9zaG90Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiA0MCxcbiAgICAgICAgZGFtYWdlOiA3NSxcbiAgICAgICAgbGlmZXRpbWU6IDYsXG4gICAgICAgIHBpZXJjaW5nOiB0cnVlLFxuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2RzIHRvIGNvbmZpZ3VyZSB3ZWFwb24gZm9yIHRlc3RpbmdcbiAgcHVibGljIHNldFdlYXBvblN1YmNsYXNzKHN1YmNsYXNzOiBXZWFwb25TdWJjbGFzcyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gc3ViY2xhc3M7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gc2V0IGJvdyByZWxlYXNlIGNhbGxiYWNrXG4gIHB1YmxpYyBzZXRCb3dSZWxlYXNlQ2FsbGJhY2soY2FsbGJhY2s6IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkJvd1JlbGVhc2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGl2aW5lU3Rvcm1DYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0UHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjazogKHByb2plY3RpbGVUeXBlOiBzdHJpbmcsIHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGNvbmZpZzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFZpcGVyU3RpbmdDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0QmFycmFnZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25CYXJyYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRSZWFuaW1hdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25SZWFuaW1hdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RnJvc3ROb3ZhQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRDb2JyYVNob3RDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29icmFTaG90Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldENoYXJnZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFyZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGVmbGVjdENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EZWZsZWN0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFNreWZhbGxDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uU2t5ZmFsbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRCYWNrc3RhYkNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZGFtYWdlOiBudW1iZXIsIGlzQmFja3N0YWI6IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQmFja3N0YWJDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0U3VuZGVyQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBkYW1hZ2U6IG51bWJlciwgc3RhY2tDb3VudDogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblN1bmRlckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREZWJ1ZmZDYWxsYmFjayhjYWxsYmFjazogKHRhcmdldEVudGl0eUlkOiBudW1iZXIsIGRlYnVmZlR5cGU6ICdmcm96ZW4nIHwgJ3Nsb3dlZCcgfCAnc3R1bm5lZCcsIGR1cmF0aW9uOiBudW1iZXIsIHBvc2l0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRlYnVmZkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gdHJpZ2dlciBib3cgcmVsZWFzZSBlZmZlY3RzXG4gIHByaXZhdGUgdHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzKGZpbmFsQ2hhcmdlUHJvZ3Jlc3M6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBhIHBlcmZlY3Qgc2hvdFxuICAgICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjc1OyAvLyA4NSUgY2hhcmdlXG4gICAgICBjb25zdCBwZXJmZWN0U2hvdE1heFRocmVzaG9sZCA9IDAuOTg7IC8vIDk1JSBjaGFyZ2VcbiAgICAgIGNvbnN0IGlzUGVyZmVjdFNob3QgPSBmaW5hbENoYXJnZVByb2dyZXNzID49IHBlcmZlY3RTaG90TWluVGhyZXNob2xkICYmIGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPD0gcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQ7XG4gICAgICBcbiAgICAgIHRoaXMub25Cb3dSZWxlYXNlQ2FsbGJhY2soZmluYWxDaGFyZ2VQcm9ncmVzcywgaXNQZXJmZWN0U2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFdlYXBvbkxldmVsKGxldmVsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgcHVibGljIGdldEN1cnJlbnRXZWFwb25Db25maWcoKTogeyB3ZWFwb246IFdlYXBvblR5cGU7IHN1YmNsYXNzOiBXZWFwb25TdWJjbGFzczsgbGV2ZWw6IG51bWJlciB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgd2VhcG9uOiB0aGlzLmN1cnJlbnRXZWFwb24sXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWxcbiAgICB9O1xuICB9XG5cbiAgLy8gR2V0dGVycyBmb3Igd2VhcG9uIHN0YXRlIChmb3IgVUkvcmVuZGVyaW5nKVxuICBwdWJsaWMgZ2V0Q3VycmVudFdlYXBvbigpOiBXZWFwb25UeXBlIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50V2VhcG9uO1xuICB9XG5cbiAgcHVibGljIGdldEN1cnJlbnRTdWJjbGFzcygpOiBXZWFwb25TdWJjbGFzcyB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN1YmNsYXNzO1xuICB9XG5cbiAgcHVibGljIGlzV2VhcG9uQ2hhcmdpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzVmlwZXJTdGluZ0NoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldFZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc0JhcnJhZ2VDaGFyZ2luZ0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRCYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNDb2JyYVNob3RDaGFyZ2luZ0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldENvYnJhU2hvdENoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNXZWFwb25Td2luZ2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1N3aW5naW5nO1xuICB9XG5cbiAgLy8gU3dvcmQtc3BlY2lmaWMgZ2V0dGVyc1xuICBwdWJsaWMgZ2V0U3dvcmRDb21ib1N0ZXAoKTogMSB8IDIgfCAzIHtcbiAgICByZXR1cm4gdGhpcy5zd29yZENvbWJvU3RlcDtcbiAgfVxuXG4gIHB1YmxpYyBpc0RpdmluZVN0b3JtQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRGl2aW5lU3Rvcm1pbmc7XG4gIH1cblxuICBwdWJsaWMgaXNDaGFyZ2VBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTd29yZENoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGlzRGVmbGVjdEFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RlZmxlY3Rpbmc7XG4gIH1cbiAgXG4gIHB1YmxpYyBpc1NreWZhbGxBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTa3lmYWxsaW5nO1xuICB9XG4gIFxuICBwdWJsaWMgaXNCYWNrc3RhYkFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0JhY2tzdGFiYmluZztcbiAgfVxuICBcbiAgcHVibGljIGlzU3VuZGVyQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU3VuZGVyaW5nO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTd29yZElucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIHN3b3JkIG1lbGVlIGF0dGFja3NcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dvcmRDaGFyZ2luZyAmJiAhdGhpcy5pc0RlZmxlY3RpbmcpIHsgLy8gTGVmdCBtb3VzZSBidXR0b25cbiAgICAgIHRoaXMucGVyZm9ybVN3b3JkTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIERpdmluZSBTdG9ybSBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtRGl2aW5lU3Rvcm0ocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENoYXJnZSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEaXZpbmVTdG9ybWluZyAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtQ2hhcmdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBEZWZsZWN0IGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzRGVmbGVjdGluZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1EZWZsZWN0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBjb21ibyByZXNldFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U3dvcmRBdHRhY2tUaW1lID4gdGhpcy5zd29yZENvbWJvUmVzZXRUaW1lKSB7XG4gICAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gMTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1Td29yZE1lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHN3b3JkLXNwZWNpZmljIGZpcmUgcmF0ZSlcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5zd29yZEZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5sYXN0U3dvcmRBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gU2V0IHN3aW5naW5nIHN0YXRlIC0gY29tcGxldGlvbiB3aWxsIGJlIGhhbmRsZWQgYnkgc3dvcmQgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIG1lbGVlIGRhbWFnZSBpbiBhIGNvbmUgaW4gZnJvbnQgb2YgcGxheWVyXG4gICAgdGhpcy5wZXJmb3JtTWVsZWVEYW1hZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBOb3RlOiBTd2luZyBjb21wbGV0aW9uIGFuZCBjb21ibyBhZHZhbmNlbWVudCBpcyBub3cgaGFuZGxlZCBieSBvblN3b3JkU3dpbmdDb21wbGV0ZSBjYWxsYmFja1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIHN3aW5nIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uU3dvcmRTd2luZ0NvbXBsZXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1N3aW5naW5nKSByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHNcbiAgICBcbiAgICAvLyBSZXNldCBzd2luZ2luZyBzdGF0ZVxuICAgIHRoaXMuaXNTd2luZ2luZyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEFkdmFuY2UgY29tYm8gc3RlcCBmb3IgbmV4dCBhdHRhY2tcbiAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gKHRoaXMuc3dvcmRDb21ib1N0ZXAgJSAzICsgMSkgYXMgMSB8IDIgfCAzO1xuICAgIFxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTYWJyZXNJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBsZWZ0IGNsaWNrIGZvciBkdWFsIHNhYnJlIGF0dGFja1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzU2t5ZmFsbGluZyAmJiAhdGhpcy5pc1N1bmRlcmluZykge1xuICAgICAgdGhpcy5wZXJmb3JtU2FicmVzTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFEga2V5IGZvciBCYWNrc3RhYiBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1CYWNrc3RhYihwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRSBrZXkgZm9yIFN1bmRlciBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1TdW5kZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFIga2V5IGZvciBTa3lmYWxsIGFiaWxpdHkgKHN3aXRjaGVkIGZyb20gRSlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Ta3lmYWxsKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBTa3lmYWxsIHN0YXRlIGlmIGFjdGl2ZVxuICAgIGlmICh0aGlzLmlzU2t5ZmFsbGluZykge1xuICAgICAgdGhpcy51cGRhdGVTa3lmYWxsTW92ZW1lbnQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIEJhY2tzdGFiIHN0YXRlIGlmIGFjdGl2ZVxuICAgIGlmICh0aGlzLmlzQmFja3N0YWJiaW5nKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJhY2tzdGFiU3RhdGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIFN1bmRlciBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc1N1bmRlcmluZykge1xuICAgICAgdGhpcy51cGRhdGVTdW5kZXJTdGF0ZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHNhYnJlcy1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc2FicmVzRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pqU77iPIFNhYnJlcyBkdWFsIGF0dGFjayBpbml0aWF0ZWQnKTtcbiAgICBcbiAgICAvLyBTZXQgc3dpbmdpbmcgc3RhdGUgLSBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieSBzYWJyZXMgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIG1lbGVlIGRhbWFnZSBpbiBhIGNvbmUgaW4gZnJvbnQgb2YgcGxheWVyIChkdWFsIGF0dGFjaylcbiAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHNhYnJlcyBjb21wb25lbnQgd2hlbiBzd2luZyBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvblNhYnJlc1N3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGR1YWwgc3dpbmcgY29tcGxldGVkJyk7XG4gICAgXG4gICAgLy8gUmVzZXQgc3dpbmdpbmcgc3RhdGVcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIHRoYXQgY291bGQgYmUgZGFtYWdlZFxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSBhbGxFbnRpdGllcy5maWx0ZXIoZW50aXR5ID0+IFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChIZWFsdGgpICYmIFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChUcmFuc2Zvcm0pICYmXG4gICAgICBlbnRpdHkgIT09IHRoaXMucGxheWVyRW50aXR5XG4gICAgKTtcbiAgICBcbiAgICAvLyBTQUJSRVMgREFNQUdFXG4gICAgY29uc3QgYXR0YWNrUmFuZ2UgPSAzLjg7IC8vIFNsaWdodGx5IGxvbmdlciByYW5nZSB0aGFuIHN3b3JkXG4gICAgY29uc3QgYXR0YWNrQW5nbGUgPSBNYXRoLlBJIC8gMjsgLy8gNjAgZGVncmVlIGNvbmUgKHdpZGVyIHRoYW4gc3dvcmQpXG4gICAgY29uc3QgbGVmdFNhYnJlRGFtYWdlID0gMTk7XG4gICAgY29uc3QgcmlnaHRTYWJyZURhbWFnZSA9IDIzO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEgZGlyZWN0aW9uIGZvciBhdHRhY2sgZGlyZWN0aW9uXG4gICAgY29uc3QgYXR0YWNrRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihhdHRhY2tEaXJlY3Rpb24pO1xuICAgIGF0dGFja0RpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBvdGVudGlhbFRhcmdldHMpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldEhlYWx0aCB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpcmVjdGlvbiB0byB0YXJnZXRcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvVGFyZ2V0ID0gZGlyZWN0aW9uVG9UYXJnZXQubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkaXN0YW5jZVRvVGFyZ2V0ID4gYXR0YWNrUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgd2l0aGluIGF0dGFjayBjb25lXG4gICAgICBkaXJlY3Rpb25Ub1RhcmdldC5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBhdHRhY2tEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVG9UYXJnZXQgPSBNYXRoLmFjb3MoTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGRvdFByb2R1Y3QpKSk7XG4gICAgICBcbiAgICAgIGlmIChhbmdsZVRvVGFyZ2V0ID4gYXR0YWNrQW5nbGUgLyAyKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gVGFyZ2V0IGlzIHdpdGhpbiByYW5nZSBhbmQgY29uZSAtIGFwcGx5IGRhbWFnZSBmcm9tIGJvdGggc2FicmVzXG4gICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICAvLyBMZWZ0IHNhYnJlIGhpdCAoaW1tZWRpYXRlKVxuICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCBsZWZ0U2FicmVEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSaWdodCBzYWJyZSBoaXQgKHdpdGggc21hbGwgZGVsYXkpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghdGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldCwgcmlnaHRTYWJyZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7IC8vIDEwMG1zIGRlbGF5IGJldHdlZW4gc2FicmUgaGl0c1xuICAgICAgICBcbiAgICAgICAgaGl0Q291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTa3lmYWxsIGFiaWxpdHkgaW1wbGVtZW50YXRpb25cbiAgcHJpdmF0ZSBwZXJmb3JtU2t5ZmFsbChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSA8IHRoaXMuc2t5ZmFsbENvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGVuZXJneSBjb3N0XG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoIWdhbWVVSSB8fCAhZ2FtZVVJLmNhbkNhc3RTa3lmYWxsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg0MCk7XG4gICAgXG4gICAgLy8gU3RhcnQgU2t5ZmFsbFxuICAgIHRoaXMuaXNTa3lmYWxsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdhc2NlbmRpbmcnO1xuICAgIHRoaXMuc2t5ZmFsbFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMubGFzdFNreWZhbGxUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5za3lmYWxsU3RhcnRQb3NpdGlvbi5jb3B5KHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgXG4gICAgLy8gU2V0IHRhcmdldCBoZWlnaHQgKGRvdWJsZSBqdW1wIGhlaWdodClcbiAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5Py5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgdGhpcy5za3lmYWxsT3JpZ2luYWxHcmF2aXR5ID0gcGxheWVyTW92ZW1lbnQuZ3Jhdml0eTtcbiAgICAgIHRoaXMuc2t5ZmFsbFRhcmdldEhlaWdodCA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHBsYXllck1vdmVtZW50Lmp1bXBGb3JjZSAqIDEuNCk7IC8vIFJlZHVjZWQgaGVpZ2h0IGJ5IDMwJSAod2FzIDJ4LCBub3cgMS40eClcbiAgICAgICAgICAgIFxuICAgICAgLy8gQXBwbHkgdXB3YXJkIHZlbG9jaXR5XG4gICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gcGxheWVyTW92ZW1lbnQuanVtcEZvcmNlICogMjsgLy8gU3Ryb25nZXIgaW5pdGlhbCB2ZWxvY2l0eVxuICAgICAgcGxheWVyTW92ZW1lbnQuZ3Jhdml0eSA9IDA7IC8vIERpc2FibGUgZ3Jhdml0eSBkdXJpbmcgYXNjZW50XG4gICAgICAvLyBEb24ndCBkaXNhYmxlIGNhbk1vdmUgYXMgaXQgcHJldmVudHMgYWxsIHBoeXNpY3MgdXBkYXRlcyBpbmNsdWRpbmcgZ3Jhdml0eVxuICAgICAgLy8gSW5zdGVhZCB3ZSdsbCBjb250cm9sIGhvcml6b250YWwgbW92ZW1lbnQgaW4gdGhlIENvbnRyb2xTeXN0ZW1cbiAgICB9XG5cbiAgICBcbiAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllci92aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uU2t5ZmFsbENhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIHRoaXMub25Ta3lmYWxsQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVTa3lmYWxsTW92ZW1lbnQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHk/LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKCFwbGF5ZXJNb3ZlbWVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSB0aGlzLnNreWZhbGxTdGFydFRpbWU7XG4gICAgXG5cbiAgICBcbiAgICBzd2l0Y2ggKHRoaXMuc2t5ZmFsbFBoYXNlKSB7XG4gICAgICBjYXNlICdhc2NlbmRpbmcnOlxuICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRhcmdldCBoZWlnaHQgb3Igc3RhcnRlZCBmYWxsaW5nXG4gICAgICAgIGlmIChwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24ueSA+PSB0aGlzLnNreWZhbGxUYXJnZXRIZWlnaHQgfHwgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnZGVzY2VuZGluZyc7XG4gICAgICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueSA9IDA7IC8vIFN0b3AgYXQgcGVha1xuICAgICAgICAgIHBsYXllck1vdmVtZW50LmdyYXZpdHkgPSB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHkgKiAzMDsgLy8gRmFzdGVyIGRlc2NlbnRcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdkZXNjZW5kaW5nJzpcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgbGFuZGVkIChjbG9zZSB0byBvcmlnaW5hbCBoZWlnaHQgb3Igb24gZ3JvdW5kKVxuICAgICAgICBpZiAocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLnkgPD0gdGhpcy5za3lmYWxsU3RhcnRQb3NpdGlvbi55ICsgMC41KSB7XG4gICAgICAgICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnbGFuZGluZyc7XG4gICAgICAgICAgdGhpcy5wZXJmb3JtU2t5ZmFsbExhbmRpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdsYW5kaW5nJzpcbiAgICAgICAgLy8gTGFuZGluZyBwaGFzZSBjb21wbGV0ZVxuICAgICAgICB0aGlzLmNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIC8vIFNhZmV0eSB0aW1lb3V0IChpZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgZW5kIGFmdGVyIDUgc2Vjb25kcylcbiAgICBpZiAoZWxhcHNlZFRpbWUgPiA0LjApIHtcbiAgICAgIHRoaXMuY29tcGxldGVTa3lmYWxsQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBwZXJmb3JtU2t5ZmFsbExhbmRpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBEZWFsIGRhbWFnZSB0byBlbmVtaWVzIGluIGxhbmRpbmcgYXJlYVxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IGxhbmRpbmdQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCBkYW1hZ2VSYWRpdXMgPSA0LjA7IC8vIDQgdW5pdCByYWRpdXNcbiAgICBjb25zdCBza3lmYWxsRGFtYWdlID0gMTI1OyAvLyAxMjUgZGFtYWdlIGFzIHJlcXVlc3RlZFxuICAgIFxuICAgIGxldCBoaXRDb3VudCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgYWxsRW50aXRpZXMpIHtcbiAgICAgIGlmIChlbnRpdHkgPT09IHRoaXMucGxheWVyRW50aXR5KSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBkaXN0YW5jZSB0byBsYW5kaW5nIHBvc2l0aW9uXG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGFuZGluZyA9IGxhbmRpbmdQb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZVRvTGFuZGluZyA8PSBkYW1hZ2VSYWRpdXMpIHtcbiAgICAgICAgLy8gQXBwbHkgU2t5ZmFsbCBkYW1hZ2VcbiAgICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIHNreWZhbGxEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgaGl0Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBjb21wbGV0ZVNreWZhbGxBYmlsaXR5KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmVzZXQgYWxsIFNreWZhbGwgc3RhdGVzXG4gICAgdGhpcy5pc1NreWZhbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdub25lJztcbiAgICBcbiAgICAvLyBSZXN0b3JlIHBsYXllciBtb3ZlbWVudFxuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHk/LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC5ncmF2aXR5ID0gdGhpcy5za3lmYWxsT3JpZ2luYWxHcmF2aXR5O1xuICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueSA9IDA7IC8vIFN0b3AgYW55IHJlbWFpbmluZyB2ZXJ0aWNhbCBtb3ZlbWVudFxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVCYWNrc3RhYlN0YXRlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5iYWNrc3RhYlN0YXJ0VGltZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBiYWNrc3RhYiBhbmltYXRpb24gZHVyYXRpb24gaGFzIGVsYXBzZWRcbiAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGhpcy5iYWNrc3RhYkR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmlzQmFja3N0YWJiaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvLyBTdW5kZXIgYWJpbGl0eSBpbXBsZW1lbnRhdGlvblxuICBwcml2YXRlIHBlcmZvcm1TdW5kZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U3VuZGVyVGltZSA8IHRoaXMuc3VuZGVyQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZW5lcmd5IGNvc3QgKDM1IGVuZXJneSlcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmICghZ2FtZVVJIHx8ICFnYW1lVUkuY2FuQ2FzdFN1bmRlcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koMzUpO1xuICAgIFxuICAgIC8vIFNldCBjb29sZG93blxuICAgIHRoaXMubGFzdFN1bmRlclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBzdW5kZXIgYW5pbWF0aW9uIChzYW1lIGFzIGJhY2tzdGFiKVxuICAgIHRoaXMuaXNTdW5kZXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VuZGVyU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBzdW5kZXIgZGFtYWdlIHdpdGggc3RhY2tpbmcgbG9naWNcbiAgICB0aGlzLnBlcmZvcm1TdW5kZXJEYW1hZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVTdW5kZXJTdGF0ZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuc3VuZGVyU3RhcnRUaW1lO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHN1bmRlciBhbmltYXRpb24gZHVyYXRpb24gaGFzIGVsYXBzZWRcbiAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGhpcy5zdW5kZXJEdXJhdGlvbikge1xuICAgICAgdGhpcy5pc1N1bmRlcmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBwZXJmb3JtU3VuZGVyRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGVuZW1pZXMvcGxheWVyc1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgZmFjaW5nIGRpcmVjdGlvbiAoY2FtZXJhIGRpcmVjdGlvbilcbiAgICBjb25zdCBwbGF5ZXJEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKHBsYXllckRpcmVjdGlvbik7XG4gICAgcGxheWVyRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHN1bmRlclJhbmdlID0gMy41OyAvLyBTYW1lIHJhbmdlIGFzIGJhY2tzdGFiXG4gICAgbGV0IGhpdENvdW50ID0gMDtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBpZiAoZW50aXR5ID09PSB0aGlzLnBsYXllckVudGl0eSkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRIZWFsdGggfHwgIXRhcmdldFRyYW5zZm9ybSB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIHJhbmdlXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZSA+IHN1bmRlclJhbmdlKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIGZyb250IG9mIHBsYXllciAoY29uZSBhdHRhY2spXG4gICAgICBjb25zdCBkaXJlY3Rpb25Ub1RhcmdldCA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgLnN1YlZlY3RvcnModGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLCBwbGF5ZXJQb3NpdGlvbilcbiAgICAgICAgLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICBjb25zdCBkb3RQcm9kdWN0ID0gcGxheWVyRGlyZWN0aW9uLmRvdChkaXJlY3Rpb25Ub1RhcmdldCk7XG4gICAgICBjb25zdCBhbmdsZVRocmVzaG9sZCA9IE1hdGguY29zKE1hdGguUEkgLyA0KTsgLy8gNjAgZGVncmVlIGNvbmVcbiAgICAgIFxuICAgICAgaWYgKGRvdFByb2R1Y3QgPCBhbmdsZVRocmVzaG9sZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IFN1bmRlciBzdGFja3MgYW5kIGNhbGN1bGF0ZSBkYW1hZ2VcbiAgICAgIGNvbnN0IHsgZGFtYWdlLCBzdGFja0NvdW50LCBpc1N0dW5uZWQgfSA9IHRoaXMuYXBwbHlTdW5kZXJTdGFjayhlbnRpdHkuaWQsIGN1cnJlbnRUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgZGFtYWdlXG4gICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoXG4gICAgICAgICAgZW50aXR5LFxuICAgICAgICAgIGRhbWFnZSxcbiAgICAgICAgICB0aGlzLnBsYXllckVudGl0eSEsXG4gICAgICAgICAgJ3N1bmRlcidcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IHN0dW4gZWZmZWN0IGlmIGF0IDMgc3RhY2tzXG4gICAgICAgIGlmIChpc1N0dW5uZWQpIHtcbiAgICAgICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgICAgIGlmIChlbmVteSkge1xuICAgICAgICAgICAgZW5lbXkuZnJlZXplKDQuMCwgY3VycmVudFRpbWUpOyAvLyA0IHNlY29uZCBzdHVuICh1c2luZyBmcmVlemUgbWVjaGFuaWNzIGZvciBtb3ZlbWVudClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHZpc3VhbCBzdHVuIGVmZmVjdCAoZGlmZmVyZW50IGZyb20gZnJlZXplKVxuICAgICAgICAgICAgYWRkR2xvYmFsU3R1bm5lZEVuZW15KGVudGl0eS5pZC50b1N0cmluZygpLCB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBCcm9hZGNhc3Qgc3R1biBlZmZlY3QgZm9yIFBWUCAodXNpbmcgbmV3ICdzdHVubmVkJyB0eXBlKVxuICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQ2hlY2sgaWYgd2UncmUgYWJvdXQgdG8gdGFyZ2V0IG91cnNlbHZlcyBiZWZvcmUgYnJvYWRjYXN0aW5nIGRlYnVmZlxuICAgICAgICAgIGlmICh0aGlzLm9uRGVidWZmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU29ja2V0SWQgPSAod2luZG93IGFzIGFueSkubG9jYWxTb2NrZXRJZDtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclBsYXllckVudGl0aWVzID0gKHdpbmRvdyBhcyBhbnkpLnNlcnZlclBsYXllckVudGl0aWVzO1xuICAgICAgICAgICAgbGV0IHRhcmdldFBsYXllcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlcnZlclBsYXllckVudGl0aWVzICYmIHNlcnZlclBsYXllckVudGl0aWVzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudC5mb3JFYWNoKChsb2NhbEVudGl0eUlkOiBudW1iZXIsIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxFbnRpdHlJZCA9PT0gZW50aXR5LmlkKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJJZCA9IHBsYXllcklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE5FVkVSIGJyb2FkY2FzdCBkZWJ1ZmYgdG8gb3Vyc2VsdmVzXG4gICAgICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQgJiYgdGFyZ2V0UGxheWVySWQgIT09IGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gQnJvYWRjYXN0aW5nIHN0dW4gZWZmZWN0IHRvIHBsYXllciAke3RhcmdldFBsYXllcklkfSAoTk9UIGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9KWApO1xuICAgICAgICAgICAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2soZW50aXR5LmlkLCAnc3R1bm5lZCcsIDQwMDAsIHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFNraXBwaW5nIHN0dW4gYnJvYWRjYXN0IC0gd291bGQgdGFyZ2V0IGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9IG9yIGludmFsaWQgdGFyZ2V0ICR7dGFyZ2V0UGxheWVySWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBoaXRDb3VudCsrO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllci92aXN1YWwgZWZmZWN0c1xuICAgICAgaWYgKHRoaXMub25TdW5kZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uU3VuZGVyQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBwbGF5ZXJEaXJlY3Rpb24sIGRhbWFnZSwgc3RhY2tDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGFwcGx5U3VuZGVyU3RhY2soZW50aXR5SWQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHsgZGFtYWdlOiBudW1iZXI7IHN0YWNrQ291bnQ6IG51bWJlcjsgaXNTdHVubmVkOiBib29sZWFuIH0ge1xuICAgIGNvbnN0IHN0YWNrRHVyYXRpb24gPSAxMC4wOyAvLyAxMCBzZWNvbmRzXG4gICAgbGV0IGN1cnJlbnRTdGFja3MgPSB0aGlzLnN1bmRlclN0YWNrcy5nZXQoZW50aXR5SWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4cGlyZWQgc3RhY2tzIG9yIGluaXRpYWxpemUgbmV3IGVudHJ5XG4gICAgaWYgKCFjdXJyZW50U3RhY2tzIHx8IChjdXJyZW50VGltZSAtIGN1cnJlbnRTdGFja3MubGFzdEFwcGxpZWQpID4gc3RhY2tEdXJhdGlvbikge1xuICAgICAgY3VycmVudFN0YWNrcyA9IHsgc3RhY2tzOiAwLCBsYXN0QXBwbGllZDogY3VycmVudFRpbWUsIGR1cmF0aW9uOiBzdGFja0R1cmF0aW9uIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBkYW1hZ2UgYmFzZWQgb24gY3VycmVudCBzdGFjayBjb3VudCAoYmVmb3JlIGFkZGluZyBuZXcgc3RhY2spXG4gICAgY29uc3QgYmFzZURhbWFnZXMgPSBbNjAsIDcwLCA4MCwgOTBdOyAvLyAwLCAxLCAyLCAzIHN0YWNrc1xuICAgIGNvbnN0IGRhbWFnZSA9IGJhc2VEYW1hZ2VzW01hdGgubWluKGN1cnJlbnRTdGFja3Muc3RhY2tzLCAzKV07XG4gICAgXG4gICAgbGV0IGlzU3R1bm5lZCA9IGZhbHNlO1xuICAgIGxldCBuZXdTdGFja0NvdW50ID0gY3VycmVudFN0YWNrcy5zdGFja3M7XG4gICAgXG4gICAgLy8gQXBwbHkgbmV3IHN0YWNrXG4gICAgaWYgKGN1cnJlbnRTdGFja3Muc3RhY2tzIDwgMykge1xuICAgICAgbmV3U3RhY2tDb3VudCA9IGN1cnJlbnRTdGFja3Muc3RhY2tzICsgMTtcbiAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLnNldChlbnRpdHlJZCwge1xuICAgICAgICBzdGFja3M6IG5ld1N0YWNrQ291bnQsXG4gICAgICAgIGxhc3RBcHBsaWVkOiBjdXJyZW50VGltZSxcbiAgICAgICAgZHVyYXRpb246IHN0YWNrRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCAzIHN0YWNrcywgYXBwbHkgc3R1biBhbmQgcmVzZXQgdG8gMCBzdGFja3NcbiAgICAgIGlzU3R1bm5lZCA9IHRydWU7XG4gICAgICBuZXdTdGFja0NvdW50ID0gMDtcbiAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLnNldChlbnRpdHlJZCwge1xuICAgICAgICBzdGFja3M6IDAsXG4gICAgICAgIGxhc3RBcHBsaWVkOiBjdXJyZW50VGltZSxcbiAgICAgICAgZHVyYXRpb246IHN0YWNrRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBkYW1hZ2UsIHN0YWNrQ291bnQ6IG5ld1N0YWNrQ291bnQsIGlzU3R1bm5lZCB9O1xuICB9XG4gIFxuICAvLyBDbGVhbiB1cCBleHBpcmVkIFN1bmRlciBzdGFja3MgcGVyaW9kaWNhbGx5XG4gIHByaXZhdGUgY2xlYW51cFN1bmRlclN0YWNrcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IHN0YWNrRHVyYXRpb24gPSAxMC4wO1xuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgdG8gYXZvaWQgaXRlcmF0aW9uIGlzc3Vlc1xuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuc3VuZGVyU3RhY2tzLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIHN0YWNrRGF0YV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKChjdXJyZW50VGltZSAtIHN0YWNrRGF0YS5sYXN0QXBwbGllZCkgPiBzdGFja0R1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLmRlbGV0ZShlbnRpdHlJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOiB2b2lkIHtcbiAgICAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgIHRoaXMuaXNTa3lmYWxsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnbm9uZSc7XG4gICAgdGhpcy5pc0JhY2tzdGFiYmluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdW5kZXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2xlYXIgU3VuZGVyIHN0YWNrcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgdGhpcy5zdW5kZXJTdGFja3MuY2xlYXIoKTtcbiAgfVxuXG4gIC8vIEJhY2tzdGFiIGFiaWxpdHkgaW1wbGVtZW50YXRpb25cbiAgcHJpdmF0ZSBwZXJmb3JtQmFja3N0YWIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFja3N0YWJUaW1lIDwgdGhpcy5iYWNrc3RhYkNvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGVuZXJneSBjb3N0XG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoIWdhbWVVSSB8fCAhZ2FtZVVJLmNhbkNhc3RCYWNrc3RhYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNjApO1xuICAgIFxuICAgIC8vIFNldCBjb29sZG93blxuICAgIHRoaXMubGFzdEJhY2tzdGFiVGltZSA9IGN1cnJlbnRUaW1lO1xuICBcbiAgICBcbiAgICAvLyBTdGFydCBiYWNrc3RhYiBhbmltYXRpb25cbiAgICB0aGlzLmlzQmFja3N0YWJiaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmJhY2tzdGFiU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXIvdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkJhY2tzdGFiQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgdGhpcy5vbkJhY2tzdGFiQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBkaXJlY3Rpb24sIDc1LCBmYWxzZSk7IC8vIEJhc2UgZGFtYWdlLCBub3QgYmFja3N0YWIgYnkgZGVmYXVsdFxuICAgIH1cbiAgICBcbiAgICAvLyBQZXJmb3JtIGJhY2tzdGFiIGRhbWFnZVxuICAgIHRoaXMucGVyZm9ybUJhY2tzdGFiRGFtYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1CYWNrc3RhYkRhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBlbmVtaWVzL3BsYXllcnNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIGZhY2luZyBkaXJlY3Rpb24gKGNhbWVyYSBkaXJlY3Rpb24pXG4gICAgY29uc3QgcGxheWVyRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihwbGF5ZXJEaXJlY3Rpb24pO1xuICAgIHBsYXllckRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCBiYWNrc3RhYlJhbmdlID0gNC4yNTsgLy8gU2FicmUgbWVsZWUgcmFuZ2VcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBpZiAoZW50aXR5ID09PSB0aGlzLnBsYXllckVudGl0eSkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRIZWFsdGggfHwgIXRhcmdldFRyYW5zZm9ybSB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIHJhbmdlXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZSA+IGJhY2tzdGFiUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgaW4gZnJvbnQgb2YgcGxheWVyIChjb25lIGF0dGFjaylcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKVxuICAgICAgICAuc3ViVmVjdG9ycyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24sIHBsYXllclBvc2l0aW9uKVxuICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBwbGF5ZXJEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVGhyZXNob2xkID0gTWF0aC5jb3MoTWF0aC5QSSAvIDMpOyAvLyA2MCBkZWdyZWUgY29uZVxuICAgICAgXG4gICAgICBpZiAoZG90UHJvZHVjdCA8IGFuZ2xlVGhyZXNob2xkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBiYWNrc3RhYiAoYXR0YWNraW5nIGZyb20gYmVoaW5kIHRoZSB0YXJnZXQpXG4gICAgICBsZXQgaXNCYWNrc3RhYiA9IGZhbHNlO1xuICAgICAgbGV0IGRhbWFnZSA9IDc1OyAvLyBCYXNlIGRhbWFnZVxuICAgICAgXG4gICAgICAvLyBGb3IgUFZQIHBsYXllcnMsIGNoZWNrIGlmIHdlJ3JlIGJlaGluZCB0aGVtXG4gICAgICBjb25zdCBwdnBQbGF5ZXJzID0gKHdpbmRvdyBhcyBhbnkpLnB2cFBsYXllcnM7XG4gICAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgICBcbiAgICAgIGlmIChwdnBQbGF5ZXJzICYmIGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgdGFyZ2V0IHBsYXllciBpbiBQVlAgcGxheWVycyBtYXBcbiAgICAgICAgbGV0IHRhcmdldFBsYXllciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgW3BsYXllcklkLCBwbGF5ZXJdIG9mIHB2cFBsYXllcnMpIHtcbiAgICAgICAgICBpZiAocGxheWVySWQgIT09IGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXllclBvcyA9IG5ldyBWZWN0b3IzKHBsYXllci5wb3NpdGlvbi54LCBwbGF5ZXIucG9zaXRpb24ueSwgcGxheWVyLnBvc2l0aW9uLnopO1xuICAgICAgICAgICAgaWYgKHBsYXllclBvcy5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgPCAwLjUpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0UGxheWVyID0gcGxheWVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0YXJnZXRQbGF5ZXIpIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGFyZ2V0J3MgZmFjaW5nIGRpcmVjdGlvbiBmcm9tIHRoZWlyIHJvdGF0aW9uXG4gICAgICAgICAgY29uc3QgdGFyZ2V0RmFjaW5nRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoXG4gICAgICAgICAgICBNYXRoLnNpbih0YXJnZXRQbGF5ZXIucm90YXRpb24ueSksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC5jb3ModGFyZ2V0UGxheWVyLnJvdGF0aW9uLnkpXG4gICAgICAgICAgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZWN0b3IgZnJvbSB0YXJnZXQgdG8gYXR0YWNrZXJcbiAgICAgICAgICBjb25zdCBhdHRhY2tlckRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgICAgIC5zdWJWZWN0b3JzKHBsYXllclBvc2l0aW9uLCB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pXG4gICAgICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYXR0YWNrZXIgaXMgYmVoaW5kIHRhcmdldCAoZG90IHByb2R1Y3QgPCAwIG1lYW5zIG9wcG9zaXRlIGRpcmVjdGlvbilcbiAgICAgICAgICBjb25zdCBiZWhpbmREb3RQcm9kdWN0ID0gdGFyZ2V0RmFjaW5nRGlyZWN0aW9uLmRvdChhdHRhY2tlckRpcmVjdGlvbik7XG4gICAgICAgICAgaXNCYWNrc3RhYiA9IGJlaGluZERvdFByb2R1Y3QgPCAtMC4zOyAvLyA3MCBkZWdyZWUgY29uZSBiZWhpbmQgdGFyZ2V0XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGlzQmFja3N0YWIpIHtcbiAgICAgICAgICAgIGRhbWFnZSA9IDE3NTsgLy8gQmFja3N0YWIgZGFtYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IGRhbWFnZVxuICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgIGlmIChjb21iYXRTeXN0ZW0pIHtcbiAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgICBkYW1hZ2UsXG4gICAgICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkhLFxuICAgICAgICAgICdiYWNrc3RhYidcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGhpdENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtTWVsZWVEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZCB0byBjaGVjayBmb3IgZW5lbWllc1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgZmFjaW5nIGRpcmVjdGlvbiAoY2FtZXJhIGRpcmVjdGlvbilcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIE1lbGVlIGF0dGFjayBwYXJhbWV0ZXJzIC0gaW5jcmVhc2VkIGZvciBQVlAgY29tYmF0XG4gICAgY29uc3QgbWVsZWVSYW5nZSA9IDQuNTsgLy8gSW5jcmVhc2VkIGF0dGFjayByYW5nZSBmb3IgUFZQXG4gICAgY29uc3QgbWVsZWVBbmdsZSA9IE1hdGguUEkgLyAyOyAvLyAxMjAgZGVncmVlIGNvbmUgKDYwIGRlZ3JlZXMgZWFjaCBzaWRlKVxuICAgIFxuICAgIC8vIEJhc2UgZGFtYWdlIHZhbHVlcyBiYXNlZCBvbiBjb21ibyBzdGVwIC0gd29ya3MgZm9yIGFsbCBzdWJjbGFzc2VzXG4gICAgbGV0IGJhc2VEYW1hZ2UgPSA0NTsgLy8gQmFzZSBzd29yZCBkYW1hZ2VcbiAgICAvLyBDb21ibyBkYW1hZ2Ugc2NhbGluZ1xuICAgIHN3aXRjaCAodGhpcy5zd29yZENvbWJvU3RlcCkge1xuICAgICAgY2FzZSAxOiBiYXNlRGFtYWdlID0gNDA7IGJyZWFrO1xuICAgICAgY2FzZSAyOiBiYXNlRGFtYWdlID0gNDU7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBiYXNlRGFtYWdlID0gNTU7IGJyZWFrOyAvLyBGaW5pc2hlciBkb2VzIG1vcmUgZGFtYWdlXG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBjb21iYXQgc3lzdGVtIHRvIGFwcGx5IGRhbWFnZVxuICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgXG4gICAgLy8gVHJhY2sgZW5lbWllcyBoaXQgZm9yIHJhZ2UgZ2VuZXJhdGlvblxuICAgIGxldCBlbmVtaWVzSGl0ID0gMDtcbiAgICBcbiAgICBhbGxFbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiB7XG4gICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaGFzIGVuZW15IGNvbXBvbmVudCBhbmQgaGVhbHRoXG4gICAgICBjb25zdCBlbmVteVRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IGVuZW15SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgaWYgKCFlbmVteVRyYW5zZm9ybSB8fCAhZW5lbXlIZWFsdGggfHwgZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgZW5lbXlQb3NpdGlvbiA9IGVuZW15VHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgY29uc3QgdG9FbmVteSA9IGVuZW15UG9zaXRpb24uY2xvbmUoKS5zdWIocGxheWVyUG9zaXRpb24pO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0b0VuZW15Lmxlbmd0aCgpO1xuICAgICAgXG4gICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBQVlAgaGl0IGRldGVjdGlvblxuICAgICAgXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGVuZW15IGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRpc3RhbmNlIDw9IG1lbGVlUmFuZ2UpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW5lbXkgaXMgd2l0aGluIGF0dGFjayBjb25lXG4gICAgICAgIHRvRW5lbXkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gZGlyZWN0aW9uLmFuZ2xlVG8odG9FbmVteSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlRGVncmVlcyA9IGFuZ2xlICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgY29uc3QgbWF4QW5nbGVEZWdyZWVzID0gKG1lbGVlQW5nbGUgLyAyKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKGFuZ2xlIDw9IG1lbGVlQW5nbGUgLyAyKSB7XG4gICAgICAgICAgLy8gRW5lbXkgaXMgd2l0aGluIGF0dGFjayBjb25lIC0gZGVhbCBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSAmJiB0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgICAgLy8gUXVldWUgZGFtYWdlIHRocm91Z2ggY29tYmF0IHN5c3RlbSAod2hpY2ggd2lsbCByb3V0ZSB0byBtdWx0aXBsYXllciBmb3IgZW5lbWllcylcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIGJhc2VEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5LCAnbWVsZWUnKTtcbiAgICAgICAgICAgIGVuZW1pZXNIaXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSByYWdlIG9ubHkgaWYgd2UgaGl0IGVuZW1pZXMgKDUgcmFnZSBwZXIgaGl0LCBtYXggNSBwZXIgc3dpbmcpXG4gICAgaWYgKGVuZW1pZXNIaXQgPiAwKSB7XG4gICAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgICAgaWYgKGdhbWVVSSkge1xuICAgICAgICBjb25zdCByYWdlVG9HYWluID0gTWF0aC5taW4oZW5lbWllc0hpdCAqIDUsIDUpOyAvLyA1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nXG4gICAgICAgIGdhbWVVSS5nYWluUmFnZShyYWdlVG9HYWluKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9yRGFzaElucHV0KG1vdmVtZW50OiBNb3ZlbWVudCwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBmb3IgZG91YmxlLXRhcCBvbiBtb3ZlbWVudCBrZXlzXG4gICAgY29uc3QgZGFzaERpcmVjdGlvbnMgPSBbXG4gICAgICB7IGtleTogJ3cnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDAsIDAsIC0xKSB9LCAvLyBGb3J3YXJkXG4gICAgICB7IGtleTogJ3MnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDAsIDAsIDEpIH0sICAvLyBCYWNrd2FyZFxuICAgICAgeyBrZXk6ICdhJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygtMSwgMCwgMCkgfSwgLy8gTGVmdFxuICAgICAgeyBrZXk6ICdkJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygxLCAwLCAwKSB9ICAgLy8gUmlnaHRcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCB7IGtleSwgZGlyZWN0aW9uIH0gb2YgZGFzaERpcmVjdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5jaGVja0RvdWJsZVRhcChrZXkpKSB7XG4gICAgICAgIC8vIERlYnVnOiBMb2cgdGhlIGRvdWJsZSB0YXAgZGV0ZWN0aW9uXG4gICAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IHRoaXMuaW5wdXRNYW5hZ2VyLmdldERvdWJsZVRhcERlYnVnSW5mbyhrZXkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBpbnB1dCBkaXJlY3Rpb24gdG8gd29ybGQgc3BhY2UgYmFzZWQgb24gY2FtZXJhIG9yaWVudGF0aW9uXG4gICAgICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gdGhpcy5nZXRXb3JsZFNwYWNlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHRlbXB0IHRvIHN0YXJ0IGRhc2hcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgICAgIGNvbnN0IGRhc2hTdGFydGVkID0gbW92ZW1lbnQuc3RhcnREYXNoKHdvcmxkRGlyZWN0aW9uLCB0cmFuc2Zvcm0ucG9zaXRpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXNoU3RhcnRlZCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSBkb3VibGUtdGFwIHN0YXRlIHRvIHByZXZlbnQgbXVsdGlwbGUgZGFzaGVzXG4gICAgICAgICAgdGhpcy5pbnB1dE1hbmFnZXIucmVzZXREb3VibGVUYXAoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYnJlYWs7IC8vIE9ubHkgcHJvY2VzcyBvbmUgZGFzaCBwZXIgZnJhbWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZURhc2hNb3ZlbWVudChtb3ZlbWVudDogTW92ZW1lbnQsIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKCFtb3ZlbWVudC5pc0Rhc2hpbmcpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgIGNvbnN0IGRhc2hSZXN1bHQgPSBtb3ZlbWVudC51cGRhdGVEYXNoKGN1cnJlbnRUaW1lKTtcblxuICAgIGlmIChkYXNoUmVzdWx0Lm5ld1Bvc2l0aW9uKSB7XG4gICAgICAvLyBBcHBseSBib3VuZHMgY2hlY2tpbmcgKHNpbWlsYXIgdG8gb2xkIGltcGxlbWVudGF0aW9uKVxuICAgICAgY29uc3QgTUFYX0RBU0hfQk9VTkRTID0gMjk7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW4gKG1hdGNoZXMgbWFwIGJvdW5kYXJ5KVxuICAgICAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gZGFzaFJlc3VsdC5uZXdQb3NpdGlvbi5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlRnJvbU9yaWdpbiA8PSBNQVhfREFTSF9CT1VORFMpIHtcbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkoZGFzaFJlc3VsdC5uZXdQb3NpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYW5jZWwgZGFzaCBpZiBpdCB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKGBEYXNoIGNhbmNlbGxlZDogd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luICgke2Rpc3RhbmNlRnJvbU9yaWdpbi50b0ZpeGVkKDIpfSA+ICR7TUFYX0RBU0hfQk9VTkRTfSlgKTtcbiAgICAgICAgbW92ZW1lbnQuY2FuY2VsRGFzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhcmdlTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNDaGFyZ2luZykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY2hhcmdlIHdhcyBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgIGlmICh0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbikge1xuICAgICAgbW92ZW1lbnQuY2FuY2VsQ2hhcmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZVJlc3VsdCA9IG1vdmVtZW50LnVwZGF0ZUNoYXJnZShjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uKSB7XG4gICAgICAvLyBBcHBseSBib3VuZHMgY2hlY2tpbmdcbiAgICAgIGNvbnN0IE1BWF9DSEFSR0VfQk9VTkRTID0gMjk7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW4gKG1hdGNoZXMgbWFwIGJvdW5kYXJ5KVxuICAgICAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcGlsbGFyIGNvbGxpc2lvblxuICAgICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihjaGFyZ2VSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2VGcm9tT3JpZ2luID4gTUFYX0NIQVJHRV9CT1VORFMpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW5cbiAgICAgICAgbW92ZW1lbnQuY2FuY2VsQ2hhcmdlKCk7XG4gICAgICAgIC8vIE5vdGlmeSBzd29yZCBjb21wb25lbnQgdGhhdCBjaGFyZ2Ugd2FzIGNhbmNlbGxlZFxuICAgICAgICB0aGlzLm9uQ2hhcmdlQ29tcGxldGUoKTtcbiAgICAgIH0gZWxzZSBpZiAocGlsbGFyQ29sbGlzaW9uLmhhc0NvbGxpc2lvbikge1xuICAgICAgICAvLyBDYW5jZWwgY2hhcmdlIGlmIGl0IHdvdWxkIGNvbGxpZGUgd2l0aCBhIHBpbGxhclxuICAgICAgICBjb25zb2xlLndhcm4oYENoYXJnZSBjYW5jZWxsZWQ6IHdvdWxkIGNvbGxpZGUgd2l0aCBwaWxsYXIgYXQgWyR7cGlsbGFyQ29sbGlzaW9uLnBpbGxhckNlbnRlci50b0FycmF5KCkuam9pbignLCAnKX1dYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAvLyBOb3RpZnkgc3dvcmQgY29tcG9uZW50IHRoYXQgY2hhcmdlIHdhcyBjYW5jZWxsZWRcbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbikge1xuICAgICAgICAvLyBPbmx5IHVwZGF0ZSBwb3NpdGlvbiBpZiBub3Qgc3RvcHBlZCBieSBjb2xsaXNpb25cbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkoY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hhcmdlUmVzdWx0LmlzQ29tcGxldGUgfHwgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ2hhcmdlIG1vdmVtZW50IGNvbXBsZXRlZCcpO1xuICAgICAgLy8gTm90aWZ5IHN3b3JkIGNvbXBvbmVudCB0aGF0IGNoYXJnZSBpcyBjb21wbGV0ZVxuICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRGVmaW5lIHBpbGxhciBwb3NpdGlvbnMgKHNhbWUgYXMgaW4gRW52aXJvbm1lbnQudHN4KVxuICBwcml2YXRlIHJlYWRvbmx5IFBJTExBUl9QT1NJVElPTlMgPSBbXG4gICAgbmV3IFZlY3RvcjMoMCwgMCwgLTUpLCAgICAgICAgLy8gRnJvbnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoLTQuMjUsIDAsIDIuNSksICAgLy8gTGVmdCBwaWxsYXJcbiAgICBuZXcgVmVjdG9yMyg0LjI1LCAwLCAyLjUpICAgICAvLyBSaWdodCBwaWxsYXJcbiAgXTtcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUkFESVVTID0gMC43OyAvLyBTYW1lIGFzIFBpbGxhckNvbGxpc2lvbi50c3hcblxuICBwcml2YXRlIGNoZWNrUGlsbGFyQ29sbGlzaW9uKHBvc2l0aW9uOiBWZWN0b3IzKTogeyBoYXNDb2xsaXNpb246IGJvb2xlYW47IG5vcm1hbDogVmVjdG9yMzsgcGlsbGFyQ2VudGVyOiBWZWN0b3IzIH0ge1xuICAgIGZvciAoY29uc3QgcGlsbGFyUG9zIG9mIHRoaXMuUElMTEFSX1BPU0lUSU9OUykge1xuICAgICAgLy8gT25seSBjaGVjayBob3Jpem9udGFsIGRpc3RhbmNlIChpZ25vcmUgWSlcbiAgICAgIGNvbnN0IGhvcml6b250YWxQb3MgPSBuZXcgVmVjdG9yMyhwb3NpdGlvbi54LCAwLCBwb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHBpbGxhckhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhwaWxsYXJQb3MueCwgMCwgcGlsbGFyUG9zLnopO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBob3Jpem9udGFsUG9zLmRpc3RhbmNlVG8ocGlsbGFySG9yaXpvbnRhbCk7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZSA8IHRoaXMuUElMTEFSX1JBRElVUykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbm9ybWFsIHZlY3RvciBwb2ludGluZyBhd2F5IGZyb20gcGlsbGFyIGNlbnRlclxuICAgICAgICBjb25zdCBub3JtYWwgPSBob3Jpem9udGFsUG9zLmNsb25lKCkuc3ViKHBpbGxhckhvcml6b250YWwpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBwbGF5ZXIgaXMgZXhhY3RseSBhdCBwaWxsYXIgY2VudGVyXG4gICAgICAgIGlmIChub3JtYWwubGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgICBub3JtYWwuc2V0KDEsIDAsIDApOyAvLyBEZWZhdWx0IGRpcmVjdGlvblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzQ29sbGlzaW9uOiB0cnVlLFxuICAgICAgICAgIG5vcm1hbDogbm9ybWFsLFxuICAgICAgICAgIHBpbGxhckNlbnRlcjogcGlsbGFyUG9zLmNsb25lKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgaGFzQ29sbGlzaW9uOiBmYWxzZSwgbm9ybWFsOiBuZXcgVmVjdG9yMygpLCBwaWxsYXJDZW50ZXI6IG5ldyBWZWN0b3IzKCkgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0V29ybGRTcGFjZURpcmVjdGlvbihpbnB1dERpcmVjdGlvbjogVmVjdG9yMyk6IFZlY3RvcjMge1xuICAgIC8vIEdldCBjYW1lcmEgZGlyZWN0aW9uIHZlY3RvcnNcbiAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgXG4gICAgLy8gR2V0IGNhbWVyYSdzIHJpZ2h0IHZlY3RvclxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoY2FtZXJhRGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gR2V0IGNhbWVyYSdzIGZvcndhcmQgdmVjdG9yIChwcm9qZWN0ZWQgb24gWFogcGxhbmUpXG4gICAgY29uc3QgY2FtZXJhRm9yd2FyZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhRm9yd2FyZC5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoMCwgMSwgMCksIGNhbWVyYVJpZ2h0KS5ub3JtYWxpemUoKTtcblxuICAgIC8vIFRyYW5zZm9ybSBpbnB1dCBkaXJlY3Rpb24gdG8gd29ybGQgc3BhY2VcbiAgICBjb25zdCB3b3JsZERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYVJpZ2h0LCBpbnB1dERpcmVjdGlvbi54KTtcbiAgICB3b3JsZERpcmVjdGlvbi5hZGRTY2FsZWRWZWN0b3IoY2FtZXJhRm9yd2FyZCwgLWlucHV0RGlyZWN0aW9uLnopO1xuICAgIHdvcmxkRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIHdvcmxkRGlyZWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRGl2aW5lU3Rvcm0ocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCByYWdlIChtaW5pbXVtIDIwIHJhZ2UgcmVxdWlyZWQpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdERpdmluZVN0b3JtKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGl2aW5lU3Rvcm1UaW1lIDwgdGhpcy5kaXZpbmVTdG9ybUNvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgcmFnZSBhbW91bnQgYW5kIGNvbnN1bWUgQUxMIHJhZ2VcbiAgICBjb25zdCBjdXJyZW50UmFnZSA9IGdhbWVVSSA/IGdhbWVVSS5nZXRDdXJyZW50UmFnZSgpIDogNDA7IC8vIEZhbGxiYWNrIHRvIDQwIGlmIGdhbWVVSSBub3QgYXZhaWxhYmxlXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVBbGxSYWdlKCk7IC8vIENvbnN1bWUgYWxsIHJhZ2UgaW5zdGVhZCBvZiBqdXN0IDIwXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGV4dGVuZGVkIGR1cmF0aW9uOiBiYXNlIDQgc2Vjb25kcyArIDEgc2Vjb25kIHBlciAxMCByYWdlIGNvbnN1bWVkXG4gICAgY29uc3QgYmFzZVN0b3JtRHVyYXRpb24gPSAxMDAwOyAvLyA0IHNlY29uZHMgYmFzZVxuICAgIGNvbnN0IGJvbnVzRHVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRSYWdlIC8gMTApICogNTAwOyAvLyAxIHNlY29uZCBwZXIgMTAgcmFnZVxuICAgIGNvbnN0IHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbiA9IGJhc2VTdG9ybUR1cmF0aW9uICsgYm9udXNEdXJhdGlvbjtcblxuICAgIHRoaXMuaXNEaXZpbmVTdG9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0RGl2aW5lU3Rvcm1UaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBEaXZpbmUgU3Rvcm0gY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24sIHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gRGl2aW5lIFN0b3JtIGxhc3RzIGZvciBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSBmYWxzZTtcbiAgICB9LCB0b3RhbERpdmluZVN0b3JtRHVyYXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQ2hhcmdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENoYXJnZVRpbWUgPCB0aGlzLmNoYXJnZUNvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1N3b3JkQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMubGFzdENoYXJnZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBSZXNldCBjb2xsaXNpb24gdHJhY2tpbmcgZm9yIG5ldyBjaGFyZ2VcbiAgICB0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbiA9IGZhbHNlO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgQ2hhcmdlIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllclxuICAgIGlmICh0aGlzLm9uQ2hhcmdlQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5vbkNoYXJnZUNhbGxiYWNrKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBHYWluIHJhZ2UgZm9yIHVzaW5nIGNoYXJnZSBhYmlsaXR5ICgrMjAgcmFnZSlcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5nYWluUmFnZSgyMCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0YXJ0IHRoZSBjaGFyZ2UgbW92ZW1lbnQgdXNpbmcgdGhlIHNlcGFyYXRlIGNoYXJnZSBzeXN0ZW1cbiAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgICAvLyBHZXQgY2hhcmdlIGRpcmVjdGlvbiBmcm9tIGNhbWVyYVxuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICBkaXJlY3Rpb24ueSA9IDA7IC8vIEtlZXAgbW92ZW1lbnQgaG9yaXpvbnRhbFxuICAgICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCBjaGFyZ2Ugd2l0aCAxMC41IGRpc3RhbmNlIChzZXBhcmF0ZSBmcm9tIGRhc2ggc3lzdGVtKVxuICAgICAgICBjb25zdCBjaGFyZ2VTdGFydGVkID0gcGxheWVyTW92ZW1lbnQuc3RhcnRDaGFyZ2UoZGlyZWN0aW9uLCBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChjaGFyZ2VTdGFydGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgY2hhcmdlIGRhbWFnZSBkZXRlY3Rpb24gZHVyaW5nIG1vdmVtZW50XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0sIGRpcmVjdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhY2sgY2hhcmdlIGhpdCBlbnRpdGllcyB0byBwcmV2ZW50IG11bHRpcGxlIGhpdHMgYW5kIGVuYWJsZSBjb2xsaXNpb24gc3RvcHBpbmdcbiAgcHJpdmF0ZSBjaGFyZ2VIaXRFbnRpdGllcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBwcml2YXRlIGNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbiA9IGZhbHNlO1xuXG4gIC8vIFNjaGVkdWxlIGRhbWFnZSBkZXRlY3Rpb24gZHVyaW5nIGNoYXJnZSBtb3ZlbWVudFxuICBwcml2YXRlIHNjaGVkdWxlQ2hhcmdlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtLCBjaGFyZ2VEaXJlY3Rpb246IFZlY3RvcjMsIHN0YXJ0VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSAwLjY7IFxuICAgIGNvbnN0IGRhbWFnZUNoZWNrSW50ZXJ2YWwgPSA1MDsgLy8gQ2hlY2sgZm9yIGRhbWFnZSBldmVyeSA1MG1zIGZvciBiZXR0ZXIgY29sbGlzaW9uIGRldGVjdGlvblxuICAgIGNvbnN0IGNoYXJnZURhbWFnZSA9IDQwOyAvLyBIaWdoIGRhbWFnZSBmb3IgY2hhcmdlIGFiaWxpdHlcbiAgICBjb25zdCBjaGFyZ2VSYWRpdXMgPSAyLjU7IC8vIERhbWFnZSByYWRpdXMgYXJvdW5kIHBsYXllciBkdXJpbmcgY2hhcmdlXG4gICAgXG4gICAgLy8gUmVzZXQgY2hhcmdlIGhpdCB0cmFja2luZ1xuICAgIHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbiA9IGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IGRhbWFnZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgIFxuICAgICAgLy8gU3RvcCBpZiBjaGFyZ2UgaXMgY29tcGxldGUsIGNhbmNlbGxlZCwgb3Igc3RvcHBlZCBieSBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5pc1N3b3JkQ2hhcmdpbmcgfHwgY3VycmVudFRpbWUgLSBzdGFydFRpbWUgPiBjaGFyZ2VEdXJhdGlvbiB8fCB0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbikge1xuICAgICAgICBjbGVhckludGVydmFsKGRhbWFnZUludGVydmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZCB0byBjaGVjayBmb3IgZGFtYWdlXG4gICAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBsZXQgaGl0U29tZXRoaW5nID0gZmFsc2U7XG4gICAgICBcbiAgICAgIC8vIERlYnVnOiBMb2cgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZCBkdXJpbmcgY2hhcmdlXG4gICAgICBcbiAgICAgIC8vIEVOSEFOQ0VEOiBBbHNvIGNoZWNrIGFnYWluc3Qgc2VydmVyIHBsYXllciBwb3NpdGlvbnMgZGlyZWN0bHkgYXMgYSBmYWxsYmFja1xuICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IG1pc3MgY29sbGlzaW9ucyBkdWUgdG8gZW50aXR5IHN5bmMgaXNzdWVzXG4gICAgICBjb25zdCBzZXJ2ZXJQbGF5ZXJzID0gKHdpbmRvdyBhcyBhbnkpLnB2cFBsYXllcnMgfHwgbmV3IE1hcCgpO1xuICAgICAgY29uc3QgbG9jYWxTb2NrZXRJZCA9ICh3aW5kb3cgYXMgYW55KS5sb2NhbFNvY2tldElkO1xuICAgICAgICAgICAgXG4gICAgICBzZXJ2ZXJQbGF5ZXJzLmZvckVhY2goKHNlcnZlclBsYXllcjogYW55LCBwbGF5ZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIC8vIFNraXAgc2VsZlxuICAgICAgICBpZiAocGxheWVySWQgPT09IGxvY2FsU29ja2V0SWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIFNraXAgYWxyZWFkeSBoaXQgcGxheWVycyAodXNlIGhhc2ggb2YgcGxheWVyIElEIGZvciB0cmFja2luZylcbiAgICAgICAgY29uc3QgcGxheWVySWRIYXNoID0gcGxheWVySWQubGVuZ3RoICogMTAwMCArIHBsYXllcklkLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmICh0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmhhcyhwbGF5ZXJJZEhhc2gpKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZXJ2ZXJQbGF5ZXJQb3MgPSBuZXcgVmVjdG9yMyhzZXJ2ZXJQbGF5ZXIucG9zaXRpb24ueCwgc2VydmVyUGxheWVyLnBvc2l0aW9uLnksIHNlcnZlclBsYXllci5wb3NpdGlvbi56KTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKHNlcnZlclBsYXllclBvcyk7XG4gICAgICAgIGNvbnN0IHN0b3BEaXN0YW5jZSA9IDAuOSArIDEuMDsgLy8gUGxheWVyIGNvbGxpc2lvbiByYWRpdXMgKyBidWZmZXJcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gc3RvcERpc3RhbmNlICYmIHNlcnZlclBsYXllci5oZWFsdGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5hZGQocGxheWVySWRIYXNoKTtcbiAgICAgICAgICBoaXRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IGRhbWFnZSB0aHJvdWdoIFBWUCBzeXN0ZW0gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnc3dvcmRfY2hhcmdlX2hpdCcsIHBsYXllclBvc2l0aW9uLmNsb25lKCksIGNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLCB7XG4gICAgICAgICAgICAgIGRhbWFnZTogY2hhcmdlRGFtYWdlLFxuICAgICAgICAgICAgICB0YXJnZXRJZDogcGxheWVySWQsXG4gICAgICAgICAgICAgIGhpdFBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogc2VydmVyUGxheWVyUG9zLngsXG4gICAgICAgICAgICAgICAgeTogc2VydmVyUGxheWVyUG9zLnksXG4gICAgICAgICAgICAgICAgejogc2VydmVyUGxheWVyUG9zLnpcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgICAvLyBTa2lwIHNlbGZcbiAgICAgICAgaWYgKGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIGFscmVhZHkgaGl0IGVudGl0aWVzXG4gICAgICAgIGlmICh0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmhhcyhlbnRpdHkuaWQpKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaGFzIHRyYW5zZm9ybSBhbmQgaGVhbHRoIChjb3VsZCBiZSBlbmVteSBvciBwbGF5ZXIpXG4gICAgICAgIGNvbnN0IGVudGl0eVRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgY29uc3QgZW50aXR5SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgICBjb25zdCBlbnRpdHlDb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gRGVidWc6IExvZyBlbnRpdHkgZGV0YWlsc1xuICAgICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgICBjb25zdCBlbnRpdHlUeXBlID0gZW5lbXkgPyBgRW5lbXkoJHtlbmVteS5nZXREaXNwbGF5TmFtZSgpfSlgIDogYFBsYXllcigke2VudGl0eS5pZH0pYDtcbiAgICAgICAgXG4gICAgICAgIGlmICghZW50aXR5VHJhbnNmb3JtIHx8ICFlbnRpdHlIZWFsdGggfHwgZW50aXR5SGVhbHRoLmlzRGVhZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZW50aXR5UG9zaXRpb24gPSBlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcGxheWVyUG9zaXRpb24uZGlzdGFuY2VUbyhlbnRpdHlQb3NpdGlvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaXMgd2l0aGluIGNoYXJnZSBkYW1hZ2UgcmFkaXVzXG4gICAgICAgIC8vIEluIFBWUCwgd2Ugd2FudCB0byBzdG9wIGp1c3QgYmVmb3JlIGhpdHRpbmcgdGhlIGVuZW15LCBub3Qgb3ZlcmxhcCB3aXRoIHRoZW1cbiAgICAgICAgY29uc3Qgc3RvcERpc3RhbmNlID0gZW50aXR5Q29sbGlkZXIgPyBlbnRpdHlDb2xsaWRlci5yYWRpdXMgKyAxLjAgOiBjaGFyZ2VSYWRpdXM7IC8vIFN0b3AgMSB1bml0IGF3YXkgZnJvbSBlbmVteSBlZGdlXG4gICAgICAgIFxuICAgICAgICAvLyBEZWJ1ZzogTG9nIHBvc2l0aW9uIGFuZCBkaXN0YW5jZSBpbmZvcm1hdGlvblxuICAgICAgICBcbiAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHN0b3BEaXN0YW5jZSkge1xuICAgICAgICAgIC8vIE1hcmsgYXMgaGl0IHRvIHByZXZlbnQgbXVsdGlwbGUgaGl0c1xuICAgICAgICAgIHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuYWRkKGVudGl0eS5pZCk7XG4gICAgICAgICAgaGl0U29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcHBseSBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtXG4gICAgICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgICAgICBpZiAoY29tYmF0U3lzdGVtICYmIHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCBjaGFyZ2VEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5LCAnY2hhcmdlJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgICAgICBjb25zdCBlbnRpdHlUeXBlID0gZW5lbXkgPyBgRW5lbXkoJHtlbmVteS5nZXREaXNwbGF5TmFtZSgpfSlgIDogYFBsYXllcigke2VudGl0eS5pZH0pYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQnJvYWRjYXN0IGNoYXJnZSBhdHRhY2sgZm9yIFBWUCAoaW5jbHVkZXMgZGFtYWdlIGFuZCBhbmltYXRpb24pXG4gICAgICAgICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3N3b3JkX2NoYXJnZV9oaXQnLCBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpLCBjaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKSwge1xuICAgICAgICAgICAgICAgIGRhbWFnZTogY2hhcmdlRGFtYWdlLFxuICAgICAgICAgICAgICAgIHRhcmdldElkOiBlbnRpdHkuaWQsXG4gICAgICAgICAgICAgICAgaGl0UG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IGVudGl0eVBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICB5OiBlbnRpdHlQb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgejogZW50aXR5UG9zaXRpb24uelxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gSW4gUFZQIG1vZGUsIHN0b3AgY2hhcmdlIHdoZW4gaGl0dGluZyBzb21ldGhpbmdcbiAgICAgIGlmIChoaXRTb21ldGhpbmcpIHtcbiAgICAgICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcCB0aGUgY2hhcmdlIG1vdmVtZW50IGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgICAgIHBsYXllck1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRhbWFnZSBpbnRlcnZhbCBpbW1lZGlhdGVseSB0byBwcmV2ZW50IGZ1cnRoZXIgaGl0c1xuICAgICAgICBjbGVhckludGVydmFsKGRhbWFnZUludGVydmFsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgY2hhcmdlIGNvbXBsZXRpb25cbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgZGFtYWdlQ2hlY2tJbnRlcnZhbCk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gQ2hhcmdlIGNvbXBsZXRlc1xuICBwdWJsaWMgb25DaGFyZ2VDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRGVmbGVjdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REZWZsZWN0VGltZSA8IHRoaXMuZGVmbGVjdENvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc0RlZmxlY3RpbmcgPSB0cnVlO1xuICAgIHRoaXMubGFzdERlZmxlY3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBEZWZsZWN0IGNhbGxiYWNrIGZvciBtdWx0aXBsYXllclxuICAgIGlmICh0aGlzLm9uRGVmbGVjdENhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIHRoaXMub25EZWZsZWN0Q2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCB1cCBkZWZsZWN0IGJhcnJpZXIgdGhhdCBibG9ja3MgZGFtYWdlIGFuZCByZWZsZWN0cyBwcm9qZWN0aWxlc1xuICAgIHRoaXMuc2V0dXBEZWZsZWN0QmFycmllcihwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIEF1dG8tY29tcGxldGUgZGVmbGVjdCBhZnRlciBkdXJhdGlvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5vbkRlZmxlY3RDb21wbGV0ZSgpO1xuICAgIH0sIHRoaXMuZGVmbGVjdER1cmF0aW9uICogMTAwMCk7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1WaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFZpcGVyU3RpbmdUaW1lIDwgdGhpcy52aXBlclN0aW5nRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBlbmVyZ3kgKDYwIGVuZXJneSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RWaXBlclN0aW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDYwKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBjaGFyZ2luZyBhbmltYXRpb25cbiAgICBjb25zdCBjaGFyZ2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMTAwMDsgLy8gMSBzZWNvbmQgY2hhcmdlIHRpbWVcbiAgICBcbiAgICBjb25zdCBjaGFyZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gY2hhcmdlU3RhcnRUaW1lO1xuICAgICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGFyZ2VJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZmlyZVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDAuODI1OyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBzYW1lIGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiBhcyBvdGhlciBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXMgZG93bndhcmQgY29tcGVuc2F0aW9uXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSByb3RhdGlvbiBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgdG8gdGlsdCB0aGUgZGlyZWN0aW9uIGRvd253YXJkXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gT2Zmc2V0IHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBsYXllclBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIFxuICAgIC8vIE5vdGU6IFZpcGVyIFN0aW5nIGRhbWFnZSBpcyBoYW5kbGVkIGJ5IFZpcGVyU3RpbmdNYW5hZ2VyLCBub3QgRUNTIHByb2plY3RpbGVzXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgcHJvamVjdGlsZXMgYW5kIGRhbWFnZVxuICAgIFxuICAgIC8vIFRyaWdnZXIgVmlwZXIgU3RpbmcgY2FsbGJhY2sgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25WaXBlclN0aW5nQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25WaXBlclN0aW5nQ2FsbGJhY2socGxheWVyUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyaWdnZXIgdGhlIGdsb2JhbCBWaXBlciBTdGluZyBtYW5hZ2VyIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0cmlnZ2VyR2xvYmFsVmlwZXJTdGluZygpO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygn8J+QjSBWaXBlciBTdGluZyB2aXN1YWwgZWZmZWN0cyBzdWNjZXNzZnVsbHkgdHJpZ2dlcmVkIScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygndmlwZXJfc3RpbmdfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwge1xuICAgICAgICBzcGVlZDogMTYsXG4gICAgICAgIGRhbWFnZTogNjEsXG4gICAgICAgIGxpZmV0aW1lOiA1LFxuICAgICAgICBpc1JldHVybmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFycmFnZVRpbWUgPCB0aGlzLmJhcnJhZ2VGaXJlUmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYOKPsCBCYXJyYWdlIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmJhcnJhZ2VGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lKSkudG9GaXhlZCgxKX1zYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg0MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0QmFycmFnZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg0MCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdEJhcnJhZ2VUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gU3RhcnQgY2hhcmdpbmcgYW5pbWF0aW9uXG4gICAgY29uc3QgY2hhcmdlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjaGFyZ2VEdXJhdGlvbiA9IDUwMDsgLy8gMSBzZWNvbmQgY2hhcmdlIHRpbWVcbiAgICBcbiAgICBjb25zdCBjaGFyZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gY2hhcmdlU3RhcnRUaW1lO1xuICAgICAgdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGFyZ2VJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZmlyZUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDAuODI1OyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgY29tcGVuc2F0aW9uIGFzIHByb2plY3RpbGUgc3lzdGVtXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlc1xuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIDUgYXJyb3dzOiBjZW50ZXIgKDDCsCksIGxlZnQgKDE1wrAsIDMwwrApLCByaWdodCAoLTE1wrAsIC0zMMKwKSB1c2luZyBwcm9wZXIgRUNTIHByb2plY3RpbGVzXG4gICAgY29uc3QgYW5nbGVzID0gWzAsIE1hdGguUEkgLyAxMiwgLU1hdGguUEkgLyAxMiwgTWF0aC5QSSAvIDYsIC1NYXRoLlBJIC8gNl07IC8vIDDCsCwgMTXCsCwgLTE1wrAsIDMwwrAsIC0zMMKwXG4gICAgXG4gICAgYW5nbGVzLmZvckVhY2goYW5nbGUgPT4ge1xuICAgICAgLy8gUm90YXRlIHRoZSBiYXNlIGRpcmVjdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCkubWFrZVJvdGF0aW9uWShhbmdsZSk7XG4gICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgc3Bhd25Qb3NpdGlvbi5hZGQocHJvamVjdGlsZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHByb3BlciBFQ1MgcHJvamVjdGlsZSBlbnRpdHlcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiAyMiwgLy8gU2xpZ2h0bHkgZmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3MgKDIwKVxuICAgICAgICBkYW1hZ2U6IDMwLCAvLyBIaWdoIGRhbWFnZSBmb3IgYmFycmFnZSBhcnJvd3NcbiAgICAgICAgbGlmZXRpbWU6IDgsXG4gICAgICAgIG1heERpc3RhbmNlOiAyNSwgLy8gTGltaXQgYmFycmFnZSBhcnJvd3MgdG8gMjUgdW5pdHMgZGlzdGFuY2UgKHNhbWUgYXMgcmVndWxhciBhcnJvd3MpXG4gICAgICAgIHBpZXJjaW5nOiBmYWxzZSxcbiAgICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICAgIHByb2plY3RpbGVEaXJlY3Rpb24sXG4gICAgICAgIHRoaXMucGxheWVyRW50aXR5IS5pZCxcbiAgICAgICAgcHJvamVjdGlsZUNvbmZpZ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gTWFyayBhcyBiYXJyYWdlIGFycm93IGZvciB2aXN1YWwgaWRlbnRpZmljYXRpb25cbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpIGFzIFJlbmRlcmVyO1xuICAgICAgaWYgKHJlbmRlcmVyPy5tZXNoKSB7XG4gICAgICAgIHJlbmRlcmVyLm1lc2gudXNlckRhdGEuaXNCYXJyYWdlQXJyb3cgPSB0cnVlO1xuICAgICAgICByZW5kZXJlci5tZXNoLnVzZXJEYXRhLmlzUmVndWxhckFycm93ID0gZmFsc2U7IC8vIE92ZXJyaWRlIHJlZ3VsYXIgYXJyb3cgbWFya2luZ1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2JhcnJhZ2VfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIHByb2plY3RpbGVEaXJlY3Rpb24sIHByb2plY3RpbGVDb25maWcpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBCYXJyYWdlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHZpc3VhbCBlZmZlY3RzIGlmIG5lZWRlZFxuICAgIGlmICh0aGlzLm9uQmFycmFnZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQmFycmFnZUNhbGxiYWNrKHBsYXllclBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBEZWZsZWN0QmFycmllcihwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEFjdGl2YXRlIHRoZSBkZWZsZWN0IGJhcnJpZXJcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgY29uc3QgcGxheWVyUm90YXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBVc2UgU0FNRSByb3RhdGlvbiBsb2dpYyBhcyBEcmFnb25SZW5kZXJlciBmb3IgY29uc2lzdGVuY3kgd2l0aCB2aXN1YWwgc2hpZWxkXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDAuMSkge1xuICAgICAgICAvLyBQbGF5ZXIgaXMgYWN0aXZlbHkgbW92aW5nIC0gdXNlIG1vdmVtZW50IGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlcilcbiAgICAgICAgY29uc3QgbW92ZURpciA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb247XG4gICAgICAgIGlmIChtb3ZlRGlyLmxlbmd0aCgpID4gMC4xKSB7XG4gICAgICAgICAgY29uc3QgbW92ZUFuZ2xlID0gTWF0aC5hdGFuMihtb3ZlRGlyLngsIG1vdmVEaXIueik7XG4gICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IG1vdmVBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90IG1vdmluZyAtIHVzZSBjYW1lcmEgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyIGZhbGxiYWNrKVxuICAgICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgICAgICBwbGF5ZXJSb3RhdGlvbi55ID0gTWF0aC5hdGFuMihjYW1lcmFEaXJlY3Rpb24ueCwgY2FtZXJhRGlyZWN0aW9uLnopO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmRlZmxlY3RCYXJyaWVyLmFjdGl2YXRlKHBsYXllclBvc2l0aW9uLCBwbGF5ZXJSb3RhdGlvbiwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgZGVmbGVjdCBiYXJyaWVyIHBvc2l0aW9uIGlmIGl0J3MgYWN0aXZlXG4gICAgaWYgKHRoaXMuZGVmbGVjdEJhcnJpZXIuaXNCYXJyaWVyQWN0aXZlKCkpIHtcbiAgICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IHBsYXllclJvdGF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBTQU1FIHJvdGF0aW9uIGxvZ2ljIGFzIERyYWdvblJlbmRlcmVyIGZvciBjb25zaXN0ZW5jeSB3aXRoIHZpc3VhbCBzaGllbGRcbiAgICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICBjb25zdCBtb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICAgIGlmIChtb3ZlbWVudCAmJiBtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoID4gMC4xKSB7XG4gICAgICAgICAgLy8gUGxheWVyIGlzIGFjdGl2ZWx5IG1vdmluZyAtIHVzZSBtb3ZlbWVudCBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIpXG4gICAgICAgICAgY29uc3QgbW92ZURpciA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb247XG4gICAgICAgICAgaWYgKG1vdmVEaXIubGVuZ3RoKCkgPiAwLjEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVBbmdsZSA9IE1hdGguYXRhbjIobW92ZURpci54LCBtb3ZlRGlyLnopO1xuICAgICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IG1vdmVBbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm90IG1vdmluZyAtIHVzZSBjYW1lcmEgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyIGZhbGxiYWNrKVxuICAgICAgICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgICBwbGF5ZXJSb3RhdGlvbi55ID0gTWF0aC5hdGFuMihjYW1lcmFEaXJlY3Rpb24ueCwgY2FtZXJhRGlyZWN0aW9uLnopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBiYXJyaWVyIHBvc2l0aW9uIHRvIGZvbGxvdyBwbGF5ZXJcbiAgICAgIHRoaXMuZGVmbGVjdEJhcnJpZXIudXBkYXRlUG9zaXRpb24ocGxheWVyUG9zaXRpb24sIHBsYXllclJvdGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gRGVmbGVjdCBjb21wbGV0ZXNcbiAgcHVibGljIG9uRGVmbGVjdENvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICAvLyBQdWJsaWMgbWV0aG9kcyB0byBnZXQgY29vbGRvd24gaW5mb3JtYXRpb24gZm9yIFVJXG4gIHB1YmxpYyBnZXRXZWFwb25Td2l0Y2hDb29sZG93bigpOiB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXIgfSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUpKSxcbiAgICAgIG1heDogdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93blxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0QWJpbGl0eUNvb2xkb3ducygpOiBSZWNvcmQ8c3RyaW5nLCB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXI7IGlzQWN0aXZlOiBib29sZWFuIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIGNvbnN0IGNvb2xkb3duczogUmVjb3JkPHN0cmluZywgeyBjdXJyZW50OiBudW1iZXI7IG1heDogbnVtYmVyOyBpc0FjdGl2ZTogYm9vbGVhbiB9PiA9IHt9O1xuICAgIFxuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRlZmxlY3RDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERlZmxlY3RUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5kZWZsZWN0Q29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGVmbGVjdGluZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNoYXJnZUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY2hhcmdlQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzU3dvcmRDaGFyZ2luZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGl2aW5lU3Rvcm1pbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuQk9XKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5iYXJyYWdlRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYXJyYWdlVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuYmFycmFnZUZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNvYnJhU2hvdEZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q29icmFTaG90VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY29icmFTaG90RmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFZpcGVyU3RpbmdUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy52aXBlclN0aW5nRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNDWVRIRSkge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIDEuMCAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUpKSxcbiAgICAgICAgbWF4OiAxLjAsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmZyb3N0Tm92YUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q3Jvc3NlbnRyb3B5VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQUJSRVMpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmJhY2tzdGFiQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYWNrc3RhYlRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmJhY2tzdGFiQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQmFja3N0YWJiaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuc3VuZGVyQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTdW5kZXJUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5zdW5kZXJDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNTdW5kZXJpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5za3lmYWxsQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuc2t5ZmFsbENvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1NreWZhbGxpbmdcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb29sZG93bnM7XG4gIH1cbn0iXSwibmFtZXMiOlsiVmVjdG9yMyIsIk1hdHJpeDQiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkhlYWx0aCIsIkVuZW15IiwiUmVuZGVyZXIiLCJDb2xsaWRlciIsIkNvbWJhdFN5c3RlbSIsIldlYXBvblN1YmNsYXNzIiwiV2VhcG9uVHlwZSIsIkRlZmxlY3RCYXJyaWVyIiwidHJpZ2dlckdsb2JhbEZyb3N0Tm92YSIsImFkZEdsb2JhbEZyb3plbkVuZW15IiwiYWRkR2xvYmFsU3R1bm5lZEVuZW15IiwidHJpZ2dlckdsb2JhbENvYnJhU2hvdCIsInRyaWdnZXJHbG9iYWxWaXBlclN0aW5nIiwiQ29udHJvbFN5c3RlbSIsInNldFBsYXllciIsImVudGl0eSIsInBsYXllckVudGl0eSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwicGxheWVyVHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwicGxheWVyTW92ZW1lbnQiLCJ1cGRhdGVEZWJ1ZmZzIiwiY2xlYW51cFN1bmRlclN0YWNrcyIsImhhbmRsZVdlYXBvblN3aXRjaGluZyIsImhhbmRsZURhc2hNb3ZlbWVudCIsImhhbmRsZUNoYXJnZU1vdmVtZW50IiwiaXNEYXNoaW5nIiwiaXNDaGFyZ2luZyIsImlzRnJvemVuIiwiaXNTa3lmYWxsaW5nIiwiaGFuZGxlTW92ZW1lbnRJbnB1dCIsImhhbmRsZUNvbWJhdElucHV0IiwidXBkYXRlRGVmbGVjdEJhcnJpZXIiLCJtb3ZlbWVudCIsImNoZWNrRm9yRGFzaElucHV0IiwiaW5wdXREaXJlY3Rpb24iLCJoYXNJbnB1dCIsImlucHV0TWFuYWdlciIsImlzS2V5UHJlc3NlZCIsInoiLCJ4IiwibGVuZ3RoIiwibm9ybWFsaXplIiwiY2FtZXJhRGlyZWN0aW9uIiwiY2FtZXJhIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJjYW1lcmFSaWdodCIsImNyb3NzVmVjdG9ycyIsImNhbWVyYUZvcndhcmQiLCJ3b3JsZERpcmVjdGlvbiIsImFkZFNjYWxlZFZlY3RvciIsInNldE1vdmVEaXJlY3Rpb24iLCJqdW1wIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFdlYXBvblN3aXRjaFRpbWUiLCJ3ZWFwb25Td2l0Y2hDb29sZG93biIsImN1cnJlbnRXZWFwb24iLCJTV09SRCIsInJlc2V0QWxsQWJpbGl0eVN0YXRlcyIsImN1cnJlbnRTdWJjbGFzcyIsIkRJVklOSVRZIiwiZmlyZVJhdGUiLCJzd29yZEZpcmVSYXRlIiwic3dvcmRDb21ib1N0ZXAiLCJCT1ciLCJFTEVNRU5UQUwiLCJTQ1lUSEUiLCJDSEFPUyIsInNjeXRoZUZpcmVSYXRlIiwiU0FCUkVTIiwiRlJPU1QiLCJzYWJyZXNGaXJlUmF0ZSIsImhhbmRsZUJvd0lucHV0IiwiaGFuZGxlU2N5dGhlSW5wdXQiLCJoYW5kbGVTd29yZElucHV0IiwiaGFuZGxlU2FicmVzSW5wdXQiLCJpc1ZpcGVyU3RpbmdDaGFyZ2luZyIsInBlcmZvcm1WaXBlclN0aW5nIiwiaXNCYXJyYWdlQ2hhcmdpbmciLCJwZXJmb3JtQmFycmFnZSIsImlzQ29icmFTaG90Q2hhcmdpbmciLCJwZXJmb3JtQ29icmFTaG90IiwiaXNNb3VzZUJ1dHRvblByZXNzZWQiLCJjaGFyZ2VQcm9ncmVzcyIsIk1hdGgiLCJtaW4iLCJmaW5hbENoYXJnZVByb2dyZXNzIiwiZmlyZVByb2plY3RpbGUiLCJ0cmlnZ2VyQm93UmVsZWFzZUVmZmVjdHMiLCJjb25zb2xlIiwibG9nIiwiZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJmaXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHkiLCJwZXJmb3JtUmVhbmltYXRlQWJpbGl0eSIsInBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5IiwibGFzdEZpcmVUaW1lIiwiZGlyZWN0aW9uIiwiY29tcGVuc2F0aW9uQW5nbGUiLCJQSSIsInJvdGF0aW9uTWF0cml4IiwibWFrZVJvdGF0aW9uQXhpcyIsImFwcGx5TWF0cml4NCIsInBlcmZlY3RTaG90TWluVGhyZXNob2xkIiwicGVyZmVjdFNob3RNYXhUaHJlc2hvbGQiLCJpc1BlcmZlY3RTaG90IiwiY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZSIsInBvc2l0aW9uIiwiY2xvbmUiLCJjcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUiLCJhbmdsZSIsImF0YW4yIiwiY3JlYXRlUHJvamVjdGlsZSIsInNwaW5TdGF0dXMiLCJjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlIiwibGFzdENyb3NzZW50cm9weVRpbWUiLCJjcm9zc2VudHJvcHlGaXJlUmF0ZSIsImNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlIiwicG90ZW50aWFsVGFyZ2V0cyIsIndvcmxkIiwicXVlcnlFbnRpdGllcyIsInZhbGlkVGFyZ2V0cyIsImZpbHRlciIsInRhcmdldCIsImlkIiwiaXNEZWFkIiwiaGFzVmFsaWRUYXJnZXRzIiwic2hvdWxkQnJvYWRjYXN0Iiwib25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrIiwidW5kZWZpbmVkIiwic3Bhd25Qb3NpdGlvbiIsImFkZCIsIm11bHRpcGx5U2NhbGFyIiwieSIsInByb2plY3RpbGVDb25maWciLCJzcGVlZCIsImRhbWFnZSIsImxpZmV0aW1lIiwibWF4RGlzdGFuY2UiLCJzdWJjbGFzcyIsImxldmVsIiwiY3VycmVudExldmVsIiwib3BhY2l0eSIsInByb2plY3RpbGVTeXN0ZW0iLCJnYW1lVUkiLCJ3aW5kb3ciLCJjYW5DYXN0RW50cm9waWNCb2x0IiwiY29uc3VtZU1hbmEiLCJlbnRyb3BpY0NvbmZpZyIsInBpZXJjaW5nIiwiZXhwbG9zaXZlIiwiZXhwbG9zaW9uUmFkaXVzIiwiY2FuQ2FzdENyb3NzZW50cm9weUJvbHQiLCJjcm9zc2VudHJvcHlDb25maWciLCJsYXN0UmVhbmltYXRlVGltZSIsImN1cnJlbnRNYW5hIiwiZ2V0Q3VycmVudE1hbmEiLCJjYW5DYXN0UmVhbmltYXRlIiwibWFuYUJlZm9yZSIsIm1hbmFBZnRlciIsInRyaWdnZXJSZWFuaW1hdGVFZmZlY3QiLCJoZWFsdGhDb21wb25lbnQiLCJkaWRIZWFsIiwiaGVhbCIsIm9uUmVhbmltYXRlQ2FsbGJhY2siLCJwbGF5ZXJQb3NpdGlvbiIsImxhc3RGcm9zdE5vdmFUaW1lIiwiZnJvc3ROb3ZhRmlyZVJhdGUiLCJjYW5DYXN0RnJvc3ROb3ZhIiwiZ2V0V29ybGRQb3NpdGlvbiIsIm9uRnJvc3ROb3ZhQ2FsbGJhY2siLCJmcmVlemVFbmVtaWVzSW5SYWRpdXMiLCJsYXN0Q29icmFTaG90VGltZSIsImNvYnJhU2hvdEZpcmVSYXRlIiwiY2FuQ2FzdENvYnJhU2hvdCIsImNvbnN1bWVFbmVyZ3kiLCJjb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyIsImNoYXJnZVN0YXJ0VGltZSIsImNoYXJnZUR1cmF0aW9uIiwiY2hhcmdlSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImVsYXBzZWQiLCJjbGVhckludGVydmFsIiwiZmlyZUNvYnJhU2hvdCIsIm9uQ29icmFTaG90Q2FsbGJhY2siLCJ2ZW5vbUR1cmF0aW9uIiwiY2VudGVyUG9zaXRpb24iLCJyYWRpdXMiLCJhbGxFbnRpdGllcyIsImdldEFsbEVudGl0aWVzIiwiZnJvemVuQ291bnQiLCJkYW1hZ2VkUGxheWVycyIsImxvY2FsU29ja2V0SWQiLCJmb3JFYWNoIiwiZW50aXR5VHJhbnNmb3JtIiwiZW50aXR5SGVhbHRoIiwiZW50aXR5UG9zaXRpb24iLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJlbmVteSIsImZyZWV6ZSIsInRvU3RyaW5nIiwic2VydmVyUGxheWVyRW50aXRpZXMiLCJ0YXJnZXRQbGF5ZXJJZCIsImN1cnJlbnQiLCJsb2NhbEVudGl0eUlkIiwicGxheWVySWQiLCJjb21iYXRTeXN0ZW0iLCJnZXRTeXN0ZW0iLCJmcm9zdE5vdmFEYW1hZ2UiLCJxdWV1ZURhbWFnZSIsIm9uRGVidWZmQ2FsbGJhY2siLCJjaGFyZ2VkQXJyb3dDb25maWciLCJzZXRXZWFwb25TdWJjbGFzcyIsInNldEJvd1JlbGVhc2VDYWxsYmFjayIsImNhbGxiYWNrIiwib25Cb3dSZWxlYXNlQ2FsbGJhY2siLCJzZXREaXZpbmVTdG9ybUNhbGxiYWNrIiwib25EaXZpbmVTdG9ybUNhbGxiYWNrIiwic2V0UHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayIsInNldFZpcGVyU3RpbmdDYWxsYmFjayIsIm9uVmlwZXJTdGluZ0NhbGxiYWNrIiwic2V0QmFycmFnZUNhbGxiYWNrIiwib25CYXJyYWdlQ2FsbGJhY2siLCJzZXRSZWFuaW1hdGVDYWxsYmFjayIsInNldEZyb3N0Tm92YUNhbGxiYWNrIiwic2V0Q29icmFTaG90Q2FsbGJhY2siLCJzZXRDaGFyZ2VDYWxsYmFjayIsIm9uQ2hhcmdlQ2FsbGJhY2siLCJzZXREZWZsZWN0Q2FsbGJhY2siLCJvbkRlZmxlY3RDYWxsYmFjayIsInNldFNreWZhbGxDYWxsYmFjayIsIm9uU2t5ZmFsbENhbGxiYWNrIiwic2V0QmFja3N0YWJDYWxsYmFjayIsIm9uQmFja3N0YWJDYWxsYmFjayIsInNldFN1bmRlckNhbGxiYWNrIiwib25TdW5kZXJDYWxsYmFjayIsInNldERlYnVmZkNhbGxiYWNrIiwic2V0V2VhcG9uTGV2ZWwiLCJnZXRDdXJyZW50V2VhcG9uQ29uZmlnIiwid2VhcG9uIiwiZ2V0Q3VycmVudFdlYXBvbiIsImdldEN1cnJlbnRTdWJjbGFzcyIsImlzV2VhcG9uQ2hhcmdpbmciLCJnZXRDaGFyZ2VQcm9ncmVzcyIsImlzVmlwZXJTdGluZ0NoYXJnaW5nQWN0aXZlIiwiZ2V0VmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzIiwidmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzIiwiaXNCYXJyYWdlQ2hhcmdpbmdBY3RpdmUiLCJnZXRCYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MiLCJiYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MiLCJpc0NvYnJhU2hvdENoYXJnaW5nQWN0aXZlIiwiZ2V0Q29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MiLCJpc1dlYXBvblN3aW5naW5nIiwiaXNTd2luZ2luZyIsImdldFN3b3JkQ29tYm9TdGVwIiwiaXNEaXZpbmVTdG9ybUFjdGl2ZSIsImlzRGl2aW5lU3Rvcm1pbmciLCJpc0NoYXJnZUFjdGl2ZSIsImlzU3dvcmRDaGFyZ2luZyIsImlzRGVmbGVjdEFjdGl2ZSIsImlzRGVmbGVjdGluZyIsImlzU2t5ZmFsbEFjdGl2ZSIsImlzQmFja3N0YWJBY3RpdmUiLCJpc0JhY2tzdGFiYmluZyIsImlzU3VuZGVyQWN0aXZlIiwiaXNTdW5kZXJpbmciLCJwZXJmb3JtU3dvcmRNZWxlZUF0dGFjayIsInBlcmZvcm1EaXZpbmVTdG9ybSIsInBlcmZvcm1DaGFyZ2UiLCJwZXJmb3JtRGVmbGVjdCIsImxhc3RTd29yZEF0dGFja1RpbWUiLCJzd29yZENvbWJvUmVzZXRUaW1lIiwicGVyZm9ybU1lbGVlRGFtYWdlIiwib25Td29yZFN3aW5nQ29tcGxldGUiLCJwZXJmb3JtU2FicmVzTWVsZWVBdHRhY2siLCJwZXJmb3JtQmFja3N0YWIiLCJwZXJmb3JtU3VuZGVyIiwicGVyZm9ybVNreWZhbGwiLCJ1cGRhdGVTa3lmYWxsTW92ZW1lbnQiLCJ1cGRhdGVCYWNrc3RhYlN0YXRlIiwidXBkYXRlU3VuZGVyU3RhdGUiLCJwZXJmb3JtU2FicmVzTWVsZWVEYW1hZ2UiLCJvblNhYnJlc1N3aW5nQ29tcGxldGUiLCJoYXNDb21wb25lbnQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0FuZ2xlIiwibGVmdFNhYnJlRGFtYWdlIiwicmlnaHRTYWJyZURhbWFnZSIsImF0dGFja0RpcmVjdGlvbiIsImhpdENvdW50IiwidGFyZ2V0VHJhbnNmb3JtIiwidGFyZ2V0SGVhbHRoIiwiZGlyZWN0aW9uVG9UYXJnZXQiLCJzdWIiLCJkaXN0YW5jZVRvVGFyZ2V0IiwiZG90UHJvZHVjdCIsImRvdCIsImFuZ2xlVG9UYXJnZXQiLCJhY29zIiwibWF4Iiwic2V0VGltZW91dCIsImxhc3RTa3lmYWxsVGltZSIsInNreWZhbGxDb29sZG93biIsImNhbkNhc3RTa3lmYWxsIiwic2t5ZmFsbFBoYXNlIiwic2t5ZmFsbFN0YXJ0VGltZSIsInNreWZhbGxTdGFydFBvc2l0aW9uIiwiY29weSIsInNreWZhbGxPcmlnaW5hbEdyYXZpdHkiLCJncmF2aXR5Iiwic2t5ZmFsbFRhcmdldEhlaWdodCIsImp1bXBGb3JjZSIsInZlbG9jaXR5IiwiZWxhcHNlZFRpbWUiLCJwZXJmb3JtU2t5ZmFsbExhbmRpbmciLCJjb21wbGV0ZVNreWZhbGxBYmlsaXR5IiwibGFuZGluZ1Bvc2l0aW9uIiwiZGFtYWdlUmFkaXVzIiwic2t5ZmFsbERhbWFnZSIsImRpc3RhbmNlVG9MYW5kaW5nIiwiYmFja3N0YWJTdGFydFRpbWUiLCJiYWNrc3RhYkR1cmF0aW9uIiwibGFzdFN1bmRlclRpbWUiLCJzdW5kZXJDb29sZG93biIsImNhbkNhc3RTdW5kZXIiLCJzdW5kZXJTdGFydFRpbWUiLCJwZXJmb3JtU3VuZGVyRGFtYWdlIiwic3VuZGVyRHVyYXRpb24iLCJwbGF5ZXJEaXJlY3Rpb24iLCJzdW5kZXJSYW5nZSIsInN1YlZlY3RvcnMiLCJhbmdsZVRocmVzaG9sZCIsImNvcyIsInN0YWNrQ291bnQiLCJpc1N0dW5uZWQiLCJhcHBseVN1bmRlclN0YWNrIiwiZW50aXR5SWQiLCJzdGFja0R1cmF0aW9uIiwiY3VycmVudFN0YWNrcyIsInN1bmRlclN0YWNrcyIsImdldCIsImxhc3RBcHBsaWVkIiwic3RhY2tzIiwiZHVyYXRpb24iLCJiYXNlRGFtYWdlcyIsIm5ld1N0YWNrQ291bnQiLCJzZXQiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwic3RhY2tEYXRhIiwiZGVsZXRlIiwiY2xlYXIiLCJsYXN0QmFja3N0YWJUaW1lIiwiYmFja3N0YWJDb29sZG93biIsImNhbkNhc3RCYWNrc3RhYiIsInBlcmZvcm1CYWNrc3RhYkRhbWFnZSIsImJhY2tzdGFiUmFuZ2UiLCJpc0JhY2tzdGFiIiwicHZwUGxheWVycyIsInRhcmdldFBsYXllciIsInBsYXllciIsInBsYXllclBvcyIsInRhcmdldEZhY2luZ0RpcmVjdGlvbiIsInNpbiIsInJvdGF0aW9uIiwiYXR0YWNrZXJEaXJlY3Rpb24iLCJiZWhpbmREb3RQcm9kdWN0IiwibWVsZWVSYW5nZSIsIm1lbGVlQW5nbGUiLCJiYXNlRGFtYWdlIiwiZW5lbWllc0hpdCIsImVuZW15VHJhbnNmb3JtIiwiZW5lbXlIZWFsdGgiLCJlbmVteVBvc2l0aW9uIiwidG9FbmVteSIsImFuZ2xlVG8iLCJhbmdsZURlZ3JlZXMiLCJtYXhBbmdsZURlZ3JlZXMiLCJyYWdlVG9HYWluIiwiZ2FpblJhZ2UiLCJ0cmFuc2Zvcm0iLCJkYXNoRGlyZWN0aW9ucyIsImtleSIsImNoZWNrRG91YmxlVGFwIiwiZGVidWdJbmZvIiwiZ2V0RG91YmxlVGFwRGVidWdJbmZvIiwiZ2V0V29ybGRTcGFjZURpcmVjdGlvbiIsImRhc2hTdGFydGVkIiwic3RhcnREYXNoIiwicmVzZXREb3VibGVUYXAiLCJkYXNoUmVzdWx0IiwidXBkYXRlRGFzaCIsIm5ld1Bvc2l0aW9uIiwiTUFYX0RBU0hfQk9VTkRTIiwiZGlzdGFuY2VGcm9tT3JpZ2luIiwiY2FuY2VsRGFzaCIsImNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbiIsImNhbmNlbENoYXJnZSIsImNoYXJnZVJlc3VsdCIsInVwZGF0ZUNoYXJnZSIsIk1BWF9DSEFSR0VfQk9VTkRTIiwicGlsbGFyQ29sbGlzaW9uIiwiY2hlY2tQaWxsYXJDb2xsaXNpb24iLCJvbkNoYXJnZUNvbXBsZXRlIiwiaGFzQ29sbGlzaW9uIiwid2FybiIsInBpbGxhckNlbnRlciIsInRvQXJyYXkiLCJqb2luIiwiaXNDb21wbGV0ZSIsInBpbGxhclBvcyIsIlBJTExBUl9QT1NJVElPTlMiLCJob3Jpem9udGFsUG9zIiwicGlsbGFySG9yaXpvbnRhbCIsIlBJTExBUl9SQURJVVMiLCJub3JtYWwiLCJjYW5DYXN0RGl2aW5lU3Rvcm0iLCJsYXN0RGl2aW5lU3Rvcm1UaW1lIiwiZGl2aW5lU3Rvcm1Db29sZG93biIsImN1cnJlbnRSYWdlIiwiZ2V0Q3VycmVudFJhZ2UiLCJjb25zdW1lQWxsUmFnZSIsImJhc2VTdG9ybUR1cmF0aW9uIiwiYm9udXNEdXJhdGlvbiIsImZsb29yIiwidG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uIiwibGFzdENoYXJnZVRpbWUiLCJjaGFyZ2VDb29sZG93biIsImNoYXJnZVN0YXJ0ZWQiLCJzdGFydENoYXJnZSIsInNjaGVkdWxlQ2hhcmdlRGFtYWdlIiwiY2hhcmdlRGlyZWN0aW9uIiwic3RhcnRUaW1lIiwiZGFtYWdlQ2hlY2tJbnRlcnZhbCIsImNoYXJnZURhbWFnZSIsImNoYXJnZVJhZGl1cyIsImNoYXJnZUhpdEVudGl0aWVzIiwiZGFtYWdlSW50ZXJ2YWwiLCJoaXRTb21ldGhpbmciLCJzZXJ2ZXJQbGF5ZXJzIiwiTWFwIiwic2VydmVyUGxheWVyIiwicGxheWVySWRIYXNoIiwiY2hhckNvZGVBdCIsImhhcyIsInNlcnZlclBsYXllclBvcyIsInN0b3BEaXN0YW5jZSIsImhlYWx0aCIsInRhcmdldElkIiwiaGl0UG9zaXRpb24iLCJlbnRpdHlDb2xsaWRlciIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImxhc3REZWZsZWN0VGltZSIsImRlZmxlY3RDb29sZG93biIsInNldHVwRGVmbGVjdEJhcnJpZXIiLCJvbkRlZmxlY3RDb21wbGV0ZSIsImRlZmxlY3REdXJhdGlvbiIsImxhc3RWaXBlclN0aW5nVGltZSIsInZpcGVyU3RpbmdGaXJlUmF0ZSIsImNhbkNhc3RWaXBlclN0aW5nIiwiZmlyZVZpcGVyU3RpbmciLCJzdWNjZXNzIiwiaXNSZXR1cm5pbmciLCJsYXN0QmFycmFnZVRpbWUiLCJiYXJyYWdlRmlyZVJhdGUiLCJ0b0ZpeGVkIiwiY2FuQ2FzdEJhcnJhZ2UiLCJmaXJlQmFycmFnZSIsImFuZ2xlcyIsInByb2plY3RpbGVEaXJlY3Rpb24iLCJtYWtlUm90YXRpb25ZIiwicHJvamVjdGlsZUVudGl0eSIsInJlbmRlcmVyIiwibWVzaCIsInVzZXJEYXRhIiwiaXNCYXJyYWdlQXJyb3ciLCJpc1JlZ3VsYXJBcnJvdyIsInBsYXllclJvdGF0aW9uIiwiaW5wdXRTdHJlbmd0aCIsIm1vdmVEaXIiLCJtb3ZlRGlyZWN0aW9uIiwibW92ZUFuZ2xlIiwiZGVmbGVjdEJhcnJpZXIiLCJhY3RpdmF0ZSIsImlzQmFycmllckFjdGl2ZSIsInVwZGF0ZVBvc2l0aW9uIiwiZGVhY3RpdmF0ZSIsImdldFdlYXBvblN3aXRjaENvb2xkb3duIiwiZ2V0QWJpbGl0eUNvb2xkb3ducyIsImNvb2xkb3ducyIsImlzQWN0aXZlIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJTZXQiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ControlSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/HealthBarSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/HealthBarSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBarSystem: function() { return /* binding */ HealthBarSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/HealthBar */ \"(app-pages-browser)/./src/ecs/components/HealthBar.ts\");\n// Health bar system for rendering health bars above entities\n\n\n\n\n\nclass HealthBarSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update health bar logic\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n            if (!transform.enabled || !health.enabled || !healthBar.enabled) {\n                continue;\n            }\n            // Update health bar with current health ratio\n            const worldPosition = transform.getWorldPosition();\n            const cameraPosition = this.camera.position;\n            healthBar.updateHealthBar(health.getHealthRatio(), cameraPosition, worldPosition, deltaTime);\n        }\n    }\n    render(entities, deltaTime) {\n    // Health bars are automatically rendered as part of the scene\n    // This method can be used for any additional rendering logic\n    }\n    onEntityAdded(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Add health bar group to scene\n            this.scene.add(healthBar.getGroup());\n        }\n    }\n    onEntityRemoved(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Remove health bar group from scene and dispose resources\n            this.scene.remove(healthBar.getGroup());\n            healthBar.dispose();\n        }\n    }\n    onDisable() {\n        // Clean up all health bars from scene\n        const healthBarGroups = [];\n        this.scene.traverse((object)=>{\n            if (object instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group && object.userData.isHealthBar) {\n                healthBarGroups.push(object);\n            }\n        });\n        for (const group of healthBarGroups){\n            this.scene.remove(group);\n        }\n    }\n    constructor(scene, camera){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar\n        ];\n        this.scene = scene;\n        this.camera = camera;\n        this.priority = 100; // Render after main objects\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0hlYWx0aEJhclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDQTtBQUNqQjtBQUVXO0FBQ047QUFDTTtBQUVoRCxNQUFNSyx3QkFBd0JKLHFEQUFZQTtJQVl4Q0ssT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQkFBMEI7UUFDMUIsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1QsZ0VBQVNBO1lBQy9DLE1BQU1VLFNBQVNILE9BQU9FLFlBQVksQ0FBQ1IsMERBQU1BO1lBQ3pDLE1BQU1VLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBRS9DLElBQUksQ0FBQ00sVUFBVUksT0FBTyxJQUFJLENBQUNGLE9BQU9FLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCTCxVQUFVTSxnQkFBZ0I7WUFDaEQsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1lBRTNDTixVQUFVTyxlQUFlLENBQ3ZCUixPQUFPUyxjQUFjLElBQ3JCSixnQkFDQUYsZUFDQVA7UUFFSjtJQUNGO0lBRU9jLE9BQU9mLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7SUFDekQsOERBQThEO0lBQzlELDZEQUE2RDtJQUMvRDtJQUVPZSxjQUFjZCxNQUFjLEVBQVE7UUFDekMsTUFBTUksWUFBWUosT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7UUFDL0MsSUFBSVMsV0FBVztZQUNiLGdDQUFnQztZQUNoQyxJQUFJLENBQUNXLEtBQUssQ0FBQ0MsR0FBRyxDQUFDWixVQUFVYSxRQUFRO1FBQ25DO0lBQ0Y7SUFFT0MsZ0JBQWdCbEIsTUFBYyxFQUFRO1FBQzNDLE1BQU1JLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1FBQy9DLElBQUlTLFdBQVc7WUFDYiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDVyxLQUFLLENBQUNJLE1BQU0sQ0FBQ2YsVUFBVWEsUUFBUTtZQUNwQ2IsVUFBVWdCLE9BQU87UUFDbkI7SUFDRjtJQUVPQyxZQUFrQjtRQUN2QixzQ0FBc0M7UUFDdEMsTUFBTUMsa0JBQTJCLEVBQUU7UUFFbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDQztZQUNuQixJQUFJQSxrQkFBa0JqQyx1REFBS0EsSUFBSWlDLE9BQU9DLFFBQVEsQ0FBQ0MsV0FBVyxFQUFFO2dCQUMxREosZ0JBQWdCSyxJQUFJLENBQUNIO1lBQ3ZCO1FBQ0Y7UUFFQSxLQUFLLE1BQU1JLFNBQVNOLGdCQUFpQjtZQUNuQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUztRQUNwQjtJQUNGO0lBbEVBQyxZQUFZZCxLQUFZLEVBQUVOLE1BQWMsQ0FBRTtRQUN4QyxLQUFLO2FBTFNxQixxQkFBcUI7WUFBQ3JDLGdFQUFTQTtZQUFFQywwREFBTUE7WUFBRUMsZ0VBQVNBO1NBQUM7UUFNakUsSUFBSSxDQUFDb0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRyxLQUFLLDRCQUE0QjtJQUNuRDtBQThERiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9IZWFsdGhCYXJTeXN0ZW0udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIHN5c3RlbSBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBHcm91cCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEhlYWx0aEJhciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoQmFyJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhclN5c3RlbSBleHRlbmRzIFJlbmRlclN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBIZWFsdGgsIEhlYWx0aEJhcl07XG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwOyAvLyBSZW5kZXIgYWZ0ZXIgbWFpbiBvYmplY3RzXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBsb2dpY1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWhlYWx0aC5lbmFibGVkIHx8ICFoZWFsdGhCYXIuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2l0aCBjdXJyZW50IGhlYWx0aCByYXRpb1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBoZWFsdGhCYXIudXBkYXRlSGVhbHRoQmFyKFxuICAgICAgICBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSxcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgIGRlbHRhVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBIZWFsdGggYmFycyBhcmUgYXV0b21hdGljYWxseSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzY2VuZVxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBhbnkgYWRkaXRpb25hbCByZW5kZXJpbmcgbG9naWNcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgaGVhbHRoQmFyID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGhCYXIpO1xuICAgIGlmIChoZWFsdGhCYXIpIHtcbiAgICAgIC8vIEFkZCBoZWFsdGggYmFyIGdyb3VwIHRvIHNjZW5lXG4gICAgICB0aGlzLnNjZW5lLmFkZChoZWFsdGhCYXIuZ2V0R3JvdXAoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKTtcbiAgICBpZiAoaGVhbHRoQmFyKSB7XG4gICAgICAvLyBSZW1vdmUgaGVhbHRoIGJhciBncm91cCBmcm9tIHNjZW5lIGFuZCBkaXNwb3NlIHJlc291cmNlc1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoaGVhbHRoQmFyLmdldEdyb3VwKCkpO1xuICAgICAgaGVhbHRoQmFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBoZWFsdGggYmFycyBmcm9tIHNjZW5lXG4gICAgY29uc3QgaGVhbHRoQmFyR3JvdXBzOiBHcm91cFtdID0gW107XG4gICAgXG4gICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgR3JvdXAgJiYgb2JqZWN0LnVzZXJEYXRhLmlzSGVhbHRoQmFyKSB7XG4gICAgICAgIGhlYWx0aEJhckdyb3Vwcy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGhlYWx0aEJhckdyb3Vwcykge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoZ3JvdXApO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdyb3VwIiwiUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiSGVhbHRoQmFyIiwiSGVhbHRoQmFyU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoZWFsdGgiLCJoZWFsdGhCYXIiLCJlbmFibGVkIiwid29ybGRQb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYSIsInBvc2l0aW9uIiwidXBkYXRlSGVhbHRoQmFyIiwiZ2V0SGVhbHRoUmF0aW8iLCJyZW5kZXIiLCJvbkVudGl0eUFkZGVkIiwic2NlbmUiLCJhZGQiLCJnZXRHcm91cCIsIm9uRW50aXR5UmVtb3ZlZCIsInJlbW92ZSIsImRpc3Bvc2UiLCJvbkRpc2FibGUiLCJoZWFsdGhCYXJHcm91cHMiLCJ0cmF2ZXJzZSIsIm9iamVjdCIsInVzZXJEYXRhIiwiaXNIZWFsdGhCYXIiLCJwdXNoIiwiZ3JvdXAiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/HealthBarSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/InterpolationSystem.ts":
/*!********************************************!*\
  !*** ./src/systems/InterpolationSystem.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterpolationSystem: function() { return /* binding */ InterpolationSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Interpolation */ \"(app-pages-browser)/./src/ecs/components/Interpolation.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Interpolation system for smooth entity movement and rotation\n\n\n\n\n\nclass InterpolationSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    /**\n   * Update interpolation for all entities with interpolation buffers\n   */ update(entities, deltaTime) {\n        this.currentTime = performance.now();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_4__.Movement);\n            if (!(transform === null || transform === void 0 ? void 0 : transform.enabled) || !(interpolationBuffer === null || interpolationBuffer === void 0 ? void 0 : interpolationBuffer.enabled)) {\n                continue;\n            }\n            // Skip local players (entities that can move) - they should not be interpolated\n            // Only remote players (canMove = false) should use interpolation\n            if (movement && movement.canMove) {\n                continue;\n            }\n            this.interpolateEntity(transform, interpolationBuffer);\n        }\n    }\n    /**\n   * Render interpolation (called during render phase for smooth visuals)\n   */ render(entities, deltaTime) {\n        // For now, render and update phases are the same for interpolation\n        // In the future, we could separate concerns if needed\n        this.update(entities, deltaTime);\n    }\n    /**\n   * Interpolate a single entity's transform\n   */ interpolateEntity(transform, interpolationBuffer) {\n        const interpolatedTransform = interpolationBuffer.getInterpolatedTransform(this.currentTime);\n        // Apply interpolated position\n        transform.position.copy(interpolatedTransform.position);\n        // Apply interpolated rotation\n        transform.quaternion.copy(interpolatedTransform.rotation);\n        // Update the transform's Euler rotation to match the quaternion\n        transform.rotation.setFromQuaternion(transform.quaternion);\n        // Mark matrices as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    /**\n   * Add server state to an entity's interpolation buffer\n   */ addServerState(entity, position, rotation, timestamp) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            interpolationBuffer.addServerState(position, rotation, timestamp);\n        }\n    }\n    /**\n   * Get interpolation statistics for debugging\n   */ getInterpolationStats(entity) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            return interpolationBuffer.getBufferStats();\n        }\n        return null;\n    }\n    /**\n   * Clear interpolation buffer for an entity\n   */ clearInterpolationBuffer(entity) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            interpolationBuffer.clearBuffer();\n        }\n    }\n    /**\n   * Set interpolation delay for all entities (in milliseconds)\n   */ setInterpolationDelay(entity, delayMs) {\n        // Note: This would require modifying the InterpolationBuffer component\n        // For now, the delay is fixed in the component itself\n        console.warn(\"Interpolation delay is currently fixed in InterpolationBuffer component\");\n    }\n    /**\n   * Get the current render time used for interpolation\n   */ getCurrentRenderTime() {\n        return this.currentTime;\n    }\n    /**\n   * Advanced interpolation methods for smoother movement\n   */ /**\n   * Hermite spline interpolation for smoother curves\n   * This provides better interpolation between keyframes by considering velocity\n   */ static hermiteInterpolate(p0, p1, v0, v1, t // Interpolation factor [0,1]\n    ) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        // Hermite basis functions\n        const h00 = 2 * t3 - 3 * t2 + 1; // (1 + 2t)(1 - t)^2\n        const h10 = t3 - 2 * t2 + t; // t(1 - t)^2\n        const h01 = -2 * t3 + 3 * t2; // t^2(3 - 2t)\n        const h11 = t3 - t2; // t^2(t - 1)\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, h00);\n        result.addScaledVector(v0, h10);\n        result.addScaledVector(p1, h01);\n        result.addScaledVector(v1, h11);\n        return result;\n    }\n    /**\n   * Catmull-Rom spline interpolation for smooth curves through waypoints\n   */ static catmullRomInterpolate(p0, p1, p2, p3, t // Interpolation factor [0,1]\n    ) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        // Catmull-Rom basis functions\n        const c00 = -0.5 * t3 + t2 - 0.5 * t;\n        const c10 = 1.5 * t3 - 2.5 * t2 + 1;\n        const c20 = -1.5 * t3 + 2 * t2 + 0.5 * t;\n        const c30 = 0.5 * t3 - 0.5 * t2;\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, c00);\n        result.addScaledVector(p1, c10);\n        result.addScaledVector(p2, c20);\n        result.addScaledVector(p3, c30);\n        return result;\n    }\n    /**\n   * Cubic Bezier interpolation for smooth curves with control points\n   */ static bezierInterpolate(p0, p1, p2, p3, t // Interpolation factor [0,1]\n    ) {\n        const u = 1 - t;\n        const tt = t * t;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ttt = tt * t;\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, uuu); // (1-t)^3 * p0\n        result.addScaledVector(p1, 3 * uu * t); // 3*(1-t)^2*t * p1\n        result.addScaledVector(p2, 3 * u * tt); // 3*(1-t)*t^2 * p2\n        result.addScaledVector(p3, ttt); // t^3 * p3\n        return result;\n    }\n    /**\n   * Smooth step interpolation for easing\n   */ static smoothStepInterpolate(start, end, t) {\n        // Smoothstep function: 3t^2 - 2t^3\n        const smoothT = t * t * (3 - 2 * t);\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(start, end, smoothT);\n    }\n    /**\n   * Smoother step interpolation for even smoother easing\n   */ static smootherStepInterpolate(start, end, t) {\n        // Smootherstep function: 6t^5 - 15t^4 + 10t^3\n        const smoothT = t * t * t * (t * (6 * t - 15) + 10);\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(start, end, smoothT);\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer\n        ];\n        this.currentTime = 0;\n        this.priority = 20; // Run after physics but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0ludGVycG9sYXRpb25TeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsK0RBQStEO0FBQ0g7QUFDdEI7QUFFaUI7QUFDYztBQUNoQjtBQUU5QyxNQUFNSyw0QkFBNEJKLCtDQUFNQTtJQVM3Qzs7R0FFQyxHQUNELE9BQWNNLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsSUFBSSxDQUFDQyxXQUFXLEdBQUdDLFlBQVlDLEdBQUc7UUFFbEMsS0FBSyxNQUFNQyxVQUFVTCxTQUFVO1lBQzdCLE1BQU1NLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1osZ0VBQVNBO1lBQy9DLE1BQU1hLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1lBQ25FLE1BQU1hLFdBQVdKLE9BQU9FLFlBQVksQ0FBQ1YsOERBQVFBO1lBRTdDLElBQUksRUFBQ1Msc0JBQUFBLGdDQUFBQSxVQUFXSSxPQUFPLEtBQUksRUFBQ0YsZ0NBQUFBLDBDQUFBQSxvQkFBcUJFLE9BQU8sR0FBRTtnQkFDeEQ7WUFDRjtZQUVBLGdGQUFnRjtZQUNoRixpRUFBaUU7WUFDakUsSUFBSUQsWUFBWUEsU0FBU0UsT0FBTyxFQUFFO2dCQUNoQztZQUNGO1lBRUEsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ04sV0FBV0U7UUFDcEM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBY1IsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxtRUFBbUU7UUFDbkUsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ0YsTUFBTSxDQUFDQyxVQUFVQztJQUN4QjtJQUVBOztHQUVDLEdBQ0Qsa0JBQTBCSyxTQUFvQixFQUFFRSxtQkFBd0MsRUFBUTtRQUM5RixNQUFNTSx3QkFBd0JOLG9CQUFvQk8sd0JBQXdCLENBQUMsSUFBSSxDQUFDYixXQUFXO1FBRTNGLDhCQUE4QjtRQUM5QkksVUFBVVUsUUFBUSxDQUFDQyxJQUFJLENBQUNILHNCQUFzQkUsUUFBUTtRQUV0RCw4QkFBOEI7UUFDOUJWLFVBQVVZLFVBQVUsQ0FBQ0QsSUFBSSxDQUFDSCxzQkFBc0JLLFFBQVE7UUFFeEQsZ0VBQWdFO1FBQ2hFYixVQUFVYSxRQUFRLENBQUNDLGlCQUFpQixDQUFDZCxVQUFVWSxVQUFVO1FBRXpELGtDQUFrQztRQUNsQ1osVUFBVWUsaUJBQWlCLEdBQUc7SUFDaEM7SUFFQTs7R0FFQyxHQUNELGVBQXNCaEIsTUFBYyxFQUFFVyxRQUFpQixFQUFFRyxRQUFvQixFQUFFSSxTQUFrQixFQUFRO1FBQ3ZHLE1BQU1mLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1FBQ25FLElBQUlZLHFCQUFxQjtZQUN2QkEsb0JBQW9CYyxjQUFjLENBQUNOLFVBQVVHLFVBQVVJO1FBQ3pEO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUE2QmxCLE1BQWMsRUFBTztRQUNoRCxNQUFNRyxzQkFBc0JILE9BQU9FLFlBQVksQ0FBQ1gsOEVBQW1CQTtRQUNuRSxJQUFJWSxxQkFBcUI7WUFDdkIsT0FBT0Esb0JBQW9CaUIsY0FBYztRQUMzQztRQUNBLE9BQU87SUFDVDtJQUVBOztHQUVDLEdBQ0QseUJBQWdDcEIsTUFBYyxFQUFRO1FBQ3BELE1BQU1HLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1FBQ25FLElBQUlZLHFCQUFxQjtZQUN2QkEsb0JBQW9CbUIsV0FBVztRQUNqQztJQUNGO0lBRUE7O0dBRUMsR0FDRCxzQkFBNkJ0QixNQUFjLEVBQUV3QixPQUFlLEVBQVE7UUFDbEUsdUVBQXVFO1FBQ3ZFLHNEQUFzRDtRQUN0REMsUUFBUUMsSUFBSSxDQUFDO0lBQ2Y7SUFFQTs7R0FFQyxHQUNELHVCQUFzQztRQUNwQyxPQUFPLElBQUksQ0FBQzdCLFdBQVc7SUFDekI7SUFFQTs7R0FFQyxHQUVEOzs7R0FHQyxHQUNELE9BQWMrQixtQkFDWkMsRUFBVyxFQUNYQyxFQUFXLEVBQ1hDLEVBQVcsRUFDWEMsRUFBVyxFQUNYQyxFQUFZLDZCQUE2QjtJQUFoQyxFQUNBO1FBQ1QsTUFBTUMsS0FBS0QsSUFBSUE7UUFDZixNQUFNRSxLQUFLRCxLQUFLRDtRQUVoQiwwQkFBMEI7UUFDMUIsTUFBTUcsTUFBTSxJQUFJRCxLQUFLLElBQUlELEtBQUssR0FBTSxvQkFBb0I7UUFDeEQsTUFBTUcsTUFBTUYsS0FBSyxJQUFJRCxLQUFLRCxHQUFVLGFBQWE7UUFDakQsTUFBTUssTUFBTSxDQUFDLElBQUlILEtBQUssSUFBSUQsSUFBVSxjQUFjO1FBQ2xELE1BQU1LLE1BQU1KLEtBQUtELElBQW1CLGFBQWE7UUFFakQsTUFBTU0sU0FBUyxJQUFJcEQseURBQU9BO1FBQzFCb0QsT0FBT0MsZUFBZSxDQUFDWixJQUFJTztRQUMzQkksT0FBT0MsZUFBZSxDQUFDVixJQUFJTTtRQUMzQkcsT0FBT0MsZUFBZSxDQUFDWCxJQUFJUTtRQUMzQkUsT0FBT0MsZUFBZSxDQUFDVCxJQUFJTztRQUUzQixPQUFPQztJQUNUO0lBRUE7O0dBRUMsR0FDRCxPQUFjRSxzQkFDWmIsRUFBVyxFQUNYQyxFQUFXLEVBQ1hhLEVBQVcsRUFDWEMsRUFBVyxFQUNYWCxFQUFhLDZCQUE2QjtJQUFqQyxFQUNBO1FBQ1QsTUFBTUMsS0FBS0QsSUFBSUE7UUFDZixNQUFNRSxLQUFLRCxLQUFLRDtRQUVoQiw4QkFBOEI7UUFDOUIsTUFBTVksTUFBTSxDQUFDLE1BQU1WLEtBQUtELEtBQUssTUFBTUQ7UUFDbkMsTUFBTWEsTUFBTSxNQUFNWCxLQUFLLE1BQU1ELEtBQUs7UUFDbEMsTUFBTWEsTUFBTSxDQUFDLE1BQU1aLEtBQUssSUFBSUQsS0FBSyxNQUFNRDtRQUN2QyxNQUFNZSxNQUFNLE1BQU1iLEtBQUssTUFBTUQ7UUFFN0IsTUFBTU0sU0FBUyxJQUFJcEQseURBQU9BO1FBQzFCb0QsT0FBT0MsZUFBZSxDQUFDWixJQUFJZ0I7UUFDM0JMLE9BQU9DLGVBQWUsQ0FBQ1gsSUFBSWdCO1FBQzNCTixPQUFPQyxlQUFlLENBQUNFLElBQUlJO1FBQzNCUCxPQUFPQyxlQUFlLENBQUNHLElBQUlJO1FBRTNCLE9BQU9SO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQWNTLGtCQUNacEIsRUFBVyxFQUNYQyxFQUFXLEVBQ1hhLEVBQVcsRUFDWEMsRUFBVyxFQUNYWCxFQUFhLDZCQUE2QjtJQUFqQyxFQUNBO1FBQ1QsTUFBTWlCLElBQUksSUFBSWpCO1FBQ2QsTUFBTWtCLEtBQUtsQixJQUFJQTtRQUNmLE1BQU1tQixLQUFLRixJQUFJQTtRQUNmLE1BQU1HLE1BQU1ELEtBQUtGO1FBQ2pCLE1BQU1JLE1BQU1ILEtBQUtsQjtRQUVqQixNQUFNTyxTQUFTLElBQUlwRCx5REFBT0E7UUFDMUJvRCxPQUFPQyxlQUFlLENBQUNaLElBQUl3QixNQUFXLGVBQWU7UUFDckRiLE9BQU9DLGVBQWUsQ0FBQ1gsSUFBSSxJQUFJc0IsS0FBS25CLElBQUksbUJBQW1CO1FBQzNETyxPQUFPQyxlQUFlLENBQUNFLElBQUksSUFBSU8sSUFBSUMsS0FBTSxtQkFBbUI7UUFDNURYLE9BQU9DLGVBQWUsQ0FBQ0csSUFBSVUsTUFBWSxXQUFXO1FBRWxELE9BQU9kO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQWNlLHNCQUFzQkMsS0FBYyxFQUFFQyxHQUFZLEVBQUV4QixDQUFTLEVBQVc7UUFDcEYsbUNBQW1DO1FBQ25DLE1BQU15QixVQUFVekIsSUFBSUEsSUFBSyxLQUFJLElBQUlBLENBQUFBO1FBQ2pDLE9BQU8sSUFBSTdDLHlEQUFPQSxHQUFHdUUsV0FBVyxDQUFDSCxPQUFPQyxLQUFLQztJQUMvQztJQUVBOztHQUVDLEdBQ0QsT0FBY0Usd0JBQXdCSixLQUFjLEVBQUVDLEdBQVksRUFBRXhCLENBQVMsRUFBVztRQUN0Riw4Q0FBOEM7UUFDOUMsTUFBTXlCLFVBQVV6QixJQUFJQSxJQUFJQSxJQUFLQSxDQUFBQSxJQUFLLEtBQUlBLElBQUksRUFBQyxJQUFLLEVBQUM7UUFDakQsT0FBTyxJQUFJN0MseURBQU9BLEdBQUd1RSxXQUFXLENBQUNILE9BQU9DLEtBQUtDO0lBQy9DO0lBL01BRyxhQUFjO1FBQ1osS0FBSzthQUpTQyxxQkFBcUI7WUFBQ3hFLGdFQUFTQTtZQUFFQyw4RUFBbUJBO1NBQUM7YUFDN0RNLGNBQWM7UUFJcEIsSUFBSSxDQUFDa0UsUUFBUSxHQUFHLElBQUkseUNBQXlDO0lBQy9EO0FBNk1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0ludGVycG9sYXRpb25TeXN0ZW0udHM/NjNlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbnRlcnBvbGF0aW9uIHN5c3RlbSBmb3Igc21vb3RoIGVudGl0eSBtb3ZlbWVudCBhbmQgcm90YXRpb25cbmltcG9ydCB7IFZlY3RvcjMsIFF1YXRlcm5pb24gfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBJbnRlcnBvbGF0aW9uQnVmZmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIEludGVycG9sYXRpb25CdWZmZXJdO1xuICBwcml2YXRlIGN1cnJlbnRUaW1lID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyMDsgLy8gUnVuIGFmdGVyIHBoeXNpY3MgYnV0IGJlZm9yZSByZW5kZXJpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJwb2xhdGlvbiBmb3IgYWxsIGVudGl0aWVzIHdpdGggaW50ZXJwb2xhdGlvbiBidWZmZXJzXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbkJ1ZmZlciA9IGVudGl0eS5nZXRDb21wb25lbnQoSW50ZXJwb2xhdGlvbkJ1ZmZlcik7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuXG4gICAgICBpZiAoIXRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhaW50ZXJwb2xhdGlvbkJ1ZmZlcj8uZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBsb2NhbCBwbGF5ZXJzIChlbnRpdGllcyB0aGF0IGNhbiBtb3ZlKSAtIHRoZXkgc2hvdWxkIG5vdCBiZSBpbnRlcnBvbGF0ZWRcbiAgICAgIC8vIE9ubHkgcmVtb3RlIHBsYXllcnMgKGNhbk1vdmUgPSBmYWxzZSkgc2hvdWxkIHVzZSBpbnRlcnBvbGF0aW9uXG4gICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuY2FuTW92ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnRlcnBvbGF0ZUVudGl0eSh0cmFuc2Zvcm0sIGludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgaW50ZXJwb2xhdGlvbiAoY2FsbGVkIGR1cmluZyByZW5kZXIgcGhhc2UgZm9yIHNtb290aCB2aXN1YWxzKVxuICAgKi9cbiAgcHVibGljIHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRm9yIG5vdywgcmVuZGVyIGFuZCB1cGRhdGUgcGhhc2VzIGFyZSB0aGUgc2FtZSBmb3IgaW50ZXJwb2xhdGlvblxuICAgIC8vIEluIHRoZSBmdXR1cmUsIHdlIGNvdWxkIHNlcGFyYXRlIGNvbmNlcm5zIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlKGVudGl0aWVzLCBkZWx0YVRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgc2luZ2xlIGVudGl0eSdzIHRyYW5zZm9ybVxuICAgKi9cbiAgcHJpdmF0ZSBpbnRlcnBvbGF0ZUVudGl0eSh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgaW50ZXJwb2xhdGlvbkJ1ZmZlcjogSW50ZXJwb2xhdGlvbkJ1ZmZlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRlZFRyYW5zZm9ybSA9IGludGVycG9sYXRpb25CdWZmZXIuZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtKHRoaXMuY3VycmVudFRpbWUpO1xuXG4gICAgLy8gQXBwbHkgaW50ZXJwb2xhdGVkIHBvc2l0aW9uXG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkoaW50ZXJwb2xhdGVkVHJhbnNmb3JtLnBvc2l0aW9uKTtcblxuICAgIC8vIEFwcGx5IGludGVycG9sYXRlZCByb3RhdGlvblxuICAgIHRyYW5zZm9ybS5xdWF0ZXJuaW9uLmNvcHkoaW50ZXJwb2xhdGVkVHJhbnNmb3JtLnJvdGF0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNmb3JtJ3MgRXVsZXIgcm90YXRpb24gdG8gbWF0Y2ggdGhlIHF1YXRlcm5pb25cbiAgICB0cmFuc2Zvcm0ucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odHJhbnNmb3JtLnF1YXRlcm5pb24pO1xuXG4gICAgLy8gTWFyayBtYXRyaWNlcyBhcyBuZWVkaW5nIHVwZGF0ZVxuICAgIHRyYW5zZm9ybS5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHNlcnZlciBzdGF0ZSB0byBhbiBlbnRpdHkncyBpbnRlcnBvbGF0aW9uIGJ1ZmZlclxuICAgKi9cbiAgcHVibGljIGFkZFNlcnZlclN0YXRlKGVudGl0eTogRW50aXR5LCBwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25CdWZmZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uQnVmZmVyKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uQnVmZmVyLmFkZFNlcnZlclN0YXRlKHBvc2l0aW9uLCByb3RhdGlvbiwgdGltZXN0YW1wKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGludGVycG9sYXRpb24gc3RhdGlzdGljcyBmb3IgZGVidWdnaW5nXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJwb2xhdGlvblN0YXRzKGVudGl0eTogRW50aXR5KTogYW55IHtcbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uQnVmZmVyID0gZW50aXR5LmdldENvbXBvbmVudChJbnRlcnBvbGF0aW9uQnVmZmVyKTtcbiAgICBpZiAoaW50ZXJwb2xhdGlvbkJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGludGVycG9sYXRpb25CdWZmZXIuZ2V0QnVmZmVyU3RhdHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgaW50ZXJwb2xhdGlvbiBidWZmZXIgZm9yIGFuIGVudGl0eVxuICAgKi9cbiAgcHVibGljIGNsZWFySW50ZXJwb2xhdGlvbkJ1ZmZlcihlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25CdWZmZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uQnVmZmVyKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uQnVmZmVyLmNsZWFyQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcnBvbGF0aW9uIGRlbGF5IGZvciBhbGwgZW50aXRpZXMgKGluIG1pbGxpc2Vjb25kcylcbiAgICovXG4gIHB1YmxpYyBzZXRJbnRlcnBvbGF0aW9uRGVsYXkoZW50aXR5OiBFbnRpdHksIGRlbGF5TXM6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIE5vdGU6IFRoaXMgd291bGQgcmVxdWlyZSBtb2RpZnlpbmcgdGhlIEludGVycG9sYXRpb25CdWZmZXIgY29tcG9uZW50XG4gICAgLy8gRm9yIG5vdywgdGhlIGRlbGF5IGlzIGZpeGVkIGluIHRoZSBjb21wb25lbnQgaXRzZWxmXG4gICAgY29uc29sZS53YXJuKCdJbnRlcnBvbGF0aW9uIGRlbGF5IGlzIGN1cnJlbnRseSBmaXhlZCBpbiBJbnRlcnBvbGF0aW9uQnVmZmVyIGNvbXBvbmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCByZW5kZXIgdGltZSB1c2VkIGZvciBpbnRlcnBvbGF0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0Q3VycmVudFJlbmRlclRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlZCBpbnRlcnBvbGF0aW9uIG1ldGhvZHMgZm9yIHNtb290aGVyIG1vdmVtZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBIZXJtaXRlIHNwbGluZSBpbnRlcnBvbGF0aW9uIGZvciBzbW9vdGhlciBjdXJ2ZXNcbiAgICogVGhpcyBwcm92aWRlcyBiZXR0ZXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGtleWZyYW1lcyBieSBjb25zaWRlcmluZyB2ZWxvY2l0eVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBoZXJtaXRlSW50ZXJwb2xhdGUoXG4gICAgcDA6IFZlY3RvcjMsIC8vIFN0YXJ0IHBvc2l0aW9uXG4gICAgcDE6IFZlY3RvcjMsIC8vIEVuZCBwb3NpdGlvblxuICAgIHYwOiBWZWN0b3IzLCAvLyBTdGFydCB2ZWxvY2l0eSAodGFuZ2VudClcbiAgICB2MTogVmVjdG9yMywgLy8gRW5kIHZlbG9jaXR5ICh0YW5nZW50KVxuICAgIHQ6IG51bWJlciAgIC8vIEludGVycG9sYXRpb24gZmFjdG9yIFswLDFdXG4gICk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgY29uc3QgdDMgPSB0MiAqIHQ7XG5cbiAgICAvLyBIZXJtaXRlIGJhc2lzIGZ1bmN0aW9uc1xuICAgIGNvbnN0IGgwMCA9IDIgKiB0MyAtIDMgKiB0MiArIDE7ICAgIC8vICgxICsgMnQpKDEgLSB0KV4yXG4gICAgY29uc3QgaDEwID0gdDMgLSAyICogdDIgKyB0OyAgICAgICAgLy8gdCgxIC0gdCleMlxuICAgIGNvbnN0IGgwMSA9IC0yICogdDMgKyAzICogdDI7ICAgICAgIC8vIHReMigzIC0gMnQpXG4gICAgY29uc3QgaDExID0gdDMgLSB0MjsgICAgICAgICAgICAgICAgLy8gdF4yKHQgLSAxKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAwLCBoMDApO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IodjAsIGgxMCk7XG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMSwgaDAxKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHYxLCBoMTEpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXRtdWxsLVJvbSBzcGxpbmUgaW50ZXJwb2xhdGlvbiBmb3Igc21vb3RoIGN1cnZlcyB0aHJvdWdoIHdheXBvaW50c1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgcDA6IFZlY3RvcjMsIC8vIFByZXZpb3VzIHBvaW50XG4gICAgcDE6IFZlY3RvcjMsIC8vIFN0YXJ0IHBvaW50XG4gICAgcDI6IFZlY3RvcjMsIC8vIEVuZCBwb2ludFxuICAgIHAzOiBWZWN0b3IzLCAvLyBOZXh0IHBvaW50XG4gICAgdDogbnVtYmVyICAgIC8vIEludGVycG9sYXRpb24gZmFjdG9yIFswLDFdXG4gICk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgY29uc3QgdDMgPSB0MiAqIHQ7XG5cbiAgICAvLyBDYXRtdWxsLVJvbSBiYXNpcyBmdW5jdGlvbnNcbiAgICBjb25zdCBjMDAgPSAtMC41ICogdDMgKyB0MiAtIDAuNSAqIHQ7XG4gICAgY29uc3QgYzEwID0gMS41ICogdDMgLSAyLjUgKiB0MiArIDE7XG4gICAgY29uc3QgYzIwID0gLTEuNSAqIHQzICsgMiAqIHQyICsgMC41ICogdDtcbiAgICBjb25zdCBjMzAgPSAwLjUgKiB0MyAtIDAuNSAqIHQyO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAwLCBjMDApO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IocDEsIGMxMCk7XG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMiwgYzIwKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAzLCBjMzApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBCZXppZXIgaW50ZXJwb2xhdGlvbiBmb3Igc21vb3RoIGN1cnZlcyB3aXRoIGNvbnRyb2wgcG9pbnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGJlemllckludGVycG9sYXRlKFxuICAgIHAwOiBWZWN0b3IzLCAvLyBTdGFydCBwb2ludFxuICAgIHAxOiBWZWN0b3IzLCAvLyBDb250cm9sIHBvaW50IDFcbiAgICBwMjogVmVjdG9yMywgLy8gQ29udHJvbCBwb2ludCAyXG4gICAgcDM6IFZlY3RvcjMsIC8vIEVuZCBwb2ludFxuICAgIHQ6IG51bWJlciAgICAvLyBJbnRlcnBvbGF0aW9uIGZhY3RvciBbMCwxXVxuICApOiBWZWN0b3IzIHtcbiAgICBjb25zdCB1ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB1dSA9IHUgKiB1O1xuICAgIGNvbnN0IHV1dSA9IHV1ICogdTtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IocDAsIHV1dSk7ICAgICAgLy8gKDEtdCleMyAqIHAwXG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMSwgMyAqIHV1ICogdCk7IC8vIDMqKDEtdCleMip0ICogcDFcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAyLCAzICogdSAqIHR0KTsgIC8vIDMqKDEtdCkqdF4yICogcDJcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAzLCB0dHQpOyAgICAgICAvLyB0XjMgKiBwM1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTbW9vdGggc3RlcCBpbnRlcnBvbGF0aW9uIGZvciBlYXNpbmdcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc21vb3RoU3RlcEludGVycG9sYXRlKHN0YXJ0OiBWZWN0b3IzLCBlbmQ6IFZlY3RvcjMsIHQ6IG51bWJlcik6IFZlY3RvcjMge1xuICAgIC8vIFNtb290aHN0ZXAgZnVuY3Rpb246IDN0XjIgLSAydF4zXG4gICAgY29uc3Qgc21vb3RoVCA9IHQgKiB0ICogKDMgLSAyICogdCk7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCkubGVycFZlY3RvcnMoc3RhcnQsIGVuZCwgc21vb3RoVCk7XG4gIH1cblxuICAvKipcbiAgICogU21vb3RoZXIgc3RlcCBpbnRlcnBvbGF0aW9uIGZvciBldmVuIHNtb290aGVyIGVhc2luZ1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzbW9vdGhlclN0ZXBJbnRlcnBvbGF0ZShzdGFydDogVmVjdG9yMywgZW5kOiBWZWN0b3IzLCB0OiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICAvLyBTbW9vdGhlcnN0ZXAgZnVuY3Rpb246IDZ0XjUgLSAxNXReNCArIDEwdF4zXG4gICAgY29uc3Qgc21vb3RoVCA9IHQgKiB0ICogdCAqICh0ICogKDYgKiB0IC0gMTUpICsgMTApO1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygpLmxlcnBWZWN0b3JzKHN0YXJ0LCBlbmQsIHNtb290aFQpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkludGVycG9sYXRpb25CdWZmZXIiLCJNb3ZlbWVudCIsIkludGVycG9sYXRpb25TeXN0ZW0iLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImN1cnJlbnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJpbnRlcnBvbGF0aW9uQnVmZmVyIiwibW92ZW1lbnQiLCJlbmFibGVkIiwiY2FuTW92ZSIsImludGVycG9sYXRlRW50aXR5IiwicmVuZGVyIiwiaW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwiZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwicG9zaXRpb24iLCJjb3B5IiwicXVhdGVybmlvbiIsInJvdGF0aW9uIiwic2V0RnJvbVF1YXRlcm5pb24iLCJtYXRyaXhOZWVkc1VwZGF0ZSIsImFkZFNlcnZlclN0YXRlIiwidGltZXN0YW1wIiwiZ2V0SW50ZXJwb2xhdGlvblN0YXRzIiwiZ2V0QnVmZmVyU3RhdHMiLCJjbGVhckludGVycG9sYXRpb25CdWZmZXIiLCJjbGVhckJ1ZmZlciIsInNldEludGVycG9sYXRpb25EZWxheSIsImRlbGF5TXMiLCJjb25zb2xlIiwid2FybiIsImdldEN1cnJlbnRSZW5kZXJUaW1lIiwiaGVybWl0ZUludGVycG9sYXRlIiwicDAiLCJwMSIsInYwIiwidjEiLCJ0IiwidDIiLCJ0MyIsImgwMCIsImgxMCIsImgwMSIsImgxMSIsInJlc3VsdCIsImFkZFNjYWxlZFZlY3RvciIsImNhdG11bGxSb21JbnRlcnBvbGF0ZSIsInAyIiwicDMiLCJjMDAiLCJjMTAiLCJjMjAiLCJjMzAiLCJiZXppZXJJbnRlcnBvbGF0ZSIsInUiLCJ0dCIsInV1IiwidXV1IiwidHR0Iiwic21vb3RoU3RlcEludGVycG9sYXRlIiwic3RhcnQiLCJlbmQiLCJzbW9vdGhUIiwibGVycFZlY3RvcnMiLCJzbW9vdGhlclN0ZXBJbnRlcnBvbGF0ZSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/InterpolationSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/PhysicsSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/PhysicsSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Physics system for handling movement physics\n\n\n\n\nclass PhysicsSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for variable timestep updates\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            // Update debuff states (frozen, slowed, etc.)\n            if (typeof movement.updateDebuffs === \"function\") {\n                movement.updateDebuffs();\n            } else {\n            // console.warn('⚠️ Movement component missing updateDebuffs method:', movement);\n            }\n            this.updateMovement(transform, movement, deltaTime);\n        }\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            this.applyPhysics(transform, movement, fixedDeltaTime);\n        }\n    }\n    updateMovement(transform, movement, deltaTime) {\n        // Update position based on velocity\n        const deltaPosition = movement.velocity.clone().multiplyScalar(deltaTime);\n        // Calculate potential new position\n        const currentPosition = transform.position.clone();\n        const potentialPosition = currentPosition.clone().add(deltaPosition);\n        // Apply map boundary constraints with smooth sliding (radius of 29 units from origin)\n        const MAP_RADIUS = 29;\n        // Only check horizontal distance (ignore Y for boundary)\n        const horizontalPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(potentialPosition.x, 0, potentialPosition.z);\n        const distanceFromCenter = horizontalPosition.length();\n        // Check for pillar collisions first\n        const pillarCollision = this.checkPillarCollision(potentialPosition);\n        if (distanceFromCenter >= MAP_RADIUS) {\n            // If we hit the boundary, calculate tangent movement for smooth sliding\n            const currentHorizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(currentPosition.x, 0, currentPosition.z);\n            const toCenter = currentHorizontalPos.clone().normalize();\n            // Create tangent vector (perpendicular to radius)\n            const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-toCenter.z, 0, toCenter.x);\n            // Project our horizontal movement onto the tangent\n            const horizontalMovement = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(deltaPosition.x, 0, deltaPosition.z);\n            const tangentMovement = tangent.multiplyScalar(horizontalMovement.dot(tangent));\n            // Apply the tangential movement while keeping distance to center constant\n            const newHorizontalPosition = currentHorizontalPos.add(tangentMovement);\n            newHorizontalPosition.normalize().multiplyScalar(MAP_RADIUS);\n            // Update position with tangent movement and preserve Y movement\n            transform.setPosition(newHorizontalPosition.x, currentPosition.y + deltaPosition.y, newHorizontalPosition.z);\n        } else if (pillarCollision.hasCollision) {\n            // Handle pillar collision with smooth sliding\n            const slidePosition = this.calculatePillarSliding(currentPosition, deltaPosition, pillarCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the pillar to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(pillarCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else {\n            // If within bounds and no pillar collision, move normally\n            transform.translate(deltaPosition.x, deltaPosition.y, deltaPosition.z);\n        }\n        // Mark transform matrix as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    calculatePillarSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from pillar center\n        const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.pillarCenter.x, 0, collision.pillarCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(pillarHorizontal);\n        if (distanceAfterSlide < this.PILLAR_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(pillarHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = pillarHorizontal.clone().add(pushDirection.multiplyScalar(this.PILLAR_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    applyPhysics(transform, movement, deltaTime) {\n        // Apply gravity (only affects Y velocity)\n        movement.applyGravity(deltaTime);\n        // Handle horizontal movement directly for immediate response\n        if (movement.inputStrength > 0) {\n            // Use effective max speed which accounts for frozen/slowed states\n            const effectiveMaxSpeed = movement.getEffectiveMaxSpeed();\n            // Direct velocity setting for responsive movement\n            const targetVelocity = movement.moveDirection.clone();\n            targetVelocity.multiplyScalar(effectiveMaxSpeed * movement.inputStrength);\n            // Set horizontal velocity directly (preserve Y velocity for gravity/jumping)\n            movement.velocity.x = targetVelocity.x;\n            movement.velocity.z = targetVelocity.z;\n        } else {\n            // No input - stop horizontal movement immediately for responsive controls\n            movement.velocity.x = 0;\n            movement.velocity.z = 0;\n        }\n        // Apply any additional forces (like knockback, wind, etc.)\n        movement.velocity.add(movement.acceleration.clone().multiplyScalar(deltaTime));\n        // Reset acceleration for next frame\n        movement.acceleration.set(0, 0, 0);\n        // Simple ground check (Y = 0 is ground level, account for sphere radius)\n        const sphereRadius = 0.5; // Player sphere radius\n        const groundLevel = sphereRadius; // Sphere center should be at radius height above ground\n        if (transform.position.y <= groundLevel && movement.velocity.y <= 0) {\n            transform.position.y = groundLevel;\n            movement.velocity.y = 0;\n            movement.isGrounded = true;\n        } else {\n            movement.isGrounded = false;\n        }\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        this.priority = 15; // Run after control system but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrQ0FBK0M7QUFDQztBQUNrQjtBQUVYO0FBQ0Y7QUFFOUMsTUFBTUMsc0JBQXNCQyxzREFBaUJBO0lBUTNDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELHNEQUFzRDtRQUN0RCxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsV0FBV0gsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ0ssYUFBYSxDQUFDRSxVQUFVO2dCQUMzQjtZQUNGO1lBRUEsSUFBSSxDQUFDRixVQUFVRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxJQUFJLENBQUNELFNBQVNFLE9BQU8sRUFBRTtnQkFDaEU7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLE9BQU9GLFNBQVNHLGFBQWEsS0FBSyxZQUFZO2dCQUNoREgsU0FBU0csYUFBYTtZQUN4QixPQUFPO1lBQ0wsaUZBQWlGO1lBQ25GO1lBRUEsSUFBSSxDQUFDQyxjQUFjLENBQUNOLFdBQVdFLFVBQVVKO1FBQzNDO0lBQ0Y7SUFFT1MsWUFBWVYsUUFBa0IsRUFBRVcsY0FBc0IsRUFBUTtRQUNuRSwwQ0FBMEM7UUFDMUMsS0FBSyxNQUFNVCxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBQy9DLE1BQU1RLFdBQVdILE9BQU9FLFlBQVksQ0FBQ04sOERBQVFBO1lBRTdDLDBDQUEwQztZQUMxQyxJQUFJLENBQUNLLGFBQWEsQ0FBQ0UsVUFBVTtnQkFDM0I7WUFDRjtZQUVBLElBQUksQ0FBQ0YsVUFBVUcsT0FBTyxJQUFJLENBQUNELFNBQVNDLE9BQU8sSUFBSSxDQUFDRCxTQUFTRSxPQUFPLEVBQUU7Z0JBQ2hFO1lBQ0Y7WUFFQSxJQUFJLENBQUNLLFlBQVksQ0FBQ1QsV0FBV0UsVUFBVU07UUFDekM7SUFDRjtJQUVRRixlQUFlTixTQUFvQixFQUFFRSxRQUFrQixFQUFFSixTQUFpQixFQUFRO1FBQ3hGLG9DQUFvQztRQUNwQyxNQUFNWSxnQkFBZ0JSLFNBQVNTLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxjQUFjLENBQUNmO1FBRS9ELG1DQUFtQztRQUNuQyxNQUFNZ0Isa0JBQWtCZCxVQUFVZSxRQUFRLENBQUNILEtBQUs7UUFDaEQsTUFBTUksb0JBQW9CRixnQkFBZ0JGLEtBQUssR0FBR0ssR0FBRyxDQUFDUDtRQUV0RCxzRkFBc0Y7UUFDdEYsTUFBTVEsYUFBYTtRQUVuQix5REFBeUQ7UUFDekQsTUFBTUMscUJBQXFCLElBQUk1Qix5REFBT0EsQ0FBQ3lCLGtCQUFrQkksQ0FBQyxFQUFFLEdBQUdKLGtCQUFrQkssQ0FBQztRQUNsRixNQUFNQyxxQkFBcUJILG1CQUFtQkksTUFBTTtRQUVwRCxvQ0FBb0M7UUFDcEMsTUFBTUMsa0JBQWtCLElBQUksQ0FBQ0Msb0JBQW9CLENBQUNUO1FBRWxELElBQUlNLHNCQUFzQkosWUFBWTtZQUNwQyx3RUFBd0U7WUFDeEUsTUFBTVEsdUJBQXVCLElBQUluQyx5REFBT0EsQ0FBQ3VCLGdCQUFnQk0sQ0FBQyxFQUFFLEdBQUdOLGdCQUFnQk8sQ0FBQztZQUNoRixNQUFNTSxXQUFXRCxxQkFBcUJkLEtBQUssR0FBR2dCLFNBQVM7WUFFdkQsa0RBQWtEO1lBQ2xELE1BQU1DLFVBQVUsSUFBSXRDLHlEQUFPQSxDQUFDLENBQUNvQyxTQUFTTixDQUFDLEVBQUUsR0FBR00sU0FBU1AsQ0FBQztZQUV0RCxtREFBbUQ7WUFDbkQsTUFBTVUscUJBQXFCLElBQUl2Qyx5REFBT0EsQ0FBQ21CLGNBQWNVLENBQUMsRUFBRSxHQUFHVixjQUFjVyxDQUFDO1lBQzFFLE1BQU1VLGtCQUFrQkYsUUFBUWhCLGNBQWMsQ0FBQ2lCLG1CQUFtQkUsR0FBRyxDQUFDSDtZQUV0RSwwRUFBMEU7WUFDMUUsTUFBTUksd0JBQXdCUCxxQkFBcUJULEdBQUcsQ0FBQ2M7WUFDdkRFLHNCQUFzQkwsU0FBUyxHQUFHZixjQUFjLENBQUNLO1lBRWpELGdFQUFnRTtZQUNoRWxCLFVBQVVrQyxXQUFXLENBQ25CRCxzQkFBc0JiLENBQUMsRUFDdkJOLGdCQUFnQnFCLENBQUMsR0FBR3pCLGNBQWN5QixDQUFDLEVBQ25DRixzQkFBc0JaLENBQUM7UUFFM0IsT0FBTyxJQUFJRyxnQkFBZ0JZLFlBQVksRUFBRTtZQUN2Qyw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCLElBQUksQ0FBQ0Msc0JBQXNCLENBQUN4QixpQkFBaUJKLGVBQWVjO1lBQ2xGeEIsVUFBVWtDLFdBQVcsQ0FBQ0csY0FBY2pCLENBQUMsRUFBRWlCLGNBQWNGLENBQUMsRUFBRUUsY0FBY2hCLENBQUM7WUFFdkUscUVBQXFFO1lBQ3JFLE1BQU1rQiwwQkFBMEJyQyxTQUFTUyxRQUFRLENBQUNDLEtBQUssR0FBRzRCLGVBQWUsQ0FBQ2hCLGdCQUFnQmlCLE1BQU07WUFDaEd2QyxTQUFTUyxRQUFRLENBQUMrQixHQUFHLENBQUNILHdCQUF3QjFCLGNBQWMsQ0FBQztRQUMvRCxPQUFPO1lBQ0wsMERBQTBEO1lBQzFEYixVQUFVMkMsU0FBUyxDQUFDakMsY0FBY1UsQ0FBQyxFQUFFVixjQUFjeUIsQ0FBQyxFQUFFekIsY0FBY1csQ0FBQztRQUN2RTtRQUVBLDBDQUEwQztRQUMxQ3JCLFVBQVU0QyxpQkFBaUIsR0FBRztJQUNoQztJQVVRbkIscUJBQXFCVixRQUFpQixFQUFxRTtRQUNqSCxLQUFLLE1BQU04QixhQUFhLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUU7WUFDN0MsNENBQTRDO1lBQzVDLE1BQU1DLGdCQUFnQixJQUFJeEQseURBQU9BLENBQUN3QixTQUFTSyxDQUFDLEVBQUUsR0FBR0wsU0FBU00sQ0FBQztZQUMzRCxNQUFNMkIsbUJBQW1CLElBQUl6RCx5REFBT0EsQ0FBQ3NELFVBQVV6QixDQUFDLEVBQUUsR0FBR3lCLFVBQVV4QixDQUFDO1lBQ2hFLE1BQU00QixXQUFXRixjQUFjRyxVQUFVLENBQUNGO1lBRTFDLElBQUlDLFdBQVcsSUFBSSxDQUFDRSxhQUFhLEVBQUU7Z0JBQ2pDLDJEQUEyRDtnQkFDM0QsTUFBTVYsU0FBU00sY0FBY25DLEtBQUssR0FBRzhCLEdBQUcsQ0FBQ00sa0JBQWtCcEIsU0FBUztnQkFDcEUsdURBQXVEO2dCQUN2RCxJQUFJYSxPQUFPbEIsTUFBTSxPQUFPLEdBQUc7b0JBQ3pCa0IsT0FBT1csR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLG9CQUFvQjtnQkFDM0M7Z0JBQ0EsT0FBTztvQkFDTGhCLGNBQWM7b0JBQ2RLLFFBQVFBO29CQUNSWSxjQUFjUixVQUFVakMsS0FBSztnQkFDL0I7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUFFd0IsY0FBYztZQUFPSyxRQUFRLElBQUlsRCx5REFBT0E7WUFBSThELGNBQWMsSUFBSTlELHlEQUFPQTtRQUFHO0lBQ25GO0lBRVErQyx1QkFBdUJ4QixlQUF3QixFQUFFSixhQUFzQixFQUFFNEMsU0FBcUQsRUFBVztRQUMvSSxxRUFBcUU7UUFDckUsTUFBTXpCLFVBQVUsSUFBSXRDLHlEQUFPQSxDQUFDLENBQUMrRCxVQUFVYixNQUFNLENBQUNwQixDQUFDLEVBQUUsR0FBR2lDLFVBQVViLE1BQU0sQ0FBQ3JCLENBQUM7UUFFdEUsMkRBQTJEO1FBQzNELE1BQU1XLGtCQUFrQnJCLGNBQWNFLEtBQUssR0FBRzRCLGVBQWUsQ0FBQ1g7UUFFOUQsbURBQW1EO1FBQ25ELE1BQU1RLGdCQUFnQnZCLGdCQUFnQkYsS0FBSyxHQUFHSyxHQUFHLENBQUNjO1FBRWxELHlEQUF5RDtRQUN6RCxNQUFNaUIsbUJBQW1CLElBQUl6RCx5REFBT0EsQ0FBQytELFVBQVVELFlBQVksQ0FBQ2pDLENBQUMsRUFBRSxHQUFHa0MsVUFBVUQsWUFBWSxDQUFDaEMsQ0FBQztRQUMxRixNQUFNa0Msa0JBQWtCLElBQUloRSx5REFBT0EsQ0FBQzhDLGNBQWNqQixDQUFDLEVBQUUsR0FBR2lCLGNBQWNoQixDQUFDO1FBQ3ZFLE1BQU1tQyxxQkFBcUJELGdCQUFnQkwsVUFBVSxDQUFDRjtRQUV0RCxJQUFJUSxxQkFBcUIsSUFBSSxDQUFDTCxhQUFhLEVBQUU7WUFDM0MsaURBQWlEO1lBQ2pELE1BQU1NLGdCQUFnQkYsZ0JBQWdCM0MsS0FBSyxHQUFHOEIsR0FBRyxDQUFDTSxrQkFBa0JwQixTQUFTO1lBQzdFLElBQUk2QixjQUFjbEMsTUFBTSxPQUFPLEdBQUc7Z0JBQ2hDa0MsY0FBY0wsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLG9CQUFvQjtZQUNsRDtZQUNBLE1BQU1NLHNCQUFzQlYsaUJBQWlCcEMsS0FBSyxHQUFHSyxHQUFHLENBQUN3QyxjQUFjNUMsY0FBYyxDQUFDLElBQUksQ0FBQ3NDLGFBQWE7WUFDeEdkLGNBQWNqQixDQUFDLEdBQUdzQyxvQkFBb0J0QyxDQUFDO1lBQ3ZDaUIsY0FBY2hCLENBQUMsR0FBR3FDLG9CQUFvQnJDLENBQUM7UUFDekM7UUFFQSxPQUFPZ0I7SUFDVDtJQUVRNUIsYUFBYVQsU0FBb0IsRUFBRUUsUUFBa0IsRUFBRUosU0FBaUIsRUFBUTtRQUN0RiwwQ0FBMEM7UUFDMUNJLFNBQVN5RCxZQUFZLENBQUM3RDtRQUV0Qiw2REFBNkQ7UUFDN0QsSUFBSUksU0FBUzBELGFBQWEsR0FBRyxHQUFHO1lBQzlCLGtFQUFrRTtZQUNsRSxNQUFNQyxvQkFBb0IzRCxTQUFTNEQsb0JBQW9CO1lBRXZELGtEQUFrRDtZQUNsRCxNQUFNQyxpQkFBaUI3RCxTQUFTOEQsYUFBYSxDQUFDcEQsS0FBSztZQUNuRG1ELGVBQWVsRCxjQUFjLENBQUNnRCxvQkFBb0IzRCxTQUFTMEQsYUFBYTtZQUV4RSw2RUFBNkU7WUFDN0UxRCxTQUFTUyxRQUFRLENBQUNTLENBQUMsR0FBRzJDLGVBQWUzQyxDQUFDO1lBQ3RDbEIsU0FBU1MsUUFBUSxDQUFDVSxDQUFDLEdBQUcwQyxlQUFlMUMsQ0FBQztRQUN4QyxPQUFPO1lBQ0wsMEVBQTBFO1lBQzFFbkIsU0FBU1MsUUFBUSxDQUFDUyxDQUFDLEdBQUc7WUFDdEJsQixTQUFTUyxRQUFRLENBQUNVLENBQUMsR0FBRztRQUN4QjtRQUVBLDJEQUEyRDtRQUMzRG5CLFNBQVNTLFFBQVEsQ0FBQ00sR0FBRyxDQUFDZixTQUFTK0QsWUFBWSxDQUFDckQsS0FBSyxHQUFHQyxjQUFjLENBQUNmO1FBRW5FLG9DQUFvQztRQUNwQ0ksU0FBUytELFlBQVksQ0FBQ2IsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUVoQyx5RUFBeUU7UUFDekUsTUFBTWMsZUFBZSxLQUFLLHVCQUF1QjtRQUNqRCxNQUFNQyxjQUFjRCxjQUFjLHdEQUF3RDtRQUUxRixJQUFJbEUsVUFBVWUsUUFBUSxDQUFDb0IsQ0FBQyxJQUFJZ0MsZUFBZWpFLFNBQVNTLFFBQVEsQ0FBQ3dCLENBQUMsSUFBSSxHQUFHO1lBQ25FbkMsVUFBVWUsUUFBUSxDQUFDb0IsQ0FBQyxHQUFHZ0M7WUFDdkJqRSxTQUFTUyxRQUFRLENBQUN3QixDQUFDLEdBQUc7WUFDdEJqQyxTQUFTa0UsVUFBVSxHQUFHO1FBQ3hCLE9BQU87WUFDTGxFLFNBQVNrRSxVQUFVLEdBQUc7UUFDeEI7SUFDRjtJQWhOQUMsYUFBYztRQUNaLEtBQUs7YUFIU0MscUJBQXFCO1lBQUM1RSxnRUFBU0E7WUFBRUMsOERBQVFBO1NBQUM7UUE2RzFELHVEQUF1RDthQUN0Q21ELG1CQUFtQjtZQUNsQyxJQUFJdkQseURBQU9BLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDbkIsSUFBSUEseURBQU9BLENBQUMsQ0FBQyxNQUFNLEdBQUc7WUFDdEIsSUFBSUEseURBQU9BLENBQUMsTUFBTSxHQUFHLEtBQVMsZUFBZTtTQUM5QzthQUNnQjRELGdCQUFnQixJQUFLLDhCQUE4Qjs7UUEvR2xFLElBQUksQ0FBQ29CLFFBQVEsR0FBRyxJQUFJLGdEQUFnRDtJQUN0RTtBQThNRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9QaHlzaWNzU3lzdGVtLnRzPzBjZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGh5c2ljcyBzeXN0ZW0gZm9yIGhhbmRsaW5nIG1vdmVtZW50IHBoeXNpY3NcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUGh5c2ljc1N5c3RlbSBhcyBCYXNlUGh5c2ljc1N5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgTW92ZW1lbnQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL01vdmVtZW50JztcblxuZXhwb3J0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBCYXNlUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBNb3ZlbWVudF07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTU7IC8vIFJ1biBhZnRlciBjb250cm9sIHN5c3RlbSBidXQgYmVmb3JlIHJlbmRlcmluZ1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB2YXJpYWJsZSB0aW1lc3RlcCB1cGRhdGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG5cbiAgICAgIC8vIFNraXAgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbWlzc2luZ1xuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIW1vdmVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFtb3ZlbWVudC5lbmFibGVkIHx8ICFtb3ZlbWVudC5jYW5Nb3ZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZGVidWZmIHN0YXRlcyAoZnJvemVuLCBzbG93ZWQsIGV0Yy4pXG4gICAgICBpZiAodHlwZW9mIG1vdmVtZW50LnVwZGF0ZURlYnVmZnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbW92ZW1lbnQudXBkYXRlRGVidWZmcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gTW92ZW1lbnQgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlRGVidWZmcyBtZXRob2Q6JywgbW92ZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZU1vdmVtZW50KHRyYW5zZm9ybSwgbW92ZW1lbnQsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGZpeGVkVXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZml4ZWREZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRoaXMgcnVucyBhdCBmaXhlZCB0aW1lc3RlcCBmb3IgcGh5c2ljc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHJlcXVpcmVkIGNvbXBvbmVudHMgYXJlIG1pc3NpbmdcbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICFtb3ZlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhbW92ZW1lbnQuZW5hYmxlZCB8fCAhbW92ZW1lbnQuY2FuTW92ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBseVBoeXNpY3ModHJhbnNmb3JtLCBtb3ZlbWVudCwgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTW92ZW1lbnQodHJhbnNmb3JtOiBUcmFuc2Zvcm0sIG1vdmVtZW50OiBNb3ZlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgcG9zaXRpb24gYmFzZWQgb24gdmVsb2NpdHlcbiAgICBjb25zdCBkZWx0YVBvc2l0aW9uID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwb3RlbnRpYWwgbmV3IHBvc2l0aW9uXG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgY29uc3QgcG90ZW50aWFsUG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb24uY2xvbmUoKS5hZGQoZGVsdGFQb3NpdGlvbik7XG4gICAgXG4gICAgLy8gQXBwbHkgbWFwIGJvdW5kYXJ5IGNvbnN0cmFpbnRzIHdpdGggc21vb3RoIHNsaWRpbmcgKHJhZGl1cyBvZiAyOSB1bml0cyBmcm9tIG9yaWdpbilcbiAgICBjb25zdCBNQVBfUkFESVVTID0gMjk7XG4gICAgXG4gICAgLy8gT25seSBjaGVjayBob3Jpem9udGFsIGRpc3RhbmNlIChpZ25vcmUgWSBmb3IgYm91bmRhcnkpXG4gICAgY29uc3QgaG9yaXpvbnRhbFBvc2l0aW9uID0gbmV3IFZlY3RvcjMocG90ZW50aWFsUG9zaXRpb24ueCwgMCwgcG90ZW50aWFsUG9zaXRpb24ueik7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tQ2VudGVyID0gaG9yaXpvbnRhbFBvc2l0aW9uLmxlbmd0aCgpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBwaWxsYXIgY29sbGlzaW9ucyBmaXJzdFxuICAgIGNvbnN0IHBpbGxhckNvbGxpc2lvbiA9IHRoaXMuY2hlY2tQaWxsYXJDb2xsaXNpb24ocG90ZW50aWFsUG9zaXRpb24pO1xuICAgIFxuICAgIGlmIChkaXN0YW5jZUZyb21DZW50ZXIgPj0gTUFQX1JBRElVUykge1xuICAgICAgLy8gSWYgd2UgaGl0IHRoZSBib3VuZGFyeSwgY2FsY3VsYXRlIHRhbmdlbnQgbW92ZW1lbnQgZm9yIHNtb290aCBzbGlkaW5nXG4gICAgICBjb25zdCBjdXJyZW50SG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKGN1cnJlbnRQb3NpdGlvbi54LCAwLCBjdXJyZW50UG9zaXRpb24ueik7XG4gICAgICBjb25zdCB0b0NlbnRlciA9IGN1cnJlbnRIb3Jpem9udGFsUG9zLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0YW5nZW50IHZlY3RvciAocGVycGVuZGljdWxhciB0byByYWRpdXMpXG4gICAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLXRvQ2VudGVyLnosIDAsIHRvQ2VudGVyLngpO1xuICAgICAgXG4gICAgICAvLyBQcm9qZWN0IG91ciBob3Jpem9udGFsIG1vdmVtZW50IG9udG8gdGhlIHRhbmdlbnRcbiAgICAgIGNvbnN0IGhvcml6b250YWxNb3ZlbWVudCA9IG5ldyBWZWN0b3IzKGRlbHRhUG9zaXRpb24ueCwgMCwgZGVsdGFQb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHRhbmdlbnRNb3ZlbWVudCA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIoaG9yaXpvbnRhbE1vdmVtZW50LmRvdCh0YW5nZW50KSk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHRoZSB0YW5nZW50aWFsIG1vdmVtZW50IHdoaWxlIGtlZXBpbmcgZGlzdGFuY2UgdG8gY2VudGVyIGNvbnN0YW50XG4gICAgICBjb25zdCBuZXdIb3Jpem9udGFsUG9zaXRpb24gPSBjdXJyZW50SG9yaXpvbnRhbFBvcy5hZGQodGFuZ2VudE1vdmVtZW50KTtcbiAgICAgIG5ld0hvcml6b250YWxQb3NpdGlvbi5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihNQVBfUkFESVVTKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIHdpdGggdGFuZ2VudCBtb3ZlbWVudCBhbmQgcHJlc2VydmUgWSBtb3ZlbWVudFxuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKFxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24ueCwgXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbi55ICsgZGVsdGFQb3NpdGlvbi55LCAvLyBBbGxvdyB2ZXJ0aWNhbCBtb3ZlbWVudCAoanVtcGluZywgZmFsbGluZylcbiAgICAgICAgbmV3SG9yaXpvbnRhbFBvc2l0aW9uLnpcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwaWxsYXJDb2xsaXNpb24uaGFzQ29sbGlzaW9uKSB7XG4gICAgICAvLyBIYW5kbGUgcGlsbGFyIGNvbGxpc2lvbiB3aXRoIHNtb290aCBzbGlkaW5nXG4gICAgICBjb25zdCBzbGlkZVBvc2l0aW9uID0gdGhpcy5jYWxjdWxhdGVQaWxsYXJTbGlkaW5nKGN1cnJlbnRQb3NpdGlvbiwgZGVsdGFQb3NpdGlvbiwgcGlsbGFyQ29sbGlzaW9uKTtcbiAgICAgIHRyYW5zZm9ybS5zZXRQb3NpdGlvbihzbGlkZVBvc2l0aW9uLngsIHNsaWRlUG9zaXRpb24ueSwgc2xpZGVQb3NpdGlvbi56KTtcbiAgICAgIFxuICAgICAgLy8gUmVkdWNlIHZlbG9jaXR5IGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHBpbGxhciB0byBwcmV2ZW50IGJvdW5jaW5nXG4gICAgICBjb25zdCB2ZWxvY2l0eU5vcm1hbENvbXBvbmVudCA9IG1vdmVtZW50LnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHBpbGxhckNvbGxpc2lvbi5ub3JtYWwpO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkuc3ViKHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50Lm11bHRpcGx5U2NhbGFyKDAuNSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3aXRoaW4gYm91bmRzIGFuZCBubyBwaWxsYXIgY29sbGlzaW9uLCBtb3ZlIG5vcm1hbGx5XG4gICAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKGRlbHRhUG9zaXRpb24ueCwgZGVsdGFQb3NpdGlvbi55LCBkZWx0YVBvc2l0aW9uLnopO1xuICAgIH1cblxuICAgIC8vIE1hcmsgdHJhbnNmb3JtIG1hdHJpeCBhcyBuZWVkaW5nIHVwZGF0ZVxuICAgIHRyYW5zZm9ybS5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICAvLyBEZWZpbmUgcGlsbGFyIHBvc2l0aW9ucyAoc2FtZSBhcyBpbiBFbnZpcm9ubWVudC50c3gpXG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1BPU0lUSU9OUyA9IFtcbiAgICBuZXcgVmVjdG9yMygwLCAwLCAtNSksICAgICAgICAvLyBGcm9udCBwaWxsYXJcbiAgICBuZXcgVmVjdG9yMygtNC4yNSwgMCwgMi41KSwgICAvLyBMZWZ0IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKDQuMjUsIDAsIDIuNSkgICAgIC8vIFJpZ2h0IHBpbGxhclxuICBdO1xuICBwcml2YXRlIHJlYWRvbmx5IFBJTExBUl9SQURJVVMgPSAwLjc7IC8vIFNhbWUgYXMgUGlsbGFyQ29sbGlzaW9uLnRzeFxuXG4gIHByaXZhdGUgY2hlY2tQaWxsYXJDb2xsaXNpb24ocG9zaXRpb246IFZlY3RvcjMpOiB7IGhhc0NvbGxpc2lvbjogYm9vbGVhbjsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSB7XG4gICAgZm9yIChjb25zdCBwaWxsYXJQb3Mgb2YgdGhpcy5QSUxMQVJfUE9TSVRJT05TKSB7XG4gICAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKHBvc2l0aW9uLngsIDAsIHBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKHBpbGxhclBvcy54LCAwLCBwaWxsYXJQb3Mueik7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGhvcml6b250YWxQb3MuZGlzdGFuY2VUbyhwaWxsYXJIb3Jpem9udGFsKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5QSUxMQVJfUkFESVVTKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBub3JtYWwgdmVjdG9yIHBvaW50aW5nIGF3YXkgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGhvcml6b250YWxQb3MuY2xvbmUoKS5zdWIocGlsbGFySG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHBsYXllciBpcyBleGFjdGx5IGF0IHBpbGxhciBjZW50ZXJcbiAgICAgICAgaWYgKG5vcm1hbC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgIG5vcm1hbC5zZXQoMSwgMCwgMCk7IC8vIERlZmF1bHQgZGlyZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNDb2xsaXNpb246IHRydWUsXG4gICAgICAgICAgbm9ybWFsOiBub3JtYWwsXG4gICAgICAgICAgcGlsbGFyQ2VudGVyOiBwaWxsYXJQb3MuY2xvbmUoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBoYXNDb2xsaXNpb246IGZhbHNlLCBub3JtYWw6IG5ldyBWZWN0b3IzKCksIHBpbGxhckNlbnRlcjogbmV3IFZlY3RvcjMoKSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVQaWxsYXJTbGlkaW5nKGN1cnJlbnRQb3NpdGlvbjogVmVjdG9yMywgZGVsdGFQb3NpdGlvbjogVmVjdG9yMywgY29sbGlzaW9uOiB7IG5vcm1hbDogVmVjdG9yMzsgcGlsbGFyQ2VudGVyOiBWZWN0b3IzIH0pOiBWZWN0b3IzIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIG5vcm1hbCBpbiBYWiBwbGFuZSlcbiAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLWNvbGxpc2lvbi5ub3JtYWwueiwgMCwgY29sbGlzaW9uLm5vcm1hbC54KTtcbiAgICBcbiAgICAvLyBQcm9qZWN0IHRoZSBtb3ZlbWVudCB2ZWN0b3Igb250byB0aGUgdGFuZ2VudCBmb3Igc2xpZGluZ1xuICAgIGNvbnN0IHRhbmdlbnRNb3ZlbWVudCA9IGRlbHRhUG9zaXRpb24uY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IodGFuZ2VudCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgcG9zaXRpb24gd2l0aCBzbGlkaW5nIG1vdmVtZW50XG4gICAgY29uc3Qgc2xpZGVQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0YW5nZW50TW92ZW1lbnQpO1xuICAgIFxuICAgIC8vIEVuc3VyZSB3ZSBtYWludGFpbiBtaW5pbXVtIGRpc3RhbmNlIGZyb20gcGlsbGFyIGNlbnRlclxuICAgIGNvbnN0IHBpbGxhckhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhjb2xsaXNpb24ucGlsbGFyQ2VudGVyLngsIDAsIGNvbGxpc2lvbi5waWxsYXJDZW50ZXIueik7XG4gICAgY29uc3Qgc2xpZGVIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMoc2xpZGVQb3NpdGlvbi54LCAwLCBzbGlkZVBvc2l0aW9uLnopO1xuICAgIGNvbnN0IGRpc3RhbmNlQWZ0ZXJTbGlkZSA9IHNsaWRlSG9yaXpvbnRhbC5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgIFxuICAgIGlmIChkaXN0YW5jZUFmdGVyU2xpZGUgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgIC8vIFB1c2ggdGhlIHBvc2l0aW9uIHRvIG1haW50YWluIG1pbmltdW0gZGlzdGFuY2VcbiAgICAgIGNvbnN0IHB1c2hEaXJlY3Rpb24gPSBzbGlkZUhvcml6b250YWwuY2xvbmUoKS5zdWIocGlsbGFySG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICBpZiAocHVzaERpcmVjdGlvbi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICBwdXNoRGlyZWN0aW9uLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcnJlY3RlZEhvcml6b250YWwgPSBwaWxsYXJIb3Jpem9udGFsLmNsb25lKCkuYWRkKHB1c2hEaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIodGhpcy5QSUxMQVJfUkFESVVTKSk7XG4gICAgICBzbGlkZVBvc2l0aW9uLnggPSBjb3JyZWN0ZWRIb3Jpem9udGFsLng7XG4gICAgICBzbGlkZVBvc2l0aW9uLnogPSBjb3JyZWN0ZWRIb3Jpem9udGFsLno7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbGlkZVBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBhcHBseVBoeXNpY3ModHJhbnNmb3JtOiBUcmFuc2Zvcm0sIG1vdmVtZW50OiBNb3ZlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBBcHBseSBncmF2aXR5IChvbmx5IGFmZmVjdHMgWSB2ZWxvY2l0eSlcbiAgICBtb3ZlbWVudC5hcHBseUdyYXZpdHkoZGVsdGFUaW1lKTtcblxuICAgIC8vIEhhbmRsZSBob3Jpem9udGFsIG1vdmVtZW50IGRpcmVjdGx5IGZvciBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICBpZiAobW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDApIHtcbiAgICAgIC8vIFVzZSBlZmZlY3RpdmUgbWF4IHNwZWVkIHdoaWNoIGFjY291bnRzIGZvciBmcm96ZW4vc2xvd2VkIHN0YXRlc1xuICAgICAgY29uc3QgZWZmZWN0aXZlTWF4U3BlZWQgPSBtb3ZlbWVudC5nZXRFZmZlY3RpdmVNYXhTcGVlZCgpO1xuICAgICAgXG4gICAgICAvLyBEaXJlY3QgdmVsb2NpdHkgc2V0dGluZyBmb3IgcmVzcG9uc2l2ZSBtb3ZlbWVudFxuICAgICAgY29uc3QgdGFyZ2V0VmVsb2NpdHkgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uLmNsb25lKCk7XG4gICAgICB0YXJnZXRWZWxvY2l0eS5tdWx0aXBseVNjYWxhcihlZmZlY3RpdmVNYXhTcGVlZCAqIG1vdmVtZW50LmlucHV0U3RyZW5ndGgpO1xuICAgICAgXG4gICAgICAvLyBTZXQgaG9yaXpvbnRhbCB2ZWxvY2l0eSBkaXJlY3RseSAocHJlc2VydmUgWSB2ZWxvY2l0eSBmb3IgZ3Jhdml0eS9qdW1waW5nKVxuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueCA9IHRhcmdldFZlbG9jaXR5Lng7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS56ID0gdGFyZ2V0VmVsb2NpdHkuejtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gaW5wdXQgLSBzdG9wIGhvcml6b250YWwgbW92ZW1lbnQgaW1tZWRpYXRlbHkgZm9yIHJlc3BvbnNpdmUgY29udHJvbHNcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnggPSAwO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueiA9IDA7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgYW55IGFkZGl0aW9uYWwgZm9yY2VzIChsaWtlIGtub2NrYmFjaywgd2luZCwgZXRjLilcbiAgICBtb3ZlbWVudC52ZWxvY2l0eS5hZGQobW92ZW1lbnQuYWNjZWxlcmF0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lKSk7XG5cbiAgICAvLyBSZXNldCBhY2NlbGVyYXRpb24gZm9yIG5leHQgZnJhbWVcbiAgICBtb3ZlbWVudC5hY2NlbGVyYXRpb24uc2V0KDAsIDAsIDApO1xuXG4gICAgLy8gU2ltcGxlIGdyb3VuZCBjaGVjayAoWSA9IDAgaXMgZ3JvdW5kIGxldmVsLCBhY2NvdW50IGZvciBzcGhlcmUgcmFkaXVzKVxuICAgIGNvbnN0IHNwaGVyZVJhZGl1cyA9IDAuNTsgLy8gUGxheWVyIHNwaGVyZSByYWRpdXNcbiAgICBjb25zdCBncm91bmRMZXZlbCA9IHNwaGVyZVJhZGl1czsgLy8gU3BoZXJlIGNlbnRlciBzaG91bGQgYmUgYXQgcmFkaXVzIGhlaWdodCBhYm92ZSBncm91bmRcbiAgICBcbiAgICBpZiAodHJhbnNmb3JtLnBvc2l0aW9uLnkgPD0gZ3JvdW5kTGV2ZWwgJiYgbW92ZW1lbnQudmVsb2NpdHkueSA8PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueSA9IGdyb3VuZExldmVsO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueSA9IDA7XG4gICAgICBtb3ZlbWVudC5pc0dyb3VuZGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZW1lbnQuaXNHcm91bmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJQaHlzaWNzU3lzdGVtIiwiQmFzZVBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwiZW50aXR5IiwidHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwibW92ZW1lbnQiLCJlbmFibGVkIiwiY2FuTW92ZSIsInVwZGF0ZURlYnVmZnMiLCJ1cGRhdGVNb3ZlbWVudCIsImZpeGVkVXBkYXRlIiwiZml4ZWREZWx0YVRpbWUiLCJhcHBseVBoeXNpY3MiLCJkZWx0YVBvc2l0aW9uIiwidmVsb2NpdHkiLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwiY3VycmVudFBvc2l0aW9uIiwicG9zaXRpb24iLCJwb3RlbnRpYWxQb3NpdGlvbiIsImFkZCIsIk1BUF9SQURJVVMiLCJob3Jpem9udGFsUG9zaXRpb24iLCJ4IiwieiIsImRpc3RhbmNlRnJvbUNlbnRlciIsImxlbmd0aCIsInBpbGxhckNvbGxpc2lvbiIsImNoZWNrUGlsbGFyQ29sbGlzaW9uIiwiY3VycmVudEhvcml6b250YWxQb3MiLCJ0b0NlbnRlciIsIm5vcm1hbGl6ZSIsInRhbmdlbnQiLCJob3Jpem9udGFsTW92ZW1lbnQiLCJ0YW5nZW50TW92ZW1lbnQiLCJkb3QiLCJuZXdIb3Jpem9udGFsUG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsInkiLCJoYXNDb2xsaXNpb24iLCJzbGlkZVBvc2l0aW9uIiwiY2FsY3VsYXRlUGlsbGFyU2xpZGluZyIsInZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50IiwicHJvamVjdE9uVmVjdG9yIiwibm9ybWFsIiwic3ViIiwidHJhbnNsYXRlIiwibWF0cml4TmVlZHNVcGRhdGUiLCJwaWxsYXJQb3MiLCJQSUxMQVJfUE9TSVRJT05TIiwiaG9yaXpvbnRhbFBvcyIsInBpbGxhckhvcml6b250YWwiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJQSUxMQVJfUkFESVVTIiwic2V0IiwicGlsbGFyQ2VudGVyIiwiY29sbGlzaW9uIiwic2xpZGVIb3Jpem9udGFsIiwiZGlzdGFuY2VBZnRlclNsaWRlIiwicHVzaERpcmVjdGlvbiIsImNvcnJlY3RlZEhvcml6b250YWwiLCJhcHBseUdyYXZpdHkiLCJpbnB1dFN0cmVuZ3RoIiwiZWZmZWN0aXZlTWF4U3BlZWQiLCJnZXRFZmZlY3RpdmVNYXhTcGVlZCIsInRhcmdldFZlbG9jaXR5IiwibW92ZURpcmVjdGlvbiIsImFjY2VsZXJhdGlvbiIsInNwaGVyZVJhZGl1cyIsImdyb3VuZExldmVsIiwiaXNHcm91bmRlZCIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/PhysicsSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ProjectileSystem.ts":
/*!*****************************************!*\
  !*** ./src/systems/ProjectileSystem.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectileSystem: function() { return /* binding */ ProjectileSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Projectile system for handling projectile movement and collisions\n\n\n\n\n\n\n\n\nclass ProjectileSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    update(entities, deltaTime) {\n        this.projectilesToDestroy.length = 0;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n            if (!transform.enabled || !projectile.enabled) {\n                continue;\n            }\n            // Update projectile\n            projectile.update(deltaTime);\n            // Check if projectile has expired\n            if (projectile.isExpired()) {\n                this.projectilesToDestroy.push(entity.id);\n                continue;\n            }\n            // Move projectile\n            this.moveProjectile(transform, projectile, deltaTime);\n            // Update homing direction if projectile is homing\n            this.updateHomingDirection(entity, projectile, deltaTime);\n            // Arrow orientation is set once at creation - no need to update every frame\n            // this.updateArrowOrientation(entity, projectile);\n            // Check collisions\n            this.checkCollisions(entity, transform, projectile);\n            // Check world boundaries\n            this.checkWorldBounds(entity, transform);\n        }\n        // Destroy expired projectiles\n        for (const entityId of this.projectilesToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    moveProjectile(transform, projectile, deltaTime) {\n        // Use temp vector to avoid allocations\n        this.tempVector.copy(projectile.velocity).multiplyScalar(deltaTime);\n        // Update position\n        transform.translate(this.tempVector.x, this.tempVector.y, this.tempVector.z);\n        transform.matrixNeedsUpdate = true;\n    }\n    updateHomingDirection(projectileEntity, projectile, deltaTime) {\n        // Skip if not homing\n        if (!projectile.targetEntityId || projectile.homingStrength <= 0) {\n            return;\n        }\n        // Get target entity\n        const targetEntity = this.world.getEntity(projectile.targetEntityId);\n        if (!targetEntity) {\n            // Target no longer exists, disable homing\n            projectile.disableHoming();\n            return;\n        }\n        // Get target position\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            projectile.disableHoming();\n            return;\n        }\n        // Get projectile position\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!projectileTransform) {\n            return;\n        }\n        // Calculate direction to target\n        const currentPosition = projectileTransform.position;\n        const targetPosition = targetTransform.position;\n        this.tempVector.copy(targetPosition).sub(currentPosition);\n        const distanceToTarget = this.tempVector.length();\n        // If very close to target, maintain current direction\n        if (distanceToTarget < 0.1) {\n            return;\n        }\n        // Normalize target direction\n        this.tempVector.normalize();\n        // Get current velocity direction\n        const currentDirection = projectile.velocity.clone().normalize();\n        // Calculate desired direction (interpolate between current and target direction)\n        const desiredDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        desiredDirection.lerpVectors(currentDirection, this.tempVector, projectile.homingStrength);\n        // Calculate angle between current and desired direction\n        const angle = currentDirection.angleTo(desiredDirection);\n        // Limit turn rate\n        const maxTurnThisFrame = projectile.maxTurnRate * deltaTime;\n        const turnAngle = Math.min(angle, maxTurnThisFrame);\n        // If we need to turn\n        if (turnAngle > 0.001) {\n            // Calculate rotation axis\n            const rotationAxis = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            rotationAxis.crossVectors(currentDirection, desiredDirection).normalize();\n            // Create rotation quaternion\n            const cosHalfAngle = Math.cos(turnAngle / 2);\n            const sinHalfAngle = Math.sin(turnAngle / 2);\n            // Apply rotation to current direction\n            const newDirection = currentDirection.clone();\n            newDirection.applyAxisAngle(rotationAxis, turnAngle);\n            // Update velocity while maintaining speed\n            projectile.velocity.copy(newDirection).multiplyScalar(projectile.speed);\n        }\n    }\n    checkCollisions(projectileEntity, transform, projectile) {\n        var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n        const projectilePos = transform.position;\n        // Skip barrage and viper sting projectiles in PVP mode - they should only be handled by specialized PVP managers\n        const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        if ((renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isBarrageArrow) || (renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.projectileType) === \"viper_sting\") {\n            // In PVP mode, these projectiles are handled by the specialized PVP managers\n            // Skip ECS collision detection to prevent duplicate damage and self-targeting\n            return;\n        }\n        // Get all entities that could be hit - specifically look for enemies with colliders\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        // Early exit if no targets\n        if (potentialTargets.length === 0) return;\n        for (const target of potentialTargets){\n            // Skip self and owner\n            if (target.id === projectileEntity.id || target.id === projectile.owner) {\n                // Debug logging for owner collision prevention\n                if (target.id === projectile.owner) {\n                // console.log(`🚫 Projectile ${projectileEntity.id} skipping owner ${projectile.owner} (target ${target.id})`);\n                }\n                continue;\n            }\n            // Skip if already hit and not piercing\n            if (!projectile.canHitTarget(target.id)) {\n                continue;\n            }\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            // Skip if target is dead\n            if (targetHealth.isDead) {\n                continue;\n            }\n            // Check if projectile can hit this target (layer-based collision)\n            // In PVP mode, projectiles can hit both ENEMY (remote players) and PLAYER (local player) layers\n            if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER) {\n                continue;\n            }\n            // Additional safety check: prevent projectiles from hitting their owner in PVP mode\n            // This is a backup check in case the owner comparison above fails\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && target.id === projectile.owner) {\n                continue;\n            }\n            const targetPos = targetTransform.getWorldPosition();\n            // Use collider radius for more accurate collision detection\n            const projectileRadius = 0.2; // Increased from 0.1 for more forgiving collision detection\n            const targetRadius = targetCollider.radius;\n            // Use squared distance for performance (avoid sqrt)\n            const distanceSquared = projectilePos.distanceToSquared(targetPos);\n            const collisionRadiusSquared = (projectileRadius + targetRadius) ** 2;\n            if (distanceSquared <= collisionRadiusSquared) {\n                this.handleHit(projectileEntity, target, projectile, targetHealth);\n                // If not piercing, destroy projectile\n                if (!projectile.piercing) {\n                    this.projectilesToDestroy.push(projectileEntity.id);\n                    break;\n                }\n            }\n        }\n    }\n    handleHit(projectileEntity, target, projectile, targetHealth) {\n        // Mark target as hit\n        projectile.addHitTarget(target.id);\n        // Deal damage through combat system if available, otherwise directly\n        if (this.combatSystem) {\n            var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n            // Check projectile type for special damage handling\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            const isCrossentropyBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isCrossentropyBolt;\n            const isEntropicBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.isEntropicBolt;\n            let damageType = \"projectile\";\n            if (isCrossentropyBolt) {\n                damageType = \"crossentropy\";\n            } else if (isEntropicBolt) {\n                damageType = \"entropic\";\n            }\n            this.combatSystem.queueDamage(target, projectile.damage, projectileEntity, damageType);\n        } else {\n            // Fallback to direct damage (pass entity for shield absorption)\n            const currentTime = Date.now() / 1000;\n            const damageDealt = targetHealth.takeDamage(projectile.damage, currentTime, target);\n        }\n        // Handle explosion if explosive\n        if (projectile.explosionRadius > 0) {\n            this.handleExplosion(projectileEntity, projectile);\n        }\n    }\n    handleExplosion(projectileEntity, projectile) {\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const explosionCenter = projectileTransform.position;\n        // Emit explosion event for visual effects\n        this.world.emitEvent(\"explosion\", {\n            position: explosionCenter.clone(),\n            color: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(\"#00ff44\"),\n            size: projectile.explosionRadius,\n            duration: 0.5\n        });\n        // Find all entities within explosion radius\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const target of potentialTargets){\n            if (target.id === projectile.owner) continue; // Don't damage owner\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const distance = explosionCenter.distanceTo(targetTransform.position);\n            if (distance <= projectile.explosionRadius) {\n                // Calculate damage falloff based on distance\n                const damageFalloff = 1 - distance / projectile.explosionRadius;\n                const explosionDamage = Math.floor(projectile.damage * damageFalloff);\n                if (explosionDamage > 0) {\n                    const currentTime = Date.now() / 1000;\n                    targetHealth.takeDamage(explosionDamage, currentTime, target);\n                }\n            }\n        }\n    }\n    checkWorldBounds(entity, transform) {\n        const pos = transform.position;\n        const maxDistance = 40; // Maximum distance from origin\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Check if projectile is too far from origin (using squared distance)\n        if (pos.lengthSq() > maxDistanceSquared) {\n            this.projectilesToDestroy.push(entity.id);\n            return; // Early exit\n        }\n        // Check if projectile is below ground (simple ground check)\n        if (pos.y < -10) {\n            this.projectilesToDestroy.push(entity.id);\n        }\n    }\n    // Utility method to create a ChargedArrow projectile for fully charged bow\n    createChargedArrowProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with charged arrow-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 35; // Faster than regular arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 25; // Higher damage than regular arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for ChargedArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a ChargedArrow for special handling\n        placeholderMesh.userData.isChargedArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        return projectileEntity;\n    }\n    // Utility method to create a CrossentropyBolt projectile for scythe\n    createCrossentropyBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with scythe-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Slower than arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 30; // Higher damage than arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for CrossentropyBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.28, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a CrossentropyBolt for special handling\n        placeholderMesh.userData.isCrossentropyBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n        // console.warn('⚠️ Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create an EntropicBolt projectile for scythe left click\n    createEntropicBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with EntropicBolt-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Faster than CrossentropyBolt\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 20; // EntropicBolt damage\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Shorter lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for EntropicBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 6, 6);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as an EntropicBolt for special handling\n        placeholderMesh.userData.isEntropicBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n        // console.warn('⚠️ Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create a projectile\n    createProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20;\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 5; // Set default damage to 5 as requested\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 2;\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        projectile.setStartPosition(position);\n        // Set max distance if specified (for bow arrows)\n        if ((config === null || config === void 0 ? void 0 : config.maxDistance) !== undefined) {\n            projectile.setMaxDistance(config.maxDistance);\n        }\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for RegularArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a RegularArrow for special handling\n        placeholderMesh.userData.isRegularArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        placeholderMesh.userData.projectileType = config === null || config === void 0 ? void 0 : config.projectileType;\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false); // Projectiles don't need to cast shadows\n        } else {\n        // console.warn('⚠️ Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        // Notify systems that the entity is ready (this will trigger RenderSystem.onEntityAdded)\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Get pool statistics for debugging\n    getPoolStats() {\n        return {\n            vector3: this.vector3Pool.getPoolSize()\n        };\n    }\n    // Dispose of all pools when system is destroyed\n    onDisable() {\n        this.vector3Pool.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ];\n        this.combatSystem = null;\n        this.projectilesToDestroy = [];\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 20; // Run after movement\n        // Initialize vector pool for calculations\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 100);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FO0FBQytCO0FBQzdEO0FBRWlCO0FBQ0U7QUFDUjtBQUNJO0FBQ2dCO0FBR3JCO0FBTXpDLE1BQU1hLHlCQUF5QlIsK0NBQU1BO0lBOEJuQ1MsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQ0Msb0JBQW9CLENBQUNDLE1BQU0sR0FBRztRQUVuQyxLQUFLLE1BQU1DLFVBQVVKLFNBQVU7WUFDN0IsTUFBTUssWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixhQUFhSCxPQUFPRSxZQUFZLENBQUNoQixrRUFBVUE7WUFFakQsSUFBSSxDQUFDZSxVQUFVRyxPQUFPLElBQUksQ0FBQ0QsV0FBV0MsT0FBTyxFQUFFO2dCQUM3QztZQUNGO1lBRUEsb0JBQW9CO1lBQ3BCRCxXQUFXUixNQUFNLENBQUNFO1lBRWxCLGtDQUFrQztZQUNsQyxJQUFJTSxXQUFXRSxTQUFTLElBQUk7Z0JBQzFCLElBQUksQ0FBQ1Asb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtnQkFDeEM7WUFDRjtZQUVBLGtCQUFrQjtZQUNsQixJQUFJLENBQUNDLGNBQWMsQ0FBQ1AsV0FBV0UsWUFBWU47WUFFM0Msa0RBQWtEO1lBQ2xELElBQUksQ0FBQ1kscUJBQXFCLENBQUNULFFBQVFHLFlBQVlOO1lBRS9DLDRFQUE0RTtZQUM1RSxtREFBbUQ7WUFFbkQsbUJBQW1CO1lBQ25CLElBQUksQ0FBQ2EsZUFBZSxDQUFDVixRQUFRQyxXQUFXRTtZQUV4Qyx5QkFBeUI7WUFDekIsSUFBSSxDQUFDUSxnQkFBZ0IsQ0FBQ1gsUUFBUUM7UUFDaEM7UUFFQSw4QkFBOEI7UUFD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SyxjQUFjLElBQUkvSyx5REFBT0E7UUFJL0IsSUFBSSxDQUFDa0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzhJLFFBQVEsR0FBRyxJQUFJLHFCQUFxQjtRQUl6QywwQ0FBMEM7UUFDMUMsSUFBSSxDQUFDUCxXQUFXLEdBQUcsSUFBSTdKLHlEQUFVQSxDQUMvQixJQUFNLElBQUlaLHlEQUFPQSxJQUNqQixDQUFDaUwsU0FBV0EsT0FBT0MsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUM3QjtJQUVKO0FBNG5CRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Qcm9qZWN0aWxlU3lzdGVtLnRzPzAwYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvamVjdGlsZSBzeXN0ZW0gZm9yIGhhbmRsaW5nIHByb2plY3RpbGUgbW92ZW1lbnQgYW5kIGNvbGxpc2lvbnNcbmltcG9ydCB7IFZlY3RvcjMsIENvbG9yLCBTcGhlcmVHZW9tZXRyeSwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIE1lc2ggfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBQcm9qZWN0aWxlIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IEVuZW15IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9FbmVteSc7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IE9iamVjdFBvb2wgfSBmcm9tICdAL3V0aWxzL09iamVjdFBvb2wnO1xuXG5pbXBvcnQgeyBXZWFwb25TdWJjbGFzcyB9IGZyb20gJ0AvY29tcG9uZW50cy9kcmFnb24vd2VhcG9ucyc7XG5pbXBvcnQgeyBDb21iYXRTeXN0ZW0gfSBmcm9tICcuL0NvbWJhdFN5c3RlbSc7XG5pbXBvcnQgQ3Jvc3NlbnRyb3B5Qm9sdCBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvQ3Jvc3NlbnRyb3B5Qm9sdCc7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0aWxlU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFByb2plY3RpbGVdO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBjb21iYXRTeXN0ZW06IENvbWJhdFN5c3RlbSB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHByb2plY3RpbGVzVG9EZXN0cm95OiBudW1iZXJbXSA9IFtdO1xuICBcblxuICBcbiAgLy8gT2JqZWN0IHBvb2xzIGZvciBwZXJmb3JtYW5jZSAoa2VlcGluZyB2ZWN0b3IgcG9vbCBmb3IgY2FsY3VsYXRpb25zKVxuICBwcml2YXRlIHZlY3RvcjNQb29sOiBPYmplY3RQb29sPFZlY3RvcjM+O1xuICBcbiAgLy8gUmV1c2FibGUgb2JqZWN0cyB0byByZWR1Y2UgYWxsb2NhdGlvbnNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDIwOyAvLyBSdW4gYWZ0ZXIgbW92ZW1lbnRcbiAgICBcblxuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdmVjdG9yIHBvb2wgZm9yIGNhbGN1bGF0aW9uc1xuICAgIHRoaXMudmVjdG9yM1Bvb2wgPSBuZXcgT2JqZWN0UG9vbChcbiAgICAgICgpID0+IG5ldyBWZWN0b3IzKCksXG4gICAgICAodmVjdG9yKSA9PiB2ZWN0b3Iuc2V0KDAsIDAsIDApLFxuICAgICAgMTAwXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb21iYXRTeXN0ZW0oY29tYmF0U3lzdGVtOiBDb21iYXRTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLmNvbWJhdFN5c3RlbSA9IGNvbWJhdFN5c3RlbTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kubGVuZ3RoID0gMDtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcHJvamVjdGlsZSA9IGVudGl0eS5nZXRDb21wb25lbnQoUHJvamVjdGlsZSkhO1xuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFwcm9qZWN0aWxlLmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBwcm9qZWN0aWxlXG4gICAgICBwcm9qZWN0aWxlLnVwZGF0ZShkZWx0YVRpbWUpO1xuXG4gICAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGhhcyBleHBpcmVkXG4gICAgICBpZiAocHJvamVjdGlsZS5pc0V4cGlyZWQoKSkge1xuICAgICAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95LnB1c2goZW50aXR5LmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE1vdmUgcHJvamVjdGlsZVxuICAgICAgdGhpcy5tb3ZlUHJvamVjdGlsZSh0cmFuc2Zvcm0sIHByb2plY3RpbGUsIGRlbHRhVGltZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBob21pbmcgZGlyZWN0aW9uIGlmIHByb2plY3RpbGUgaXMgaG9taW5nXG4gICAgICB0aGlzLnVwZGF0ZUhvbWluZ0RpcmVjdGlvbihlbnRpdHksIHByb2plY3RpbGUsIGRlbHRhVGltZSk7XG5cbiAgICAgIC8vIEFycm93IG9yaWVudGF0aW9uIGlzIHNldCBvbmNlIGF0IGNyZWF0aW9uIC0gbm8gbmVlZCB0byB1cGRhdGUgZXZlcnkgZnJhbWVcbiAgICAgIC8vIHRoaXMudXBkYXRlQXJyb3dPcmllbnRhdGlvbihlbnRpdHksIHByb2plY3RpbGUpO1xuXG4gICAgICAvLyBDaGVjayBjb2xsaXNpb25zXG4gICAgICB0aGlzLmNoZWNrQ29sbGlzaW9ucyhlbnRpdHksIHRyYW5zZm9ybSwgcHJvamVjdGlsZSk7XG5cbiAgICAgIC8vIENoZWNrIHdvcmxkIGJvdW5kYXJpZXNcbiAgICAgIHRoaXMuY2hlY2tXb3JsZEJvdW5kcyhlbnRpdHksIHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gRGVzdHJveSBleHBpcmVkIHByb2plY3RpbGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95KSB7XG4gICAgICB0aGlzLndvcmxkLmRlc3Ryb3lFbnRpdHkoZW50aXR5SWQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbW92ZVByb2plY3RpbGUodHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHByb2plY3RpbGU6IFByb2plY3RpbGUsIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVXNlIHRlbXAgdmVjdG9yIHRvIGF2b2lkIGFsbG9jYXRpb25zXG4gICAgdGhpcy50ZW1wVmVjdG9yLmNvcHkocHJvamVjdGlsZS52ZWxvY2l0eSkubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgIHRyYW5zZm9ybS50cmFuc2xhdGUodGhpcy50ZW1wVmVjdG9yLngsIHRoaXMudGVtcFZlY3Rvci55LCB0aGlzLnRlbXBWZWN0b3Iueik7XG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSG9taW5nRGlyZWN0aW9uKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgcHJvamVjdGlsZTogUHJvamVjdGlsZSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBTa2lwIGlmIG5vdCBob21pbmdcbiAgICBpZiAoIXByb2plY3RpbGUudGFyZ2V0RW50aXR5SWQgfHwgcHJvamVjdGlsZS5ob21pbmdTdHJlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHRhcmdldCBlbnRpdHlcbiAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eShwcm9qZWN0aWxlLnRhcmdldEVudGl0eUlkKTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgLy8gVGFyZ2V0IG5vIGxvbmdlciBleGlzdHMsIGRpc2FibGUgaG9taW5nXG4gICAgICBwcm9qZWN0aWxlLmRpc2FibGVIb21pbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGFyZ2V0IHBvc2l0aW9uXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICBwcm9qZWN0aWxlLmRpc2FibGVIb21pbmcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgcHJvamVjdGlsZSBwb3NpdGlvblxuICAgIGNvbnN0IHByb2plY3RpbGVUcmFuc2Zvcm0gPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghcHJvamVjdGlsZVRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gdG8gdGFyZ2V0XG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gcHJvamVjdGlsZVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbjtcblxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFBvc2l0aW9uKS5zdWIoY3VycmVudFBvc2l0aW9uKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvVGFyZ2V0ID0gdGhpcy50ZW1wVmVjdG9yLmxlbmd0aCgpO1xuXG4gICAgLy8gSWYgdmVyeSBjbG9zZSB0byB0YXJnZXQsIG1haW50YWluIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgaWYgKGRpc3RhbmNlVG9UYXJnZXQgPCAwLjEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgdGFyZ2V0IGRpcmVjdGlvblxuICAgIHRoaXMudGVtcFZlY3Rvci5ub3JtYWxpemUoKTtcblxuICAgIC8vIEdldCBjdXJyZW50IHZlbG9jaXR5IGRpcmVjdGlvblxuICAgIGNvbnN0IGN1cnJlbnREaXJlY3Rpb24gPSBwcm9qZWN0aWxlLnZlbG9jaXR5LmNsb25lKCkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVzaXJlZCBkaXJlY3Rpb24gKGludGVycG9sYXRlIGJldHdlZW4gY3VycmVudCBhbmQgdGFyZ2V0IGRpcmVjdGlvbilcbiAgICBjb25zdCBkZXNpcmVkRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBkZXNpcmVkRGlyZWN0aW9uLmxlcnBWZWN0b3JzKGN1cnJlbnREaXJlY3Rpb24sIHRoaXMudGVtcFZlY3RvciwgcHJvamVjdGlsZS5ob21pbmdTdHJlbmd0aCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgYW5nbGUgYmV0d2VlbiBjdXJyZW50IGFuZCBkZXNpcmVkIGRpcmVjdGlvblxuICAgIGNvbnN0IGFuZ2xlID0gY3VycmVudERpcmVjdGlvbi5hbmdsZVRvKGRlc2lyZWREaXJlY3Rpb24pO1xuXG4gICAgLy8gTGltaXQgdHVybiByYXRlXG4gICAgY29uc3QgbWF4VHVyblRoaXNGcmFtZSA9IHByb2plY3RpbGUubWF4VHVyblJhdGUgKiBkZWx0YVRpbWU7XG4gICAgY29uc3QgdHVybkFuZ2xlID0gTWF0aC5taW4oYW5nbGUsIG1heFR1cm5UaGlzRnJhbWUpO1xuXG4gICAgLy8gSWYgd2UgbmVlZCB0byB0dXJuXG4gICAgaWYgKHR1cm5BbmdsZSA+IDAuMDAxKSB7IC8vIFNtYWxsIHRocmVzaG9sZCB0byBhdm9pZCBqaXR0ZXJcbiAgICAgIC8vIENhbGN1bGF0ZSByb3RhdGlvbiBheGlzXG4gICAgICBjb25zdCByb3RhdGlvbkF4aXMgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgcm90YXRpb25BeGlzLmNyb3NzVmVjdG9ycyhjdXJyZW50RGlyZWN0aW9uLCBkZXNpcmVkRGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcblxuICAgICAgLy8gQ3JlYXRlIHJvdGF0aW9uIHF1YXRlcm5pb25cbiAgICAgIGNvbnN0IGNvc0hhbGZBbmdsZSA9IE1hdGguY29zKHR1cm5BbmdsZSAvIDIpO1xuICAgICAgY29uc3Qgc2luSGFsZkFuZ2xlID0gTWF0aC5zaW4odHVybkFuZ2xlIC8gMik7XG5cbiAgICAgIC8vIEFwcGx5IHJvdGF0aW9uIHRvIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgICBjb25zdCBuZXdEaXJlY3Rpb24gPSBjdXJyZW50RGlyZWN0aW9uLmNsb25lKCk7XG4gICAgICBuZXdEaXJlY3Rpb24uYXBwbHlBeGlzQW5nbGUocm90YXRpb25BeGlzLCB0dXJuQW5nbGUpO1xuXG4gICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgd2hpbGUgbWFpbnRhaW5pbmcgc3BlZWRcbiAgICAgIHByb2plY3RpbGUudmVsb2NpdHkuY29weShuZXdEaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHByb2plY3RpbGUuc3BlZWQpO1xuICAgIH1cbiAgfVxuXG5cblxuICBwcml2YXRlIGNoZWNrQ29sbGlzaW9ucyhwcm9qZWN0aWxlRW50aXR5OiBFbnRpdHksIHRyYW5zZm9ybTogVHJhbnNmb3JtLCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKTogdm9pZCB7XG4gICAgY29uc3QgcHJvamVjdGlsZVBvcyA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcblxuICAgIC8vIFNraXAgYmFycmFnZSBhbmQgdmlwZXIgc3RpbmcgcHJvamVjdGlsZXMgaW4gUFZQIG1vZGUgLSB0aGV5IHNob3VsZCBvbmx5IGJlIGhhbmRsZWQgYnkgc3BlY2lhbGl6ZWQgUFZQIG1hbmFnZXJzXG4gICAgY29uc3QgcmVuZGVyZXIgPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChSZW5kZXJlcik7XG4gICAgaWYgKHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNCYXJyYWdlQXJyb3cgfHwgcmVuZGVyZXI/Lm1lc2g/LnVzZXJEYXRhPy5wcm9qZWN0aWxlVHlwZSA9PT0gJ3ZpcGVyX3N0aW5nJykge1xuICAgICAgLy8gSW4gUFZQIG1vZGUsIHRoZXNlIHByb2plY3RpbGVzIGFyZSBoYW5kbGVkIGJ5IHRoZSBzcGVjaWFsaXplZCBQVlAgbWFuYWdlcnNcbiAgICAgIC8vIFNraXAgRUNTIGNvbGxpc2lvbiBkZXRlY3Rpb24gdG8gcHJldmVudCBkdXBsaWNhdGUgZGFtYWdlIGFuZCBzZWxmLXRhcmdldGluZ1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgdGhhdCBjb3VsZCBiZSBoaXQgLSBzcGVjaWZpY2FsbHkgbG9vayBmb3IgZW5lbWllcyB3aXRoIGNvbGxpZGVyc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuXG4gICAgLy8gRWFybHkgZXhpdCBpZiBubyB0YXJnZXRzXG4gICAgaWYgKHBvdGVudGlhbFRhcmdldHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICAvLyBTa2lwIHNlbGYgYW5kIG93bmVyXG4gICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlRW50aXR5LmlkIHx8IHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikge1xuICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBvd25lciBjb2xsaXNpb24gcHJldmVudGlvblxuICAgICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYPCfmqsgUHJvamVjdGlsZSAke3Byb2plY3RpbGVFbnRpdHkuaWR9IHNraXBwaW5nIG93bmVyICR7cHJvamVjdGlsZS5vd25lcn0gKHRhcmdldCAke3RhcmdldC5pZH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBoaXQgYW5kIG5vdCBwaWVyY2luZ1xuICAgICAgaWYgKCFwcm9qZWN0aWxlLmNhbkhpdFRhcmdldCh0YXJnZXQuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IHRhcmdldENvbGxpZGVyID0gdGFyZ2V0LmdldENvbXBvbmVudChDb2xsaWRlcikhO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGlmIHRhcmdldCBpcyBkZWFkXG4gICAgICBpZiAodGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBjYW4gaGl0IHRoaXMgdGFyZ2V0IChsYXllci1iYXNlZCBjb2xsaXNpb24pXG4gICAgICAvLyBJbiBQVlAgbW9kZSwgcHJvamVjdGlsZXMgY2FuIGhpdCBib3RoIEVORU1ZIChyZW1vdGUgcGxheWVycykgYW5kIFBMQVlFUiAobG9jYWwgcGxheWVyKSBsYXllcnNcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkgJiYgdGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLlBMQVlFUikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkaXRpb25hbCBzYWZldHkgY2hlY2s6IHByZXZlbnQgcHJvamVjdGlsZXMgZnJvbSBoaXR0aW5nIHRoZWlyIG93bmVyIGluIFBWUCBtb2RlXG4gICAgICAvLyBUaGlzIGlzIGEgYmFja3VwIGNoZWNrIGluIGNhc2UgdGhlIG93bmVyIGNvbXBhcmlzb24gYWJvdmUgZmFpbHNcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSICYmIHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5qrIEV4dHJhIHNhZmV0eTogUHJvamVjdGlsZSAke3Byb2plY3RpbGVFbnRpdHkuaWR9IHByZXZlbnRlZCBmcm9tIGhpdHRpbmcgb3duZXIgJHtwcm9qZWN0aWxlLm93bmVyfSAoUFZQIG1vZGUpYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRQb3MgPSB0YXJnZXRUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuXG4gICAgICAvLyBVc2UgY29sbGlkZXIgcmFkaXVzIGZvciBtb3JlIGFjY3VyYXRlIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgIGNvbnN0IHByb2plY3RpbGVSYWRpdXMgPSAwLjI7IC8vIEluY3JlYXNlZCBmcm9tIDAuMSBmb3IgbW9yZSBmb3JnaXZpbmcgY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgY29uc3QgdGFyZ2V0UmFkaXVzID0gdGFyZ2V0Q29sbGlkZXIucmFkaXVzO1xuXG4gICAgICAvLyBVc2Ugc3F1YXJlZCBkaXN0YW5jZSBmb3IgcGVyZm9ybWFuY2UgKGF2b2lkIHNxcnQpXG4gICAgICBjb25zdCBkaXN0YW5jZVNxdWFyZWQgPSBwcm9qZWN0aWxlUG9zLmRpc3RhbmNlVG9TcXVhcmVkKHRhcmdldFBvcyk7XG4gICAgICBjb25zdCBjb2xsaXNpb25SYWRpdXNTcXVhcmVkID0gKHByb2plY3RpbGVSYWRpdXMgKyB0YXJnZXRSYWRpdXMpICoqIDI7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZVNxdWFyZWQgPD0gY29sbGlzaW9uUmFkaXVzU3F1YXJlZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUhpdChwcm9qZWN0aWxlRW50aXR5LCB0YXJnZXQsIHByb2plY3RpbGUsIHRhcmdldEhlYWx0aCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBub3QgcGllcmNpbmcsIGRlc3Ryb3kgcHJvamVjdGlsZVxuICAgICAgICBpZiAoIXByb2plY3RpbGUucGllcmNpbmcpIHtcbiAgICAgICAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95LnB1c2gocHJvamVjdGlsZUVudGl0eS5pZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUhpdChcbiAgICBwcm9qZWN0aWxlRW50aXR5OiBFbnRpdHksIFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlLCBcbiAgICB0YXJnZXRIZWFsdGg6IEhlYWx0aFxuICApOiB2b2lkIHtcbiAgICAvLyBNYXJrIHRhcmdldCBhcyBoaXRcbiAgICBwcm9qZWN0aWxlLmFkZEhpdFRhcmdldCh0YXJnZXQuaWQpO1xuXG4gICAgLy8gRGVhbCBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGRpcmVjdGx5XG4gICAgaWYgKHRoaXMuY29tYmF0U3lzdGVtKSB7XG4gICAgICAvLyBDaGVjayBwcm9qZWN0aWxlIHR5cGUgZm9yIHNwZWNpYWwgZGFtYWdlIGhhbmRsaW5nXG4gICAgICBjb25zdCByZW5kZXJlciA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICAgIGNvbnN0IGlzQ3Jvc3NlbnRyb3B5Qm9sdCA9IHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNDcm9zc2VudHJvcHlCb2x0O1xuICAgICAgY29uc3QgaXNFbnRyb3BpY0JvbHQgPSByZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LmlzRW50cm9waWNCb2x0O1xuICAgICAgXG4gICAgICBsZXQgZGFtYWdlVHlwZSA9ICdwcm9qZWN0aWxlJztcbiAgICAgIGlmIChpc0Nyb3NzZW50cm9weUJvbHQpIHtcbiAgICAgICAgZGFtYWdlVHlwZSA9ICdjcm9zc2VudHJvcHknO1xuICAgICAgfSBlbHNlIGlmIChpc0VudHJvcGljQm9sdCkge1xuICAgICAgICBkYW1hZ2VUeXBlID0gJ2VudHJvcGljJztcbiAgICAgIH1cbiAgICAgIFxuXG4gICAgICBcbiAgICAgIHRoaXMuY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldCwgcHJvamVjdGlsZS5kYW1hZ2UsIHByb2plY3RpbGVFbnRpdHksIGRhbWFnZVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgZGFtYWdlIChwYXNzIGVudGl0eSBmb3Igc2hpZWxkIGFic29ycHRpb24pXG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgY29uc3QgZGFtYWdlRGVhbHQgPSB0YXJnZXRIZWFsdGgudGFrZURhbWFnZShwcm9qZWN0aWxlLmRhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG4gICAgICBcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZXhwbG9zaW9uIGlmIGV4cGxvc2l2ZVxuICAgIGlmIChwcm9qZWN0aWxlLmV4cGxvc2lvblJhZGl1cyA+IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlRXhwbG9zaW9uKHByb2plY3RpbGVFbnRpdHksIHByb2plY3RpbGUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRXhwbG9zaW9uKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgcHJvamVjdGlsZTogUHJvamVjdGlsZSk6IHZvaWQge1xuICAgIGNvbnN0IHByb2plY3RpbGVUcmFuc2Zvcm0gPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICBjb25zdCBleHBsb3Npb25DZW50ZXIgPSBwcm9qZWN0aWxlVHJhbnNmb3JtLnBvc2l0aW9uO1xuXG4gICAgLy8gRW1pdCBleHBsb3Npb24gZXZlbnQgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgdGhpcy53b3JsZC5lbWl0RXZlbnQoJ2V4cGxvc2lvbicsIHtcbiAgICAgIHBvc2l0aW9uOiBleHBsb3Npb25DZW50ZXIuY2xvbmUoKSxcbiAgICAgIGNvbG9yOiBuZXcgQ29sb3IoJyMwMGZmNDQnKSxcbiAgICAgIHNpemU6IHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzLFxuICAgICAgZHVyYXRpb246IDAuNVxuICAgIH0pO1xuXG4gICAgLy8gRmluZCBhbGwgZW50aXRpZXMgd2l0aGluIGV4cGxvc2lvbiByYWRpdXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aF0pO1xuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcG90ZW50aWFsVGFyZ2V0cykge1xuICAgICAgaWYgKHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikgY29udGludWU7IC8vIERvbid0IGRhbWFnZSBvd25lclxuXG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gZXhwbG9zaW9uQ2VudGVyLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGRpc3RhbmNlIDw9IHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBkYW1hZ2UgZmFsbG9mZiBiYXNlZCBvbiBkaXN0YW5jZVxuICAgICAgICBjb25zdCBkYW1hZ2VGYWxsb2ZmID0gMSAtIChkaXN0YW5jZSAvIHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzKTtcbiAgICAgICAgY29uc3QgZXhwbG9zaW9uRGFtYWdlID0gTWF0aC5mbG9vcihwcm9qZWN0aWxlLmRhbWFnZSAqIGRhbWFnZUZhbGxvZmYpO1xuXG4gICAgICAgIGlmIChleHBsb3Npb25EYW1hZ2UgPiAwKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICB0YXJnZXRIZWFsdGgudGFrZURhbWFnZShleHBsb3Npb25EYW1hZ2UsIGN1cnJlbnRUaW1lLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja1dvcmxkQm91bmRzKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IHBvcyA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCBtYXhEaXN0YW5jZSA9IDQwOyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luXG4gICAgY29uc3QgbWF4RGlzdGFuY2VTcXVhcmVkID0gbWF4RGlzdGFuY2UgKiBtYXhEaXN0YW5jZTtcblxuICAgIC8vIENoZWNrIGlmIHByb2plY3RpbGUgaXMgdG9vIGZhciBmcm9tIG9yaWdpbiAodXNpbmcgc3F1YXJlZCBkaXN0YW5jZSlcbiAgICBpZiAocG9zLmxlbmd0aFNxKCkgPiBtYXhEaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgICAgcmV0dXJuOyAvLyBFYXJseSBleGl0XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBpcyBiZWxvdyBncm91bmQgKHNpbXBsZSBncm91bmQgY2hlY2spXG4gICAgaWYgKHBvcy55IDwgLTEwKSB7XG4gICAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95LnB1c2goZW50aXR5LmlkKTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYSBDaGFyZ2VkQXJyb3cgcHJvamVjdGlsZSBmb3IgZnVsbHkgY2hhcmdlZCBib3dcbiAgcHVibGljIGNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggY2hhcmdlZCBhcnJvdy1zcGVjaWZpYyBzZXR0aW5nc1xuICAgIGNvbnN0IHByb2plY3RpbGUgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgcHJvamVjdGlsZS5zcGVlZCA9IGNvbmZpZz8uc3BlZWQgfHwgMzU7IC8vIEZhc3RlciB0aGFuIHJlZ3VsYXIgYXJyb3dzXG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCAyNTsgLy8gSGlnaGVyIGRhbWFnZSB0aGFuIHJlZ3VsYXIgYXJyb3dzXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgNTsgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgQ2hhcmdlZEFycm93XG4gICAgY29uc3QgcmVuZGVyZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBwbGFjZWhvbGRlciBtZXNoIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgUmVhY3QgY29tcG9uZW50XG4gICAgY29uc3QgcGxhY2Vob2xkZXJHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgwLjE1LCA4LCA4KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZTogJyNmZmFhMDAnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDMsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAuMSAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGEgQ2hhcmdlZEFycm93IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzQ2hhcmdlZEFycm93ID0gdHJ1ZTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnN1YmNsYXNzID0gY29uZmlnPy5zdWJjbGFzcztcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEubGV2ZWwgPSBjb25maWc/LmxldmVsO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5vcGFjaXR5ID0gY29uZmlnPy5vcGFjaXR5IHx8IDEuMDtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIC8vIEFkZCBDb2xsaWRlciBjb21wb25lbnRcbiAgICBjb25zdCBjb2xsaWRlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChDb2xsaWRlcik7XG4gICAgY29sbGlkZXIucmFkaXVzID0gMC4xNTtcbiAgICBjb2xsaWRlci5sYXllciA9IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQoY29sbGlkZXIpO1xuXG4gICAgcmV0dXJuIHByb2plY3RpbGVFbnRpdHk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYSBDcm9zc2VudHJvcHlCb2x0IHByb2plY3RpbGUgZm9yIHNjeXRoZVxuICBwdWJsaWMgY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggc2N5dGhlLXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDsgLy8gU2xvd2VyIHRoYW4gYXJyb3dzXG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCAzMDsgLy8gSGlnaGVyIGRhbWFnZSB0aGFuIGFycm93c1xuICAgIHByb2plY3RpbGUubWF4TGlmZXRpbWUgPSBjb25maWc/LmxpZmV0aW1lIHx8IDEuNzU7IC8vIExvbmdlciBsaWZldGltZVxuICAgIHByb2plY3RpbGUub3duZXIgPSBvd25lcklkO1xuICAgIHByb2plY3RpbGUuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgXG4gICAgaWYgKGNvbmZpZz8ucGllcmNpbmcpIHByb2plY3RpbGUuc2V0UGllcmNpbmcodHJ1ZSk7XG4gICAgaWYgKGNvbmZpZz8uZXhwbG9zaXZlICYmIGNvbmZpZz8uZXhwbG9zaW9uUmFkaXVzKSB7XG4gICAgICBwcm9qZWN0aWxlLnNldEV4cGxvc2l2ZShjb25maWcuZXhwbG9zaW9uUmFkaXVzKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocHJvamVjdGlsZSk7XG5cbiAgICAvLyBBZGQgUmVuZGVyZXIgY29tcG9uZW50IC0gd2UnbGwgdXNlIGEgc3BlY2lhbCBtYXJrZXIgZm9yIENyb3NzZW50cm9weUJvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMjgsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMCxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMCAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGEgQ3Jvc3NlbnRyb3B5Qm9sdCBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5pc0Nyb3NzZW50cm9weUJvbHQgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlRW50aXR5ID0gcHJvamVjdGlsZUVudGl0eTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIFxuICAgIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgdGhlIGVudGl0eSBpcyByZWFkeVxuICAgIHRoaXMud29ybGQubm90aWZ5RW50aXR5QWRkZWQocHJvamVjdGlsZUVudGl0eSk7XG4gICAgXG4gICAgcmV0dXJuIHByb2plY3RpbGVFbnRpdHk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjcmVhdGUgYW4gRW50cm9waWNCb2x0IHByb2plY3RpbGUgZm9yIHNjeXRoZSBsZWZ0IGNsaWNrXG4gIHB1YmxpYyBjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKFxuICAgIHdvcmxkOiBXb3JsZCxcbiAgICBwb3NpdGlvbjogVmVjdG9yMyxcbiAgICBkaXJlY3Rpb246IFZlY3RvcjMsXG4gICAgb3duZXJJZDogbnVtYmVyLFxuICAgIGNvbmZpZz86IHtcbiAgICAgIHNwZWVkPzogbnVtYmVyO1xuICAgICAgZGFtYWdlPzogbnVtYmVyO1xuICAgICAgbGlmZXRpbWU/OiBudW1iZXI7XG4gICAgICBwaWVyY2luZz86IGJvb2xlYW47XG4gICAgICBleHBsb3NpdmU/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaW9uUmFkaXVzPzogbnVtYmVyO1xuICAgICAgc3ViY2xhc3M/OiBXZWFwb25TdWJjbGFzcztcbiAgICAgIGxldmVsPzogbnVtYmVyO1xuICAgICAgb3BhY2l0eT86IG51bWJlcjtcbiAgICB9XG4gICk6IEVudGl0eSB7XG4gICAgY29uc3QgcHJvamVjdGlsZUVudGl0eSA9IHdvcmxkLmNyZWF0ZUVudGl0eSgpO1xuXG4gICAgLy8gQWRkIFRyYW5zZm9ybSBjb21wb25lbnRcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQodHJhbnNmb3JtKTtcblxuICAgIC8vIEFkZCBQcm9qZWN0aWxlIGNvbXBvbmVudCB3aXRoIEVudHJvcGljQm9sdC1zcGVjaWZpYyBzZXR0aW5nc1xuICAgIGNvbnN0IHByb2plY3RpbGUgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgcHJvamVjdGlsZS5zcGVlZCA9IGNvbmZpZz8uc3BlZWQgfHwgMjA7IC8vIEZhc3RlciB0aGFuIENyb3NzZW50cm9weUJvbHRcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDIwOyAvLyBFbnRyb3BpY0JvbHQgZGFtYWdlXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwxLjc1OyAvLyBTaG9ydGVyIGxpZmV0aW1lXG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgRW50cm9waWNCb2x0XG4gICAgY29uc3QgcmVuZGVyZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBwbGFjZWhvbGRlciBtZXNoIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgUmVhY3QgY29tcG9uZW50XG4gICAgY29uc3QgcGxhY2Vob2xkZXJHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgwLjE1LCA2LCA2KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZTogJyMwMGZmNDQnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDAsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAgLy8gVmVyeSBsb3cgb3BhY2l0eSBzaW5jZSBSZWFjdCBjb21wb25lbnQgd2lsbCBoYW5kbGUgdmlzdWFsc1xuICAgIH0pO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWVzaCA9IG5ldyBNZXNoKHBsYWNlaG9sZGVyR2VvbWV0cnksIHBsYWNlaG9sZGVyTWF0ZXJpYWwpO1xuICAgIFxuICAgIC8vIE1hcmsgdGhpcyBhcyBhbiBFbnRyb3BpY0JvbHQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNFbnRyb3BpY0JvbHQgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlRW50aXR5ID0gcHJvamVjdGlsZUVudGl0eTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIHByb2plY3RpbGVcbiAgcHVibGljIGNyZWF0ZVByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgICAgbWF4RGlzdGFuY2U/OiBudW1iZXI7XG4gICAgICBwcm9qZWN0aWxlVHlwZT86IHN0cmluZzsgLy8gQWRkIHByb2plY3RpbGUgdHlwZSBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50XG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDtcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDU7IC8vIFNldCBkZWZhdWx0IGRhbWFnZSB0byA1IGFzIHJlcXVlc3RlZFxuICAgIHByb2plY3RpbGUubWF4TGlmZXRpbWUgPSBjb25maWc/LmxpZmV0aW1lIHx8IDI7XG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBwcm9qZWN0aWxlLnNldFN0YXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIFxuICAgIC8vIFNldCBtYXggZGlzdGFuY2UgaWYgc3BlY2lmaWVkIChmb3IgYm93IGFycm93cylcbiAgICBpZiAoY29uZmlnPy5tYXhEaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9qZWN0aWxlLnNldE1heERpc3RhbmNlKGNvbmZpZy5tYXhEaXN0YW5jZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBSZWd1bGFyQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBSZWd1bGFyQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNSZWd1bGFyQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlVHlwZSA9IGNvbmZpZz8ucHJvamVjdGlsZVR5cGU7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpOyAvLyBQcm9qZWN0aWxlcyBkb24ndCBuZWVkIHRvIGNhc3Qgc2hhZG93c1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIC8vIEFkZCBDb2xsaWRlciBjb21wb25lbnRcbiAgICBjb25zdCBjb2xsaWRlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChDb2xsaWRlcik7XG4gICAgY29sbGlkZXIucmFkaXVzID0gMC4xNTtcbiAgICBjb2xsaWRlci5sYXllciA9IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQoY29sbGlkZXIpO1xuICAgIFxuICAgIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgdGhlIGVudGl0eSBpcyByZWFkeSAodGhpcyB3aWxsIHRyaWdnZXIgUmVuZGVyU3lzdGVtLm9uRW50aXR5QWRkZWQpXG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG5cblxuICAvLyBHZXQgcG9vbCBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldFBvb2xTdGF0cygpOiB7IFxuICAgIHZlY3RvcjM6IG51bWJlcjtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlY3RvcjM6IHRoaXMudmVjdG9yM1Bvb2wuZ2V0UG9vbFNpemUoKVxuICAgIH07XG4gIH1cblxuICAvLyBEaXNwb3NlIG9mIGFsbCBwb29scyB3aGVuIHN5c3RlbSBpcyBkZXN0cm95ZWRcbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLnZlY3RvcjNQb29sLmNsZWFyKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJTcGhlcmVHZW9tZXRyeSIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiTWVzaCIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIlByb2plY3RpbGUiLCJIZWFsdGgiLCJSZW5kZXJlciIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJPYmplY3RQb29sIiwiUHJvamVjdGlsZVN5c3RlbSIsInNldENvbWJhdFN5c3RlbSIsImNvbWJhdFN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwicHJvamVjdGlsZXNUb0Rlc3Ryb3kiLCJsZW5ndGgiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJwcm9qZWN0aWxlIiwiZW5hYmxlZCIsImlzRXhwaXJlZCIsInB1c2giLCJpZCIsIm1vdmVQcm9qZWN0aWxlIiwidXBkYXRlSG9taW5nRGlyZWN0aW9uIiwiY2hlY2tDb2xsaXNpb25zIiwiY2hlY2tXb3JsZEJvdW5kcyIsImVudGl0eUlkIiwid29ybGQiLCJkZXN0cm95RW50aXR5IiwidGVtcFZlY3RvciIsImNvcHkiLCJ2ZWxvY2l0eSIsIm11bHRpcGx5U2NhbGFyIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwibWF0cml4TmVlZHNVcGRhdGUiLCJwcm9qZWN0aWxlRW50aXR5IiwidGFyZ2V0RW50aXR5SWQiLCJob21pbmdTdHJlbmd0aCIsInRhcmdldEVudGl0eSIsImdldEVudGl0eSIsImRpc2FibGVIb21pbmciLCJ0YXJnZXRUcmFuc2Zvcm0iLCJwcm9qZWN0aWxlVHJhbnNmb3JtIiwiY3VycmVudFBvc2l0aW9uIiwicG9zaXRpb24iLCJ0YXJnZXRQb3NpdGlvbiIsInN1YiIsImRpc3RhbmNlVG9UYXJnZXQiLCJub3JtYWxpemUiLCJjdXJyZW50RGlyZWN0aW9uIiwiY2xvbmUiLCJkZXNpcmVkRGlyZWN0aW9uIiwibGVycFZlY3RvcnMiLCJhbmdsZSIsImFuZ2xlVG8iLCJtYXhUdXJuVGhpc0ZyYW1lIiwibWF4VHVyblJhdGUiLCJ0dXJuQW5nbGUiLCJNYXRoIiwibWluIiwicm90YXRpb25BeGlzIiwiY3Jvc3NWZWN0b3JzIiwiY29zSGFsZkFuZ2xlIiwiY29zIiwic2luSGFsZkFuZ2xlIiwic2luIiwibmV3RGlyZWN0aW9uIiwiYXBwbHlBeGlzQW5nbGUiLCJzcGVlZCIsInJlbmRlcmVyIiwicHJvamVjdGlsZVBvcyIsIm1lc2giLCJ1c2VyRGF0YSIsImlzQmFycmFnZUFycm93IiwicHJvamVjdGlsZVR5cGUiLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsInRhcmdldCIsIm93bmVyIiwiY2FuSGl0VGFyZ2V0IiwidGFyZ2V0SGVhbHRoIiwidGFyZ2V0Q29sbGlkZXIiLCJpc0RlYWQiLCJsYXllciIsIkVORU1ZIiwiUExBWUVSIiwidGFyZ2V0UG9zIiwiZ2V0V29ybGRQb3NpdGlvbiIsInByb2plY3RpbGVSYWRpdXMiLCJ0YXJnZXRSYWRpdXMiLCJyYWRpdXMiLCJkaXN0YW5jZVNxdWFyZWQiLCJkaXN0YW5jZVRvU3F1YXJlZCIsImNvbGxpc2lvblJhZGl1c1NxdWFyZWQiLCJoYW5kbGVIaXQiLCJwaWVyY2luZyIsImFkZEhpdFRhcmdldCIsImlzQ3Jvc3NlbnRyb3B5Qm9sdCIsImlzRW50cm9waWNCb2x0IiwiZGFtYWdlVHlwZSIsInF1ZXVlRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwiZGFtYWdlRGVhbHQiLCJ0YWtlRGFtYWdlIiwiZXhwbG9zaW9uUmFkaXVzIiwiaGFuZGxlRXhwbG9zaW9uIiwiZXhwbG9zaW9uQ2VudGVyIiwiZW1pdEV2ZW50IiwiY29sb3IiLCJzaXplIiwiZHVyYXRpb24iLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJkYW1hZ2VGYWxsb2ZmIiwiZXhwbG9zaW9uRGFtYWdlIiwiZmxvb3IiLCJwb3MiLCJtYXhEaXN0YW5jZSIsIm1heERpc3RhbmNlU3F1YXJlZCIsImxlbmd0aFNxIiwiY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZSIsImRpcmVjdGlvbiIsIm93bmVySWQiLCJjb25maWciLCJjcmVhdGVFbnRpdHkiLCJjcmVhdGVDb21wb25lbnQiLCJhZGRDb21wb25lbnQiLCJtYXhMaWZldGltZSIsImxpZmV0aW1lIiwic2V0RGlyZWN0aW9uIiwic2V0UGllcmNpbmciLCJleHBsb3NpdmUiLCJzZXRFeHBsb3NpdmUiLCJwbGFjZWhvbGRlckdlb21ldHJ5IiwicGxhY2Vob2xkZXJNYXRlcmlhbCIsImVtaXNzaXZlIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJwbGFjZWhvbGRlck1lc2giLCJpc0NoYXJnZWRBcnJvdyIsInN1YmNsYXNzIiwibGV2ZWwiLCJjb2xsaWRlciIsIlBST0pFQ1RJTEUiLCJjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZSIsInNldENhc3RTaGFkb3ciLCJub3RpZnlFbnRpdHlBZGRlZCIsImNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJjcmVhdGVQcm9qZWN0aWxlIiwic2V0U3RhcnRQb3NpdGlvbiIsInVuZGVmaW5lZCIsInNldE1heERpc3RhbmNlIiwiaXNSZWd1bGFyQXJyb3ciLCJnZXRQb29sU3RhdHMiLCJ2ZWN0b3IzIiwidmVjdG9yM1Bvb2wiLCJnZXRQb29sU2l6ZSIsIm9uRGlzYWJsZSIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5IiwidmVjdG9yIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ProjectileSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/RenderSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/RenderSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n// Render system for 3D rendering with Three.js\n\n\n\n\nclass RenderSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update animations and renderer components\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            // Update animations with safety check\n            if (typeof rendererComponent.updateAnimations === \"function\") {\n                rendererComponent.updateAnimations(deltaTime);\n            } else {\n            // console.warn('⚠️ Renderer component missing updateAnimations method:', rendererComponent);\n            }\n            // Update mesh if needed\n            this.updateEntityMesh(entity, transform, rendererComponent);\n        }\n    }\n    render(entities, deltaTime) {\n        // Update all entity transforms and meshes\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            this.updateEntityTransform(entity, transform, rendererComponent);\n        }\n        // Render the scene\n        this.renderer.render(this.scene, this.camera);\n    }\n    updateEntityMesh(entity, transform, rendererComponent) {\n        const existingMesh = this.meshMap.get(entity.id);\n        // Handle pre-built mesh/group (like arrows)\n        if (!existingMesh && rendererComponent.mesh) {\n            this.meshMap.set(entity.id, rendererComponent.mesh);\n            this.scene.add(rendererComponent.mesh);\n            return;\n        }\n        // Create mesh if it doesn't exist or needs update (traditional geometry + material)\n        if (!existingMesh && rendererComponent.geometry && rendererComponent.material) {\n            const mesh = rendererComponent.createMesh();\n            if (mesh) {\n                this.meshMap.set(entity.id, mesh);\n                this.scene.add(mesh);\n            }\n        } else if (existingMesh) {\n            // Update existing mesh with safety check\n            if (typeof rendererComponent.updateMesh === \"function\") {\n                rendererComponent.updateMesh();\n            } else {\n            // console.warn('⚠️ Renderer component missing updateMesh method:', rendererComponent);\n            }\n        }\n    }\n    updateEntityTransform(entity, transform, rendererComponent) {\n        const meshOrGroup = this.meshMap.get(entity.id);\n        if (!meshOrGroup) return;\n        // Update transform matrix\n        transform.updateMatrix();\n        // Apply transform to mesh or group\n        meshOrGroup.position.copy(transform.position);\n        meshOrGroup.quaternion.copy(transform.quaternion);\n        meshOrGroup.scale.copy(transform.scale);\n        // Handle instanced rendering (only for meshes)\n        if (rendererComponent.isInstanced && meshOrGroup instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            rendererComponent.updateInstanceMatrix(transform.matrix);\n        }\n    }\n    onEntityAdded(entity) {\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent) {\n            // console.log(`🎨 RenderSystem: Adding entity ${entity.id} to scene`);\n            // Handle pre-built mesh/group (like arrows and elite enemies)\n            if (rendererComponent.mesh) {\n                // console.log(`🏹 Adding pre-built mesh/group for entity ${entity.id}`);\n                this.meshMap.set(entity.id, rendererComponent.mesh);\n                this.scene.add(rendererComponent.mesh);\n                return;\n            }\n            // Handle traditional geometry + material\n            if (rendererComponent.geometry && rendererComponent.material) {\n                // console.log(`🔷 Creating mesh from geometry + material for entity ${entity.id}`);\n                const mesh = rendererComponent.createMesh();\n                if (mesh) {\n                    this.meshMap.set(entity.id, mesh);\n                    this.scene.add(mesh);\n                }\n            } else {\n            // console.log(`⚪ Entity ${entity.id} has Renderer but no geometry/material - skipping mesh creation`);\n            }\n        } else {\n        // console.log(`⚠️ RenderSystem: Entity ${entity.id} has no Renderer component`);\n        }\n    }\n    onEntityRemoved(entity) {\n        const mesh = this.meshMap.get(entity.id);\n        if (mesh) {\n            this.scene.remove(mesh);\n            this.meshMap.delete(entity.id);\n        }\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent && typeof rendererComponent.dispose === \"function\") {\n            rendererComponent.dispose();\n        }\n    }\n    getMesh(entityId) {\n        return this.meshMap.get(entityId);\n    }\n    getScene() {\n        return this.scene;\n    }\n    getCamera() {\n        return this.camera;\n    }\n    getRenderer() {\n        return this.renderer;\n    }\n    // Utility methods for managing the scene\n    addLight(light) {\n        this.scene.add(light);\n    }\n    removeLight(light) {\n        this.scene.remove(light);\n    }\n    addObject(object) {\n        this.scene.add(object);\n    }\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    setFog(fog) {\n        this.scene.fog = fog;\n    }\n    setBackground(background) {\n        this.scene.background = background;\n    }\n    enableShadows() {\n        let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.renderer.shadowMap.enabled = enable;\n        this.renderer.shadowMap.type = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;\n    }\n    setPixelRatio(ratio) {\n        this.renderer.setPixelRatio(ratio || window.devicePixelRatio);\n    }\n    setSize(width, height) {\n        this.renderer.setSize(width, height);\n        if (this.camera instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    dispose() {\n        // Clean up all meshes\n        for (const [entityId, mesh] of Array.from(this.meshMap.entries())){\n            this.scene.remove(mesh);\n        }\n        this.meshMap.clear();\n        // Dispose renderer\n        this.renderer.dispose();\n    }\n    constructor(scene, camera, renderer){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer\n        ];\n        this.meshMap = new Map() // Entity ID -> Mesh/Group mapping\n        ;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.priority = 1000; // Render systems should run last\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLCtDQUErQztBQUNvSTtBQUNuSDtBQUVUO0FBQ0Y7QUFFOUMsTUFBTUcscUJBQXFCQyxxREFBZ0JBO0lBZXpDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDRDQUE0QztRQUM1QyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9ELGtCQUFrQkUsZ0JBQWdCLEtBQUssWUFBWTtnQkFDNURGLGtCQUFrQkUsZ0JBQWdCLENBQUNOO1lBQ3JDLE9BQU87WUFDTCw2RkFBNkY7WUFDL0Y7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBQ04sUUFBUUMsV0FBV0U7UUFDM0M7SUFDRjtJQUVPSSxPQUFPVCxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDBDQUEwQztRQUMxQyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLElBQUksQ0FBQ0kscUJBQXFCLENBQUNSLFFBQVFDLFdBQVdFO1FBQ2hEO1FBRUEsbUJBQW1CO1FBQ25CLElBQUksQ0FBQ00sUUFBUSxDQUFDRixNQUFNLENBQUMsSUFBSSxDQUFD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Q0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUMrRCxRQUFRLEdBQUcsTUFBTSxpQ0FBaUM7SUFDekQ7QUFxTUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvUmVuZGVyU3lzdGVtLnRzP2IzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVuZGVyIHN5c3RlbSBmb3IgM0QgcmVuZGVyaW5nIHdpdGggVGhyZWUuanNcbmltcG9ydCB7IFNjZW5lLCBDYW1lcmEsIFdlYkdMUmVuZGVyZXIsIE1lc2gsIEdyb3VwLCBMaWdodCwgT2JqZWN0M0QsIENvbG9yLCBUZXh0dXJlLCBQQ0ZTb2Z0U2hhZG93TWFwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgRm9nLCBGb2dFeHAyLCBDdWJlVGV4dHVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gYXMgQmFzZVJlbmRlclN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcblxuZXhwb3J0IGNsYXNzIFJlbmRlclN5c3RlbSBleHRlbmRzIEJhc2VSZW5kZXJTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgUmVuZGVyZXJdO1xuICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcbiAgcHJpdmF0ZSBjYW1lcmE6IENhbWVyYTtcbiAgcHJpdmF0ZSByZW5kZXJlcjogV2ViR0xSZW5kZXJlcjtcbiAgcHJpdmF0ZSBtZXNoTWFwID0gbmV3IE1hcDxudW1iZXIsIE1lc2ggfCBHcm91cD4oKTsgLy8gRW50aXR5IElEIC0+IE1lc2gvR3JvdXAgbWFwcGluZ1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEsIHJlbmRlcmVyOiBXZWJHTFJlbmRlcmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxMDAwOyAvLyBSZW5kZXIgc3lzdGVtcyBzaG91bGQgcnVuIGxhc3RcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBhbmltYXRpb25zIGFuZCByZW5kZXJlciBjb21wb25lbnRzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcmVuZGVyZXJDb21wb25lbnQuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbnMgd2l0aCBzYWZldHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlQW5pbWF0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZW5kZXJlckNvbXBvbmVudC51cGRhdGVBbmltYXRpb25zKGRlbHRhVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVBbmltYXRpb25zIG1ldGhvZDonLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBtZXNoIGlmIG5lZWRlZFxuICAgICAgdGhpcy51cGRhdGVFbnRpdHlNZXNoKGVudGl0eSwgdHJhbnNmb3JtLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGFsbCBlbnRpdHkgdHJhbnNmb3JtcyBhbmQgbWVzaGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcmVuZGVyZXJDb21wb25lbnQuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbnRpdHlUcmFuc2Zvcm0oZW50aXR5LCB0cmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGhlIHNjZW5lXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVFbnRpdHlNZXNoKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQ6IFJlbmRlcmVyKTogdm9pZCB7XG4gICAgY29uc3QgZXhpc3RpbmdNZXNoID0gdGhpcy5tZXNoTWFwLmdldChlbnRpdHkuaWQpO1xuXG4gICAgLy8gSGFuZGxlIHByZS1idWlsdCBtZXNoL2dyb3VwIChsaWtlIGFycm93cylcbiAgICBpZiAoIWV4aXN0aW5nTWVzaCAmJiByZW5kZXJlckNvbXBvbmVudC5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgcmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChyZW5kZXJlckNvbXBvbmVudC5tZXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbWVzaCBpZiBpdCBkb2Vzbid0IGV4aXN0IG9yIG5lZWRzIHVwZGF0ZSAodHJhZGl0aW9uYWwgZ2VvbWV0cnkgKyBtYXRlcmlhbClcbiAgICBpZiAoIWV4aXN0aW5nTWVzaCAmJiByZW5kZXJlckNvbXBvbmVudC5nZW9tZXRyeSAmJiByZW5kZXJlckNvbXBvbmVudC5tYXRlcmlhbCkge1xuICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVyQ29tcG9uZW50LmNyZWF0ZU1lc2goKTtcbiAgICAgIGlmIChtZXNoKSB7XG4gICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCBtZXNoKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ01lc2gpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBtZXNoIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZU1lc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlTWVzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlTWVzaCBtZXRob2Q6JywgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRW50aXR5VHJhbnNmb3JtKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQ6IFJlbmRlcmVyKTogdm9pZCB7XG4gICAgY29uc3QgbWVzaE9yR3JvdXAgPSB0aGlzLm1lc2hNYXAuZ2V0KGVudGl0eS5pZCk7XG4gICAgaWYgKCFtZXNoT3JHcm91cCkgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICB0cmFuc2Zvcm0udXBkYXRlTWF0cml4KCk7XG5cbiAgICAvLyBBcHBseSB0cmFuc2Zvcm0gdG8gbWVzaCBvciBncm91cFxuICAgIG1lc2hPckdyb3VwLnBvc2l0aW9uLmNvcHkodHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICBtZXNoT3JHcm91cC5xdWF0ZXJuaW9uLmNvcHkodHJhbnNmb3JtLnF1YXRlcm5pb24pO1xuICAgIG1lc2hPckdyb3VwLnNjYWxlLmNvcHkodHJhbnNmb3JtLnNjYWxlKTtcblxuICAgIC8vIEhhbmRsZSBpbnN0YW5jZWQgcmVuZGVyaW5nIChvbmx5IGZvciBtZXNoZXMpXG4gICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50LmlzSW5zdGFuY2VkICYmIG1lc2hPckdyb3VwIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlSW5zdGFuY2VNYXRyaXgodHJhbnNmb3JtLm1hdHJpeCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5QWRkZWQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIGlmIChyZW5kZXJlckNvbXBvbmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYPCfjqggUmVuZGVyU3lzdGVtOiBBZGRpbmcgZW50aXR5ICR7ZW50aXR5LmlkfSB0byBzY2VuZWApO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcHJlLWJ1aWx0IG1lc2gvZ3JvdXAgKGxpa2UgYXJyb3dzIGFuZCBlbGl0ZSBlbmVtaWVzKVxuICAgICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYPCfj7kgQWRkaW5nIHByZS1idWlsdCBtZXNoL2dyb3VwIGZvciBlbnRpdHkgJHtlbnRpdHkuaWR9YCk7XG4gICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCByZW5kZXJlckNvbXBvbmVudC5tZXNoKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQocmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHRyYWRpdGlvbmFsIGdlb21ldHJ5ICsgbWF0ZXJpYWxcbiAgICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5nZW9tZXRyeSAmJiByZW5kZXJlckNvbXBvbmVudC5tYXRlcmlhbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+UtyBDcmVhdGluZyBtZXNoIGZyb20gZ2VvbWV0cnkgKyBtYXRlcmlhbCBmb3IgZW50aXR5ICR7ZW50aXR5LmlkfWApO1xuICAgICAgICBjb25zdCBtZXNoID0gcmVuZGVyZXJDb21wb25lbnQuY3JlYXRlTWVzaCgpO1xuICAgICAgICBpZiAobWVzaCkge1xuICAgICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCBtZXNoKTtcbiAgICAgICAgICB0aGlzLnNjZW5lLmFkZChtZXNoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYOKaqiBFbnRpdHkgJHtlbnRpdHkuaWR9IGhhcyBSZW5kZXJlciBidXQgbm8gZ2VvbWV0cnkvbWF0ZXJpYWwgLSBza2lwcGluZyBtZXNoIGNyZWF0aW9uYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDimqDvuI8gUmVuZGVyU3lzdGVtOiBFbnRpdHkgJHtlbnRpdHkuaWR9IGhhcyBubyBSZW5kZXJlciBjb21wb25lbnRgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25FbnRpdHlSZW1vdmVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaE1hcC5nZXQoZW50aXR5LmlkKTtcbiAgICBpZiAobWVzaCkge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUobWVzaCk7XG4gICAgICB0aGlzLm1lc2hNYXAuZGVsZXRlKGVudGl0eS5pZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXJDb21wb25lbnQgJiYgdHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyQ29tcG9uZW50LmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0TWVzaChlbnRpdHlJZDogbnVtYmVyKTogTWVzaCB8IEdyb3VwIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tZXNoTWFwLmdldChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U2NlbmUoKTogU2NlbmUge1xuICAgIHJldHVybiB0aGlzLnNjZW5lO1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYSgpOiBDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZW5kZXJlcigpOiBXZWJHTFJlbmRlcmVyIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgbWFuYWdpbmcgdGhlIHNjZW5lXG4gIHB1YmxpYyBhZGRMaWdodChsaWdodDogTGlnaHQpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlTGlnaHQobGlnaHQ6IExpZ2h0KTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5yZW1vdmUobGlnaHQpO1xuICB9XG5cbiAgcHVibGljIGFkZE9iamVjdChvYmplY3Q6IE9iamVjdDNEKTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5hZGQob2JqZWN0KTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVPYmplY3Qob2JqZWN0OiBPYmplY3QzRCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUucmVtb3ZlKG9iamVjdCk7XG4gIH1cblxuICBwdWJsaWMgc2V0Rm9nKGZvZzogRm9nIHwgRm9nRXhwMiB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmZvZyA9IGZvZztcbiAgfVxuXG4gIHB1YmxpYyBzZXRCYWNrZ3JvdW5kKGJhY2tncm91bmQ6IENvbG9yIHwgVGV4dHVyZSB8IEN1YmVUZXh0dXJlIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gIH1cblxuICBwdWJsaWMgZW5hYmxlU2hhZG93cyhlbmFibGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IGVuYWJsZTtcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gUENGU29mdFNoYWRvd01hcDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQaXhlbFJhdGlvKHJhdGlvPzogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHJhdGlvIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIGlmICh0aGlzLmNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBhbGwgbWVzaGVzXG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIG1lc2hdIG9mIEFycmF5LmZyb20odGhpcy5tZXNoTWFwLmVudHJpZXMoKSkpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgIH1cbiAgICB0aGlzLm1lc2hNYXAuY2xlYXIoKTtcblxuICAgIC8vIERpc3Bvc2UgcmVuZGVyZXJcbiAgICB0aGlzLnJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJQQ0ZTb2Z0U2hhZG93TWFwIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJSZW5kZXJTeXN0ZW0iLCJCYXNlUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiUmVuZGVyZXIiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInJlbmRlcmVyQ29tcG9uZW50IiwiZW5hYmxlZCIsInVwZGF0ZUFuaW1hdGlvbnMiLCJ1cGRhdGVFbnRpdHlNZXNoIiwicmVuZGVyIiwidXBkYXRlRW50aXR5VHJhbnNmb3JtIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImV4aXN0aW5nTWVzaCIsIm1lc2hNYXAiLCJnZXQiLCJpZCIsIm1lc2giLCJzZXQiLCJhZGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiY3JlYXRlTWVzaCIsInVwZGF0ZU1lc2giLCJtZXNoT3JHcm91cCIsInVwZGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwiY29weSIsInF1YXRlcm5pb24iLCJzY2FsZSIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJvbkVudGl0eUFkZGVkIiwib25FbnRpdHlSZW1vdmVkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZGlzcG9zZSIsImdldE1lc2giLCJlbnRpdHlJZCIsImdldFNjZW5lIiwiZ2V0Q2FtZXJhIiwiZ2V0UmVuZGVyZXIiLCJhZGRMaWdodCIsImxpZ2h0IiwicmVtb3ZlTGlnaHQiLCJhZGRPYmplY3QiLCJvYmplY3QiLCJyZW1vdmVPYmplY3QiLCJzZXRGb2ciLCJmb2ciLCJzZXRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsImVuYWJsZVNoYWRvd3MiLCJlbmFibGUiLCJzaGFkb3dNYXAiLCJ0eXBlIiwic2V0UGl4ZWxSYXRpbyIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/RenderSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/SummonedUnitSystem.ts":
/*!*******************************************!*\
  !*** ./src/systems/SummonedUnitSystem.ts ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SummonedUnitSystem: function() { return /* binding */ SummonedUnitSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n// SummonedUnit system for managing PVP tower minions\n\n\n\n\n\n\n\n\nclass SummonedUnitSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    updatePlayerPosition(playerId, position) {\n        this.playerPositions.set(playerId, position.clone());\n    }\n    updateTowerPosition(towerId, position) {\n        this.towerPositions.set(towerId, position.clone());\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        this.unitsToDestroy.length = 0;\n        // Process existing units\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const unit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!transform || !unit || !health) continue;\n            // Check if unit is expired\n            if (unit.isExpired(currentTime)) {\n                this.unitsToDestroy.push(entity.id);\n                continue;\n            }\n            // Check if unit is dead\n            if (health.isDead && !unit.isDead) {\n                unit.die(currentTime);\n                this.unitsToDestroy.push(entity.id);\n                continue;\n            }\n            // Skip inactive or dead units\n            if (!unit.isActive || unit.isDead) continue;\n            // Update unit behavior\n            this.updateUnitBehavior(entity, transform, unit, currentTime, deltaTime);\n        }\n        // Handle spawning new units\n        this.handleUnitSpawning(currentTime);\n        // Destroy expired units\n        for (const entityId of this.unitsToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    updateUnitBehavior(entity, transform, unit, currentTime, deltaTime) {\n        // Search for targets periodically\n        if (unit.canSearchForTargets(currentTime)) {\n            this.findTargetForUnit(unit, transform.position);\n            unit.updateTargetSearch(currentTime);\n        }\n        // Move towards target position if no specific target\n        if (!unit.currentTarget && unit.targetPosition) {\n            this.moveTowardsPosition(entity, transform, unit, deltaTime);\n        }\n        // Handle combat with current target\n        if (unit.currentTarget && unit.canAttack(currentTime)) {\n            this.handleUnitAttack(entity, unit, currentTime);\n        }\n    }\n    findTargetForUnit(unit, unitPosition) {\n        // Priority 1: Find enemy units to attack\n        const enemyUnits = this.findEnemyUnits(unit.ownerId, unitPosition);\n        if (enemyUnits.length > 0) {\n            // Target the closest enemy unit\n            const closestUnit = this.findClosestEntity(enemyUnits, unitPosition);\n            if (closestUnit) {\n                unit.setTarget(closestUnit.id);\n                return;\n            }\n        }\n        // Priority 2: If no enemy units, target enemy tower\n        const enemyTower = this.findEnemyTower(unit.ownerId, unitPosition);\n        if (enemyTower) {\n            unit.setTarget(enemyTower.id);\n            return;\n        }\n        // No targets found, clear target\n        unit.clearTarget();\n    }\n    findEnemyUnits(ownerId, unitPosition) {\n        const enemyUnits = [];\n        const allEntities = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        for (const entity of allEntities){\n            const summonedUnit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            if (!summonedUnit || !health || !collider) continue;\n            if (health.isDead || !summonedUnit.isActive) continue;\n            // Check if this is an enemy unit (different owner)\n            if (summonedUnit.ownerId !== ownerId && collider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY) {\n                enemyUnits.push(entity);\n            }\n        }\n        return enemyUnits;\n    }\n    findEnemyTower(ownerId, unitPosition) {\n        const allEntities = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        for (const entity of allEntities){\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            if (!tower || !health || !collider) continue;\n            if (health.isDead || !tower.isActive) continue;\n            // Check if this is an enemy tower\n            if (tower.ownerId !== ownerId && collider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY) {\n                return entity;\n            }\n        }\n        return null;\n    }\n    findClosestEntity(entities, fromPosition) {\n        let closestEntity = null;\n        let closestDistance = Infinity;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!transform) continue;\n            const distance = fromPosition.distanceTo(transform.position);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestEntity = entity;\n            }\n        }\n        return closestEntity;\n    }\n    moveTowardsPosition(entity, transform, unit, deltaTime) {\n        if (!unit.targetPosition) return;\n        const currentPos = transform.position;\n        const targetPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(unit.targetPosition.x, unit.targetPosition.y, unit.targetPosition.z);\n        // Calculate direction to target\n        this.tempVector.copy(targetPos).sub(currentPos);\n        const distance = this.tempVector.length();\n        // If close enough to target position, stop moving\n        if (distance < 0.5) {\n            unit.targetPosition = null;\n            return;\n        }\n        // Normalize and move\n        this.tempVector.normalize();\n        const moveDistance = unit.moveSpeed * deltaTime;\n        if (moveDistance < distance) {\n            // Move towards target\n            const newPosition = currentPos.clone().add(this.tempVector.multiplyScalar(moveDistance));\n            transform.setPosition(newPosition.x, newPosition.y, newPosition.z);\n        } else {\n            // Arrived at target\n            transform.setPosition(targetPos.x, targetPos.y, targetPos.z);\n            unit.targetPosition = null;\n        }\n        // Update movement component if it exists\n        const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (movement) {\n            movement.velocity.copy(this.tempVector).multiplyScalar(unit.moveSpeed);\n        }\n    }\n    handleUnitAttack(entity, unit, currentTime) {\n        if (!unit.currentTarget) return;\n        const targetEntity = this.world.getEntity(unit.currentTarget);\n        if (!targetEntity) {\n            unit.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetHealth = targetEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (!targetTransform || !targetHealth) {\n            unit.clearTarget();\n            return;\n        }\n        // Check if target is still in range\n        const unitTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!unitTransform) return;\n        const distance = unitTransform.position.distanceTo(targetTransform.position);\n        if (distance > unit.attackRange) {\n            unit.clearTarget();\n            return;\n        }\n        // Check if target is still alive\n        if (targetHealth.isDead) {\n            unit.clearTarget();\n            return;\n        }\n        // Perform attack\n        if (this.combatSystem) {\n            // Use combat system to handle damage\n            this.combatSystem.queueDamage(targetEntity, unit.attackDamage, entity, \"melee\");\n        } else {\n            // Fallback direct damage\n            targetHealth.takeDamage(unit.attackDamage, currentTime, targetEntity);\n        }\n        unit.performAttack(currentTime);\n    }\n    handleUnitSpawning(currentTime) {\n        // Get all towers to check for spawning\n        const towers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const towerEntity of towers){\n            const tower = towerEntity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower);\n            const towerTransform = towerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!tower || !towerTransform) continue;\n            if (!tower.isActive || tower.isDead) continue;\n            // Check if it's time to spawn units for this tower\n            const lastSpawn = this.lastSpawnTime.get(tower.ownerId) || 0;\n            if (currentTime - lastSpawn >= this.spawnInterval) {\n                this.spawnUnitsForTower(tower, towerTransform.position, currentTime);\n                this.lastSpawnTime.set(tower.ownerId, currentTime);\n            }\n        }\n    }\n    spawnUnitsForTower(tower, towerPosition, currentTime) {\n        // Find the opposing tower position for targeting\n        let opposingTowerPosition = this.findOpposingTowerPosition(tower.ownerId);\n        // If no opposing tower found, use a default position in front of current tower\n        if (!opposingTowerPosition) {\n            opposingTowerPosition = towerPosition.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 20));\n        }\n        // Spawn 2 units\n        for(let i = 0; i < 2; i++){\n            this.spawnUnit(tower.ownerId, towerPosition, opposingTowerPosition, i, currentTime);\n        }\n    }\n    findOpposingTowerPosition(ownerId) {\n        const towers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const towerEntity of towers){\n            const tower = towerEntity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower);\n            const towerTransform = towerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!tower || !towerTransform) continue;\n            if (tower.ownerId !== ownerId) {\n                return towerTransform.position.clone();\n            }\n        }\n        return null;\n    }\n    spawnUnit(ownerId, spawnPosition, targetPosition, unitIndex, currentTime) {\n        const unitEntity = this.world.createEntity();\n        const unitId = \"\".concat(ownerId, \"_unit_\").concat(currentTime, \"_\").concat(unitIndex);\n        // Add offset to spawn position to avoid stacking\n        const offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3((unitIndex - 0.5) * 2, 0, 0);\n        const actualSpawnPosition = spawnPosition.clone().add(offset);\n        // Add Transform component\n        const transform = this.world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.setPosition(actualSpawnPosition.x, actualSpawnPosition.y, actualSpawnPosition.z);\n        unitEntity.addComponent(transform);\n        // Add SummonedUnit component\n        const summonedUnit = this.world.createComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n        summonedUnit.ownerId = ownerId;\n        summonedUnit.unitId = unitId;\n        summonedUnit.targetPosition = {\n            x: targetPosition.x,\n            y: targetPosition.y,\n            z: targetPosition.z\n        };\n        summonedUnit.summonTime = currentTime;\n        unitEntity.addComponent(summonedUnit);\n        // Add Health component\n        const health = new _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health(summonedUnit.maxHealth);\n        unitEntity.addComponent(health);\n        // Add Movement component\n        const movement = this.world.createComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        movement.maxSpeed = summonedUnit.moveSpeed;\n        movement.friction = 0.9;\n        unitEntity.addComponent(movement);\n        // Add Collider component\n        const collider = this.world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.type = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.ColliderType.SPHERE; // Use sphere collider for units\n        collider.radius = 0.5;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY; // Use enemy layer for PVP\n        collider.setOffset(0, 0.6, 0); // Center on unit\n        unitEntity.addComponent(collider);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(unitEntity);\n    }\n    // Utility methods for external access\n    getUnitCount(ownerId) {\n        const units = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        return units.filter((entity)=>{\n            const unit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            return unit && health && unit.ownerId === ownerId && unit.isActive && !unit.isDead && !health.isDead;\n        }).length;\n    }\n    getAllUnits() {\n        return this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n    }\n    getUnitsByOwner(ownerId) {\n        const allUnits = this.getAllUnits();\n        return allUnits.filter((entity)=>{\n            const unit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            return unit && unit.ownerId === ownerId;\n        });\n    }\n    onDisable() {\n        // Clean up when system is disabled\n        this.lastSpawnTime.clear();\n        this.playerPositions.clear();\n        this.towerPositions.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ];\n        this.combatSystem = null;\n        // Unit spawning tracking\n        this.lastSpawnTime = new Map() // ownerId -> last spawn time\n        ;\n        this.spawnInterval = 30 // 30 seconds between spawns\n        ;\n        // Unit tracking\n        this.unitsToDestroy = [];\n        // Player and tower positions for targeting\n        this.playerPositions = new Map();\n        this.towerPositions = new Map();\n        // Reusable objects\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 15; // Run before combat system\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1N1bW1vbmVkVW5pdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxxREFBcUQ7QUFDTDtBQUNWO0FBRWlCO0FBQ0Y7QUFDSjtBQUNZO0FBQ3NCO0FBQ3BDO0FBSXhDLE1BQU1VLDJCQUEyQlQsK0NBQU1BO0lBMkJyQ1UsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxxQkFBcUJDLFFBQWdCLEVBQUVDLFFBQWlCLEVBQVE7UUFDckUsSUFBSSxDQUFDQyxlQUFlLENBQUNDLEdBQUcsQ0FBQ0gsVUFBVUMsU0FBU0csS0FBSztJQUNuRDtJQUVPQyxvQkFBb0JDLE9BQWUsRUFBRUwsUUFBaUIsRUFBUTtRQUNuRSxJQUFJLENBQUNNLGNBQWMsQ0FBQ0osR0FBRyxDQUFDRyxTQUFTTCxTQUFTRyxLQUFLO0lBQ2pEO0lBRU9JLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRyxLQUFLLE1BQU0scUJBQXFCO1FBRTVELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxNQUFNLEdBQUc7UUFFN0IseUJBQXlCO1FBQ3pCLEtBQUssTUFBTUMsVUFBVVAsU0FBVTtZQUM3QixNQUFNUSxZQUFZRCxPQUFPRSxZQUFZLENBQUM5QixnRUFBU0E7WUFDL0MsTUFBTStCLE9BQU9ILE9BQU9FLFlBQVksQ0FBQzNCLHNFQUFZQTtZQUM3QyxNQUFNNkIsU0FBU0osT0FBT0UsWUFBWSxDQUFDNUIsMERBQU1BO1lBRXpDLElBQUksQ0FBQzJCLGFBQWEsQ0FBQ0UsUUFBUSxDQUFDQyxRQUFRO1lBRXBDLDJCQUEyQjtZQUMzQixJQUFJRCxLQUFLRSxTQUFTLENBQUNWLGNBQWM7Z0JBQy9CLElBQUksQ0FBQ0csY0FBYyxDQUFDUSxJQUFJLENBQUNOLE9BQU9PLEVBQUU7Z0JBQ2xDO1lBQ0Y7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSUgsT0FBT0ksTUFBTSxJQUFJLENBQUNMLEtBQUtLLE1BQU0sRUFBRTtnQkFDakNMLEtBQUtNLEdBQUcsQ0FBQ2Q7Z0JBQ1QsSUFBSSxDQUFDRyxjQUFjLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtnQkFDbEM7WUFDRjtZQUVBLDhCQUE4QjtZQUM5QixJQUFJLENBQUNKLEtBQUtPLFFBQVEsSUFBSVAsS0FBS0ssTUFBTSxFQUFFO1lBRW5DLHVCQUF1QjtZQUN2QixJQUFJLENBQUNHLGtCQUFrQixDQUFDWCxRQUFRQyxXQUFXRSxNQUFNUixhQUFhRDtRQUNoRTtRQUVBLDRCQUE0QjtRQUM1QixJQUFJLENBQUNrQixrQkFBa0IsQ0FBQ2pCO1FBRXhCLHdCQUF3QjtRQUN4QixLQUFLLE1BQU1rQixZQUFZLElBQUksQ0FBQ2YsY0FBYyxDQUFFO1lBQzFDLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ0MsYUFBYSxDQUFDRjtRQUMzQjtJQUNGO0lBRVFGLG1CQUNOWCxNQUFjLEVBQ2RDLFNBQW9CLEVBQ3BCRSxJQUFrQixFQUNsQlIsV0FBbUIsRUFDbkJELFNBQWlCLEVBQ1g7UUFDTixrQ0FBa0M7UUFDbEMsSUFBSVMsS0FBS2EsbUJBQW1CLENBQUNyQixjQUFjO1lBQ3pDLElBQUksQ0FBQ3NCLGlCQUFpQixDQUFDZCxNQUFNRixVQUFVaEIsUUFBUTtZQUMvQ2tCLEtBQUtlLGtCQUFrQixDQUFDdkI7UUFDMUI7UUFFQSxxREFBcUQ7UUFDckQsSUFBSSxDQUFDUSxLQUFLZ0IsYUFBYSxJQUFJaEIsS0FBS2lCLGNBQWMsRUFBRTtZQUM5QyxJQUFJLENBQUNDLG1CQUFtQixDQUFDckIsUUFBUUMsV0FBV0UsTUFBTVQ7UUFDcEQ7UUFFQSxvQ0FBb0M7UUFDcEMsSUFBSVMsS0FBS2dCLGFBQWEsSUFBSWhCLEtBQUttQixTQUFTLENBQUMzQixjQUFjO1lBQ3JELElBQUksQ0FBQzRCLGdCQUFnQixDQUFDdkIsUUFBUUcsTUFBTVI7UUFDdEM7SUFDRjtJQUVRc0Isa0JBQWtCZCxJQUFrQixFQUFFcUIsWUFBcUIsRUFBUTtRQUN6RSx5Q0FBeUM7UUFDekMsTUFBTUMsYUFBYSxJQUFJLENBQUNDLGNBQWMsQ0FBQ3ZCLEtBQUt3QixPQUFPLEVBQUVIO1FBQ3JELElBQUlDLFdBQVcxQixNQUFNLEdBQUcsR0FBRztZQUN6QixnQ0FBZ0M7WUFDaEMsTUFBTTZCLGNBQWMsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0osWUFBWUQ7WUFDdkQsSUFBSUksYUFBYTtnQkFDZnpCLEtBQUsyQixTQUFTLENBQUNGLFlBQVlyQixFQUFFO2dCQUM3QjtZQUNGO1FBQ0Y7UUFFQSxvREFBb0Q7UUFDcEQsTUFBTXdCLGFBQWEsSUFBSSxDQUFDQyxjQUFjLENBQUM3QixLQUFLd0IsT0FBTyxFQUFFSDtRQUNyRCxJQUFJTyxZQUFZO1lBQ2Q1QixLQUFLMkIsU0FBUyxDQUFDQyxXQUFXeEIsRUFBRTtZQUM1QjtRQUNGO1FBRUEsaUNBQWlDO1FBQ2pDSixLQUFLOEIsV0FBVztJQUNsQjtJQUVRUCxlQUFlQyxPQUFlLEVBQUVILFlBQXFCLEVBQVk7UUFDdkUsTUFBTUMsYUFBdUIsRUFBRTtRQUMvQixNQUFNUyxjQUFjLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ3FCLGFBQWEsQ0FBQztZQUFDL0QsZ0VBQVNBO1lBQUVHLHNFQUFZQTtZQUFFRCwwREFBTUE7WUFBRUUsOERBQVFBO1NBQUM7UUFFeEYsS0FBSyxNQUFNd0IsVUFBVWtDLFlBQWE7WUFDaEMsTUFBTUUsZUFBZXBDLE9BQU9FLFlBQVksQ0FBQzNCLHNFQUFZQTtZQUNyRCxNQUFNNkIsU0FBU0osT0FBT0UsWUFBWSxDQUFDNUIsMERBQU1BO1lBQ3pDLE1BQU0rRCxXQUFXckMsT0FBT0UsWUFBWSxDQUFDMUIsOERBQVFBO1lBRTdDLElBQUksQ0FBQzRELGdCQUFnQixDQUFDaEMsVUFBVSxDQUFDaUMsVUFBVTtZQUMzQyxJQUFJakMsT0FBT0ksTUFBTSxJQUFJLENBQUM0QixhQUFhMUIsUUFBUSxFQUFFO1lBRTdDLG1EQUFtRDtZQUNuRCxJQUFJMEIsYUFBYVQsT0FBTyxLQUFLQSxXQUFXVSxTQUFTQyxLQUFLLEtBQUs3RCxvRUFBY0EsQ0FBQzhELEtBQUssRUFBRTtnQkFDL0VkLFdBQVduQixJQUFJLENBQUNOO1lBQ2xCO1FBQ0Y7UUFFQSxPQUFPeUI7SUFDVDtJQUVRTyxlQUFlTCxPQUFlLEVBQUVILFlBQXFCLEVBQWlCO1FBQzVFLE1BQU1VLGNBQWMsSUFBSSxDQUFDcEIsS0FBSyxDQUFDcUIsYUFBYSxDQUFDO1lBQUMvRCxnRUFBU0E7WUFBRU8sd0RBQUtBO1lBQUVMLDBEQUFNQTtZQUFFRSw4REFBUUE7U0FBQztRQUVqRixLQUFLLE1BQU13QixVQUFVa0MsWUFBYTtZQUNoQyxNQUFNTSxRQUFReEMsT0FBT0UsWUFBWSxDQUFDdkIsd0RBQUtBO1lBQ3ZDLE1BQU15QixTQUFTSixPQUFPRSxZQUFZLENBQUM1QiwwREFBTUE7WUFDekMsTUFBTStELFdBQVdyQyxPQUFPRSxZQUFZLENBQUMxQiw4REFBUUE7WUFFN0MsSUFBSSxDQUFDZ0UsU0FBUyxDQUFDcEMsVUFBVSxDQUFDaUMsVUFBVTtZQUNwQyxJQUFJakMsT0FBT0ksTUFBTSxJQUFJLENBQUNnQyxNQUFNOUIsUUFBUSxFQUFFO1lBRXRDLGtDQUFrQztZQUNsQyxJQUFJOEIsTUFBTWIsT0FBTyxLQUFLQSxXQUFXVSxTQUFTQyxLQUFLLEtBQUs3RCxvRUFBY0EsQ0FBQzhELEtBQUssRUFBRTtnQkFDeEUsT0FBT3ZDO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVRNkIsa0JBQWtCcEMsUUFBa0IsRUFBRWdELFlBQXFCLEVBQWlCO1FBQ2xGLElBQUlDLGdCQUErQjtRQUNuQyxJQUFJQyxrQkFBa0JDO1FBRXRCLEtBQUssTUFBTTVDLFVBQVVQLFNBQVU7WUFDN0IsTUFBTVEsWUFBWUQsT0FBT0UsWUFBWSxDQUFDOUIsZ0VBQVNBO1lBQy9DLElBQUksQ0FBQzZCLFdBQVc7WUFFaEIsTUFBTTRDLFdBQVdKLGFBQWFLLFVBQVUsQ0FBQzdDLFVBQVVoQixRQUFRO1lBQzNELElBQUk0RCxXQUFXRixpQkFBaUI7Z0JBQzlCQSxrQkFBa0JFO2dCQUNsQkgsZ0JBQWdCMUM7WUFDbEI7UUFDRjtRQUVBLE9BQU8wQztJQUNUO0lBRVFyQixvQkFDTnJCLE1BQWMsRUFDZEMsU0FBb0IsRUFDcEJFLElBQWtCLEVBQ2xCVCxTQUFpQixFQUNYO1FBQ04sSUFBSSxDQUFDUyxLQUFLaUIsY0FBYyxFQUFFO1FBRTFCLE1BQU0yQixhQUFhOUMsVUFBVWhCLFFBQVE7UUFDckMsTUFBTStELFlBQVksSUFBSTlFLHlEQUFPQSxDQUFDaUMsS0FBS2lCLGNBQWMsQ0FBQzZCLENBQUMsRUFBRTlDLEtBQUtpQixjQUFjLENBQUM4QixDQUFDLEVBQUUvQyxLQUFLaUIsY0FBYyxDQUFDK0IsQ0FBQztRQUVqRyxnQ0FBZ0M7UUFDaEMsSUFBSSxDQUFDQyxVQUFVLENBQUNDLElBQUksQ0FBQ0wsV0FBV00sR0FBRyxDQUFDUDtRQUNwQyxNQUFNRixXQUFXLElBQUksQ0FBQ08sVUFBVSxDQUFDckQsTUFBTTtRQUV2QyxrREFBa0Q7UUFDbEQsSUFBSThDLFdBQVcsS0FBSztZQUNsQjFDLEtBQUtpQixjQUFjLEdBQUc7WUFDdEI7UUFDRjtRQUVBLHFCQUFxQjtRQUNyQixJQUFJLENBQUNnQyxVQUFVLENBQUNHLFNBQVM7UUFDekIsTUFBTUMsZUFBZXJELEtBQUtzRCxTQUFTLEdBQUcvRDtRQUV0QyxJQUFJOEQsZUFBZVgsVUFBVTtZQUMzQixzQkFBc0I7WUFDdEIsTUFBTWEsY0FBY1gsV0FBVzNELEtBQUssR0FBR3VFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFVBQVUsQ0FBQ1EsY0FBYyxDQUFDSjtZQUMxRXZELFVBQVU0RCxXQUFXLENBQUNILFlBQVlULENBQUMsRUFBRVMsWUFBWVIsQ0FBQyxFQUFFUSxZQUFZUCxDQUFDO1FBQ25FLE9BQU87WUFDTCxvQkFBb0I7WUFDcEJsRCxVQUFVNEQsV0FBVyxDQUFDYixVQUFVQyxDQUFDLEVBQUVELFVBQVVFLENBQUMsRUFBRUYsVUFBVUcsQ0FBQztZQUMzRGhELEtBQUtpQixjQUFjLEdBQUc7UUFDeEI7UUFFQSx5Q0FBeUM7UUFDekMsTUFBTTBDLFdBQVc5RCxPQUFPRSxZQUFZLENBQUM3Qiw4REFBUUE7UUFDN0MsSUFBSXlGLFVBQVU7WUFDWkEsU0FBU0MsUUFBUSxDQUFDVixJQUFJLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUVRLGNBQWMsQ0FBQ3pELEtBQUtzRCxTQUFTO1FBQ3ZFO0lBQ0Y7SUFFUWxDLGlCQUFpQnZCLE1BQWMsRUFBRUcsSUFBa0IsRUFBRVIsV0FBbUIsRUFBUTtRQUN0RixJQUFJLENBQUNRLEtBQUtnQixhQUFhLEVBQUU7UUFFekIsTUFBTTZDLGVBQWUsSUFBSSxDQUFDbEQsS0FBSyxDQUFDbUQsU0FBUyxDQUFDOUQsS0FBS2dCLGFBQWE7UUFDNUQsSUFBSSxDQUFDNkMsY0FBYztZQUNqQjdELEtBQUs4QixXQUFXO1lBQ2hCO1FBQ0Y7UUFFQSxNQUFNaUMsa0JBQWtCRixhQUFhOUQsWUFBWSxDQUFDOUIsZ0VBQVNBO1FBQzNELE1BQU0rRixlQUFlSCxhQUFhOUQsWUFBWSxDQUFDNUIsMERBQU1BO1FBRXJELElBQUksQ0FBQzRGLG1CQUFtQixDQUFDQyxjQUFjO1lBQ3JDaEUsS0FBSzhCLFdBQVc7WUFDaEI7UUFDRjtRQUVBLG9DQUFvQztRQUNwQyxNQUFNbUMsZ0JBQWdCcEUsT0FBT0UsWUFBWSxDQUFDOUIsZ0VBQVNBO1FBQ25ELElBQUksQ0FBQ2dHLGVBQWU7UUFFcEIsTUFBTXZCLFdBQVd1QixjQUFjbkYsUUFBUSxDQUFDNkQsVUFBVSxDQUFDb0IsZ0JBQWdCakYsUUFBUTtRQUMzRSxJQUFJNEQsV0FBVzFDLEtBQUtrRSxXQUFXLEVBQUU7WUFDL0JsRSxLQUFLOEIsV0FBVztZQUNoQjtRQUNGO1FBRUEsaUNBQWlDO1FBQ2pDLElBQUlrQyxhQUFhM0QsTUFBTSxFQUFFO1lBQ3ZCTCxLQUFLOEIsV0FBVztZQUNoQjtRQUNGO1FBRUEsaUJBQWlCO1FBQ2pCLElBQUksSUFBSSxDQUFDbkQsWUFBWSxFQUFFO1lBQ3JCLHFDQUFxQztZQUNyQyxJQUFJLENBQUNBLFlBQVksQ0FBQ3dGLFdBQVcsQ0FBQ04sY0FBYzdELEtBQUtvRSxZQUFZLEVBQUV2RSxRQUFRO1FBQ3pFLE9BQU87WUFDTCx5QkFBeUI7WUFDekJtRSxhQUFhSyxVQUFVLENBQUNyRSxLQUFLb0UsWUFBWSxFQUFFNUUsYUFBYXFFO1FBQzFEO1FBRUE3RCxLQUFLc0UsYUFBYSxDQUFDOUU7SUFDckI7SUFFUWlCLG1CQUFtQmpCLFdBQW1CLEVBQVE7UUFDcEQsdUNBQXVDO1FBQ3ZDLE1BQU0rRSxTQUFTLElBQUksQ0FBQzVELEtBQUssQ0FBQ3FCLGFBQWEsQ0FBQztZQUFDL0QsZ0VBQVNBO1lBQUVPLHdEQUFLQTtZQUFFTCwwREFBTUE7U0FBQztRQUVsRSxLQUFLLE1BQU1xRyxlQUFlRCxPQUFRO1lBQ2hDLE1BQU1sQyxRQUFRbUMsWUFBWXpFLFlBQVksQ0FBQ3ZCLHdEQUFLQTtZQUM1QyxNQUFNaUcsaUJBQWlCRCxZQUFZekUsWUFBWSxDQUFDOUIsZ0VBQVNBO1lBRXpELElBQUksQ0FBQ29FLFNBQVMsQ0FBQ29DLGdCQUFnQjtZQUMvQixJQUFJLENBQUNwQyxNQUFNOUIsUUFBUSxJQUFJOEIsTUFBTWhDLE1BQU0sRUFBRTtZQUVyQyxtREFBbUQ7WUFDbkQsTUFBTXFFLFlBQVksSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ3ZDLE1BQU1iLE9BQU8sS0FBSztZQUMzRCxJQUFJaEMsY0FBY2tGLGFBQWEsSUFBSSxDQUFDRyxhQUFhLEVBQUU7Z0JBQ2pELElBQUksQ0FBQ0Msa0JBQWtCLENBQUN6QyxPQUFPb0MsZUFBZTNGLFFBQVEsRUFBRVU7Z0JBQ3hELElBQUksQ0FBQ21GLGFBQWEsQ0FBQzNGLEdBQUcsQ0FBQ3FELE1BQU1iLE9BQU8sRUFBRWhDO1lBQ3hDO1FBQ0Y7SUFDRjtJQUVRc0YsbUJBQW1CekMsS0FBWSxFQUFFMEMsYUFBc0IsRUFBRXZGLFdBQW1CLEVBQVE7UUFDMUYsaURBQWlEO1FBQ2pELElBQUl3Rix3QkFBd0IsSUFBSSxDQUFDQyx5QkFBeUIsQ0FBQzVDLE1BQU1iLE9BQU87UUFFeEUsK0VBQStFO1FBQy9FLElBQUksQ0FBQ3dELHVCQUF1QjtZQUMxQkEsd0JBQXdCRCxjQUFjOUYsS0FBSyxHQUFHdUUsR0FBRyxDQUFDLElBQUl6Rix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDdEU7UUFFQSxnQkFBZ0I7UUFDaEIsSUFBSyxJQUFJbUgsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUIsSUFBSSxDQUFDQyxTQUFTLENBQUM5QyxNQUFNYixPQUFPLEVBQUV1RCxlQUFlQyx1QkFBdUJFLEdBQUcxRjtRQUN6RTtJQUNGO0lBRVF5RiwwQkFBMEJ6RCxPQUFlLEVBQWtCO1FBQ2pFLE1BQU0rQyxTQUFTLElBQUksQ0FBQzVELEtBQUssQ0FBQ3FCLGFBQWEsQ0FBQztZQUFDL0QsZ0VBQVNBO1lBQUVPLHdEQUFLQTtZQUFFTCwwREFBTUE7U0FBQztRQUVsRSxLQUFLLE1BQU1xRyxlQUFlRCxPQUFRO1lBQ2hDLE1BQU1sQyxRQUFRbUMsWUFBWXpFLFlBQVksQ0FBQ3ZCLHdEQUFLQTtZQUM1QyxNQUFNaUcsaUJBQWlCRCxZQUFZekUsWUFBWSxDQUFDOUIsZ0VBQVNBO1lBRXpELElBQUksQ0FBQ29FLFNBQVMsQ0FBQ29DLGdCQUFnQjtZQUMvQixJQUFJcEMsTUFBTWIsT0FBTyxLQUFLQSxTQUFTO2dCQUM3QixPQUFPaUQsZUFBZTNGLFFBQVEsQ0FBQ0csS0FBSztZQUN0QztRQUNGO1FBRUEsT0FBTztJQUNUO0lBRVFrRyxVQUNOM0QsT0FBZSxFQUNmNEQsYUFBc0IsRUFDdEJuRSxjQUF1QixFQUN2Qm9FLFNBQWlCLEVBQ2pCN0YsV0FBbUIsRUFDYjtRQUNOLE1BQU04RixhQUFhLElBQUksQ0FBQzNFLEtBQUssQ0FBQzRFLFlBQVk7UUFDMUMsTUFBTUMsU0FBUyxHQUFtQmhHLE9BQWhCZ0MsU0FBUSxVQUF1QjZELE9BQWY3RixhQUFZLEtBQWEsT0FBVjZGO1FBRWpELGlEQUFpRDtRQUNqRCxNQUFNSSxTQUFTLElBQUkxSCx5REFBT0EsQ0FDeEIsQ0FBQ3NILFlBQVksR0FBRSxJQUFLLEdBQ3BCLEdBQ0E7UUFFRixNQUFNSyxzQkFBc0JOLGNBQWNuRyxLQUFLLEdBQUd1RSxHQUFHLENBQUNpQztRQUV0RCwwQkFBMEI7UUFDMUIsTUFBTTNGLFlBQVksSUFBSSxDQUFDYSxLQUFLLENBQUNnRixlQUFlLENBQUMxSCxnRUFBU0E7UUFDdEQ2QixVQUFVNEQsV0FBVyxDQUFDZ0Msb0JBQW9CNUMsQ0FBQyxFQUFFNEMsb0JBQW9CM0MsQ0FBQyxFQUFFMkMsb0JBQW9CMUMsQ0FBQztRQUN6RnNDLFdBQVdNLFlBQVksQ0FBQzlGO1FBRXhCLDZCQUE2QjtRQUM3QixNQUFNbUMsZUFBZSxJQUFJLENBQUN0QixLQUFLLENBQUNnRixlQUFlLENBQUN2SCxzRUFBWUE7UUFDNUQ2RCxhQUFhVCxPQUFPLEdBQUdBO1FBQ3ZCUyxhQUFhdUQsTUFBTSxHQUFHQTtRQUN0QnZELGFBQWFoQixjQUFjLEdBQUc7WUFDNUI2QixHQUFHN0IsZUFBZTZCLENBQUM7WUFDbkJDLEdBQUc5QixlQUFlOEIsQ0FBQztZQUNuQkMsR0FBRy9CLGVBQWUrQixDQUFDO1FBQ3JCO1FBQ0FmLGFBQWE0RCxVQUFVLEdBQUdyRztRQUMxQjhGLFdBQVdNLFlBQVksQ0FBQzNEO1FBRXhCLHVCQUF1QjtRQUN2QixNQUFNaEMsU0FBUyxJQUFJOUIsMERBQU1BLENBQUM4RCxhQUFhNkQsU0FBUztRQUNoRFIsV0FBV00sWUFBWSxDQUFDM0Y7UUFFeEIseUJBQXlCO1FBQ3pCLE1BQU0wRCxXQUFXLElBQUksQ0FBQ2hELEtBQUssQ0FBQ2dGLGVBQWUsQ0FBQ3pILDhEQUFRQTtRQUNwRHlGLFNBQVNvQyxRQUFRLEdBQUc5RCxhQUFhcUIsU0FBUztRQUMxQ0ssU0FBU3FDLFFBQVEsR0FBRztRQUNwQlYsV0FBV00sWUFBWSxDQUFDakM7UUFFeEIseUJBQXlCO1FBQ3pCLE1BQU16QixXQUFXLElBQUksQ0FBQ3ZCLEtBQUssQ0FBQ2dGLGVBQWUsQ0FBQ3RILDhEQUFRQTtRQUNwRDZELFNBQVMrRCxJQUFJLEdBQUcxSCxrRUFBWUEsQ0FBQzJILE1BQU0sRUFBRSxnQ0FBZ0M7UUFDckVoRSxTQUFTaUUsTUFBTSxHQUFHO1FBQ2xCakUsU0FBU0MsS0FBSyxHQUFHN0Qsb0VBQWNBLENBQUM4RCxLQUFLLEVBQUUsMEJBQTBCO1FBQ2pFRixTQUFTa0UsU0FBUyxDQUFDLEdBQUcsS0FBSyxJQUFJLGlCQUFpQjtRQUNoRGQsV0FBV00sWUFBWSxDQUFDMUQ7UUFFeEIsMENBQTBDO1FBQzFDLElBQUksQ0FBQ3ZCLEtBQUssQ0FBQzBGLGlCQUFpQixDQUFDZjtJQUMvQjtJQUVBLHNDQUFzQztJQUMvQmdCLGFBQWE5RSxPQUFlLEVBQVU7UUFDM0MsTUFBTStFLFFBQVEsSUFBSSxDQUFDNUYsS0FBSyxDQUFDcUIsYUFBYSxDQUFDO1lBQUMvRCxnRUFBU0E7WUFBRUcsc0VBQVlBO1lBQUVELDBEQUFNQTtTQUFDO1FBQ3hFLE9BQU9vSSxNQUFNQyxNQUFNLENBQUMzRyxDQUFBQTtZQUNsQixNQUFNRyxPQUFPSCxPQUFPRSxZQUFZLENBQUMzQixzRUFBWUE7WUFDN0MsTUFBTTZCLFNBQVNKLE9BQU9FLFlBQVksQ0FBQzVCLDBEQUFNQTtZQUN6QyxPQUFPNkIsUUFBUUMsVUFBVUQsS0FBS3dCLE9BQU8sS0FBS0EsV0FBV3hCLEtBQUtPLFFBQVEsSUFBSSxDQUFDUCxLQUFLSyxNQUFNLElBQUksQ0FBQ0osT0FBT0ksTUFBTTtRQUN0RyxHQUFHVCxNQUFNO0lBQ1g7SUFFTzZHLGNBQXdCO1FBQzdCLE9BQU8sSUFBSSxDQUFDOUYsS0FBSyxDQUFDcUIsYUFBYSxDQUFDO1lBQUMvRCxnRUFBU0E7WUFBRUcsc0VBQVlBO1lBQUVELDBEQUFNQTtTQUFDO0lBQ25FO0lBRU91SSxnQkFBZ0JsRixPQUFlLEVBQVk7UUFDaEQsTUFBTW1GLFdBQVcsSUFBSSxDQUFDRixXQUFXO1FBQ2pDLE9BQU9FLFNBQVNILE1BQU0sQ0FBQzNHLENBQUFBO1lBQ3JCLE1BQU1HLE9BQU9ILE9BQU9FLFlBQVksQ0FBQzNCLHNFQUFZQTtZQUM3QyxPQUFPNEIsUUFBUUEsS0FBS3dCLE9BQU8sS0FBS0E7UUFDbEM7SUFDRjtJQUVPb0YsWUFBa0I7UUFDdkIsbUNBQW1DO1FBQ25DLElBQUksQ0FBQ2pDLGFBQWEsQ0FBQ2tDLEtBQUs7UUFDeEIsSUFBSSxDQUFDOUgsZUFBZSxDQUFDOEgsS0FBSztRQUMxQixJQUFJLENBQUN6SCxjQUFjLENBQUN5SCxLQUFLO0lBQzNCO0lBcFlBQyxZQUFZbkcsS0FBWSxDQUFFO1FBQ3hCLEtBQUs7YUFyQlNvRyxxQkFBcUI7WUFBQzlJLGdFQUFTQTtZQUFFRyxzRUFBWUE7WUFBRUQsMERBQU1BO1NBQUM7YUFHOURRLGVBQW9DO1FBRTVDLHlCQUF5QjthQUNqQmdHLGdCQUFxQyxJQUFJcUMsTUFBTyw2QkFBNkI7O2FBQzdFbkMsZ0JBQXdCLEdBQUksNEJBQTRCOztRQUVoRSxnQkFBZ0I7YUFDUmxGLGlCQUEyQixFQUFFO1FBRXJDLDJDQUEyQzthQUNuQ1osa0JBQXdDLElBQUlpSTthQUM1QzVILGlCQUF1QyxJQUFJNEg7UUFFbkQsbUJBQW1CO2FBQ1gvRCxhQUFhLElBQUlsRix5REFBT0E7YUFDeEJrSixjQUFjLElBQUlsSix5REFBT0E7UUFJL0IsSUFBSSxDQUFDNEMsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3VHLFFBQVEsR0FBRyxJQUFJLDJCQUEyQjtJQUNqRDtBQWlZRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9TdW1tb25lZFVuaXRTeXN0ZW0udHM/OGMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTdW1tb25lZFVuaXQgc3lzdGVtIGZvciBtYW5hZ2luZyBQVlAgdG93ZXIgbWluaW9uc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBTdW1tb25lZFVuaXQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1N1bW1vbmVkVW5pdCc7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIsIENvbGxpZGVyVHlwZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXInO1xuaW1wb3J0IHsgVG93ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1Rvd2VyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgQ29tYmF0U3lzdGVtIH0gZnJvbSAnLi9Db21iYXRTeXN0ZW0nO1xuXG5leHBvcnQgY2xhc3MgU3VtbW9uZWRVbml0U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFN1bW1vbmVkVW5pdCwgSGVhbHRoXTtcblxuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBjb21iYXRTeXN0ZW06IENvbWJhdFN5c3RlbSB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFVuaXQgc3Bhd25pbmcgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0U3Bhd25UaW1lOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpOyAvLyBvd25lcklkIC0+IGxhc3Qgc3Bhd24gdGltZVxuICBwcml2YXRlIHNwYXduSW50ZXJ2YWw6IG51bWJlciA9IDMwOyAvLyAzMCBzZWNvbmRzIGJldHdlZW4gc3Bhd25zXG5cbiAgLy8gVW5pdCB0cmFja2luZ1xuICBwcml2YXRlIHVuaXRzVG9EZXN0cm95OiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIFBsYXllciBhbmQgdG93ZXIgcG9zaXRpb25zIGZvciB0YXJnZXRpbmdcbiAgcHJpdmF0ZSBwbGF5ZXJQb3NpdGlvbnM6IE1hcDxzdHJpbmcsIFZlY3RvcjM+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHRvd2VyUG9zaXRpb25zOiBNYXA8c3RyaW5nLCBWZWN0b3IzPiA9IG5ldyBNYXAoKTtcblxuICAvLyBSZXVzYWJsZSBvYmplY3RzXG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxNTsgLy8gUnVuIGJlZm9yZSBjb21iYXQgc3lzdGVtXG4gIH1cblxuICBwdWJsaWMgc2V0Q29tYmF0U3lzdGVtKGNvbWJhdFN5c3RlbTogQ29tYmF0U3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5jb21iYXRTeXN0ZW0gPSBjb21iYXRTeXN0ZW07XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlUGxheWVyUG9zaXRpb24ocGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICB0aGlzLnBsYXllclBvc2l0aW9ucy5zZXQocGxheWVySWQsIHBvc2l0aW9uLmNsb25lKCkpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVRvd2VyUG9zaXRpb24odG93ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIHRoaXMudG93ZXJQb3NpdGlvbnMuc2V0KHRvd2VySWQsIHBvc2l0aW9uLmNsb25lKCkpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG5cbiAgICB0aGlzLnVuaXRzVG9EZXN0cm95Lmxlbmd0aCA9IDA7XG5cbiAgICAvLyBQcm9jZXNzIGV4aXN0aW5nIHVuaXRzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHVuaXQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCk7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICF1bml0IHx8ICFoZWFsdGgpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBDaGVjayBpZiB1bml0IGlzIGV4cGlyZWRcbiAgICAgIGlmICh1bml0LmlzRXhwaXJlZChjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy51bml0c1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1bml0IGlzIGRlYWRcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkICYmICF1bml0LmlzRGVhZCkge1xuICAgICAgICB1bml0LmRpZShjdXJyZW50VGltZSk7XG4gICAgICAgIHRoaXMudW5pdHNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpbmFjdGl2ZSBvciBkZWFkIHVuaXRzXG4gICAgICBpZiAoIXVuaXQuaXNBY3RpdmUgfHwgdW5pdC5pc0RlYWQpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBVcGRhdGUgdW5pdCBiZWhhdmlvclxuICAgICAgdGhpcy51cGRhdGVVbml0QmVoYXZpb3IoZW50aXR5LCB0cmFuc2Zvcm0sIHVuaXQsIGN1cnJlbnRUaW1lLCBkZWx0YVRpbWUpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGF3bmluZyBuZXcgdW5pdHNcbiAgICB0aGlzLmhhbmRsZVVuaXRTcGF3bmluZyhjdXJyZW50VGltZSk7XG5cbiAgICAvLyBEZXN0cm95IGV4cGlyZWQgdW5pdHNcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMudW5pdHNUb0Rlc3Ryb3kpIHtcbiAgICAgIHRoaXMud29ybGQuZGVzdHJveUVudGl0eShlbnRpdHlJZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVVbml0QmVoYXZpb3IoXG4gICAgZW50aXR5OiBFbnRpdHksXG4gICAgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sXG4gICAgdW5pdDogU3VtbW9uZWRVbml0LFxuICAgIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gICAgZGVsdGFUaW1lOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgLy8gU2VhcmNoIGZvciB0YXJnZXRzIHBlcmlvZGljYWxseVxuICAgIGlmICh1bml0LmNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZpbmRUYXJnZXRGb3JVbml0KHVuaXQsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICB1bml0LnVwZGF0ZVRhcmdldFNlYXJjaChjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSB0b3dhcmRzIHRhcmdldCBwb3NpdGlvbiBpZiBubyBzcGVjaWZpYyB0YXJnZXRcbiAgICBpZiAoIXVuaXQuY3VycmVudFRhcmdldCAmJiB1bml0LnRhcmdldFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLm1vdmVUb3dhcmRzUG9zaXRpb24oZW50aXR5LCB0cmFuc2Zvcm0sIHVuaXQsIGRlbHRhVGltZSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbWJhdCB3aXRoIGN1cnJlbnQgdGFyZ2V0XG4gICAgaWYgKHVuaXQuY3VycmVudFRhcmdldCAmJiB1bml0LmNhbkF0dGFjayhjdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlVW5pdEF0dGFjayhlbnRpdHksIHVuaXQsIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZpbmRUYXJnZXRGb3JVbml0KHVuaXQ6IFN1bW1vbmVkVW5pdCwgdW5pdFBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgLy8gUHJpb3JpdHkgMTogRmluZCBlbmVteSB1bml0cyB0byBhdHRhY2tcbiAgICBjb25zdCBlbmVteVVuaXRzID0gdGhpcy5maW5kRW5lbXlVbml0cyh1bml0Lm93bmVySWQsIHVuaXRQb3NpdGlvbik7XG4gICAgaWYgKGVuZW15VW5pdHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gVGFyZ2V0IHRoZSBjbG9zZXN0IGVuZW15IHVuaXRcbiAgICAgIGNvbnN0IGNsb3Nlc3RVbml0ID0gdGhpcy5maW5kQ2xvc2VzdEVudGl0eShlbmVteVVuaXRzLCB1bml0UG9zaXRpb24pO1xuICAgICAgaWYgKGNsb3Nlc3RVbml0KSB7XG4gICAgICAgIHVuaXQuc2V0VGFyZ2V0KGNsb3Nlc3RVbml0LmlkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByaW9yaXR5IDI6IElmIG5vIGVuZW15IHVuaXRzLCB0YXJnZXQgZW5lbXkgdG93ZXJcbiAgICBjb25zdCBlbmVteVRvd2VyID0gdGhpcy5maW5kRW5lbXlUb3dlcih1bml0Lm93bmVySWQsIHVuaXRQb3NpdGlvbik7XG4gICAgaWYgKGVuZW15VG93ZXIpIHtcbiAgICAgIHVuaXQuc2V0VGFyZ2V0KGVuZW15VG93ZXIuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vIHRhcmdldHMgZm91bmQsIGNsZWFyIHRhcmdldFxuICAgIHVuaXQuY2xlYXJUYXJnZXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZEVuZW15VW5pdHMob3duZXJJZDogc3RyaW5nLCB1bml0UG9zaXRpb246IFZlY3RvcjMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW5lbXlVbml0czogRW50aXR5W10gPSBbXTtcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBTdW1tb25lZFVuaXQsIEhlYWx0aCwgQ29sbGlkZXJdKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBjb25zdCBzdW1tb25lZFVuaXQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCk7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuXG4gICAgICBpZiAoIXN1bW1vbmVkVW5pdCB8fCAhaGVhbHRoIHx8ICFjb2xsaWRlcikgY29udGludWU7XG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCB8fCAhc3VtbW9uZWRVbml0LmlzQWN0aXZlKSBjb250aW51ZTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBlbmVteSB1bml0IChkaWZmZXJlbnQgb3duZXIpXG4gICAgICBpZiAoc3VtbW9uZWRVbml0Lm93bmVySWQgIT09IG93bmVySWQgJiYgY29sbGlkZXIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLkVORU1ZKSB7XG4gICAgICAgIGVuZW15VW5pdHMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbmVteVVuaXRzO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRW5lbXlUb3dlcihvd25lcklkOiBzdHJpbmcsIHVuaXRQb3NpdGlvbjogVmVjdG9yMyk6IEVudGl0eSB8IG51bGwge1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFRvd2VyLCBIZWFsdGgsIENvbGxpZGVyXSk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBhbGxFbnRpdGllcykge1xuICAgICAgY29uc3QgdG93ZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRvd2VyKTtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgIGlmICghdG93ZXIgfHwgIWhlYWx0aCB8fCAhY29sbGlkZXIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQgfHwgIXRvd2VyLmlzQWN0aXZlKSBjb250aW51ZTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBlbmVteSB0b3dlclxuICAgICAgaWYgKHRvd2VyLm93bmVySWQgIT09IG93bmVySWQgJiYgY29sbGlkZXIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLkVORU1ZKSB7XG4gICAgICAgIHJldHVybiBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIGZpbmRDbG9zZXN0RW50aXR5KGVudGl0aWVzOiBFbnRpdHlbXSwgZnJvbVBvc2l0aW9uOiBWZWN0b3IzKTogRW50aXR5IHwgbnVsbCB7XG4gICAgbGV0IGNsb3Nlc3RFbnRpdHk6IEVudGl0eSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gZnJvbVBvc2l0aW9uLmRpc3RhbmNlVG8odHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgY2xvc2VzdEVudGl0eSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvc2VzdEVudGl0eTtcbiAgfVxuXG4gIHByaXZhdGUgbW92ZVRvd2FyZHNQb3NpdGlvbihcbiAgICBlbnRpdHk6IEVudGl0eSxcbiAgICB0cmFuc2Zvcm06IFRyYW5zZm9ybSxcbiAgICB1bml0OiBTdW1tb25lZFVuaXQsXG4gICAgZGVsdGFUaW1lOiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF1bml0LnRhcmdldFBvc2l0aW9uKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50UG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IHRhcmdldFBvcyA9IG5ldyBWZWN0b3IzKHVuaXQudGFyZ2V0UG9zaXRpb24ueCwgdW5pdC50YXJnZXRQb3NpdGlvbi55LCB1bml0LnRhcmdldFBvc2l0aW9uLnopO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpcmVjdGlvbiB0byB0YXJnZXRcbiAgICB0aGlzLnRlbXBWZWN0b3IuY29weSh0YXJnZXRQb3MpLnN1YihjdXJyZW50UG9zKTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMudGVtcFZlY3Rvci5sZW5ndGgoKTtcblxuICAgIC8vIElmIGNsb3NlIGVub3VnaCB0byB0YXJnZXQgcG9zaXRpb24sIHN0b3AgbW92aW5nXG4gICAgaWYgKGRpc3RhbmNlIDwgMC41KSB7XG4gICAgICB1bml0LnRhcmdldFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgYW5kIG1vdmVcbiAgICB0aGlzLnRlbXBWZWN0b3Iubm9ybWFsaXplKCk7XG4gICAgY29uc3QgbW92ZURpc3RhbmNlID0gdW5pdC5tb3ZlU3BlZWQgKiBkZWx0YVRpbWU7XG5cbiAgICBpZiAobW92ZURpc3RhbmNlIDwgZGlzdGFuY2UpIHtcbiAgICAgIC8vIE1vdmUgdG93YXJkcyB0YXJnZXRcbiAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gY3VycmVudFBvcy5jbG9uZSgpLmFkZCh0aGlzLnRlbXBWZWN0b3IubXVsdGlwbHlTY2FsYXIobW92ZURpc3RhbmNlKSk7XG4gICAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24obmV3UG9zaXRpb24ueCwgbmV3UG9zaXRpb24ueSwgbmV3UG9zaXRpb24ueik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFycml2ZWQgYXQgdGFyZ2V0XG4gICAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24odGFyZ2V0UG9zLngsIHRhcmdldFBvcy55LCB0YXJnZXRQb3Mueik7XG4gICAgICB1bml0LnRhcmdldFBvc2l0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbW92ZW1lbnQgY29tcG9uZW50IGlmIGl0IGV4aXN0c1xuICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKG1vdmVtZW50KSB7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS5jb3B5KHRoaXMudGVtcFZlY3RvcikubXVsdGlwbHlTY2FsYXIodW5pdC5tb3ZlU3BlZWQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVW5pdEF0dGFjayhlbnRpdHk6IEVudGl0eSwgdW5pdDogU3VtbW9uZWRVbml0LCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF1bml0LmN1cnJlbnRUYXJnZXQpIHJldHVybjtcblxuICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHVuaXQuY3VycmVudFRhcmdldCk7XG4gICAgaWYgKCF0YXJnZXRFbnRpdHkpIHtcbiAgICAgIHVuaXQuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXRFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuXG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldEhlYWx0aCkge1xuICAgICAgdW5pdC5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBzdGlsbCBpbiByYW5nZVxuICAgIGNvbnN0IHVuaXRUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF1bml0VHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IHVuaXRUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIGlmIChkaXN0YW5jZSA+IHVuaXQuYXR0YWNrUmFuZ2UpIHtcbiAgICAgIHVuaXQuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgc3RpbGwgYWxpdmVcbiAgICBpZiAodGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgdW5pdC5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXR0YWNrXG4gICAgaWYgKHRoaXMuY29tYmF0U3lzdGVtKSB7XG4gICAgICAvLyBVc2UgY29tYmF0IHN5c3RlbSB0byBoYW5kbGUgZGFtYWdlXG4gICAgICB0aGlzLmNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZSh0YXJnZXRFbnRpdHksIHVuaXQuYXR0YWNrRGFtYWdlLCBlbnRpdHksICdtZWxlZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBkaXJlY3QgZGFtYWdlXG4gICAgICB0YXJnZXRIZWFsdGgudGFrZURhbWFnZSh1bml0LmF0dGFja0RhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldEVudGl0eSk7XG4gICAgfVxuXG4gICAgdW5pdC5wZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVW5pdFNwYXduaW5nKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIHRvd2VycyB0byBjaGVjayBmb3Igc3Bhd25pbmdcbiAgICBjb25zdCB0b3dlcnMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aF0pO1xuXG4gICAgZm9yIChjb25zdCB0b3dlckVudGl0eSBvZiB0b3dlcnMpIHtcbiAgICAgIGNvbnN0IHRvd2VyID0gdG93ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRvd2VyKTtcbiAgICAgIGNvbnN0IHRvd2VyVHJhbnNmb3JtID0gdG93ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG5cbiAgICAgIGlmICghdG93ZXIgfHwgIXRvd2VyVHJhbnNmb3JtKSBjb250aW51ZTtcbiAgICAgIGlmICghdG93ZXIuaXNBY3RpdmUgfHwgdG93ZXIuaXNEZWFkKSBjb250aW51ZTtcblxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyB0aW1lIHRvIHNwYXduIHVuaXRzIGZvciB0aGlzIHRvd2VyXG4gICAgICBjb25zdCBsYXN0U3Bhd24gPSB0aGlzLmxhc3RTcGF3blRpbWUuZ2V0KHRvd2VyLm93bmVySWQpIHx8IDA7XG4gICAgICBpZiAoY3VycmVudFRpbWUgLSBsYXN0U3Bhd24gPj0gdGhpcy5zcGF3bkludGVydmFsKSB7XG4gICAgICAgIHRoaXMuc3Bhd25Vbml0c0ZvclRvd2VyKHRvd2VyLCB0b3dlclRyYW5zZm9ybS5wb3NpdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgICB0aGlzLmxhc3RTcGF3blRpbWUuc2V0KHRvd2VyLm93bmVySWQsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNwYXduVW5pdHNGb3JUb3dlcih0b3dlcjogVG93ZXIsIHRvd2VyUG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBGaW5kIHRoZSBvcHBvc2luZyB0b3dlciBwb3NpdGlvbiBmb3IgdGFyZ2V0aW5nXG4gICAgbGV0IG9wcG9zaW5nVG93ZXJQb3NpdGlvbiA9IHRoaXMuZmluZE9wcG9zaW5nVG93ZXJQb3NpdGlvbih0b3dlci5vd25lcklkKTtcblxuICAgIC8vIElmIG5vIG9wcG9zaW5nIHRvd2VyIGZvdW5kLCB1c2UgYSBkZWZhdWx0IHBvc2l0aW9uIGluIGZyb250IG9mIGN1cnJlbnQgdG93ZXJcbiAgICBpZiAoIW9wcG9zaW5nVG93ZXJQb3NpdGlvbikge1xuICAgICAgb3Bwb3NpbmdUb3dlclBvc2l0aW9uID0gdG93ZXJQb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVmVjdG9yMygwLCAwLCAyMCkpO1xuICAgIH1cblxuICAgIC8vIFNwYXduIDIgdW5pdHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgdGhpcy5zcGF3blVuaXQodG93ZXIub3duZXJJZCwgdG93ZXJQb3NpdGlvbiwgb3Bwb3NpbmdUb3dlclBvc2l0aW9uLCBpLCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kT3Bwb3NpbmdUb3dlclBvc2l0aW9uKG93bmVySWQ6IHN0cmluZyk6IFZlY3RvcjMgfCBudWxsIHtcbiAgICBjb25zdCB0b3dlcnMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aF0pO1xuXG4gICAgZm9yIChjb25zdCB0b3dlckVudGl0eSBvZiB0b3dlcnMpIHtcbiAgICAgIGNvbnN0IHRvd2VyID0gdG93ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRvd2VyKTtcbiAgICAgIGNvbnN0IHRvd2VyVHJhbnNmb3JtID0gdG93ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG5cbiAgICAgIGlmICghdG93ZXIgfHwgIXRvd2VyVHJhbnNmb3JtKSBjb250aW51ZTtcbiAgICAgIGlmICh0b3dlci5vd25lcklkICE9PSBvd25lcklkKSB7XG4gICAgICAgIHJldHVybiB0b3dlclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBzcGF3blVuaXQoXG4gICAgb3duZXJJZDogc3RyaW5nLFxuICAgIHNwYXduUG9zaXRpb246IFZlY3RvcjMsXG4gICAgdGFyZ2V0UG9zaXRpb246IFZlY3RvcjMsXG4gICAgdW5pdEluZGV4OiBudW1iZXIsXG4gICAgY3VycmVudFRpbWU6IG51bWJlclxuICApOiB2b2lkIHtcbiAgICBjb25zdCB1bml0RW50aXR5ID0gdGhpcy53b3JsZC5jcmVhdGVFbnRpdHkoKTtcbiAgICBjb25zdCB1bml0SWQgPSBgJHtvd25lcklkfV91bml0XyR7Y3VycmVudFRpbWV9XyR7dW5pdEluZGV4fWA7XG5cbiAgICAvLyBBZGQgb2Zmc2V0IHRvIHNwYXduIHBvc2l0aW9uIHRvIGF2b2lkIHN0YWNraW5nXG4gICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoXG4gICAgICAodW5pdEluZGV4IC0gMC41KSAqIDIsIC8vIFNwcmVhZCB1bml0cyBsZWZ0L3JpZ2h0XG4gICAgICAwLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgYWN0dWFsU3Bhd25Qb3NpdGlvbiA9IHNwYXduUG9zaXRpb24uY2xvbmUoKS5hZGQob2Zmc2V0KTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy53b3JsZC5jcmVhdGVDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24oYWN0dWFsU3Bhd25Qb3NpdGlvbi54LCBhY3R1YWxTcGF3blBvc2l0aW9uLnksIGFjdHVhbFNwYXduUG9zaXRpb24ueik7XG4gICAgdW5pdEVudGl0eS5hZGRDb21wb25lbnQodHJhbnNmb3JtKTtcblxuICAgIC8vIEFkZCBTdW1tb25lZFVuaXQgY29tcG9uZW50XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gdGhpcy53b3JsZC5jcmVhdGVDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBzdW1tb25lZFVuaXQub3duZXJJZCA9IG93bmVySWQ7XG4gICAgc3VtbW9uZWRVbml0LnVuaXRJZCA9IHVuaXRJZDtcbiAgICBzdW1tb25lZFVuaXQudGFyZ2V0UG9zaXRpb24gPSB7XG4gICAgICB4OiB0YXJnZXRQb3NpdGlvbi54LFxuICAgICAgeTogdGFyZ2V0UG9zaXRpb24ueSxcbiAgICAgIHo6IHRhcmdldFBvc2l0aW9uLnpcbiAgICB9O1xuICAgIHN1bW1vbmVkVW5pdC5zdW1tb25UaW1lID0gY3VycmVudFRpbWU7XG4gICAgdW5pdEVudGl0eS5hZGRDb21wb25lbnQoc3VtbW9uZWRVbml0KTtcblxuICAgIC8vIEFkZCBIZWFsdGggY29tcG9uZW50XG4gICAgY29uc3QgaGVhbHRoID0gbmV3IEhlYWx0aChzdW1tb25lZFVuaXQubWF4SGVhbHRoKTtcbiAgICB1bml0RW50aXR5LmFkZENvbXBvbmVudChoZWFsdGgpO1xuXG4gICAgLy8gQWRkIE1vdmVtZW50IGNvbXBvbmVudFxuICAgIGNvbnN0IG1vdmVtZW50ID0gdGhpcy53b3JsZC5jcmVhdGVDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIG1vdmVtZW50Lm1heFNwZWVkID0gc3VtbW9uZWRVbml0Lm1vdmVTcGVlZDtcbiAgICBtb3ZlbWVudC5mcmljdGlvbiA9IDAuOTtcbiAgICB1bml0RW50aXR5LmFkZENvbXBvbmVudChtb3ZlbWVudCk7XG5cbiAgICAvLyBBZGQgQ29sbGlkZXIgY29tcG9uZW50XG4gICAgY29uc3QgY29sbGlkZXIgPSB0aGlzLndvcmxkLmNyZWF0ZUNvbXBvbmVudChDb2xsaWRlcik7XG4gICAgY29sbGlkZXIudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7IC8vIFVzZSBzcGhlcmUgY29sbGlkZXIgZm9yIHVuaXRzXG4gICAgY29sbGlkZXIucmFkaXVzID0gMC41O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuRU5FTVk7IC8vIFVzZSBlbmVteSBsYXllciBmb3IgUFZQXG4gICAgY29sbGlkZXIuc2V0T2Zmc2V0KDAsIDAuNiwgMCk7IC8vIENlbnRlciBvbiB1bml0XG4gICAgdW5pdEVudGl0eS5hZGRDb21wb25lbnQoY29sbGlkZXIpO1xuXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZCh1bml0RW50aXR5KTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgZXh0ZXJuYWwgYWNjZXNzXG4gIHB1YmxpYyBnZXRVbml0Q291bnQob3duZXJJZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCB1bml0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBTdW1tb25lZFVuaXQsIEhlYWx0aF0pO1xuICAgIHJldHVybiB1bml0cy5maWx0ZXIoZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHVuaXQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCk7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICByZXR1cm4gdW5pdCAmJiBoZWFsdGggJiYgdW5pdC5vd25lcklkID09PSBvd25lcklkICYmIHVuaXQuaXNBY3RpdmUgJiYgIXVuaXQuaXNEZWFkICYmICFoZWFsdGguaXNEZWFkO1xuICAgIH0pLmxlbmd0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxVbml0cygpOiBFbnRpdHlbXSB7XG4gICAgcmV0dXJuIHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBTdW1tb25lZFVuaXQsIEhlYWx0aF0pO1xuICB9XG5cbiAgcHVibGljIGdldFVuaXRzQnlPd25lcihvd25lcklkOiBzdHJpbmcpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgYWxsVW5pdHMgPSB0aGlzLmdldEFsbFVuaXRzKCk7XG4gICAgcmV0dXJuIGFsbFVuaXRzLmZpbHRlcihlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgdW5pdCA9IGVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICAgIHJldHVybiB1bml0ICYmIHVuaXQub3duZXJJZCA9PT0gb3duZXJJZDtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBvbkRpc2FibGUoKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgd2hlbiBzeXN0ZW0gaXMgZGlzYWJsZWRcbiAgICB0aGlzLmxhc3RTcGF3blRpbWUuY2xlYXIoKTtcbiAgICB0aGlzLnBsYXllclBvc2l0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMudG93ZXJQb3NpdGlvbnMuY2xlYXIoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkhlYWx0aCIsIlN1bW1vbmVkVW5pdCIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJDb2xsaWRlclR5cGUiLCJUb3dlciIsIlN1bW1vbmVkVW5pdFN5c3RlbSIsInNldENvbWJhdFN5c3RlbSIsImNvbWJhdFN5c3RlbSIsInVwZGF0ZVBsYXllclBvc2l0aW9uIiwicGxheWVySWQiLCJwb3NpdGlvbiIsInBsYXllclBvc2l0aW9ucyIsInNldCIsImNsb25lIiwidXBkYXRlVG93ZXJQb3NpdGlvbiIsInRvd2VySWQiLCJ0b3dlclBvc2l0aW9ucyIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwidW5pdHNUb0Rlc3Ryb3kiLCJsZW5ndGgiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJ1bml0IiwiaGVhbHRoIiwiaXNFeHBpcmVkIiwicHVzaCIsImlkIiwiaXNEZWFkIiwiZGllIiwiaXNBY3RpdmUiLCJ1cGRhdGVVbml0QmVoYXZpb3IiLCJoYW5kbGVVbml0U3Bhd25pbmciLCJlbnRpdHlJZCIsIndvcmxkIiwiZGVzdHJveUVudGl0eSIsImNhblNlYXJjaEZvclRhcmdldHMiLCJmaW5kVGFyZ2V0Rm9yVW5pdCIsInVwZGF0ZVRhcmdldFNlYXJjaCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRQb3NpdGlvbiIsIm1vdmVUb3dhcmRzUG9zaXRpb24iLCJjYW5BdHRhY2siLCJoYW5kbGVVbml0QXR0YWNrIiwidW5pdFBvc2l0aW9uIiwiZW5lbXlVbml0cyIsImZpbmRFbmVteVVuaXRzIiwib3duZXJJZCIsImNsb3Nlc3RVbml0IiwiZmluZENsb3Nlc3RFbnRpdHkiLCJzZXRUYXJnZXQiLCJlbmVteVRvd2VyIiwiZmluZEVuZW15VG93ZXIiLCJjbGVhclRhcmdldCIsImFsbEVudGl0aWVzIiwicXVlcnlFbnRpdGllcyIsInN1bW1vbmVkVW5pdCIsImNvbGxpZGVyIiwibGF5ZXIiLCJFTkVNWSIsInRvd2VyIiwiZnJvbVBvc2l0aW9uIiwiY2xvc2VzdEVudGl0eSIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiY3VycmVudFBvcyIsInRhcmdldFBvcyIsIngiLCJ5IiwieiIsInRlbXBWZWN0b3IiLCJjb3B5Iiwic3ViIiwibm9ybWFsaXplIiwibW92ZURpc3RhbmNlIiwibW92ZVNwZWVkIiwibmV3UG9zaXRpb24iLCJhZGQiLCJtdWx0aXBseVNjYWxhciIsInNldFBvc2l0aW9uIiwibW92ZW1lbnQiLCJ2ZWxvY2l0eSIsInRhcmdldEVudGl0eSIsImdldEVudGl0eSIsInRhcmdldFRyYW5zZm9ybSIsInRhcmdldEhlYWx0aCIsInVuaXRUcmFuc2Zvcm0iLCJhdHRhY2tSYW5nZSIsInF1ZXVlRGFtYWdlIiwiYXR0YWNrRGFtYWdlIiwidGFrZURhbWFnZSIsInBlcmZvcm1BdHRhY2siLCJ0b3dlcnMiLCJ0b3dlckVudGl0eSIsInRvd2VyVHJhbnNmb3JtIiwibGFzdFNwYXduIiwibGFzdFNwYXduVGltZSIsImdldCIsInNwYXduSW50ZXJ2YWwiLCJzcGF3blVuaXRzRm9yVG93ZXIiLCJ0b3dlclBvc2l0aW9uIiwib3Bwb3NpbmdUb3dlclBvc2l0aW9uIiwiZmluZE9wcG9zaW5nVG93ZXJQb3NpdGlvbiIsImkiLCJzcGF3blVuaXQiLCJzcGF3blBvc2l0aW9uIiwidW5pdEluZGV4IiwidW5pdEVudGl0eSIsImNyZWF0ZUVudGl0eSIsInVuaXRJZCIsIm9mZnNldCIsImFjdHVhbFNwYXduUG9zaXRpb24iLCJjcmVhdGVDb21wb25lbnQiLCJhZGRDb21wb25lbnQiLCJzdW1tb25UaW1lIiwibWF4SGVhbHRoIiwibWF4U3BlZWQiLCJmcmljdGlvbiIsInR5cGUiLCJTUEhFUkUiLCJyYWRpdXMiLCJzZXRPZmZzZXQiLCJub3RpZnlFbnRpdHlBZGRlZCIsImdldFVuaXRDb3VudCIsInVuaXRzIiwiZmlsdGVyIiwiZ2V0QWxsVW5pdHMiLCJnZXRVbml0c0J5T3duZXIiLCJhbGxVbml0cyIsIm9uRGlzYWJsZSIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJNYXAiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/SummonedUnitSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/TowerSystem.ts":
/*!************************************!*\
  !*** ./src/systems/TowerSystem.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TowerSystem: function() { return /* binding */ TowerSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n/* harmony import */ var _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n// Tower system for managing PVP tower AI, targeting, and shooting\n\n\n\n\n\n\n\n\nclass TowerSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setProjectileSystem(projectileSystem) {\n        this.projectileSystem = projectileSystem;\n    }\n    setTowerAttackCallback(callback) {\n        this.onTowerAttackCallback = callback;\n    }\n    setPlayerMapping(serverPlayerEntities, localSocketId) {\n        this.serverPlayerEntities = serverPlayerEntities;\n        this.localSocketId = localSocketId;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            if (!transform || !tower || !health) continue;\n            // Check if tower is dead\n            if (health.isDead && !tower.isDead) {\n                tower.die(currentTime);\n                continue;\n            }\n            // Skip inactive or dead towers\n            if (!tower.isActive || tower.isDead) continue;\n            // Search for targets periodically\n            if (tower.canSearchForTargets(currentTime)) {\n                this.searchForTarget(entity, transform, tower, currentTime);\n            }\n            // Validate current target (check if still alive and in range)\n            if (tower.currentTarget) {\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                if (!this.isValidTarget(targetEntity || null, transform, tower)) {\n                    tower.clearTarget();\n                }\n            }\n            // Attack current target if possible\n            if (tower.currentTarget && tower.canAttack(currentTime)) {\n                this.attackTarget(entity, transform, tower, currentTime);\n            }\n        }\n    }\n    searchForTarget(towerEntity, towerTransform, tower, currentTime) {\n        tower.updateTargetSearch(currentTime);\n        // Get all potential targets (players that are not the tower owner)\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        let closestTarget = null;\n        let closestDistance = Infinity;\n        let validTargetCount = 0;\n        for (const target of potentialTargets){\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (targetCollider && targetTransform) {\n                const distance = towerTransform.position.distanceTo(targetTransform.position);\n            }\n            if (!this.isValidTarget(target, towerTransform, tower)) continue;\n            validTargetCount++;\n            const targetTransform2 = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetTransform2) continue;\n            const distance = towerTransform.position.distanceTo(targetTransform2.position);\n            if (distance <= tower.targetSearchRange && distance < closestDistance) {\n                closestTarget = target;\n                closestDistance = distance;\n            }\n        }\n        if (closestTarget) {\n            tower.setTarget(closestTarget.id);\n        } else if (tower.currentTarget) {\n            // Clear target if no valid targets found\n            tower.clearTarget();\n        }\n    }\n    isValidTarget(target, towerTransform, tower) {\n        if (!target) {\n            return false;\n        }\n        const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n        const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n        // Must have required components and be alive\n        if (!targetHealth || !targetTransform || !targetCollider || targetHealth.isDead) {\n            return false;\n        }\n        // Must be a player (not an enemy or other tower)\n        if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.PLAYER && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.ENEMY) {\n            return false;\n        }\n        // Don't target other towers\n        if (target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)) {\n            return false;\n        }\n        // Check if this is a summoned unit\n        const summonedUnit = target.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n        if (summonedUnit) {\n            // Only target enemy summoned units (different owner)\n            return summonedUnit.ownerId !== tower.ownerId;\n        }\n        // In PVP mode, identify if this is an enemy player\n        if (this.localSocketId && this.serverPlayerEntities.size > 0) {\n            // Check if this is the local player (PLAYER layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.PLAYER) {\n                const shouldTarget = tower.ownerId !== this.localSocketId;\n                return shouldTarget;\n            }\n            // Check if this is a remote player (ENEMY layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.ENEMY) {\n                // Find which player this entity belongs to\n                let targetPlayerId = null;\n                this.serverPlayerEntities.forEach((entityId, playerId)=>{\n                    if (entityId === target.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n                if (targetPlayerId) {\n                    const shouldTarget = tower.ownerId !== targetPlayerId;\n                    return shouldTarget;\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n    attackTarget(towerEntity, towerTransform, tower, currentTime) {\n        const targetEntity = this.world.getEntity(tower.currentTarget);\n        if (!targetEntity) {\n            tower.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            tower.clearTarget();\n            return;\n        }\n        // Calculate direction to target\n        this.tempVector.copy(targetTransform.position);\n        this.tempVector.sub(towerTransform.position);\n        const distance = this.tempVector.length();\n        // Check if target is still in range\n        if (distance > tower.attackRange) {\n            tower.clearTarget();\n            return;\n        }\n        // Normalize direction\n        this.tempVector.normalize();\n        // Calculate projectile spawn position (slightly above tower center)\n        this.tempVector2.copy(towerTransform.position);\n        this.tempVector2.y += 2; // Spawn projectiles 2 units above tower base\n        // Create projectile\n        if (this.projectileSystem) {\n            const projectileConfig = {\n                speed: tower.projectileSpeed,\n                damage: tower.attackDamage,\n                lifetime: 2,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, this.tempVector2, this.tempVector, towerEntity.id, projectileConfig);\n            // Enable homing for tower projectiles\n            const projectile = projectileEntity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__.Projectile);\n            if (projectile && tower.currentTarget) {\n                // Set homing towards the current target with strong homing (0.9) and fast turn rate (4 radians/sec)\n                projectile.setHoming(tower.currentTarget, 0.9, 4.0);\n            }\n            // Mark projectile as tower projectile for special handling\n            const projectileRenderer = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (projectileRenderer) {\n                // Add metadata to identify this as a tower projectile\n                projectileEntity.isTowerProjectile = true;\n                projectileEntity.towerOwnerId = tower.ownerId;\n            }\n        }\n        // Broadcast attack to multiplayer if callback is set\n        if (this.onTowerAttackCallback) {\n            // We need to map the target entity back to a player ID\n            // For now, we'll use a placeholder - this will need to be improved with proper player mapping\n            const targetPlayerId = \"player_\".concat(tower.currentTarget);\n            this.onTowerAttackCallback(tower.ownerId, targetPlayerId, this.tempVector2, this.tempVector);\n        }\n        tower.performAttack(currentTime);\n    }\n    // Utility method to get all towers owned by a specific player\n    getTowersByOwner(ownerId) {\n        const allTowers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ]);\n        return allTowers.filter((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            return tower && tower.ownerId === ownerId;\n        });\n    }\n    // Utility method to get tower count for a player\n    getTowerCount(ownerId) {\n        return this.getTowersByOwner(ownerId).length;\n    }\n    // Utility method to check if a player has any active towers\n    hasActiveTowers(ownerId) {\n        const towers = this.getTowersByOwner(ownerId);\n        return towers.some((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            return tower && health && tower.isActive && !tower.isDead && !health.isDead;\n        });\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ];\n        this.projectileSystem = null;\n        // Player entity mapping for identifying tower owners vs enemies\n        this.serverPlayerEntities = new Map();\n        this.localSocketId = null;\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 25; // Run after movement and projectiles\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRWlCO0FBQ047QUFDRjtBQUNjO0FBQ0o7QUFDWTtBQUk5RCxNQUFNUyxvQkFBb0JSLCtDQUFNQTtJQXNCOUJTLG9CQUFvQkMsZ0JBQWtDLEVBQVE7UUFDbkUsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBR0E7SUFDMUI7SUFFT0MsdUJBQXVCQyxRQUF1RyxFQUFRO1FBQzNJLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRU9FLGlCQUFpQkMsb0JBQXlDLEVBQUVDLGFBQXFCLEVBQVE7UUFDOUYsSUFBSSxDQUFDRCxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxhQUFhLEdBQUdBO0lBQ3ZCO0lBRU9DLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRyxLQUFLLE1BQU0scUJBQXFCO1FBRTVELEtBQUssTUFBTUMsVUFBVUwsU0FBVTtZQUM3QixNQUFNTSxZQUFZRCxPQUFPRSxZQUFZLENBQUN4QixnRUFBU0E7WUFDL0MsTUFBTXlCLFFBQVFILE9BQU9FLFlBQVksQ0FBQ3RCLHdEQUFLQTtZQUN2QyxNQUFNd0IsU0FBU0osT0FBT0UsWUFBWSxDQUFDdkIsMERBQU1BO1lBRXpDLElBQUksQ0FBQ3NCLGFBQWEsQ0FBQ0UsU0FBUyxDQUFDQyxRQUFRO1lBRXJDLHlCQUF5QjtZQUN6QixJQUFJQSxPQUFPQyxNQUFNLElBQUksQ0FBQ0YsTUFBTUUsTUFBTSxFQUFFO2dCQUNsQ0YsTUFBTUcsR0FBRyxDQUFDVDtnQkFDVjtZQUNGO1lBRUEsK0JBQStCO1lBQy9CLElBQUksQ0FBQ00sTUFBTUksUUFBUSxJQUFJSixNQUFNRSxNQUFNLEVBQUU7WUFFckMsa0NBQWtDO1lBQ2xDLElBQUlGLE1BQU1LLG1CQUFtQixDQUFDWCxjQUFjO2dC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QUMvRSxDQUFBQTtZQUNqQixNQUFNRyxRQUFRSCxPQUFPRSxZQUFZLENBQUN0Qix3REFBS0E7WUFDdkMsTUFBTXdCLFNBQVNKLE9BQU9FLFlBQVksQ0FBQ3ZCLDBEQUFNQTtZQUN6QyxPQUFPd0IsU0FBU0MsVUFBVUQsTUFBTUksUUFBUSxJQUFJLENBQUNKLE1BQU1FLE1BQU0sSUFBSSxDQUFDRCxPQUFPQyxNQUFNO1FBQzdFO0lBQ0Y7SUFwUUEyRSxZQUFZcEUsS0FBWSxDQUFFO1FBQ3hCLEtBQUs7YUFoQlNxRSxxQkFBcUI7WUFBQ3ZHLGdFQUFTQTtZQUFFRSx3REFBS0E7WUFBRUQsMERBQU1BO1NBQUM7YUFFdkRRLG1CQUE0QztRQUtwRCxnRUFBZ0U7YUFDeERLLHVCQUE0QyxJQUFJMEY7YUFDaER6RixnQkFBK0I7UUFFdkMseUNBQXlDO2FBQ2pDeUQsYUFBYSxJQUFJMUUseURBQU9BO2FBQ3hCZ0YsY0FBYyxJQUFJaEYseURBQU9BO1FBSS9CLElBQUksQ0FBQ29DLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN1RSxRQUFRLEdBQUcsSUFBSSxxQ0FBcUM7SUFDM0Q7QUFpUUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvVG93ZXJTeXN0ZW0udHM/NmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUb3dlciBzeXN0ZW0gZm9yIG1hbmFnaW5nIFBWUCB0b3dlciBBSSwgdGFyZ2V0aW5nLCBhbmQgc2hvb3RpbmdcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBUb3dlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVG93ZXInO1xuaW1wb3J0IHsgU3VtbW9uZWRVbml0IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZSc7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlclN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJyb2FkY2FzdGluZyB0b3dlciBhdHRhY2tzIGluIG11bHRpcGxheWVyXG4gIHByaXZhdGUgb25Ub3dlckF0dGFja0NhbGxiYWNrPzogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gUGxheWVyIGVudGl0eSBtYXBwaW5nIGZvciBpZGVudGlmeWluZyB0b3dlciBvd25lcnMgdnMgZW5lbWllc1xuICBwcml2YXRlIHNlcnZlclBsYXllckVudGl0aWVzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGxvY2FsU29ja2V0SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gUmV1c2FibGUgb2JqZWN0cyB0byByZWR1Y2UgYWxsb2NhdGlvbnNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgbW92ZW1lbnQgYW5kIHByb2plY3RpbGVzXG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQcm9qZWN0aWxlU3lzdGVtKHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0gPSBwcm9qZWN0aWxlU3lzdGVtO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VG93ZXJBdHRhY2tDYWxsYmFjayhjYWxsYmFjazogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFBsYXllck1hcHBpbmcoc2VydmVyUGxheWVyRW50aXRpZXM6IE1hcDxzdHJpbmcsIG51bWJlcj4sIGxvY2FsU29ja2V0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMgPSBzZXJ2ZXJQbGF5ZXJFbnRpdGllcztcbiAgICB0aGlzLmxvY2FsU29ja2V0SWQgPSBsb2NhbFNvY2tldElkO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICF0b3dlciB8fCAhaGVhbHRoKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdG93ZXIgaXMgZGVhZFxuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQgJiYgIXRvd2VyLmlzRGVhZCkge1xuICAgICAgICB0b3dlci5kaWUoY3VycmVudFRpbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2tpcCBpbmFjdGl2ZSBvciBkZWFkIHRvd2Vyc1xuICAgICAgaWYgKCF0b3dlci5pc0FjdGl2ZSB8fCB0b3dlci5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBTZWFyY2ggZm9yIHRhcmdldHMgcGVyaW9kaWNhbGx5XG4gICAgICBpZiAodG93ZXIuY2FuU2VhcmNoRm9yVGFyZ2V0cyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGb3JUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGN1cnJlbnQgdGFyZ2V0IChjaGVjayBpZiBzdGlsbCBhbGl2ZSBhbmQgaW4gcmFuZ2UpXG4gICAgICBpZiAodG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eSh0b3dlci5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYXJnZXQodGFyZ2V0RW50aXR5IHx8IG51bGwsIHRyYW5zZm9ybSwgdG93ZXIpKSB7XG4gICAgICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdHRhY2sgY3VycmVudCB0YXJnZXQgaWYgcG9zc2libGVcbiAgICAgIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0ICYmIHRvd2VyLmNhbkF0dGFjayhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5hdHRhY2tUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHNlYXJjaEZvclRhcmdldCh0b3dlckVudGl0eTogRW50aXR5LCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0b3dlci51cGRhdGVUYXJnZXRTZWFyY2goY3VycmVudFRpbWUpO1xuICAgIFxuICAgIC8vIEdldCBhbGwgcG90ZW50aWFsIHRhcmdldHMgKHBsYXllcnMgdGhhdCBhcmUgbm90IHRoZSB0b3dlciBvd25lcilcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBcbiAgICBcbiAgICBsZXQgY2xvc2VzdFRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCB2YWxpZFRhcmdldENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIgJiYgdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhcmdldCh0YXJnZXQsIHRvd2VyVHJhbnNmb3JtLCB0b3dlcikpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICB2YWxpZFRhcmdldENvdW50Kys7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0yID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0yKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0b3dlclRyYW5zZm9ybS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybTIucG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gdG93ZXIudGFyZ2V0U2VhcmNoUmFuZ2UgJiYgZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgY2xvc2VzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGlmIChjbG9zZXN0VGFyZ2V0KSB7XG4gICAgICB0b3dlci5zZXRUYXJnZXQoY2xvc2VzdFRhcmdldC5pZCk7XG4gICAgfSBlbHNlIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhciB0YXJnZXQgaWYgbm8gdmFsaWQgdGFyZ2V0cyBmb3VuZFxuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgaXNWYWxpZFRhcmdldCh0YXJnZXQ6IEVudGl0eSB8IG51bGwsIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBcbiAgICAvLyBNdXN0IGhhdmUgcmVxdWlyZWQgY29tcG9uZW50cyBhbmQgYmUgYWxpdmVcbiAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8ICF0YXJnZXRDb2xsaWRlciB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIE11c3QgYmUgYSBwbGF5ZXIgKG5vdCBhbiBlbmVteSBvciBvdGhlciB0b3dlcilcbiAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLlBMQVlFUiAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdGFyZ2V0IG90aGVyIHRvd2Vyc1xuICAgIGlmICh0YXJnZXQuaGFzQ29tcG9uZW50KFRvd2VyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBzdW1tb25lZCB1bml0XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gdGFyZ2V0LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgIGlmIChzdW1tb25lZFVuaXQpIHtcbiAgICAgIC8vIE9ubHkgdGFyZ2V0IGVuZW15IHN1bW1vbmVkIHVuaXRzIChkaWZmZXJlbnQgb3duZXIpXG4gICAgICByZXR1cm4gc3VtbW9uZWRVbml0Lm93bmVySWQgIT09IHRvd2VyLm93bmVySWQ7XG4gICAgfVxuXG4gICAgLy8gSW4gUFZQIG1vZGUsIGlkZW50aWZ5IGlmIHRoaXMgaXMgYW4gZW5lbXkgcGxheWVyXG4gICAgaWYgKHRoaXMubG9jYWxTb2NrZXRJZCAmJiB0aGlzLnNlcnZlclBsYXllckVudGl0aWVzLnNpemUgPiAwKSB7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGxvY2FsIHBsYXllciAoUExBWUVSIGxheWVyKVxuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVIpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkVGFyZ2V0ID0gdG93ZXIub3duZXJJZCAhPT0gdGhpcy5sb2NhbFNvY2tldElkO1xuICAgICAgICByZXR1cm4gc2hvdWxkVGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmVtb3RlIHBsYXllciAoRU5FTVkgbGF5ZXIpXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLkVORU1ZKSB7XG4gICAgICAgIC8vIEZpbmQgd2hpY2ggcGxheWVyIHRoaXMgZW50aXR5IGJlbG9uZ3MgdG9cbiAgICAgICAgbGV0IHRhcmdldFBsYXllcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJQbGF5ZXJFbnRpdGllcy5mb3JFYWNoKChlbnRpdHlJZCwgcGxheWVySWQpID0+IHtcbiAgICAgICAgICBpZiAoZW50aXR5SWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgICAgICAgdGFyZ2V0UGxheWVySWQgPSBwbGF5ZXJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0YXJnZXRQbGF5ZXJJZCkge1xuICAgICAgICAgIGNvbnN0IHNob3VsZFRhcmdldCA9IHRvd2VyLm93bmVySWQgIT09IHRhcmdldFBsYXllcklkO1xuICAgICAgICAgIHJldHVybiBzaG91bGRUYXJnZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHByaXZhdGUgYXR0YWNrVGFyZ2V0KHRvd2VyRW50aXR5OiBFbnRpdHksIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHRvd2VyLmN1cnJlbnRUYXJnZXQhKTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgdGhpcy50ZW1wVmVjdG9yLnN1Yih0b3dlclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnRlbXBWZWN0b3IubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHN0aWxsIGluIHJhbmdlXG4gICAgaWYgKGRpc3RhbmNlID4gdG93ZXIuYXR0YWNrUmFuZ2UpIHtcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb25cbiAgICB0aGlzLnRlbXBWZWN0b3Iubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gKHNsaWdodGx5IGFib3ZlIHRvd2VyIGNlbnRlcilcbiAgICB0aGlzLnRlbXBWZWN0b3IyLmNvcHkodG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGVtcFZlY3RvcjIueSArPSAyOyAvLyBTcGF3biBwcm9qZWN0aWxlcyAyIHVuaXRzIGFib3ZlIHRvd2VyIGJhc2VcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLnByb2plY3RpbGVTeXN0ZW0pIHtcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiB0b3dlci5wcm9qZWN0aWxlU3BlZWQsXG4gICAgICAgIGRhbWFnZTogdG93ZXIuYXR0YWNrRGFtYWdlLFxuICAgICAgICBsaWZldGltZTogMiwgLy8gNSBzZWNvbmQgbGlmZXRpbWVcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHRoaXMudGVtcFZlY3RvcjIsIC8vIHNwYXduIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudGVtcFZlY3RvciwgIC8vIGRpcmVjdGlvblxuICAgICAgICB0b3dlckVudGl0eS5pZCwgICAvLyB0b3dlciBhcyBvd25lclxuICAgICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgICApO1xuXG4gICAgICAvLyBFbmFibGUgaG9taW5nIGZvciB0b3dlciBwcm9qZWN0aWxlc1xuICAgICAgY29uc3QgcHJvamVjdGlsZSA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgICAgaWYgKHByb2plY3RpbGUgJiYgdG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgICAvLyBTZXQgaG9taW5nIHRvd2FyZHMgdGhlIGN1cnJlbnQgdGFyZ2V0IHdpdGggc3Ryb25nIGhvbWluZyAoMC45KSBhbmQgZmFzdCB0dXJuIHJhdGUgKDQgcmFkaWFucy9zZWMpXG4gICAgICAgIHByb2plY3RpbGUuc2V0SG9taW5nKHRvd2VyLmN1cnJlbnRUYXJnZXQsIDAuOSwgNC4wKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFyayBwcm9qZWN0aWxlIGFzIHRvd2VyIHByb2plY3RpbGUgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHByb2plY3RpbGVSZW5kZXJlciA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAocHJvamVjdGlsZVJlbmRlcmVyKSB7XG4gICAgICAgIC8vIEFkZCBtZXRhZGF0YSB0byBpZGVudGlmeSB0aGlzIGFzIGEgdG93ZXIgcHJvamVjdGlsZVxuICAgICAgICAocHJvamVjdGlsZUVudGl0eSBhcyBhbnkpLmlzVG93ZXJQcm9qZWN0aWxlID0gdHJ1ZTtcbiAgICAgICAgKHByb2plY3RpbGVFbnRpdHkgYXMgYW55KS50b3dlck93bmVySWQgPSB0b3dlci5vd25lcklkO1xuICAgICAgfVxuXG4gICAgfVxuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBhdHRhY2sgdG8gbXVsdGlwbGF5ZXIgaWYgY2FsbGJhY2sgaXMgc2V0XG4gICAgaWYgKHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIG1hcCB0aGUgdGFyZ2V0IGVudGl0eSBiYWNrIHRvIGEgcGxheWVyIElEXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCB1c2UgYSBwbGFjZWhvbGRlciAtIHRoaXMgd2lsbCBuZWVkIHRvIGJlIGltcHJvdmVkIHdpdGggcHJvcGVyIHBsYXllciBtYXBwaW5nXG4gICAgICBjb25zdCB0YXJnZXRQbGF5ZXJJZCA9IGBwbGF5ZXJfJHt0b3dlci5jdXJyZW50VGFyZ2V0fWA7XG4gICAgICB0aGlzLm9uVG93ZXJBdHRhY2tDYWxsYmFjayh0b3dlci5vd25lcklkLCB0YXJnZXRQbGF5ZXJJZCwgdGhpcy50ZW1wVmVjdG9yMiwgdGhpcy50ZW1wVmVjdG9yKTtcbiAgICB9XG4gICAgXG4gICAgdG93ZXIucGVyZm9ybUF0dGFjayhjdXJyZW50VGltZSk7XG4gIH1cbiAgXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGdldCBhbGwgdG93ZXJzIG93bmVkIGJ5IGEgc3BlY2lmaWMgcGxheWVyXG4gIHB1YmxpYyBnZXRUb3dlcnNCeU93bmVyKG93bmVySWQ6IHN0cmluZyk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBhbGxUb3dlcnMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aF0pO1xuICAgIHJldHVybiBhbGxUb3dlcnMuZmlsdGVyKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgcmV0dXJuIHRvd2VyICYmIHRvd2VyLm93bmVySWQgPT09IG93bmVySWQ7XG4gICAgfSk7XG4gIH1cbiAgXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGdldCB0b3dlciBjb3VudCBmb3IgYSBwbGF5ZXJcbiAgcHVibGljIGdldFRvd2VyQ291bnQob3duZXJJZDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUb3dlcnNCeU93bmVyKG93bmVySWQpLmxlbmd0aDtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gY2hlY2sgaWYgYSBwbGF5ZXIgaGFzIGFueSBhY3RpdmUgdG93ZXJzXG4gIHB1YmxpYyBoYXNBY3RpdmVUb3dlcnMob3duZXJJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdG93ZXJzID0gdGhpcy5nZXRUb3dlcnNCeU93bmVyKG93bmVySWQpO1xuICAgIHJldHVybiB0b3dlcnMuc29tZShlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgdG93ZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRvd2VyKTtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIHJldHVybiB0b3dlciAmJiBoZWFsdGggJiYgdG93ZXIuaXNBY3RpdmUgJiYgIXRvd2VyLmlzRGVhZCAmJiAhaGVhbHRoLmlzRGVhZDtcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJIZWFsdGgiLCJUb3dlciIsIlN1bW1vbmVkVW5pdCIsIlByb2plY3RpbGUiLCJDb2xsaWRlciIsIkNvbGxpc2lvbkxheWVyIiwiVG93ZXJTeXN0ZW0iLCJzZXRQcm9qZWN0aWxlU3lzdGVtIiwicHJvamVjdGlsZVN5c3RlbSIsInNldFRvd2VyQXR0YWNrQ2FsbGJhY2siLCJjYWxsYmFjayIsIm9uVG93ZXJBdHRhY2tDYWxsYmFjayIsInNldFBsYXllck1hcHBpbmciLCJzZXJ2ZXJQbGF5ZXJFbnRpdGllcyIsImxvY2FsU29ja2V0SWQiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInRvd2VyIiwiaGVhbHRoIiwiaXNEZWFkIiwiZGllIiwiaXNBY3RpdmUiLCJjYW5TZWFyY2hGb3JUYXJnZXRzIiwic2VhcmNoRm9yVGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldEVudGl0eSIsIndvcmxkIiwiZ2V0RW50aXR5IiwiaXNWYWxpZFRhcmdldCIsImNsZWFyVGFyZ2V0IiwiY2FuQXR0YWNrIiwiYXR0YWNrVGFyZ2V0IiwidG93ZXJFbnRpdHkiLCJ0b3dlclRyYW5zZm9ybSIsInVwZGF0ZVRhcmdldFNlYXJjaCIsInBvdGVudGlhbFRhcmdldHMiLCJxdWVyeUVudGl0aWVzIiwiY2xvc2VzdFRhcmdldCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwidmFsaWRUYXJnZXRDb3VudCIsInRhcmdldCIsInRhcmdldENvbGxpZGVyIiwidGFyZ2V0VHJhbnNmb3JtIiwiZGlzdGFuY2UiLCJwb3NpdGlvbiIsImRpc3RhbmNlVG8iLCJ0YXJnZXRUcmFuc2Zvcm0yIiwidGFyZ2V0U2VhcmNoUmFuZ2UiLCJzZXRUYXJnZXQiLCJpZCIsInRhcmdldEhlYWx0aCIsImxheWVyIiwiUExBWUVSIiwiRU5FTVkiLCJoYXNDb21wb25lbnQiLCJzdW1tb25lZFVuaXQiLCJvd25lcklkIiwic2l6ZSIsInNob3VsZFRhcmdldCIsInRhcmdldFBsYXllcklkIiwiZm9yRWFjaCIsImVudGl0eUlkIiwicGxheWVySWQiLCJ0ZW1wVmVjdG9yIiwiY29weSIsInN1YiIsImxlbmd0aCIsImF0dGFja1JhbmdlIiwibm9ybWFsaXplIiwidGVtcFZlY3RvcjIiLCJ5IiwicHJvamVjdGlsZUNvbmZpZyIsInNwZWVkIiwicHJvamVjdGlsZVNwZWVkIiwiZGFtYWdlIiwiYXR0YWNrRGFtYWdlIiwibGlmZXRpbWUiLCJvcGFjaXR5IiwicHJvamVjdGlsZUVudGl0eSIsImNyZWF0ZVByb2plY3RpbGUiLCJwcm9qZWN0aWxlIiwic2V0SG9taW5nIiwicHJvamVjdGlsZVJlbmRlcmVyIiwiaXNUb3dlclByb2plY3RpbGUiLCJ0b3dlck93bmVySWQiLCJwZXJmb3JtQXR0YWNrIiwiZ2V0VG93ZXJzQnlPd25lciIsImFsbFRvd2VycyIsImZpbHRlciIsImdldFRvd2VyQ291bnQiLCJoYXNBY3RpdmVUb3dlcnMiLCJ0b3dlcnMiLCJzb21lIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJNYXAiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/TowerSystem.ts\n"));

/***/ })

}]);