"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["game-systems"],{

/***/ "(app-pages-browser)/./src/core/DamageCalculator.ts":
/*!**************************************!*\
  !*** ./src/core/DamageCalculator.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDamage: function() { return /* binding */ calculateDamage; },\n/* harmony export */   getCriticalChance: function() { return /* binding */ getCriticalChance; },\n/* harmony export */   getCriticalDamageMultiplier: function() { return /* binding */ getCriticalDamageMultiplier; },\n/* harmony export */   getGlobalRuneCounts: function() { return /* binding */ getGlobalRuneCounts; },\n/* harmony export */   setGlobalCritDamageRuneCount: function() { return /* binding */ setGlobalCritDamageRuneCount; },\n/* harmony export */   setGlobalCriticalRuneCount: function() { return /* binding */ setGlobalCriticalRuneCount; }\n/* harmony export */ });\n// Core damage calculation system with critical hit mechanics\n// Placed in core/ for performance and shared access across all systems\n// Global rune counts - will be updated by the GameState context\nlet globalCriticalRuneCount = 0;\nlet globalCritDamageRuneCount = 0;\nfunction setGlobalCriticalRuneCount(count) {\n    globalCriticalRuneCount = count;\n}\nfunction setGlobalCritDamageRuneCount(count) {\n    globalCritDamageRuneCount = count;\n}\nfunction calculateDamage(baseAmount) {\n    // Base crit chance is 11%, each rune adds 3%\n    const criticalChance = 0.11 + globalCriticalRuneCount * 0.03;\n    const isCritical = Math.random() < criticalChance;\n    // Base crit damage multiplier is 2x, each crit damage rune adds 0.15x\n    const criticalDamageMultiplier = 2.0 + globalCritDamageRuneCount * 0.15;\n    const rawDamage = isCritical ? baseAmount * criticalDamageMultiplier : baseAmount;\n    // Round down to integer to avoid floating point precision issues\n    const damage = Math.floor(rawDamage);\n    return {\n        damage,\n        isCritical\n    };\n}\n// Utility functions for debugging and testing\nfunction getCriticalChance() {\n    return 0.11 + globalCriticalRuneCount * 0.03;\n}\nfunction getCriticalDamageMultiplier() {\n    return 2.0 + globalCritDamageRuneCount * 0.15;\n}\nfunction getGlobalRuneCounts() {\n    return {\n        criticalRunes: globalCriticalRuneCount,\n        critDamageRunes: globalCritDamageRuneCount\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0RhbWFnZUNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQzdELHVFQUF1RTtBQU92RSxnRUFBZ0U7QUFDaEUsSUFBSUEsMEJBQTBCO0FBQzlCLElBQUlDLDRCQUE0QjtBQUV6QixTQUFTQywyQkFBMkJDLEtBQWE7SUFDdERILDBCQUEwQkc7QUFDNUI7QUFFTyxTQUFTQyw2QkFBNkJELEtBQWE7SUFDeERGLDRCQUE0QkU7QUFDOUI7QUFFTyxTQUFTRSxnQkFBZ0JDLFVBQWtCO0lBQ2hELDZDQUE2QztJQUM3QyxNQUFNQyxpQkFBaUIsT0FBUVAsMEJBQTBCO0lBQ3pELE1BQU1RLGFBQWFDLEtBQUtDLE1BQU0sS0FBS0g7SUFFbkMsc0VBQXNFO0lBQ3RFLE1BQU1JLDJCQUEyQixNQUFPViw0QkFBNEI7SUFDcEUsTUFBTVcsWUFBWUosYUFBYUYsYUFBYUssMkJBQTJCTDtJQUV2RSxpRUFBaUU7SUFDakUsTUFBTU8sU0FBU0osS0FBS0ssS0FBSyxDQUFDRjtJQUUxQixPQUFPO1FBQUVDO1FBQVFMO0lBQVc7QUFDOUI7QUFFQSw4Q0FBOEM7QUFDdkMsU0FBU087SUFDZCxPQUFPLE9BQVFmLDBCQUEwQjtBQUMzQztBQUVPLFNBQVNnQjtJQUNkLE9BQU8sTUFBT2YsNEJBQTRCO0FBQzVDO0FBRU8sU0FBU2dCO0lBQ2QsT0FBTztRQUNMQyxlQUFlbEI7UUFDZm1CLGlCQUFpQmxCO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvRGFtYWdlQ2FsY3VsYXRvci50cz8yNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgZGFtYWdlIGNhbGN1bGF0aW9uIHN5c3RlbSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3Ncbi8vIFBsYWNlZCBpbiBjb3JlLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHNoYXJlZCBhY2Nlc3MgYWNyb3NzIGFsbCBzeXN0ZW1zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFtYWdlUmVzdWx0IHtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIGlzQ3JpdGljYWw6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBydW5lIGNvdW50cyAtIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgR2FtZVN0YXRlIGNvbnRleHRcbmxldCBnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCA9IDA7XG5sZXQgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0aWNhbFJ1bmVDb3VudChjb3VudDogbnVtYmVyKSB7XG4gIGdsb2JhbENyaXRpY2FsUnVuZUNvdW50ID0gY291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50KGNvdW50OiBudW1iZXIpIHtcbiAgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IGNvdW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGFtYWdlKGJhc2VBbW91bnQ6IG51bWJlcik6IERhbWFnZVJlc3VsdCB7XG4gIC8vIEJhc2UgY3JpdCBjaGFuY2UgaXMgMTElLCBlYWNoIHJ1bmUgYWRkcyAzJVxuICBjb25zdCBjcml0aWNhbENoYW5jZSA9IDAuMTEgKyAoZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQgKiAwLjAzKTtcbiAgY29uc3QgaXNDcml0aWNhbCA9IE1hdGgucmFuZG9tKCkgPCBjcml0aWNhbENoYW5jZTtcbiAgXG4gIC8vIEJhc2UgY3JpdCBkYW1hZ2UgbXVsdGlwbGllciBpcyAyeCwgZWFjaCBjcml0IGRhbWFnZSBydW5lIGFkZHMgMC4xNXhcbiAgY29uc3QgY3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyID0gMi4wICsgKGdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQgKiAwLjE1KTtcbiAgY29uc3QgcmF3RGFtYWdlID0gaXNDcml0aWNhbCA/IGJhc2VBbW91bnQgKiBjcml0aWNhbERhbWFnZU11bHRpcGxpZXIgOiBiYXNlQW1vdW50O1xuICBcbiAgLy8gUm91bmQgZG93biB0byBpbnRlZ2VyIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXNcbiAgY29uc3QgZGFtYWdlID0gTWF0aC5mbG9vcihyYXdEYW1hZ2UpO1xuICBcbiAgcmV0dXJuIHsgZGFtYWdlLCBpc0NyaXRpY2FsIH07XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcml0aWNhbENoYW5jZSgpOiBudW1iZXIge1xuICByZXR1cm4gMC4xMSArIChnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCAqIDAuMDMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyKCk6IG51bWJlciB7XG4gIHJldHVybiAyLjAgKyAoZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCAqIDAuMTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsUnVuZUNvdW50cygpOiB7IGNyaXRpY2FsUnVuZXM6IG51bWJlcjsgY3JpdERhbWFnZVJ1bmVzOiBudW1iZXIgfSB7XG4gIHJldHVybiB7XG4gICAgY3JpdGljYWxSdW5lczogZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQsXG4gICAgY3JpdERhbWFnZVJ1bmVzOiBnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50Iiwic2V0R2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJjb3VudCIsInNldEdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJiYXNlQW1vdW50IiwiY3JpdGljYWxDaGFuY2UiLCJpc0NyaXRpY2FsIiwiTWF0aCIsInJhbmRvbSIsImNyaXRpY2FsRGFtYWdlTXVsdGlwbGllciIsInJhd0RhbWFnZSIsImRhbWFnZSIsImZsb29yIiwiZ2V0Q3JpdGljYWxDaGFuY2UiLCJnZXRDcml0aWNhbERhbWFnZU11bHRpcGxpZXIiLCJnZXRHbG9iYWxSdW5lQ291bnRzIiwiY3JpdGljYWxSdW5lcyIsImNyaXREYW1hZ2VSdW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/DamageCalculator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/Engine.ts":
/*!****************************!*\
  !*** ./src/core/Engine.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: function() { return /* binding */ Engine; }\n/* harmony export */ });\n/* harmony import */ var _ecs_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/World */ \"(app-pages-browser)/./src/ecs/World.ts\");\n/* harmony import */ var _GameLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameLoop */ \"(app-pages-browser)/./src/core/GameLoop.ts\");\n/* harmony import */ var _InputManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InputManager */ \"(app-pages-browser)/./src/core/InputManager.ts\");\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Main game engine with ECS integration\n\n\n\n\nclass Engine extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    async initialize(canvas) {\n        if (this.isInitialized) {\n            return;\n        }\n        this.canvas = canvas;\n        this.inputManager.initialize(canvas);\n        this.isInitialized = true;\n        this.emit(\"initialized\");\n    }\n    start() {\n        if (!this.isInitialized) {\n            throw new Error(\"Engine must be initialized before starting\");\n        }\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.gameLoop.start();\n        this.emit(\"started\");\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.gameLoop.stop();\n        this.emit(\"stopped\");\n    }\n    pause() {\n        if (this.isRunning) {\n            this.gameLoop.pause();\n            this.emit(\"paused\");\n        }\n    }\n    resume() {\n        if (this.isRunning) {\n            this.gameLoop.resume();\n            this.emit(\"resumed\");\n        }\n    }\n    getWorld() {\n        return this.world;\n    }\n    getInputManager() {\n        return this.inputManager;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isEngineRunning() {\n        return this.isRunning;\n    }\n    getCurrentFPS() {\n        return this.gameLoop.getCurrentFPS();\n    }\n    getPerformanceStats() {\n        return {\n            fps: this.gameLoop.getCurrentFPS(),\n            frameTime: this.frameTime,\n            updateTime: this.updateTime,\n            renderTime: this.renderTime\n        };\n    }\n    enableDebugMode(enabled) {\n        this.debugMode = enabled;\n    }\n    isDebugMode() {\n        return this.debugMode;\n    }\n    setupGameLoop() {\n        // Handle fixed timestep updates (physics)\n        this.gameLoop.on(\"fixedUpdate\", (param)=>{\n            let { fixedDeltaTime } = param;\n            const startTime = performance.now();\n            this.world.fixedUpdate(fixedDeltaTime);\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n        });\n        // Handle variable timestep updates (game logic)\n        this.gameLoop.on(\"update\", (param)=>{\n            let { deltaTime } = param;\n            const startTime = performance.now();\n            // Update world systems first so they can read input deltas\n            this.world.update(deltaTime);\n            // Update input manager after systems have processed input\n            this.inputManager.update();\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n            this.emit(\"update\", {\n                deltaTime\n            });\n        });\n        // Handle rendering\n        this.gameLoop.on(\"render\", (param)=>{\n            let { deltaTime, interpolation } = param;\n            const startTime = performance.now();\n            // Render world\n            this.world.render(deltaTime);\n            if (this.debugMode) {\n                this.renderTime = performance.now() - startTime;\n                this.frameTime = this.updateTime + this.renderTime;\n            }\n            this.emit(\"render\", {\n                deltaTime,\n                interpolation\n            });\n        });\n    }\n    destroy() {\n        this.stop();\n        // Clean up systems\n        this.world.destroy();\n        this.inputManager.destroy();\n        // Clear event listeners\n        this.removeAllListeners();\n        this.isInitialized = false;\n    }\n    // Utility methods for common operations\n    requestPointerLock() {\n        this.inputManager.requestPointerLock();\n    }\n    exitPointerLock() {\n        this.inputManager.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.inputManager.isKeyPressed(key);\n    }\n    isMouseButtonPressed(button) {\n        return this.inputManager.isMouseButtonPressed(button);\n    }\n    getMouseDelta() {\n        return this.inputManager.getMouseDelta();\n    }\n    constructor(config = {}){\n        super();\n        this.canvas = null;\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.debugMode = false;\n        // Performance monitoring\n        this.frameTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.world = new _ecs_World__WEBPACK_IMPORTED_MODULE_0__.World();\n        this.gameLoop = new _GameLoop__WEBPACK_IMPORTED_MODULE_1__.GameLoop();\n        this.inputManager = new _InputManager__WEBPACK_IMPORTED_MODULE_2__.InputManager();\n        this.debugMode = config.enableDebug || false;\n        this.setupGameLoop();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QztBQUNKO0FBQ0U7QUFDUTtBQUNNO0FBUTdDLE1BQU1JLGVBQWVELDZEQUFZQTtJQXlCdEMsTUFBYUUsV0FBV0MsTUFBeUIsRUFBaUI7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRSxZQUFZLENBQUNILFVBQVUsQ0FBQ0M7UUFFN0IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRSxJQUFJLENBQUM7SUFFWjtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNILGFBQWEsRUFBRTtZQUN2QixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsS0FBSztRQUNuQixJQUFJLENBQUNELElBQUksQ0FBQztJQUdaO0lBRU9LLE9BQWE7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0YsU0FBUyxFQUFFO1FBRXJCLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO1FBQ2xCLElBQUksQ0FBQ0wsSUFBSSxDQUFDO0lBR1o7SUFFT00sUUFBYztRQUNuQixJQUFJLElBQUksQ0FBQ0gsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxDQUFDRSxLQUFLO1lBQ25CLElBQUksQ0FBQ04sSUFBSSxDQUFDO1FBQ1o7SUFDRjtJQUVPTyxTQUFlO1FBQ3BCLElBQUksSUFBSSxDQUFDSixTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQyxRQUFRLENBQUNHLE1BQU07WUFDcEIsSUFBSSxDQUFDUCxJQUFJLENB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bkM7SUFFT0MsYUFBYUMsR0FBVyxFQUFXO1FBQ3hDLE9BQU8sSUFBSSxDQUFDeEMsWUFBWSxDQUFDdUMsWUFBWSxDQUFDQztJQUN4QztJQUVPQyxxQkFBcUJDLE1BQWMsRUFBVztRQUNuRCxPQUFPLElBQUksQ0FBQzFDLFlBQVksQ0FBQ3lDLG9CQUFvQixDQUFDQztJQUNoRDtJQUVPQyxnQkFBMEM7UUFDL0MsT0FBTyxJQUFJLENBQUMzQyxZQUFZLENBQUMyQyxhQUFhO0lBQ3hDO0lBbExBQyxZQUFZQyxTQUF1QixDQUFDLENBQUMsQ0FBRTtRQUNyQyxLQUFLO2FBWEMvQyxTQUFtQzthQUNuQ0MsZ0JBQWdCO2FBQ2hCSyxZQUFZO2FBQ1prQixZQUFZO1FBRXBCLHlCQUF5QjthQUNqQkwsWUFBWTthQUNaQyxhQUFhO2FBQ2JDLGFBQWE7UUFLbkIsSUFBSSxDQUFDVCxLQUFLLEdBQUcsSUFBSWxCLDZDQUFLQTtRQUN0QixJQUFJLENBQUNhLFFBQVEsR0FBRyxJQUFJWiwrQ0FBUUE7UUFDNUIsSUFBSSxDQUFDTyxZQUFZLEdBQUcsSUFBSU4sdURBQVlBO1FBQ3BDLElBQUksQ0FBQzRCLFNBQVMsR0FBR3VCLE9BQU9DLFdBQVcsSUFBSTtRQUV2QyxJQUFJLENBQUN0QixhQUFhO0lBQ3BCO0FBMEtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb3JlL0VuZ2luZS50cz8yZjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1haW4gZ2FtZSBlbmdpbmUgd2l0aCBFQ1MgaW50ZWdyYXRpb25cbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgR2FtZUxvb3AgfSBmcm9tICcuL0dhbWVMb29wJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJy4vSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0AvdXRpbHMvRXZlbnRFbWl0dGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBFbmdpbmVDb25maWcge1xuICBjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgZW5hYmxlRGVidWc/OiBib29sZWFuO1xuICB0YXJnZXRGUFM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBFbmdpbmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBnYW1lTG9vcDogR2FtZUxvb3A7XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc1J1bm5pbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWJ1Z01vZGUgPSBmYWxzZTtcblxuICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gIHByaXZhdGUgZnJhbWVUaW1lID0gMDtcbiAgcHJpdmF0ZSB1cGRhdGVUaW1lID0gMDtcbiAgcHJpdmF0ZSByZW5kZXJUaW1lID0gMDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEVuZ2luZUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLndvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgdGhpcy5nYW1lTG9vcCA9IG5ldyBHYW1lTG9vcCgpO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gbmV3IElucHV0TWFuYWdlcigpO1xuICAgIHRoaXMuZGVidWdNb2RlID0gY29uZmlnLmVuYWJsZURlYnVnIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5zZXR1cEdhbWVMb29wKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLmluaXRpYWxpemUoY2FudmFzKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnKTtcbiAgICBcbiAgfVxuXG4gIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmdpbmUgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgc3RhcnRpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5nYW1lTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnBhdXNlKCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnJlc3VtZSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFdvcmxkKCk6IFdvcmxkIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dE1hbmFnZXIoKTogSW5wdXRNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXI7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgcHVibGljIGlzRW5naW5lUnVubmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1J1bm5pbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdhbWVMb29wLmdldEN1cnJlbnRGUFMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcHM6IHRoaXMuZ2FtZUxvb3AuZ2V0Q3VycmVudEZQUygpLFxuICAgICAgZnJhbWVUaW1lOiB0aGlzLmZyYW1lVGltZSxcbiAgICAgIHVwZGF0ZVRpbWU6IHRoaXMudXBkYXRlVGltZSxcbiAgICAgIHJlbmRlclRpbWU6IHRoaXMucmVuZGVyVGltZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVuYWJsZURlYnVnTW9kZShlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBlbmFibGVkO1xuICB9XG5cbiAgcHVibGljIGlzRGVidWdNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRlYnVnTW9kZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBHYW1lTG9vcCgpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgZml4ZWQgdGltZXN0ZXAgdXBkYXRlcyAocGh5c2ljcylcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdmaXhlZFVwZGF0ZScsICh7IGZpeGVkRGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICB0aGlzLndvcmxkLmZpeGVkVXBkYXRlKGZpeGVkRGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXMgKGdhbWUgbG9naWMpXG4gICAgdGhpcy5nYW1lTG9vcC5vbigndXBkYXRlJywgKHsgZGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgd29ybGQgc3lzdGVtcyBmaXJzdCBzbyB0aGV5IGNhbiByZWFkIGlucHV0IGRlbHRhc1xuICAgICAgdGhpcy53b3JsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGlucHV0IG1hbmFnZXIgYWZ0ZXIgc3lzdGVtcyBoYXZlIHByb2Nlc3NlZCBpbnB1dFxuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIudXBkYXRlKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGRlbHRhVGltZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZW5kZXJpbmdcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdyZW5kZXInLCAoeyBkZWx0YVRpbWUsIGludGVycG9sYXRpb24gfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciB3b3JsZFxuICAgICAgdGhpcy53b3JsZC5yZW5kZXIoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IHRoaXMudXBkYXRlVGltZSArIHRoaXMucmVuZGVyVGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICB0aGlzLndvcmxkLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZChrZXkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXb3JsZCIsIkdhbWVMb29wIiwiSW5wdXRNYW5hZ2VyIiwiRXZlbnRFbWl0dGVyIiwiRW5naW5lIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImlzSW5pdGlhbGl6ZWQiLCJpbnB1dE1hbmFnZXIiLCJlbWl0Iiwic3RhcnQiLCJFcnJvciIsImlzUnVubmluZyIsImdhbWVMb29wIiwic3RvcCIsInBhdXNlIiwicmVzdW1lIiwiZ2V0V29ybGQiLCJ3b3JsZCIsImdldElucHV0TWFuYWdlciIsImdldENhbnZhcyIsImlzRW5naW5lUnVubmluZyIsImdldEN1cnJlbnRGUFMiLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwiZnBzIiwiZnJhbWVUaW1lIiwidXBkYXRlVGltZSIsInJlbmRlclRpbWUiLCJlbmFibGVEZWJ1Z01vZGUiLCJlbmFibGVkIiwiZGVidWdNb2RlIiwiaXNEZWJ1Z01vZGUiLCJzZXR1cEdhbWVMb29wIiwib24iLCJmaXhlZERlbHRhVGltZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZml4ZWRVcGRhdGUiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJpbnRlcnBvbGF0aW9uIiwicmVuZGVyIiwiZGVzdHJveSIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlcXVlc3RQb2ludGVyTG9jayIsImV4aXRQb2ludGVyTG9jayIsImlzS2V5UHJlc3NlZCIsImtleSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwiZ2V0TW91c2VEZWx0YSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiZW5hYmxlRGVidWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/Engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/GameLoop.ts":
/*!******************************!*\
  !*** ./src/core/GameLoop.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameLoop: function() { return /* binding */ GameLoop; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Optimized game loop with fixed timestep physics\n\nclass GameLoop extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.lastTime = performance.now();\n        this.accumulator = 0;\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = 0;\n        }\n    }\n    getCurrentFPS() {\n        return this.currentFPS;\n    }\n    getFixedTimeStep() {\n        return this.fixedTimeStep;\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning) return;\n        // Calculate delta time and clamp it to prevent large jumps\n        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.maxFrameTime);\n        this.lastTime = currentTime;\n        this.currentTime = currentTime;\n        // Update FPS counter\n        this.updateFPS(deltaTime);\n        // Accumulate time for fixed timestep physics\n        this.accumulator += deltaTime;\n        // Fixed timestep physics updates\n        let subSteps = 0;\n        while(this.accumulator >= this.fixedTimeStep && subSteps < this.maxSubSteps){\n            this.emit(\"fixedUpdate\", {\n                fixedDeltaTime: this.fixedTimeStep\n            });\n            this.accumulator -= this.fixedTimeStep;\n            subSteps++;\n        }\n        // Variable timestep game logic update\n        this.emit(\"update\", {\n            deltaTime\n        });\n        // Calculate interpolation factor for smooth rendering\n        const interpolation = this.accumulator / this.fixedTimeStep;\n        // Render with interpolation\n        this.emit(\"render\", {\n            deltaTime,\n            interpolation\n        });\n        // Schedule next frame\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    updateFPS(deltaTime) {\n        this.frameCount++;\n        this.fpsUpdateTime += deltaTime;\n        // Update FPS every second\n        if (this.fpsUpdateTime >= 1.0) {\n            this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);\n            this.frameCount = 0;\n            this.fpsUpdateTime = 0;\n        }\n    }\n    pause() {\n        if (this.isRunning) {\n            this.stop();\n        }\n    }\n    resume() {\n        if (!this.isRunning) {\n            this.start();\n        }\n    }\n    isPaused() {\n        return !this.isRunning;\n    }\n    // Get current time for systems that need it\n    getCurrentTime() {\n        return this.currentTime;\n    }\n    // Get accumulator ratio for interpolation\n    getInterpolationRatio() {\n        return this.accumulator / this.fixedTimeStep;\n    }\n    constructor(){\n        super();\n        this.isRunning = false;\n        this.lastTime = 0;\n        this.accumulator = 0;\n        this.currentTime = 0;\n        this.frameId = 0;\n        // Performance settings\n        this.fixedTimeStep = 1 / 60 // 60 FPS physics\n        ;\n        this.maxFrameTime = 1 / 30 // Prevent spiral of death at 30 FPS\n        ;\n        this.maxSubSteps = 5 // Maximum physics substeps per frame\n        ;\n        // Performance monitoring\n        this.frameCount = 0;\n        this.fpsUpdateTime = 0;\n        this.currentFPS = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0dhbWVMb29wLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBQ0U7QUFRN0MsTUFBTUMsaUJBQWlCRCw2REFBWUE7SUFxQmpDRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7UUFFcEIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVlDLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLHNCQUFzQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDOUQ7SUFFT0MsT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNLLE9BQU8sRUFBRTtZQUNoQksscUJBQXFCLElBQUksQ0FBQ0wsT0FBTztZQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNqQjtJQUNGO0lBRU9NLGdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtJQUVPQyxtQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNDLGFBQWE7SUFDM0I7SUFFUVAsU0FBU1EsV0FBbUIsRUFBUTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLEVBQUU7UUFFckIsMkRBQTJEO1FBQzNELE1BQU1nQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsY0FBYyxJQUFJLENBQUNkLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQ2tCLFlBQVk7UUFDbEYsSUFBSSxDQUFDbEIsUUFBUSxHQUFHYztRQUNoQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFFbkIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssU0FBUyxDQUFDSjtRQUVmLDZDQUE2QztRQUM3QyxJQUFJLENBQUNaLFdBQVcsSUFBSVk7UUFFcEIsaUNBQWlDO1FBQ2pDLElBQUlLLFdBQVc7UUFDZixNQUFPLElBQUksQ0FBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUNVLGFBQWEsSUFBSU8sV0FBVyxJQUFJLENBQUNDLFdBQVcsQ0FBRTtZQUM1RSxJQUFJLENBQUNDLElBQUksQ0FBQyxlQUFlO2dCQUFFQyxnQkFBZ0IsSUFBSSxDQUFDVixhQUFhO1lBQUM7WUFDOUQsSUFBSSxDQUFDVixXQUFXLElBQUksSUFBSSxDQUFDVSxhQUFhO1lBQ3RDTztRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVU7WUFBRVA7UUFBVTtRQUVoQyxzREFBc0Q7UUFDdEQsTUFBTVMsZ0JBQWdCLElBQUksQ0FBQ3JCLFdBQVcsR0FBRyxJQUFJLENBQUNVLGFBQWE7UUFFM0QsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ1MsSUFBSSxDQUFDLFVBQVU7WUFBRVA7WUFBV1M7UUFBYztRQUUvQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHQyxzQkFBc0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzlEO0lBRVFZLFVBQVVKLFNBQWlCLEVBQVE7UUFDekMsSUFBSSxDQUFDVSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLElBQUlYO1FBRXRCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ1csYUFBYSxJQUFJLEtBQUs7WUFDN0IsSUFBSSxDQUFDZixVQUFVLEdBQUdLLEtBQUtXLEtBQUssQ0FBQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWE7WUFDakUsSUFBSSxDQUFDRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVPRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ1MsSUFBSTtRQUNYO0lBQ0Y7SUFFT3FCLFNBQWU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNELEtBQUs7UUFDWjtJQUNGO0lBRU9nQyxXQUFvQjtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDL0IsU0FBUztJQUN4QjtJQUVBLDRDQUE0QztJQUNyQ2dDLGlCQUF5QjtRQUM5QixPQUFPLElBQUksQ0FBQ2pCLFdBQVc7SUFDekI7SUFFQSwwQ0FBMEM7SUFDbkNrQix3QkFBZ0M7UUFDckMsT0FBTyxJQUFJLENBQUM3QixXQUFXLEdBQUcsSUFBSSxDQUFDVSxhQUFhO0lBQzlDO0lBdEdBb0IsYUFBYztRQUNaLEtBQUs7YUFqQkNsQyxZQUFZO2FBQ1pDLFdBQVc7YUFDWEcsY0FBYzthQUNkVyxjQUFjO2FBQ2RWLFVBQVU7UUFFbEIsdUJBQXVCO2FBQ05TLGdCQUFnQixJQUFJLEdBQUksaUJBQWlCOzthQUN6Q0ssZUFBZSxJQUFJLEdBQUssb0NBQW9DOzthQUM1REcsY0FBYyxFQUFVLHFDQUFxQzs7UUFFOUUseUJBQXlCO2FBQ2pCSSxhQUFhO2FBQ2JDLGdCQUFnQjthQUNoQmYsYUFBYTtJQUlyQjtBQXFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9HYW1lTG9vcC50cz82ZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9wdGltaXplZCBnYW1lIGxvb3Agd2l0aCBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZUxvb3BFdmVudHMge1xuICB1cGRhdGU6IHsgZGVsdGFUaW1lOiBudW1iZXIgfTtcbiAgZml4ZWRVcGRhdGU6IHsgZml4ZWREZWx0YVRpbWU6IG51bWJlciB9O1xuICByZW5kZXI6IHsgZGVsdGFUaW1lOiBudW1iZXI7IGludGVycG9sYXRpb246IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2FtZUxvb3AgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBhY2N1bXVsYXRvciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFRpbWUgPSAwO1xuICBwcml2YXRlIGZyYW1lSWQgPSAwO1xuXG4gIC8vIFBlcmZvcm1hbmNlIHNldHRpbmdzXG4gIHByaXZhdGUgcmVhZG9ubHkgZml4ZWRUaW1lU3RlcCA9IDEgLyA2MDsgLy8gNjAgRlBTIHBoeXNpY3NcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGcmFtZVRpbWUgPSAxIC8gMzA7ICAvLyBQcmV2ZW50IHNwaXJhbCBvZiBkZWF0aCBhdCAzMCBGUFNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTdWJTdGVwcyA9IDU7ICAgICAgICAvLyBNYXhpbXVtIHBoeXNpY3Mgc3Vic3RlcHMgcGVyIGZyYW1lXG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuICBwcml2YXRlIGZwc1VwZGF0ZVRpbWUgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRGUFMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVMb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGUFM7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rml4ZWRUaW1lU3RlcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZVN0ZXA7XG4gIH1cblxuICBwcml2YXRlIGdhbWVMb29wKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGEgdGltZSBhbmQgY2xhbXAgaXQgdG8gcHJldmVudCBsYXJnZSBqdW1wc1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMCwgdGhpcy5tYXhGcmFtZVRpbWUpO1xuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnVwZGF0ZUZQUyhkZWx0YVRpbWUpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB0aW1lIGZvciBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YVRpbWU7XG5cbiAgICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZXNcbiAgICBsZXQgc3ViU3RlcHMgPSAwO1xuICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IHRoaXMuZml4ZWRUaW1lU3RlcCAmJiBzdWJTdGVwcyA8IHRoaXMubWF4U3ViU3RlcHMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZml4ZWRVcGRhdGUnLCB7IGZpeGVkRGVsdGFUaW1lOiB0aGlzLmZpeGVkVGltZVN0ZXAgfSk7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IHRoaXMuZml4ZWRUaW1lU3RlcDtcbiAgICAgIHN1YlN0ZXBzKys7XG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGUgdGltZXN0ZXAgZ2FtZSBsb2dpYyB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZGVsdGFUaW1lIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHRoaXMuYWNjdW11bGF0b3IgLyB0aGlzLmZpeGVkVGltZVN0ZXA7XG5cbiAgICAvLyBSZW5kZXIgd2l0aCBpbnRlcnBvbGF0aW9uXG4gICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcblxuICAgIC8vIFNjaGVkdWxlIG5leHQgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lTG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRlBTKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHNVcGRhdGVUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIC8vIFVwZGF0ZSBGUFMgZXZlcnkgc2Vjb25kXG4gICAgaWYgKHRoaXMuZnBzVXBkYXRlVGltZSA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3VycmVudEZQUyA9IE1hdGgucm91bmQodGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcHNVcGRhdGVUaW1lKTtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICB0aGlzLmZwc1VwZGF0ZVRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgdGltZSBmb3Igc3lzdGVtcyB0aGF0IG5lZWQgaXRcbiAgcHVibGljIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cblxuICAvLyBHZXQgYWNjdW11bGF0b3IgcmF0aW8gZm9yIGludGVycG9sYXRpb25cbiAgcHVibGljIGdldEludGVycG9sYXRpb25SYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yIC8gdGhpcy5maXhlZFRpbWVTdGVwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiR2FtZUxvb3AiLCJzdGFydCIsImlzUnVubmluZyIsImxhc3RUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhY2N1bXVsYXRvciIsImZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnYW1lTG9vcCIsImJpbmQiLCJzdG9wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRDdXJyZW50RlBTIiwiY3VycmVudEZQUyIsImdldEZpeGVkVGltZVN0ZXAiLCJmaXhlZFRpbWVTdGVwIiwiY3VycmVudFRpbWUiLCJkZWx0YVRpbWUiLCJNYXRoIiwibWluIiwibWF4RnJhbWVUaW1lIiwidXBkYXRlRlBTIiwic3ViU3RlcHMiLCJtYXhTdWJTdGVwcyIsImVtaXQiLCJmaXhlZERlbHRhVGltZSIsImludGVycG9sYXRpb24iLCJmcmFtZUNvdW50IiwiZnBzVXBkYXRlVGltZSIsInJvdW5kIiwicGF1c2UiLCJyZXN1bWUiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwiZ2V0SW50ZXJwb2xhdGlvblJhdGlvIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/GameLoop.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/InputManager.ts":
/*!**********************************!*\
  !*** ./src/core/InputManager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: function() { return /* binding */ InputManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Centralized input handling system\n\nclass InputManager extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initialize(canvas) {\n        this.canvas = canvas;\n        // Add canvas-specific event listeners to ensure we capture events\n        // that might be handled by React Three Fiber\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        canvas.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        canvas.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    // Don't automatically request pointer lock - let systems handle this\n    // canvas.addEventListener('click', () => {\n    //   if (!this.isPointerLocked) {\n    //     this.requestPointerLock();\n    //   }\n    // });\n    }\n    requestPointerLock() {\n        if (this.canvas) {\n            this.canvas.requestPointerLock();\n        }\n    }\n    exitPointerLock() {\n        document.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.keys.has(key.toLowerCase());\n    }\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    getMousePosition() {\n        return {\n            ...this.mousePosition\n        };\n    }\n    getMouseDelta() {\n        return {\n            ...this.mouseDelta\n        };\n    }\n    getInputState() {\n        return {\n            keys: new Set(this.keys),\n            mouse: {\n                x: this.mousePosition.x,\n                y: this.mousePosition.y,\n                deltaX: this.mouseDelta.x,\n                deltaY: this.mouseDelta.y,\n                buttons: new Set(this.mouseButtons)\n            }\n        };\n    }\n    checkDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return false;\n        const now = Date.now();\n        // Only return true if we have a valid double-tap sequence:\n        // 1. We have a valid first tap (press + release)\n        // 2. We're currently in a double-tap sequence\n        // 3. The second press happened within the threshold after the first release\n        if (timing.hasValidFirstTap && timing.isInDoubleTapSequence && timing.secondPressTime > 0) {\n            const timeBetweenTaps = timing.secondPressTime - timing.firstReleaseTime;\n            return timeBetweenTaps <= this.DOUBLE_TAP_THRESHOLD;\n        }\n        return false;\n    }\n    resetDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (timing) {\n            timing.firstPressTime = 0;\n            timing.firstReleaseTime = 0;\n            timing.secondPressTime = 0;\n            timing.isInDoubleTapSequence = false;\n            timing.hasValidFirstTap = false;\n        }\n    }\n    update() {\n        // Reset mouse delta each frame\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n        // Clean up old timing entries to prevent memory leaks\n        this.cleanupOldTimings();\n    }\n    cleanupOldTimings() {\n        const now = Date.now();\n        const CLEANUP_THRESHOLD = 5000; // 5 seconds\n        const keysToDelete = [];\n        // Use forEach instead of for...of to avoid ES2015 iteration issues\n        this.keyTimings.forEach((timing, key)=>{\n            // Remove entries that haven't been used in a while\n            const lastActivity = Math.max(timing.firstPressTime, timing.firstReleaseTime, timing.secondPressTime);\n            if (lastActivity > 0 && now - lastActivity > CLEANUP_THRESHOLD) {\n                keysToDelete.push(key);\n            }\n        });\n        // Delete the keys after iteration to avoid modifying map during iteration\n        keysToDelete.forEach((key)=>this.keyTimings.delete(key));\n    }\n    // Debug method to help track double tap detection\n    getDoubleTapDebugInfo(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return null;\n        const now = Date.now();\n        return {\n            key: keyLower,\n            firstPressTime: timing.firstPressTime,\n            firstReleaseTime: timing.firstReleaseTime,\n            secondPressTime: timing.secondPressTime,\n            hasValidFirstTap: timing.hasValidFirstTap,\n            isInDoubleTapSequence: timing.isInDoubleTapSequence,\n            timeSinceFirstPress: timing.firstPressTime > 0 ? now - timing.firstPressTime : 0,\n            timeSinceFirstRelease: timing.firstReleaseTime > 0 ? now - timing.firstReleaseTime : 0,\n            timeSinceSecondPress: timing.secondPressTime > 0 ? now - timing.secondPressTime : 0,\n            threshold: this.DOUBLE_TAP_THRESHOLD\n        };\n    }\n    setupEventListeners() {\n        // Keyboard events\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\n        // Mouse events\n        document.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        // Pointer lock events\n        document.addEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.addEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        // Prevent context menu\n        document.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n        // Handle window focus/blur to reset input state\n        window.addEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.addEventListener(\"focus\", this.onWindowFocus.bind(this));\n    }\n    onKeyDown(event) {\n        const key = event.key.toLowerCase();\n        if (!this.keys.has(key)) {\n            this.keys.add(key);\n            this.emit(\"keyDown\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key timing for double-tap detection\n            const now = Date.now();\n            let timing = this.keyTimings.get(key);\n            if (!timing) {\n                timing = {\n                    firstPressTime: 0,\n                    firstReleaseTime: 0,\n                    secondPressTime: 0,\n                    isInDoubleTapSequence: false,\n                    hasValidFirstTap: false\n                };\n                this.keyTimings.set(key, timing);\n            }\n            // Handle double-tap sequence logic\n            if (!timing.hasValidFirstTap) {\n                // This is the first press\n                timing.firstPressTime = now;\n                timing.isInDoubleTapSequence = false;\n                timing.hasValidFirstTap = false; // Will be set to true on release\n            } else if (timing.hasValidFirstTap && !timing.isInDoubleTapSequence) {\n                // This could be the second press - check if it's within threshold\n                const timeSinceFirstRelease = now - timing.firstReleaseTime;\n                if (timeSinceFirstRelease <= this.DOUBLE_TAP_THRESHOLD) {\n                    // Valid second press\n                    timing.secondPressTime = now;\n                    timing.isInDoubleTapSequence = true;\n                } else {\n                    // Too late for double-tap, treat as new first press\n                    timing.firstPressTime = now;\n                    timing.firstReleaseTime = 0;\n                    timing.secondPressTime = 0;\n                    timing.isInDoubleTapSequence = false;\n                    timing.hasValidFirstTap = false;\n                }\n            }\n        }\n        // Prevent default for game keys\n        if (this.isGameKey(key)) {\n            event.preventDefault();\n        }\n    }\n    onKeyUp(event) {\n        const key = event.key.toLowerCase();\n        if (this.keys.has(key)) {\n            this.keys.delete(key);\n            this.emit(\"keyUp\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key release timing for double-tap detection\n            const timing = this.keyTimings.get(key);\n            if (timing) {\n                const now = Date.now();\n                if (!timing.hasValidFirstTap && timing.firstPressTime > 0) {\n                    // This completes the first tap\n                    timing.firstReleaseTime = now;\n                    timing.hasValidFirstTap = true;\n                } else if (timing.isInDoubleTapSequence) {\n                    // This completes the double-tap sequence\n                    // The double-tap detection should have already been triggered\n                    // Reset for next potential sequence\n                    setTimeout(()=>{\n                        if (timing) {\n                            timing.firstPressTime = 0;\n                            timing.firstReleaseTime = 0;\n                            timing.secondPressTime = 0;\n                            timing.isInDoubleTapSequence = false;\n                            timing.hasValidFirstTap = false;\n                        }\n                    }, 100); // Small delay to allow dash system to process\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n        this.emit(\"mouseDown\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n        this.emit(\"mouseUp\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseMove(event) {\n        if (this.isPointerLocked) {\n            // Use movement deltas when pointer is locked\n            this.mouseDelta.x += event.movementX;\n            this.mouseDelta.y += event.movementY;\n        } else {\n            // Use absolute position when not locked\n            this.previousMousePosition.x = this.mousePosition.x;\n            this.previousMousePosition.y = this.mousePosition.y;\n            this.mousePosition.x = event.clientX;\n            this.mousePosition.y = event.clientY;\n            // Calculate delta from previous position\n            const deltaX = this.mousePosition.x - this.previousMousePosition.x;\n            const deltaY = this.mousePosition.y - this.previousMousePosition.y;\n            // Accumulate delta for this frame\n            this.mouseDelta.x += deltaX;\n            this.mouseDelta.y += deltaY;\n        }\n        this.emit(\"mouseMove\", {\n            x: this.mousePosition.x,\n            y: this.mousePosition.y,\n            deltaX: this.mouseDelta.x,\n            deltaY: this.mouseDelta.y\n        });\n    }\n    onWheel(event) {\n        this.emit(\"wheel\", {\n            deltaX: event.deltaX,\n            deltaY: event.deltaY,\n            deltaZ: event.deltaZ\n        });\n        event.preventDefault();\n    }\n    onPointerLockChange() {\n        this.isPointerLocked = document.pointerLockElement !== null;\n    }\n    onPointerLockError() {\n        // console.warn('Pointer lock failed');\n        this.isPointerLocked = false;\n    }\n    onWindowBlur() {\n        // Clear all input state when window loses focus\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n    }\n    onWindowFocus() {\n        // Reset mouse delta when window regains focus\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n    isGameKey(key) {\n        // Define which keys should have their default behavior prevented\n        const gameKeys = [\n            \"w\",\n            \"a\",\n            \"s\",\n            \"d\",\n            \" \",\n            \"shift\",\n            \"tab\",\n            \"escape\"\n        ];\n        return gameKeys.includes(key);\n    }\n    destroy() {\n        // Remove document event listeners\n        document.removeEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.removeEventListener(\"keyup\", this.onKeyUp.bind(this));\n        document.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        document.removeEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.removeEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        window.removeEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.removeEventListener(\"focus\", this.onWindowFocus.bind(this));\n        // Remove canvas event listeners if canvas exists\n        if (this.canvas) {\n            this.canvas.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n            this.canvas.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n            this.canvas.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n            this.canvas.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        }\n        // Clear state\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n        this.removeAllListeners();\n    }\n    constructor(){\n        super();\n        this.keys = new Set();\n        this.mouseButtons = new Set();\n        this.mousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.mouseDelta = {\n            x: 0,\n            y: 0\n        };\n        this.previousMousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.isPointerLocked = false;\n        this.canvas = null;\n        // Double-tap detection for dash system\n        this.keyTimings = new Map();\n        this.DOUBLE_TAP_THRESHOLD = 200 // 200ms window for double-tap (reduced from 250ms)\n        ;\n        this.setupEventListeners();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUFvQztBQUNnQjtBQXNCN0MsTUFBTUMscUJBQXFCRCw2REFBWUE7SUF3QnJDRSxXQUFXQyxNQUF5QixFQUFRO1FBQ2pELElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUVkLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0NBLE9BQU9DLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQy9ESCxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ0csU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMzREgsT0FBT0MsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNJLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDL0RILE9BQU9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDSyxPQUFPLENBQUNILElBQUksQ0FBQyxJQUFJLEdBQUc7WUFBRUksU0FBUztRQUFNO1FBQzNFUCxPQUFPQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUNPLElBQU1BLEVBQUVDLGNBQWM7SUFFOUQscUVBQXFFO0lBQ3JFLDJDQUEyQztJQUMzQyxpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU07SUFDTixNQUFNO0lBQ1I7SUFFT0MscUJBQTJCO1FBQ2hDLElBQUksSUFBSSxDQUFDVixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ1Usa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFT0Msa0JBQXdCO1FBQzdCQyxTQUFTRCxlQUFlO0lBQzFCO0lBRU9FLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxHQUFHLENBQUNGLElBQUlHLFdBQVc7SUFDdEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0osR0FB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Q1ksSUFBSSxDQUFDdUUsS0FBSztRQUNmLElBQUksQ0FBQ2xFLFlBQVksQ0FBQ2tFLEtBQUs7UUFDdkIsSUFBSSxDQUFDbEQsVUFBVSxDQUFDa0QsS0FBSztRQUNyQixJQUFJLENBQUNLLGtCQUFrQjtJQUN6QjtJQXBYQUMsYUFBYztRQUNaLEtBQUs7YUFuQkM3RSxPQUFPLElBQUlXO2FBQ1hOLGVBQWUsSUFBSU07YUFDbkJKLGdCQUFnQjtZQUFFTSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUM3QkwsYUFBYTtZQUFFSSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUMxQnNELHdCQUF3QjtZQUFFdkQsR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDckNtRCxrQkFBa0I7YUFDbEJoRixTQUFtQztRQUUzQyx1Q0FBdUM7YUFDL0JvQyxhQUFhLElBQUl5RDthQU9SaEQsdUJBQXVCLElBQUssbURBQW1EOztRQUk5RixJQUFJLENBQUNrQixtQkFBbUI7SUFDMUI7QUFrWEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvSW5wdXRNYW5hZ2VyLnRzPzBkMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VudHJhbGl6ZWQgaW5wdXQgaGFuZGxpbmcgc3lzdGVtXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRFdmVudHMge1xuICBrZXlEb3duOiB7IGtleTogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfTtcbiAga2V5VXA6IHsga2V5OiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9O1xuICBtb3VzZURvd246IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlVXA6IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlTW92ZTogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgZGVsdGFYOiBudW1iZXI7IGRlbHRhWTogbnVtYmVyIH07XG4gIHdoZWVsOiB7IGRlbHRhWDogbnVtYmVyOyBkZWx0YVk6IG51bWJlcjsgZGVsdGFaOiBudW1iZXIgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dFN0YXRlIHtcbiAga2V5czogU2V0PHN0cmluZz47XG4gIG1vdXNlOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBkZWx0YVg6IG51bWJlcjtcbiAgICBkZWx0YVk6IG51bWJlcjtcbiAgICBidXR0b25zOiBTZXQ8bnVtYmVyPjtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIElucHV0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUga2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIG1vdXNlQnV0dG9ucyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBwcml2YXRlIG1vdXNlUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgcHJpdmF0ZSBtb3VzZURlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgcHJldmlvdXNNb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8vIERvdWJsZS10YXAgZGV0ZWN0aW9uIGZvciBkYXNoIHN5c3RlbVxuICBwcml2YXRlIGtleVRpbWluZ3MgPSBuZXcgTWFwPHN0cmluZywgeyBcbiAgICBmaXJzdFByZXNzVGltZTogbnVtYmVyO1xuICAgIGZpcnN0UmVsZWFzZVRpbWU6IG51bWJlcjtcbiAgICBzZWNvbmRQcmVzc1RpbWU6IG51bWJlcjtcbiAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IGJvb2xlYW47XG4gICAgaGFzVmFsaWRGaXJzdFRhcDogYm9vbGVhbjtcbiAgfT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBET1VCTEVfVEFQX1RIUkVTSE9MRCA9IDIwMDsgLy8gMjAwbXMgd2luZG93IGZvciBkb3VibGUtdGFwIChyZWR1Y2VkIGZyb20gMjUwbXMpXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICBcbiAgICAvLyBBZGQgY2FudmFzLXNwZWNpZmljIGV2ZW50IGxpc3RlbmVycyB0byBlbnN1cmUgd2UgY2FwdHVyZSBldmVudHNcbiAgICAvLyB0aGF0IG1pZ2h0IGJlIGhhbmRsZWQgYnkgUmVhY3QgVGhyZWUgRmliZXJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbC5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIFxuICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgcmVxdWVzdCBwb2ludGVyIGxvY2sgLSBsZXQgc3lzdGVtcyBoYW5kbGUgdGhpc1xuICAgIC8vIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAvLyAgIGlmICghdGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAvLyAgICAgdGhpcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1ZXN0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZXhpdFBvaW50ZXJMb2NrKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICB9XG5cbiAgcHVibGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmtleXMuaGFzKGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc01vdXNlQnV0dG9uUHJlc3NlZChidXR0b246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1vdXNlQnV0dG9ucy5oYXMoYnV0dG9uKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb3VzZVBvc2l0aW9uIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMubW91c2VEZWx0YSB9O1xuICB9XG5cbiAgcHVibGljIGdldElucHV0U3RhdGUoKTogSW5wdXRTdGF0ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IG5ldyBTZXQodGhpcy5rZXlzKSxcbiAgICAgIG1vdXNlOiB7XG4gICAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgICB5OiB0aGlzLm1vdXNlUG9zaXRpb24ueSxcbiAgICAgICAgZGVsdGFYOiB0aGlzLm1vdXNlRGVsdGEueCxcbiAgICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICAgICAgYnV0dG9uczogbmV3IFNldCh0aGlzLm1vdXNlQnV0dG9ucyksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgY2hlY2tEb3VibGVUYXAoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIE9ubHkgcmV0dXJuIHRydWUgaWYgd2UgaGF2ZSBhIHZhbGlkIGRvdWJsZS10YXAgc2VxdWVuY2U6XG4gICAgLy8gMS4gV2UgaGF2ZSBhIHZhbGlkIGZpcnN0IHRhcCAocHJlc3MgKyByZWxlYXNlKVxuICAgIC8vIDIuIFdlJ3JlIGN1cnJlbnRseSBpbiBhIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAvLyAzLiBUaGUgc2Vjb25kIHByZXNzIGhhcHBlbmVkIHdpdGhpbiB0aGUgdGhyZXNob2xkIGFmdGVyIHRoZSBmaXJzdCByZWxlYXNlXG4gICAgaWYgKHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwICYmIFxuICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlICYmIFxuICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID4gMCkge1xuICAgICAgXG4gICAgICBjb25zdCB0aW1lQmV0d2VlblRhcHMgPSB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lIC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWU7XG4gICAgICByZXR1cm4gdGltZUJldHdlZW5UYXBzIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldERvdWJsZVRhcChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXlMb3dlcik7XG4gICAgaWYgKHRpbWluZykge1xuICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lID0gMDtcbiAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gMDtcbiAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIGVhY2ggZnJhbWVcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIG9sZCB0aW1pbmcgZW50cmllcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgIHRoaXMuY2xlYW51cE9sZFRpbWluZ3MoKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBjbGVhbnVwT2xkVGltaW5ncygpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IENMRUFOVVBfVEhSRVNIT0xEID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSBmb3JFYWNoIGluc3RlYWQgb2YgZm9yLi4ub2YgdG8gYXZvaWQgRVMyMDE1IGl0ZXJhdGlvbiBpc3N1ZXNcbiAgICB0aGlzLmtleVRpbWluZ3MuZm9yRWFjaCgodGltaW5nLCBrZXkpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgaW4gYSB3aGlsZVxuICAgICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gTWF0aC5tYXgoXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSwgXG4gICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLCBcbiAgICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGxhc3RBY3Rpdml0eSA+IDAgJiYgbm93IC0gbGFzdEFjdGl2aXR5ID4gQ0xFQU5VUF9USFJFU0hPTEQpIHtcbiAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIGtleXMgYWZ0ZXIgaXRlcmF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyBtYXAgZHVyaW5nIGl0ZXJhdGlvblxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiB0aGlzLmtleVRpbWluZ3MuZGVsZXRlKGtleSkpO1xuICB9XG4gIFxuICAvLyBEZWJ1ZyBtZXRob2QgdG8gaGVscCB0cmFjayBkb3VibGUgdGFwIGRldGVjdGlvblxuICBwdWJsaWMgZ2V0RG91YmxlVGFwRGVidWdJbmZvKGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleUxvd2VyLFxuICAgICAgZmlyc3RQcmVzc1RpbWU6IHRpbWluZy5maXJzdFByZXNzVGltZSxcbiAgICAgIGZpcnN0UmVsZWFzZVRpbWU6IHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLFxuICAgICAgc2Vjb25kUHJlc3NUaW1lOiB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lLFxuICAgICAgaGFzVmFsaWRGaXJzdFRhcDogdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAsXG4gICAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UsXG4gICAgICB0aW1lU2luY2VGaXJzdFByZXNzOiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UHJlc3NUaW1lIDogMCxcbiAgICAgIHRpbWVTaW5jZUZpcnN0UmVsZWFzZTogdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgOiAwLFxuICAgICAgdGltZVNpbmNlU2Vjb25kUHJlc3M6IHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLnNlY29uZFByZXNzVGltZSA6IDAsXG4gICAgICB0aHJlc2hvbGQ6IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTERcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIEtleWJvYXJkIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIC8vIFBvaW50ZXIgbG9jayBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Qb2ludGVyTG9ja0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2Vycm9yJywgdGhpcy5vblBvaW50ZXJMb2NrRXJyb3IuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBQcmV2ZW50IGNvbnRleHQgbWVudVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IGZvY3VzL2JsdXIgdG8gcmVzZXQgaW5wdXQgc3RhdGVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKCF0aGlzLmtleXMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMua2V5cy5hZGQoa2V5KTtcbiAgICAgIHRoaXMuZW1pdCgna2V5RG93bicsIHsga2V5OiBldmVudC5rZXksIGNvZGU6IGV2ZW50LmNvZGUgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGtleSB0aW1pbmcgZm9yIGRvdWJsZS10YXAgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5KTtcbiAgICAgIFxuICAgICAgaWYgKCF0aW1pbmcpIHtcbiAgICAgICAgdGltaW5nID0geyBcbiAgICAgICAgICBmaXJzdFByZXNzVGltZTogMCwgXG4gICAgICAgICAgZmlyc3RSZWxlYXNlVGltZTogMCwgXG4gICAgICAgICAgc2Vjb25kUHJlc3NUaW1lOiAwLFxuICAgICAgICAgIGlzSW5Eb3VibGVUYXBTZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgaGFzVmFsaWRGaXJzdFRhcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXlUaW1pbmdzLnNldChrZXksIHRpbWluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBkb3VibGUtdGFwIHNlcXVlbmNlIGxvZ2ljXG4gICAgICBpZiAoIXRpbWluZy5oYXNWYWxpZEZpcnN0VGFwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHByZXNzXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSA9IG5vdztcbiAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlOyAvLyBXaWxsIGJlIHNldCB0byB0cnVlIG9uIHJlbGVhc2VcbiAgICAgIH0gZWxzZSBpZiAodGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgIXRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSB0aGUgc2Vjb25kIHByZXNzIC0gY2hlY2sgaWYgaXQncyB3aXRoaW4gdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0UmVsZWFzZSA9IG5vdyAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lO1xuICAgICAgICBpZiAodGltZVNpbmNlRmlyc3RSZWxlYXNlIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBWYWxpZCBzZWNvbmQgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvbyBsYXRlIGZvciBkb3VibGUtdGFwLCB0cmVhdCBhcyBuZXcgZmlyc3QgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSBub3c7XG4gICAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGZvciBnYW1lIGtleXNcbiAgICBpZiAodGhpcy5pc0dhbWVLZXkoa2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBpZiAodGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmtleXMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2tleVVwJywgeyBrZXk6IGV2ZW50LmtleSwgY29kZTogZXZlbnQuY29kZSB9KTtcblxuICAgICAgLy8gVHJhY2sga2V5IHJlbGVhc2UgdGltaW5nIGZvciBkb3VibGUtdGFwIGRldGVjdGlvblxuICAgICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXkpO1xuICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCAmJiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGZpcnN0IHRhcFxuICAgICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAgICAgICAvLyBUaGUgZG91YmxlLXRhcCBkZXRlY3Rpb24gc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgIC8vIFJlc2V0IGZvciBuZXh0IHBvdGVudGlhbCBzZXF1ZW5jZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IDA7XG4gICAgICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gYWxsb3cgZGFzaCBzeXN0ZW0gdG8gcHJvY2Vzc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMubW91c2VCdXR0b25zLmFkZChldmVudC5idXR0b24pO1xuICAgIHRoaXMuZW1pdCgnbW91c2VEb3duJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZVVwKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuZGVsZXRlKGV2ZW50LmJ1dHRvbik7XG4gICAgdGhpcy5lbWl0KCdtb3VzZVVwJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAgIC8vIFVzZSBtb3ZlbWVudCBkZWx0YXMgd2hlbiBwb2ludGVyIGlzIGxvY2tlZFxuICAgICAgdGhpcy5tb3VzZURlbHRhLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgdGhpcy5tb3VzZURlbHRhLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgYWJzb2x1dGUgcG9zaXRpb24gd2hlbiBub3QgbG9ja2VkXG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi54ID0gdGhpcy5tb3VzZVBvc2l0aW9uLng7XG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi55ID0gdGhpcy5tb3VzZVBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YSBmcm9tIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1vdXNlUG9zaXRpb24ueCAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLng7XG4gICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1vdXNlUG9zaXRpb24ueSAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIC8vIEFjY3VtdWxhdGUgZGVsdGEgZm9yIHRoaXMgZnJhbWVcbiAgICAgIHRoaXMubW91c2VEZWx0YS54ICs9IGRlbHRhWDtcbiAgICAgIHRoaXMubW91c2VEZWx0YS55ICs9IGRlbHRhWTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ21vdXNlTW92ZScsIHtcbiAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnksXG4gICAgICBkZWx0YVg6IHRoaXMubW91c2VEZWx0YS54LFxuICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25XaGVlbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnd2hlZWwnLCB7XG4gICAgICBkZWx0YVg6IGV2ZW50LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuICAgICAgZGVsdGFaOiBldmVudC5kZWx0YVosXG4gICAgfSk7XG4gICAgXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0NoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUG9pbnRlckxvY2tlZCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAhPT0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0Vycm9yKCk6IHZvaWQge1xuICAgIC8vIGNvbnNvbGUud2FybignUG9pbnRlciBsb2NrIGZhaWxlZCcpO1xuICAgIHRoaXMuaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uV2luZG93Qmx1cigpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbGwgaW5wdXQgc3RhdGUgd2hlbiB3aW5kb3cgbG9zZXMgZm9jdXNcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldpbmRvd0ZvY3VzKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIHdoZW4gd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0dhbWVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBEZWZpbmUgd2hpY2gga2V5cyBzaG91bGQgaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIHByZXZlbnRlZFxuICAgIGNvbnN0IGdhbWVLZXlzID0gWyd3JywgJ2EnLCAncycsICdkJywgJyAnLCAnc2hpZnQnLCAndGFiJywgJ2VzY2FwZSddO1xuICAgIHJldHVybiBnYW1lS2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vblBvaW50ZXJMb2NrQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrZXJyb3InLCB0aGlzLm9uUG9pbnRlckxvY2tFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFJlbW92ZSBjYW52YXMgZXZlbnQgbGlzdGVuZXJzIGlmIGNhbnZhcyBleGlzdHNcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhdGVcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJJbnB1dE1hbmFnZXIiLCJpbml0aWFsaXplIiwiY2FudmFzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VEb3duIiwiYmluZCIsIm9uTW91c2VVcCIsIm9uTW91c2VNb3ZlIiwib25XaGVlbCIsInBhc3NpdmUiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZXF1ZXN0UG9pbnRlckxvY2siLCJleGl0UG9pbnRlckxvY2siLCJkb2N1bWVudCIsImlzS2V5UHJlc3NlZCIsImtleSIsImtleXMiLCJoYXMiLCJ0b0xvd2VyQ2FzZSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwibW91c2VCdXR0b25zIiwiZ2V0TW91c2VQb3NpdGlvbiIsIm1vdXNlUG9zaXRpb24iLCJnZXRNb3VzZURlbHRhIiwibW91c2VEZWx0YSIsImdldElucHV0U3RhdGUiLCJTZXQiLCJtb3VzZSIsIngiLCJ5IiwiZGVsdGFYIiwiZGVsdGFZIiwiYnV0dG9ucyIsImNoZWNrRG91YmxlVGFwIiwia2V5TG93ZXIiLCJ0aW1pbmciLCJrZXlUaW1pbmdzIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImhhc1ZhbGlkRmlyc3RUYXAiLCJpc0luRG91YmxlVGFwU2VxdWVuY2UiLCJzZWNvbmRQcmVzc1RpbWUiLCJ0aW1lQmV0d2VlblRhcHMiLCJmaXJzdFJlbGVhc2VUaW1lIiwiRE9VQkxFX1RBUF9USFJFU0hPTEQiLCJyZXNldERvdWJsZVRhcCIsImZpcnN0UHJlc3NUaW1lIiwidXBkYXRlIiwiY2xlYW51cE9sZFRpbWluZ3MiLCJDTEVBTlVQX1RIUkVTSE9MRCIsImtleXNUb0RlbGV0ZSIsImZvckVhY2giLCJsYXN0QWN0aXZpdHkiLCJNYXRoIiwibWF4IiwicHVzaCIsImRlbGV0ZSIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsInRpbWVTaW5jZUZpcnN0UHJlc3MiLCJ0aW1lU2luY2VGaXJzdFJlbGVhc2UiLCJ0aW1lU2luY2VTZWNvbmRQcmVzcyIsInRocmVzaG9sZCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJvbktleURvd24iLCJvbktleVVwIiwib25Qb2ludGVyTG9ja0NoYW5nZSIsIm9uUG9pbnRlckxvY2tFcnJvciIsIndpbmRvdyIsIm9uV2luZG93Qmx1ciIsIm9uV2luZG93Rm9jdXMiLCJldmVudCIsImFkZCIsImVtaXQiLCJjb2RlIiwic2V0IiwiaXNHYW1lS2V5Iiwic2V0VGltZW91dCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNQb2ludGVyTG9ja2VkIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwicHJldmlvdXNNb3VzZVBvc2l0aW9uIiwiZGVsdGFaIiwicG9pbnRlckxvY2tFbGVtZW50IiwiY2xlYXIiLCJnYW1lS2V5cyIsImluY2x1ZGVzIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjb25zdHJ1Y3RvciIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/InputManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/Entity.ts":
/*!***************************!*\
  !*** ./src/ecs/Entity.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ Component; },\n/* harmony export */   Entity: function() { return /* binding */ Entity; }\n/* harmony export */ });\n// Entity Component System - Entity Management\nclass Entity {\n    addComponent(component) {\n        // Use explicit componentType if available, fallback to constructor name\n        const componentName = component.componentType || component.constructor.name;\n        this.components.set(componentName, component);\n        return component;\n    }\n    removeComponent(componentType) {\n        this.components.delete(componentType.name);\n    }\n    getComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        let component = this.components.get(requestedType);\n        // If not found with explicit type, try searching by constructor name as fallback\n        if (!component && componentType.componentType) {\n            component = this.components.get(componentType.name);\n            if (component) {}\n        }\n        // If still not found, search through all components to find a match by type\n        if (!component && componentType) {\n            const entries = Array.from(this.components.entries());\n            for (const [key, comp] of entries){\n                if (comp instanceof componentType) {\n                    // Reduce spam - only log occasionally for instanceof fallback usage\n                    if (Math.random() < 0.01) {}\n                    component = comp;\n                    break;\n                }\n            }\n        }\n        if (component) {\n            const actualType = component.componentType || component.constructor.name;\n            if (actualType !== requestedType && !component.constructor.name.match(/^[a-z]$/)) {\n            // Only warn if it's not a minified single-letter class name\n            }\n        } else {\n            // Reduce spam - only log occasionally for missing components\n            if (Math.random() < 0.001) {}\n        }\n        return component;\n    }\n    hasComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        // Check with explicit type first\n        if (this.components.has(requestedType)) {\n            return true;\n        }\n        // If not found with explicit type, try constructor name as fallback\n        if (componentType.componentType && this.components.has(componentType.name)) {\n            return true;\n        }\n        // If still not found, search through all components to find a match by type\n        if (componentType) {\n            const components = Array.from(this.components.values());\n            for (const comp of components){\n                if (comp instanceof componentType) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    hasComponents(componentTypes) {\n        return componentTypes.every((type)=>this.hasComponent(type));\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getComponentNames() {\n        return Array.from(this.components.keys());\n    }\n    isActive() {\n        return this.active;\n    }\n    setActive(active) {\n        this.active = active;\n    }\n    destroy() {\n        this.components.clear();\n        this.active = false;\n    }\n    constructor(){\n        this.components = new Map();\n        this.active = true;\n        this.id = Entity.nextId++;\n    }\n}\nEntity.nextId = 1;\nclass Component {\n    constructor(){\n        this.enabled = true;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUksQ0FBQ1QsVUFBVSxDQUFDeUIsSUFBSTtJQUN4QztJQUVPQyxXQUFvQjtRQUN6QixPQUFPLElBQUksQ0FBQ0MsTUFBTTtJQUNwQjtJQUVPQyxVQUFVRCxNQUFlLEVBQVE7UUFDdEMsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2hCO0lBRU9FLFVBQWdCO1FBQ3JCLElBQUksQ0FBQzdCLFVBQVUsQ0FBQzhCLEtBQUs7UUFDckIsSUFBSSxDQUFDSCxNQUFNLEdBQUc7SUFDaEI7SUF6R0E3QixhQUFjO2FBSE5FLGFBQWEsSUFBSStCO2FBQ2pCSixTQUFTO1FBR2YsSUFBSSxDQUFDSyxFQUFFLEdBQUd2QyxPQUFPd0MsTUFBTTtJQUN6QjtBQXdHRjtBQWhIYXhDLE9BQ0l3QyxTQUFtQjtBQWlIN0IsTUFBZUM7O2FBQ2JDLFVBQVU7O0FBR25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvRW50aXR5LnRzPzVmM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRW50aXR5IENvbXBvbmVudCBTeXN0ZW0gLSBFbnRpdHkgTWFuYWdlbWVudFxuZXhwb3J0IHR5cGUgRW50aXR5SWQgPSBudW1iZXI7XG5cbmV4cG9ydCBjbGFzcyBFbnRpdHkge1xuICBwcml2YXRlIHN0YXRpYyBuZXh0SWQ6IEVudGl0eUlkID0gMTtcbiAgcHVibGljIHJlYWRvbmx5IGlkOiBFbnRpdHlJZDtcbiAgcHJpdmF0ZSBjb21wb25lbnRzID0gbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudD4oKTtcbiAgcHJpdmF0ZSBhY3RpdmUgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWQgPSBFbnRpdHkubmV4dElkKys7XG4gIH1cblxuICBwdWJsaWMgYWRkQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudDogVCk6IFQge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSAoY29tcG9uZW50IGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLmNvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50VHlwZTogbmV3ICgpID0+IFQpOiB2b2lkIHtcbiAgICB0aGlzLmNvbXBvbmVudHMuZGVsZXRlKGNvbXBvbmVudFR5cGUubmFtZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgcmVxdWVzdGVkVHlwZSA9IChjb21wb25lbnRUeXBlIGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnRUeXBlLm5hbWU7XG4gICAgbGV0IGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50cy5nZXQocmVxdWVzdGVkVHlwZSk7XG4gICAgXG4gICAgLy8gSWYgbm90IGZvdW5kIHdpdGggZXhwbGljaXQgdHlwZSwgdHJ5IHNlYXJjaGluZyBieSBjb25zdHJ1Y3RvciBuYW1lIGFzIGZhbGxiYWNrXG4gICAgaWYgKCFjb21wb25lbnQgJiYgKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlKSB7XG4gICAgICBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KGNvbXBvbmVudFR5cGUubmFtZSk7XG4gICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgc2VhcmNoIHRocm91Z2ggYWxsIGNvbXBvbmVudHMgdG8gZmluZCBhIG1hdGNoIGJ5IHR5cGVcbiAgICBpZiAoIWNvbXBvbmVudCAmJiBjb21wb25lbnRUeXBlKSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMuZW50cmllcygpKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgY29tcF0gb2YgZW50cmllcykge1xuICAgICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgaW5zdGFuY2VvZiBmYWxsYmFjayB1c2FnZVxuICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkgeyAvLyBPbmx5IGxvZyAxJSBvZiB0aGUgdGltZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSAoY29tcG9uZW50IGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChhY3R1YWxUeXBlICE9PSByZXF1ZXN0ZWRUeXBlICYmICFjb21wb25lbnQuY29uc3RydWN0b3IubmFtZS5tYXRjaCgvXlthLXpdJC8pKSB7XG4gICAgICAgIC8vIE9ubHkgd2FybiBpZiBpdCdzIG5vdCBhIG1pbmlmaWVkIHNpbmdsZS1sZXR0ZXIgY2xhc3MgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgbWlzc2luZyBjb21wb25lbnRzXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDAxKSB7IC8vIE9ubHkgbG9nIDAuMSUgb2YgdGhlIHRpbWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbXBvbmVudCBhcyBUO1xuICB9XG5cbiAgcHVibGljIGhhc0NvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IGJvb2xlYW4ge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IHJlcXVlc3RlZFR5cGUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIENoZWNrIHdpdGggZXhwbGljaXQgdHlwZSBmaXJzdFxuICAgIGlmICh0aGlzLmNvbXBvbmVudHMuaGFzKHJlcXVlc3RlZFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm90IGZvdW5kIHdpdGggZXhwbGljaXQgdHlwZSwgdHJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlICYmIHRoaXMuY29tcG9uZW50cy5oYXMoY29tcG9uZW50VHlwZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgc2VhcmNoIHRocm91Z2ggYWxsIGNvbXBvbmVudHMgdG8gZmluZCBhIG1hdGNoIGJ5IHR5cGVcbiAgICBpZiAoY29tcG9uZW50VHlwZSkge1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IEFycmF5LmZyb20odGhpcy5jb21wb25lbnRzLnZhbHVlcygpKTtcbiAgICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChjb21wIGluc3RhbmNlb2YgY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzOiAobmV3ICgpID0+IENvbXBvbmVudClbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjb21wb25lbnRUeXBlcy5ldmVyeSh0eXBlID0+IHRoaXMuaGFzQ29tcG9uZW50KHR5cGUpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICB9XG5cbiAgcHVibGljIGdldENvbXBvbmVudE5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMua2V5cygpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gIH1cblxuICBwdWJsaWMgc2V0QWN0aXZlKGFjdGl2ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jb21wb25lbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcbiAgcHVibGljIGVuYWJsZWQgPSB0cnVlO1xuICBcbiAgcHVibGljIGFic3RyYWN0IHJlc2V0KCk6IHZvaWQ7IC8vIEZvciBvYmplY3QgcG9vbGluZ1xufVxuIl0sIm5hbWVzIjpbIkVudGl0eSIsImFkZENvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbXBvbmVudE5hbWUiLCJjb21wb25lbnRUeXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29tcG9uZW50cyIsInNldCIsInJlbW92ZUNvbXBvbmVudCIsImRlbGV0ZSIsImdldENvbXBvbmVudCIsInJlcXVlc3RlZFR5cGUiLCJnZXQiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwia2V5IiwiY29tcCIsIk1hdGgiLCJyYW5kb20iLCJhY3R1YWxUeXBlIiwibWF0Y2giLCJoYXNDb21wb25lbnQiLCJoYXMiLCJ2YWx1ZXMiLCJoYXNDb21wb25lbnRzIiwiY29tcG9uZW50VHlwZXMiLCJldmVyeSIsInR5cGUiLCJnZXRBbGxDb21wb25lbnRzIiwiZ2V0Q29tcG9uZW50TmFtZXMiLCJrZXlzIiwiaXNBY3RpdmUiLCJhY3RpdmUiLCJzZXRBY3RpdmUiLCJkZXN0cm95IiwiY2xlYXIiLCJNYXAiLCJpZCIsIm5leHRJZCIsIkNvbXBvbmVudCIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/Entity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/System.ts":
/*!***************************!*\
  !*** ./src/ecs/System.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; },\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; },\n/* harmony export */   System: function() { return /* binding */ System; }\n/* harmony export */ });\n// Entity Component System - Base System Classes\nclass System {\n    matchesEntity(entity) {\n        return entity.isActive() && entity.hasComponents(this.requiredComponents);\n    }\n    constructor(){\n        this.enabled = true;\n        this.priority = 0 // Lower numbers run first\n        ;\n    }\n}\nclass RenderSystem extends System {\n}\nclass PhysicsSystem extends System {\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUd6QyxNQUFlQTtJQU9iQyxjQUFjQyxNQUFjLEVBQVc7UUFDNUMsT0FBT0EsT0FBT0MsUUFBUSxNQUFNRCxPQUFPRSxhQUFhLENBQUMsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7O2FBUE9DLFVBQVU7YUFDVkMsV0FBVyxFQUFHLDBCQUEwQjs7O0FBWWpEO0FBRU8sTUFBZUMscUJBQXFCUjtBQUUzQztBQUVPLE1BQWVTLHNCQUFzQlQ7QUFFNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9TeXN0ZW0udHM/YTgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEJhc2UgU3lzdGVtIENsYXNzZXNcbmltcG9ydCB7IEVudGl0eSwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50czogKG5ldyAoKSA9PiBDb21wb25lbnQpW107XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgcHVibGljIHByaW9yaXR5ID0gMDsgLy8gTG93ZXIgbnVtYmVycyBydW4gZmlyc3RcblxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkO1xuXG4gIHB1YmxpYyBtYXRjaGVzRW50aXR5KGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKHRoaXMucmVxdWlyZWRDb21wb25lbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkPyhlbnRpdHk6IEVudGl0eSk6IHZvaWQ7XG4gIHB1YmxpYyBvbkVudGl0eVJlbW92ZWQ/KGVudGl0eTogRW50aXR5KTogdm9pZDtcbiAgcHVibGljIG9uRW5hYmxlPygpOiB2b2lkO1xuICBwdWJsaWMgb25EaXNhYmxlPygpOiB2b2lkO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgYWJzdHJhY3QgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJtYXRjaGVzRW50aXR5IiwiZW50aXR5IiwiaXNBY3RpdmUiLCJoYXNDb21wb25lbnRzIiwicmVxdWlyZWRDb21wb25lbnRzIiwiZW5hYmxlZCIsInByaW9yaXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/System.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/World.ts":
/*!**************************!*\
  !*** ./src/ecs/World.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: function() { return /* binding */ World; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Entity Component System - World Management\n\n\n\nclass World {\n    // Entity management\n    createEntity() {\n        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity();\n        this.entities.set(entity.id, entity);\n        return entity;\n    }\n    destroyEntity(entityId) {\n        this.entitiesToDestroy.push(entityId);\n    }\n    // Notify systems that an entity has been fully configured and is ready\n    notifyEntityAdded(entity) {\n        for (const system of this.systems){\n            if (system.onEntityAdded && system.matchesEntity(entity)) {\n                system.onEntityAdded(entity);\n            }\n        }\n    }\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    // System management\n    addSystem(system) {\n        var _system_onEnable;\n        this.systems.push(system);\n        this.systems.sort((a, b)=>a.priority - b.priority);\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem) {\n            this.renderSystems.push(system);\n        }\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem) {\n            this.physicsSystems.push(system);\n        }\n        (_system_onEnable = system.onEnable) === null || _system_onEnable === void 0 ? void 0 : _system_onEnable.call(system);\n    }\n    getSystem(systemClass) {\n        return this.systems.find((system)=>system instanceof systemClass);\n    }\n    removeSystem(systemType) {\n        const index = this.systems.findIndex((s)=>s instanceof systemType);\n        if (index !== -1) {\n            var _system_onDisable;\n            const system = this.systems[index];\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n            this.systems.splice(index, 1);\n            // Remove from specialized arrays\n            const renderIndex = this.renderSystems.findIndex((s)=>s === system);\n            if (renderIndex !== -1) this.renderSystems.splice(renderIndex, 1);\n            const physicsIndex = this.physicsSystems.findIndex((s)=>s === system);\n            if (physicsIndex !== -1) this.physicsSystems.splice(physicsIndex, 1);\n        }\n    }\n    // Component pooling for performance\n    createComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const typeName = componentType.componentType || componentType.name;\n        // Disable pooling for components that have prototype method issues in production\n        const problematicComponents = [\n            \"Health\",\n            \"HealthBar\",\n            \"Transform\",\n            \"Movement\",\n            \"Collider\",\n            \"Renderer\",\n            \"Enemy\",\n            \"Projectile\",\n            \"Animation\"\n        ];\n        if (problematicComponents.includes(typeName)) {\n            return new componentType();\n        }\n        let pool = this.componentPools.get(typeName);\n        if (!pool) {\n            pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__.ObjectPool(()=>new componentType(), (obj)=>obj.reset(), 100);\n            this.componentPools.set(typeName, pool);\n        }\n        return pool.acquire();\n    }\n    returnComponent(component) {\n        const pool = this.componentPools.get(component.constructor.name);\n        if (pool) {\n            pool.release(component);\n        }\n    }\n    // Main update loop\n    update(deltaTime) {\n        // Clean up destroyed entities\n        this.cleanupDestroyedEntities();\n        // Update all systems\n        for (const system of this.systems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.update(matchingEntities, deltaTime);\n        }\n    }\n    // Fixed timestep physics update\n    fixedUpdate(fixedDeltaTime) {\n        for (const system of this.physicsSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.fixedUpdate(matchingEntities, fixedDeltaTime);\n        }\n    }\n    // Render update\n    render(deltaTime) {\n        for (const system of this.renderSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.render(matchingEntities, deltaTime);\n        }\n    }\n    // Get entities that match a system's requirements\n    getEntitiesForSystem(system) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (system.matchesEntity(entity)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Clean up destroyed entities\n    cleanupDestroyedEntities() {\n        for (const entityId of this.entitiesToDestroy){\n            const entity = this.entities.get(entityId);\n            if (entity) {\n                // Notify systems about entity removal\n                for (const system of this.systems){\n                    if (system.onEntityRemoved && system.matchesEntity(entity)) {\n                        system.onEntityRemoved(entity);\n                    }\n                }\n                // Return components to pools\n                for (const component of entity.getAllComponents()){\n                    this.returnComponent(component);\n                }\n                entity.destroy();\n                this.entities.delete(entityId);\n            }\n        }\n        this.entitiesToDestroy.length = 0;\n    }\n    // Query entities by components\n    queryEntities(componentTypes) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (entity.isActive() && entity.hasComponents(componentTypes)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Event system\n    emitEvent(eventType, eventData) {\n        if (!this.events.has(eventType)) {\n            this.events.set(eventType, []);\n        }\n        this.events.get(eventType).push(eventData);\n    }\n    getEvents(eventType) {\n        return this.events.get(eventType) || [];\n    }\n    clearEvents(eventType) {\n        this.events.set(eventType, []);\n    }\n    destroy() {\n        // Clean up all entities\n        for (const entity of Array.from(this.entities.values())){\n            entity.destroy();\n        }\n        this.entities.clear();\n        // Clean up systems\n        for (const system of this.systems){\n            var _system_onDisable;\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n        }\n        this.systems.length = 0;\n        this.renderSystems.length = 0;\n        this.physicsSystems.length = 0;\n        // Clear component pools\n        this.componentPools.clear();\n        // Clear events\n        this.events.clear();\n    }\n    constructor(){\n        this.entities = new Map();\n        this.systems = [];\n        this.renderSystems = [];\n        this.physicsSystems = [];\n        this.componentPools = new Map();\n        this.entitiesToDestroy = [];\n        this.events = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLE9BQU8sQ0FBRTtnQkFDakNEO2FBQUFBLG9CQUFBQSxPQUFPMEIsU0FBUyxjQUFoQjFCLHdDQUFBQSx1QkFBQUE7UUFDRjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxDQUFDeUQsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQzNDLGFBQWEsQ0FBQzJDLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUMxQyxjQUFjLENBQUMwQyxNQUFNLEdBQUc7UUFFN0Isd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ3JCLGNBQWMsQ0FBQ2lDLEtBQUs7UUFFekIsZUFBZTtRQUNmLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxLQUFLO0lBQ25COzthQTNOUTlFLFdBQVcsSUFBSStFO2FBQ2Z0RSxVQUFvQixFQUFFO2FBQ3RCYyxnQkFBZ0MsRUFBRTthQUNsQ0MsaUJBQWtDLEVBQUU7YUFDcENxQixpQkFBaUIsSUFBSWtDO2FBQ3JCMUUsb0JBQWdDLEVBQUU7YUFDbENxRSxTQUFTLElBQUlLOztBQXNOdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9Xb3JsZC50cz8zMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gV29ybGQgTWFuYWdlbWVudFxuaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlJZCwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuaW1wb3J0IHsgU3lzdGVtLCBSZW5kZXJTeXN0ZW0sIFBoeXNpY3NTeXN0ZW0gfSBmcm9tICcuL1N5c3RlbSc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuZXhwb3J0IGNsYXNzIFdvcmxkIHtcbiAgcHJpdmF0ZSBlbnRpdGllcyA9IG5ldyBNYXA8RW50aXR5SWQsIEVudGl0eT4oKTtcbiAgcHJpdmF0ZSBzeXN0ZW1zOiBTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIHJlbmRlclN5c3RlbXM6IFJlbmRlclN5c3RlbVtdID0gW107XG4gIHByaXZhdGUgcGh5c2ljc1N5c3RlbXM6IFBoeXNpY3NTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIGNvbXBvbmVudFBvb2xzID0gbmV3IE1hcDxzdHJpbmcsIE9iamVjdFBvb2w8YW55Pj4oKTtcbiAgcHJpdmF0ZSBlbnRpdGllc1RvRGVzdHJveTogRW50aXR5SWRbXSA9IFtdO1xuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcblxuICAvLyBFbnRpdHkgbWFuYWdlbWVudFxuICBwdWJsaWMgY3JlYXRlRW50aXR5KCk6IEVudGl0eSB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSgpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcbiAgICByZXR1cm4gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3lFbnRpdHkoZW50aXR5SWQ6IEVudGl0eUlkKTogdm9pZCB7XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5wdXNoKGVudGl0eUlkKTtcbiAgfVxuXG4gIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgYW4gZW50aXR5IGhhcyBiZWVuIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIGlzIHJlYWR5XG4gIHB1YmxpYyBub3RpZnlFbnRpdHlBZGRlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eUFkZGVkICYmIHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLm9uRW50aXR5QWRkZWQoZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RW50aXR5KGVudGl0eUlkOiBFbnRpdHlJZCk6IEVudGl0eSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxFbnRpdGllcygpOiBFbnRpdHlbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyBTeXN0ZW0gbWFuYWdlbWVudFxuICBwdWJsaWMgYWRkU3lzdGVtKHN5c3RlbTogU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB0aGlzLnN5c3RlbXMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFJlbmRlclN5c3RlbSkge1xuICAgICAgdGhpcy5yZW5kZXJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB9XG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFBoeXNpY3NTeXN0ZW0pIHtcbiAgICAgIHRoaXMucGh5c2ljc1N5c3RlbXMucHVzaChzeXN0ZW0pO1xuICAgIH1cblxuICAgIHN5c3RlbS5vbkVuYWJsZT8uKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3lzdGVtPFQgZXh0ZW5kcyBTeXN0ZW0+KHN5c3RlbUNsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3lzdGVtcy5maW5kKHN5c3RlbSA9PiBzeXN0ZW0gaW5zdGFuY2VvZiBzeXN0ZW1DbGFzcykgYXMgVCB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTeXN0ZW0oc3lzdGVtVHlwZTogbmV3ICgpID0+IFN5c3RlbSk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zeXN0ZW1zLmZpbmRJbmRleChzID0+IHMgaW5zdGFuY2VvZiBzeXN0ZW1UeXBlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSB0aGlzLnN5c3RlbXNbaW5kZXhdO1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgICB0aGlzLnN5c3RlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gc3BlY2lhbGl6ZWQgYXJyYXlzXG4gICAgICBjb25zdCByZW5kZXJJbmRleCA9IHRoaXMucmVuZGVyU3lzdGVtcy5maW5kSW5kZXgocyA9PiBzID09PSBzeXN0ZW0pO1xuICAgICAgaWYgKHJlbmRlckluZGV4ICE9PSAtMSkgdGhpcy5yZW5kZXJTeXN0ZW1zLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG5cbiAgICAgIGNvbnN0IHBoeXNpY3NJbmRleCA9IHRoaXMucGh5c2ljc1N5c3RlbXMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3lzdGVtKTtcbiAgICAgIGlmIChwaHlzaWNzSW5kZXggIT09IC0xKSB0aGlzLnBoeXNpY3NTeXN0ZW1zLnNwbGljZShwaHlzaWNzSW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBvbmVudCBwb29saW5nIGZvciBwZXJmb3JtYW5jZVxuICBwdWJsaWMgY3JlYXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgdHlwZU5hbWUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIERpc2FibGUgcG9vbGluZyBmb3IgY29tcG9uZW50cyB0aGF0IGhhdmUgcHJvdG90eXBlIG1ldGhvZCBpc3N1ZXMgaW4gcHJvZHVjdGlvblxuICAgIGNvbnN0IHByb2JsZW1hdGljQ29tcG9uZW50cyA9IFsnSGVhbHRoJywgJ0hlYWx0aEJhcicsICdUcmFuc2Zvcm0nLCAnTW92ZW1lbnQnLCAnQ29sbGlkZXInLCAnUmVuZGVyZXInLCAnRW5lbXknLCAnUHJvamVjdGlsZScsICdBbmltYXRpb24nXTtcbiAgICBpZiAocHJvYmxlbWF0aWNDb21wb25lbnRzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnRUeXBlKCk7XG4gICAgfVxuICAgIFxuICAgIGxldCBwb29sID0gdGhpcy5jb21wb25lbnRQb29scy5nZXQodHlwZU5hbWUpO1xuICAgIFxuICAgIGlmICghcG9vbCkge1xuICAgICAgcG9vbCA9IG5ldyBPYmplY3RQb29sPFQ+KCgpID0+IG5ldyBjb21wb25lbnRUeXBlKCksIChvYmopID0+IG9iai5yZXNldCgpLCAxMDApO1xuICAgICAgdGhpcy5jb21wb25lbnRQb29scy5zZXQodHlwZU5hbWUsIHBvb2wpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9vbC5hY3F1aXJlKCk7XG4gIH1cblxuICBwdWJsaWMgcmV0dXJuQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmNvbXBvbmVudFBvb2xzLmdldChjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHBvb2wucmVsZWFzZShjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1haW4gdXBkYXRlIGxvb3BcbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICAgIHRoaXMuY2xlYW51cERlc3Ryb3llZEVudGl0aWVzKCk7XG5cbiAgICAvLyBVcGRhdGUgYWxsIHN5c3RlbXNcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLnVwZGF0ZShtYXRjaGluZ0VudGl0aWVzLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpeGVkIHRpbWVzdGVwIHBoeXNpY3MgdXBkYXRlXG4gIHB1YmxpYyBmaXhlZFVwZGF0ZShmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5waHlzaWNzU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0uZml4ZWRVcGRhdGUobWF0Y2hpbmdFbnRpdGllcywgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciB1cGRhdGVcbiAgcHVibGljIHJlbmRlcihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMucmVuZGVyU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0ucmVuZGVyKG1hdGNoaW5nRW50aXRpZXMsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGVudGl0aWVzIHRoYXQgbWF0Y2ggYSBzeXN0ZW0ncyByZXF1aXJlbWVudHNcbiAgcHJpdmF0ZSBnZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW06IFN5c3RlbSk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBBcnJheS5mcm9tKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKSB7XG4gICAgICBpZiAoc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICBwcml2YXRlIGNsZWFudXBEZXN0cm95ZWRFbnRpdGllcygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgLy8gTm90aWZ5IHN5c3RlbXMgYWJvdXQgZW50aXR5IHJlbW92YWxcbiAgICAgICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5zeXN0ZW1zKSB7XG4gICAgICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eVJlbW92ZWQgJiYgc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICAgICAgc3lzdGVtLm9uRW50aXR5UmVtb3ZlZChlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJuIGNvbXBvbmVudHMgdG8gcG9vbHNcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZW50aXR5LmdldEFsbENvbXBvbmVudHMoKSkge1xuICAgICAgICAgIHRoaXMucmV0dXJuQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVudGl0eS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gUXVlcnkgZW50aXRpZXMgYnkgY29tcG9uZW50c1xuICBwdWJsaWMgcXVlcnlFbnRpdGllcyhjb21wb25lbnRUeXBlczogKG5ldyAoKSA9PiBDb21wb25lbnQpW10pOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgaWYgKGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzKSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIEV2ZW50IHN5c3RlbVxuICBwdWJsaWMgZW1pdEV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudERhdGE6IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSkhLnB1c2goZXZlbnREYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFdmVudHMoZXZlbnRUeXBlOiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpIHx8IFtdO1xuICB9XG5cbiAgcHVibGljIGNsZWFyRXZlbnRzKGV2ZW50VHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50VHlwZSwgW10pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIGVudGl0aWVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbnRpdGllcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYW4gdXAgc3lzdGVtc1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVuZGVyU3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGh5c2ljc1N5c3RlbXMubGVuZ3RoID0gMDtcblxuICAgIC8vIENsZWFyIGNvbXBvbmVudCBwb29sc1xuICAgIHRoaXMuY29tcG9uZW50UG9vbHMuY2xlYXIoKTtcbiAgICBcbiAgICAvLyBDbGVhciBldmVudHNcbiAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRW50aXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSIsIk9iamVjdFBvb2wiLCJXb3JsZCIsImNyZWF0ZUVudGl0eSIsImVudGl0eSIsImVudGl0aWVzIiwic2V0IiwiaWQiLCJkZXN0cm95RW50aXR5IiwiZW50aXR5SWQiLCJlbnRpdGllc1RvRGVzdHJveSIsInB1c2giLCJub3RpZnlFbnRpdHlBZGRlZCIsInN5c3RlbSIsInN5c3RlbXMiLCJvbkVudGl0eUFkZGVkIiwibWF0Y2hlc0VudGl0eSIsImdldEVudGl0eSIsImdldCIsImdldEFsbEVudGl0aWVzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYWRkU3lzdGVtIiwic29ydCIsImEiLCJiIiwicHJpb3JpdHkiLCJyZW5kZXJTeXN0ZW1zIiwicGh5c2ljc1N5c3RlbXMiLCJvbkVuYWJsZSIsImdldFN5c3RlbSIsInN5c3RlbUNsYXNzIiwiZmluZCIsInJlbW92ZVN5c3RlbSIsInN5c3RlbVR5cGUiLCJpbmRleCIsImZpbmRJbmRleCIsInMiLCJvbkRpc2FibGUiLCJzcGxpY2UiLCJyZW5kZXJJbmRleCIsInBoeXNpY3NJbmRleCIsImNyZWF0ZUNvbXBvbmVudCIsImNvbXBvbmVudFR5cGUiLCJ0eXBlTmFtZSIsIm5hbWUiLCJwcm9ibGVtYXRpY0NvbXBvbmVudHMiLCJpbmNsdWRlcyIsInBvb2wiLCJjb21wb25lbnRQb29scyIsIm9iaiIsInJlc2V0IiwiYWNxdWlyZSIsInJldHVybkNvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicmVsZWFzZSIsInVwZGF0ZSIsImRlbHRhVGltZSIsImNsZWFudXBEZXN0cm95ZWRFbnRpdGllcyIsImVuYWJsZWQiLCJtYXRjaGluZ0VudGl0aWVzIiwiZ2V0RW50aXRpZXNGb3JTeXN0ZW0iLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwicmVuZGVyIiwib25FbnRpdHlSZW1vdmVkIiwiZ2V0QWxsQ29tcG9uZW50cyIsImRlc3Ryb3kiLCJkZWxldGUiLCJsZW5ndGgiLCJxdWVyeUVudGl0aWVzIiwiY29tcG9uZW50VHlwZXMiLCJpc0FjdGl2ZSIsImhhc0NvbXBvbmVudHMiLCJlbWl0RXZlbnQiLCJldmVudFR5cGUiLCJldmVudERhdGEiLCJldmVudHMiLCJoYXMiLCJnZXRFdmVudHMiLCJjbGVhckV2ZW50cyIsImNsZWFyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/World.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Collider.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Collider.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collider: function() { return /* binding */ Collider; },\n/* harmony export */   ColliderType: function() { return /* binding */ ColliderType; },\n/* harmony export */   CollisionLayer: function() { return /* binding */ CollisionLayer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Collider component for collision detection\n\n\nvar ColliderType;\n(function(ColliderType) {\n    ColliderType[\"SPHERE\"] = \"sphere\";\n    ColliderType[\"BOX\"] = \"box\";\n    ColliderType[\"CAPSULE\"] = \"capsule\";\n    ColliderType[\"CYLINDER\"] = \"cylinder\";\n})(ColliderType || (ColliderType = {}));\nvar CollisionLayer;\n(function(CollisionLayer) {\n    CollisionLayer[CollisionLayer[\"DEFAULT\"] = 1] = \"DEFAULT\";\n    CollisionLayer[CollisionLayer[\"PLAYER\"] = 2] = \"PLAYER\";\n    CollisionLayer[CollisionLayer[\"ENEMY\"] = 4] = \"ENEMY\";\n    CollisionLayer[CollisionLayer[\"PROJECTILE\"] = 8] = \"PROJECTILE\";\n    CollisionLayer[CollisionLayer[\"ENVIRONMENT\"] = 16] = \"ENVIRONMENT\";\n    CollisionLayer[CollisionLayer[\"PICKUP\"] = 32] = \"PICKUP\";\n})(CollisionLayer || (CollisionLayer = {}));\nclass Collider extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    getDefaultMask(layer) {\n        switch(layer){\n            case 2:\n                return 4 | 16 | 32;\n            case 4:\n                return 2 | 8 | 16;\n            case 8:\n                return 2 | 4 | 16;\n            case 16:\n                return 2 | 4 | 8;\n            case 32:\n                return 2;\n            default:\n                return 0xFFFFFFFF; // Collide with everything\n        }\n    }\n    static createSphere(radius) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return new Collider(\"sphere\", radius, layer);\n    }\n    static createBox(size) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const collider = new Collider(\"box\", 0, layer);\n        collider.size.copy(size);\n        return collider;\n    }\n    static createCapsule(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"capsule\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    static createCylinder(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"cylinder\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    setOffset(x, y, z) {\n        this.offset.set(x, y, z);\n        this.boundsNeedUpdate = true;\n    }\n    setLayer(layer) {\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n    }\n    setMask(mask) {\n        this.mask = mask;\n    }\n    canCollideWith(other) {\n        return (this.mask & other.layer) !== 0 && (other.mask & this.layer) !== 0;\n    }\n    updateBounds(worldPosition) {\n        if (!this.boundsNeedUpdate && !this.isStatic) {\n            return;\n        }\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                this.boundingSphere.set(center, this.radius);\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.radius * 2, this.radius * 2));\n                break;\n            case \"box\":\n                this.bounds.setFromCenterAndSize(center, this.size);\n                this.boundingSphere.setFromPoints([\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-this.size.x / 2, -this.size.y / 2, -this.size.z / 2)),\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.size.x / 2, this.size.y / 2, this.size.z / 2))\n                ]);\n                break;\n            case \"capsule\":\n                const capsuleRadius = Math.max(this.radius, this.size.x / 2, this.size.z / 2);\n                this.boundingSphere.set(center, Math.max(capsuleRadius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(capsuleRadius * 2, this.height, capsuleRadius * 2));\n                break;\n            case \"cylinder\":\n                this.boundingSphere.set(center, Math.max(this.radius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.height, this.radius * 2));\n                break;\n        }\n        this.boundsNeedUpdate = false;\n    }\n    intersects(other, thisPosition, otherPosition) {\n        // Update bounds if needed\n        this.updateBounds(thisPosition);\n        other.updateBounds(otherPosition);\n        // Quick bounding sphere check first\n        if (!this.boundingSphere.intersectsSphere(other.boundingSphere)) {\n            return false;\n        }\n        // More precise collision detection based on collider types\n        return this.preciseIntersection(other, thisPosition, otherPosition);\n    }\n    preciseIntersection(other, thisPosition, otherPosition) {\n        const thisCenter = thisPosition.clone().add(this.offset);\n        const otherCenter = otherPosition.clone().add(other.offset);\n        // Sphere vs Sphere\n        if (this.type === \"sphere\" && other.type === \"sphere\") {\n            const distance = thisCenter.distanceTo(otherCenter);\n            return distance <= this.radius + other.radius;\n        }\n        // Box vs Box\n        if (this.type === \"box\" && other.type === \"box\") {\n            return this.bounds.intersectsBox(other.bounds);\n        }\n        // Sphere vs Box\n        if (this.type === \"sphere\" && other.type === \"box\" || this.type === \"box\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const box = this.type === \"box\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            box.bounds.clampPoint(sphereCenter, closestPoint);\n            return sphereCenter.distanceTo(closestPoint) <= sphere.radius;\n        }\n        // Sphere vs Cylinder (for pillar collisions)\n        if (this.type === \"sphere\" && other.type === \"cylinder\" || this.type === \"cylinder\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const cylinder = this.type === \"cylinder\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const cylinderCenter = this.type === \"cylinder\" ? thisCenter : otherCenter;\n            // Check if sphere is within cylinder's height range\n            const heightDiff = Math.abs(sphereCenter.y - cylinderCenter.y);\n            if (heightDiff > cylinder.height / 2 + sphere.radius) {\n                return false; // Sphere is above or below cylinder\n            }\n            // Check horizontal distance (XZ plane)\n            const horizontalDistance = Math.sqrt(Math.pow(sphereCenter.x - cylinderCenter.x, 2) + Math.pow(sphereCenter.z - cylinderCenter.z, 2));\n            return horizontalDistance <= sphere.radius + cylinder.radius;\n        }\n        // For other combinations, fall back to bounding box intersection\n        return this.bounds.intersectsBox(other.bounds);\n    }\n    getClosestPoint(point, worldPosition) {\n        this.updateBounds(worldPosition);\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                const direction = point.clone().sub(center).normalize();\n                return center.clone().add(direction.multiplyScalar(this.radius));\n            case \"box\":\n                const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, closestPoint);\n                return closestPoint;\n            default:\n                // For other types, use bounding box\n                const boxClosest = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, boxClosest);\n                return boxClosest;\n        }\n    }\n    getVolume() {\n        switch(this.type){\n            case \"sphere\":\n                return 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n            case \"box\":\n                return this.size.x * this.size.y * this.size.z;\n            case \"cylinder\":\n                return Math.PI * Math.pow(this.radius, 2) * this.height;\n            case \"capsule\":\n                const sphereVolume = 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n                const cylinderVolume = Math.PI * Math.pow(this.radius, 2) * (this.height - 2 * this.radius);\n                return sphereVolume + cylinderVolume;\n            default:\n                return 1;\n        }\n    }\n    reset() {\n        this.type = \"sphere\";\n        this.radius = 0.5;\n        this.size.set(1, 1, 1);\n        this.height = 2;\n        this.offset.set(0, 0, 0);\n        this.layer = 1;\n        this.mask = this.getDefaultMask(1);\n        this.isTrigger = false;\n        this.isStatic = false;\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n        this.onCollisionEnter = undefined;\n        this.onCollisionStay = undefined;\n        this.onCollisionExit = undefined;\n        this.onTriggerEnter = undefined;\n        this.onTriggerStay = undefined;\n        this.onTriggerExit = undefined;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Collider(this.type, this.radius, this.layer);\n        clone.size.copy(this.size);\n        clone.height = this.height;\n        clone.offset.copy(this.offset);\n        clone.mask = this.mask;\n        clone.isTrigger = this.isTrigger;\n        clone.isStatic = this.isStatic;\n        return clone;\n    }\n    constructor(type = \"sphere\", radius = 0.5, layer = 1){\n        super();\n        this.componentType = \"Collider\" // Instance identifier\n        ;\n        this.type = type;\n        this.radius = radius;\n        this.size = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.height = 2;\n        this.offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n        this.isTrigger = false;\n        this.isStatic = false;\n        // Initialize bounds\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n    }\n}\nCollider.componentType = \"Collider\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Db2xsaWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDZDQUE2QztBQUNpQjtBQUN4Qjs7VUFFMUJJOzs7OztHQUFBQSxpQkFBQUE7O1VBT0FDOzs7Ozs7O0dBQUFBLG1CQUFBQTtBQVNMLE1BQU1DLGlCQUFpQkgsOENBQVNBO0lBaUQ3QkksZUFBZUMsS0FBcUIsRUFBVTtRQUNwRCxPQUFRQTtZQUNOO2dCQUNFLE9BQU9IO1lBQ1Q7Z0JBQ0UsT0FBT0E7WUFDVDtnQkFDRSxPQUFPQTtZQUNUO2dCQUNFLE9BQU9BO1lBQ1Q7Z0JBQ0U7WUFDRjtnQkFDRSxPQUFPLFlBQVksMEJBQTBCO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFjSSxhQUFhQyxNQUFjLEVBQTREO1lBQTFERixRQUFBQTtRQUN6QyxPQUFPLElBQUlGLG1CQUE4QkksUUFBUUY7SUFDbkQ7SUFFQSxPQUFjRyxVQUFVQyxJQUFhLEVBQTREO1lBQTFESixRQUFBQTtRQUNyQyxNQUFNSyxXQUFXLElBQUlQLGdCQUEyQixHQUFHRTtRQUNuREssU0FBU0QsSUFBSSxDQUFDRSxJQUFJLENBQUNGO1FBQ25CLE9BQU9DO0lBQ1Q7SUFFQSxPQUFjRSxjQUFjTCxNQUFjLEVBQUVNLE1BQWMsRUFBNEQ7WUFBMURSLFFBQUFBO1FBQzFELE1BQU1LLFdBQVcsSUFBSVAsb0JBQStCSSxRQUFRRjtRQUM1REssU0FBU0csTUFBTSxHQUFHQTtRQUNsQixPQUFPSDtJQUNUO0lBRUEsT0FBY0ksZUFBZVAsTUFBYyxFQUFFTSxNQUFjLEVBQTREO1lBQTFEUixRQUFBQTtRQUMzRCxNQUFNSyxXQUFXLElBQUlQLHFCQUFnQ0ksUUFBUUY7UUFDN0RLLFNBQVNHLE1BQU0sR0FBR0E7UUFDbEIsT0FBT0g7SUFDVDtJQUVPSyxVQUFVQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFRO1FBQ3RELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUNK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QjtRQUNwQixJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJckMsc0RBQUlBO1FBQ3RCLElBQUksQ0FBQ29DLGNBQWMsR0FBRyxJQUFJbkMsd0RBQU1BO1FBQ2hDLElBQUksQ0FBQ3NCLGdCQUFnQixHQUFHO0lBQzFCO0FBZ1BGO0FBL1JhbEIsU0FDWWtGLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXIudHM/MzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsaWRlciBjb21wb25lbnQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMsIFNwaGVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBDb2xsaWRlclR5cGUge1xuICBTUEhFUkUgPSAnc3BoZXJlJyxcbiAgQk9YID0gJ2JveCcsXG4gIENBUFNVTEUgPSAnY2Fwc3VsZScsXG4gIENZTElOREVSID0gJ2N5bGluZGVyJ1xufVxuXG5leHBvcnQgZW51bSBDb2xsaXNpb25MYXllciB7XG4gIERFRkFVTFQgPSAxLFxuICBQTEFZRVIgPSAyLFxuICBFTkVNWSA9IDQsXG4gIFBST0pFQ1RJTEUgPSA4LFxuICBFTlZJUk9OTUVOVCA9IDE2LFxuICBQSUNLVVAgPSAzMlxufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB0eXBlOiBDb2xsaWRlclR5cGU7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjsgLy8gRm9yIHNwaGVyZSBhbmQgY3lsaW5kZXJcbiAgcHVibGljIHNpemU6IFZlY3RvcjM7IC8vIEZvciBib3ggKHdpZHRoLCBoZWlnaHQsIGRlcHRoKVxuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7IC8vIEZvciBjYXBzdWxlIGFuZCBjeWxpbmRlclxuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzOyAvLyBPZmZzZXQgZnJvbSB0cmFuc2Zvcm0gcG9zaXRpb25cbiAgcHVibGljIGxheWVyOiBDb2xsaXNpb25MYXllcjtcbiAgcHVibGljIG1hc2s6IG51bWJlcjsgLy8gV2hpY2ggbGF5ZXJzIHRoaXMgY29sbGlkZXIgY2FuIGNvbGxpZGUgd2l0aFxuICBwdWJsaWMgaXNUcmlnZ2VyOiBib29sZWFuOyAvLyBJZiB0cnVlLCBkb2Vzbid0IGJsb2NrIG1vdmVtZW50IGJ1dCBzdGlsbCBkZXRlY3RzIGNvbGxpc2lvbnNcbiAgcHVibGljIGlzU3RhdGljOiBib29sZWFuOyAvLyBJZiB0cnVlLCBjb2xsaWRlciBkb2Vzbid0IG1vdmUgKG9wdGltaXphdGlvbilcbiAgXG4gIC8vIENhY2hlZCBib3VuZHMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBib3VuZHM6IEJveDM7XG4gIHB1YmxpYyBib3VuZGluZ1NwaGVyZTogU3BoZXJlO1xuICBwdWJsaWMgYm91bmRzTmVlZFVwZGF0ZTogYm9vbGVhbjtcbiAgXG4gIC8vIENvbGxpc2lvbiBjYWxsYmFja3NcbiAgcHVibGljIG9uQ29sbGlzaW9uRW50ZXI/OiAob3RoZXI6IENvbGxpZGVyLCBlbnRpdHk6IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIG9uQ29sbGlzaW9uU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25Db2xsaXNpb25FeGl0PzogKG90aGVyOiBDb2xsaWRlciwgZW50aXR5OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBvblRyaWdnZXJFbnRlcj86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyRXhpdD86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IENvbGxpZGVyVHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkUsXG4gICAgcmFkaXVzOiBudW1iZXIgPSAwLjUsXG4gICAgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSAyO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2sobGF5ZXIpO1xuICAgIHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYm91bmRzXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1hc2sobGF5ZXI6IENvbGxpc2lvbkxheWVyKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGxheWVyKSB7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBMQVlFUjpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLkVORU1ZIHwgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQgfCBDb2xsaXNpb25MYXllci5QSUNLVVA7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLkVORU1ZOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRSB8IENvbGxpc2lvbkxheWVyLkVOVklST05NRU5UO1xuICAgICAgY2FzZSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuRU5FTVkgfCBDb2xsaXNpb25MYXllci5FTlZJUk9OTUVOVDtcbiAgICAgIGNhc2UgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQ6XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25MYXllci5QTEFZRVIgfCBDb2xsaXNpb25MYXllci5FTkVNWSB8IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBJQ0tVUDpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLlBMQVlFUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAweEZGRkZGRkZGOyAvLyBDb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3BoZXJlKHJhZGl1czogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIHJldHVybiBuZXcgQ29sbGlkZXIoQ29sbGlkZXJUeXBlLlNQSEVSRSwgcmFkaXVzLCBsYXllcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUJveChzaXplOiBWZWN0b3IzLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5CT1gsIDAsIGxheWVyKTtcbiAgICBjb2xsaWRlci5zaXplLmNvcHkoc2l6ZSk7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYXBzdWxlKHJhZGl1czogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk6IENvbGxpZGVyIHtcbiAgICBjb25zdCBjb2xsaWRlciA9IG5ldyBDb2xsaWRlcihDb2xsaWRlclR5cGUuQ0FQU1VMRSwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ3lsaW5kZXIocmFkaXVzOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5DWUxJTkRFUiwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPZmZzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0LnNldCh4LCB5LCB6KTtcbiAgICB0aGlzLmJvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNldExheWVyKGxheWVyOiBDb2xsaXNpb25MYXllcik6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLm1hc2sgPSB0aGlzLmdldERlZmF1bHRNYXNrKGxheWVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXNrKG1hc2s6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cblxuICBwdWJsaWMgY2FuQ29sbGlkZVdpdGgob3RoZXI6IENvbGxpZGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBvdGhlci5sYXllcikgIT09IDAgJiYgKG90aGVyLm1hc2sgJiB0aGlzLmxheWVyKSAhPT0gMDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVCb3VuZHMod29ybGRQb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ib3VuZHNOZWVkVXBkYXRlICYmICF0aGlzLmlzU3RhdGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuU1BIRVJFOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQk9YOlxuICAgICAgICB0aGlzLmJvdW5kcy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgICAgY2VudGVyLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IzKC10aGlzLnNpemUueC8yLCAtdGhpcy5zaXplLnkvMiwgLXRoaXMuc2l6ZS56LzIpKSxcbiAgICAgICAgICBjZW50ZXIuY2xvbmUoKS5hZGQobmV3IFZlY3RvcjModGhpcy5zaXplLngvMiwgdGhpcy5zaXplLnkvMiwgdGhpcy5zaXplLnovMikpXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQ0FQU1VMRTpcbiAgICAgICAgY29uc3QgY2Fwc3VsZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLnNpemUueCAvIDIsIHRoaXMuc2l6ZS56IC8gMik7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KGNlbnRlciwgTWF0aC5tYXgoY2Fwc3VsZVJhZGl1cywgdGhpcy5oZWlnaHQgLyAyKSk7XG4gICAgICAgIHRoaXMuYm91bmRzLnNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgbmV3IFZlY3RvcjMoXG4gICAgICAgICAgY2Fwc3VsZVJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCBjYXBzdWxlUmFkaXVzICogMlxuICAgICAgICApKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNZTElOREVSOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodCAvIDIpKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyAqIDJcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGludGVyc2VjdHMob3RoZXI6IENvbGxpZGVyLCB0aGlzUG9zaXRpb246IFZlY3RvcjMsIG90aGVyUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAvLyBVcGRhdGUgYm91bmRzIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlQm91bmRzKHRoaXNQb3NpdGlvbik7XG4gICAgb3RoZXIudXBkYXRlQm91bmRzKG90aGVyUG9zaXRpb24pO1xuXG4gICAgLy8gUXVpY2sgYm91bmRpbmcgc3BoZXJlIGNoZWNrIGZpcnN0XG4gICAgaWYgKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNTcGhlcmUob3RoZXIuYm91bmRpbmdTcGhlcmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9yZSBwcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmFzZWQgb24gY29sbGlkZXIgdHlwZXNcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyLCB0aGlzUG9zaXRpb24sIG90aGVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyOiBDb2xsaWRlciwgdGhpc1Bvc2l0aW9uOiBWZWN0b3IzLCBvdGhlclBvc2l0aW9uOiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGhpc0NlbnRlciA9IHRoaXNQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgY29uc3Qgb3RoZXJDZW50ZXIgPSBvdGhlclBvc2l0aW9uLmNsb25lKCkuYWRkKG90aGVyLm9mZnNldCk7XG5cbiAgICAvLyBTcGhlcmUgdnMgU3BoZXJlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXNDZW50ZXIuZGlzdGFuY2VUbyhvdGhlckNlbnRlcik7XG4gICAgICByZXR1cm4gZGlzdGFuY2UgPD0gKHRoaXMucmFkaXVzICsgb3RoZXIucmFkaXVzKTtcbiAgICB9XG5cbiAgICAvLyBCb3ggdnMgQm94XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLkJPWCAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuaW50ZXJzZWN0c0JveChvdGhlci5ib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFNwaGVyZSB2cyBCb3hcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB8fFxuICAgICAgICAodGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YICYmIG90aGVyLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUpKSB7XG4gICAgICBjb25zdCBzcGhlcmUgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBib3ggPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5CT1ggPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBzcGhlcmVDZW50ZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBib3guYm91bmRzLmNsYW1wUG9pbnQoc3BoZXJlQ2VudGVyLCBjbG9zZXN0UG9pbnQpO1xuICAgICAgcmV0dXJuIHNwaGVyZUNlbnRlci5kaXN0YW5jZVRvKGNsb3Nlc3RQb2ludCkgPD0gc3BoZXJlLnJhZGl1cztcbiAgICB9XG5cbiAgICAvLyBTcGhlcmUgdnMgQ3lsaW5kZXIgKGZvciBwaWxsYXIgY29sbGlzaW9ucylcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIpIHx8XG4gICAgICAgICh0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSkge1xuICAgICAgY29uc3Qgc3BoZXJlID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFID8gdGhpcyA6IG90aGVyO1xuICAgICAgY29uc3QgY3lsaW5kZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiA/IHRoaXMgOiBvdGhlcjtcbiAgICAgIGNvbnN0IHNwaGVyZUNlbnRlciA9IHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSA/IHRoaXNDZW50ZXIgOiBvdGhlckNlbnRlcjtcbiAgICAgIGNvbnN0IGN5bGluZGVyQ2VudGVyID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNwaGVyZSBpcyB3aXRoaW4gY3lsaW5kZXIncyBoZWlnaHQgcmFuZ2VcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhzcGhlcmVDZW50ZXIueSAtIGN5bGluZGVyQ2VudGVyLnkpO1xuICAgICAgaWYgKGhlaWdodERpZmYgPiAoY3lsaW5kZXIuaGVpZ2h0IC8gMiArIHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3BoZXJlIGlzIGFib3ZlIG9yIGJlbG93IGN5bGluZGVyXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKFhaIHBsYW5lKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzcGhlcmVDZW50ZXIueCAtIGN5bGluZGVyQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KHNwaGVyZUNlbnRlci56IC0gY3lsaW5kZXJDZW50ZXIueiwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBob3Jpem9udGFsRGlzdGFuY2UgPD0gKHNwaGVyZS5yYWRpdXMgKyBjeWxpbmRlci5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBjb21iaW5hdGlvbnMsIGZhbGwgYmFjayB0byBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3gob3RoZXIuYm91bmRzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDbG9zZXN0UG9pbnQocG9pbnQ6IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcyh3b3JsZFBvc2l0aW9uKTtcbiAgICBjb25zdCBjZW50ZXIgPSB3b3JsZFBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKSk7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkJPWDpcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuY2xhbXBQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yIG90aGVyIHR5cGVzLCB1c2UgYm91bmRpbmcgYm94XG4gICAgICAgIGNvbnN0IGJveENsb3Nlc3QgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmJvdW5kcy5jbGFtcFBvaW50KHBvaW50LCBib3hDbG9zZXN0KTtcbiAgICAgICAgcmV0dXJuIGJveENsb3Nlc3Q7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZvbHVtZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIHJldHVybiAoNC8zKSAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMyk7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5CT1g6XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55ICogdGhpcy5zaXplLno7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5DWUxJTkRFUjpcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNBUFNVTEU6XG4gICAgICAgIGNvbnN0IHNwaGVyZVZvbHVtZSA9ICg0LzMpICogTWF0aC5QSSAqIE1hdGgucG93KHRoaXMucmFkaXVzLCAzKTtcbiAgICAgICAgY29uc3QgY3lsaW5kZXJWb2x1bWUgPSBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICogKHRoaXMuaGVpZ2h0IC0gMiAqIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHNwaGVyZVZvbHVtZSArIGN5bGluZGVyVm9sdW1lO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjU7XG4gICAgdGhpcy5zaXplLnNldCgxLCAxLCAxKTtcbiAgICB0aGlzLmhlaWdodCA9IDI7XG4gICAgdGhpcy5vZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2soQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk7XG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uQ29sbGlzaW9uRW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvblN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvbkV4aXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpZ2dlclN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFeGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IENvbGxpZGVyKHRoaXMudHlwZSwgdGhpcy5yYWRpdXMsIHRoaXMubGF5ZXIpO1xuICAgIGNsb25lLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTtcbiAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgIGNsb25lLmlzVHJpZ2dlciA9IHRoaXMuaXNUcmlnZ2VyO1xuICAgIGNsb25lLmlzU3RhdGljID0gdGhpcy5pc1N0YXRpYztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwaGVyZSIsIkNvbXBvbmVudCIsIkNvbGxpZGVyVHlwZSIsIkNvbGxpc2lvbkxheWVyIiwiQ29sbGlkZXIiLCJnZXREZWZhdWx0TWFzayIsImxheWVyIiwiY3JlYXRlU3BoZXJlIiwicmFkaXVzIiwiY3JlYXRlQm94Iiwic2l6ZSIsImNvbGxpZGVyIiwiY29weSIsImNyZWF0ZUNhcHN1bGUiLCJoZWlnaHQiLCJjcmVhdGVDeWxpbmRlciIsInNldE9mZnNldCIsIngiLCJ5IiwieiIsIm9mZnNldCIsInNldCIsImJvdW5kc05lZWRVcGRhdGUiLCJzZXRMYXllciIsIm1hc2siLCJzZXRNYXNrIiwiY2FuQ29sbGlkZVdpdGgiLCJvdGhlciIsInVwZGF0ZUJvdW5kcyIsIndvcmxkUG9zaXRpb24iLCJpc1N0YXRpYyIsImNlbnRlciIsImNsb25lIiwiYWRkIiwidHlwZSIsImJvdW5kaW5nU3BoZXJlIiwiYm91bmRzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJzZXRGcm9tUG9pbnRzIiwiY2Fwc3VsZVJhZGl1cyIsIk1hdGgiLCJtYXgiLCJpbnRlcnNlY3RzIiwidGhpc1Bvc2l0aW9uIiwib3RoZXJQb3NpdGlvbiIsImludGVyc2VjdHNTcGhlcmUiLCJwcmVjaXNlSW50ZXJzZWN0aW9uIiwidGhpc0NlbnRlciIsIm90aGVyQ2VudGVyIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiaW50ZXJzZWN0c0JveCIsInNwaGVyZSIsImJveCIsInNwaGVyZUNlbnRlciIsImNsb3Nlc3RQb2ludCIsImNsYW1wUG9pbnQiLCJjeWxpbmRlciIsImN5bGluZGVyQ2VudGVyIiwiaGVpZ2h0RGlmZiIsImFicyIsImhvcml6b250YWxEaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJnZXRDbG9zZXN0UG9pbnQiLCJwb2ludCIsImRpcmVjdGlvbiIsInN1YiIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiYm94Q2xvc2VzdCIsImdldFZvbHVtZSIsIlBJIiwic3BoZXJlVm9sdW1lIiwiY3lsaW5kZXJWb2x1bWUiLCJyZXNldCIsImlzVHJpZ2dlciIsIm9uQ29sbGlzaW9uRW50ZXIiLCJ1bmRlZmluZWQiLCJvbkNvbGxpc2lvblN0YXkiLCJvbkNvbGxpc2lvbkV4aXQiLCJvblRyaWdnZXJFbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvblRyaWdnZXJFeGl0IiwiZW5hYmxlZCIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Collider.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Enemy.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Enemy.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: function() { return /* binding */ Enemy; },\n/* harmony export */   EnemyType: function() { return /* binding */ EnemyType; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Enemy component for identifying enemy entities\n\nvar EnemyType;\n(function(EnemyType) {\n    EnemyType[\"DUMMY\"] = \"dummy\";\n    EnemyType[\"GRUNT\"] = \"grunt\";\n    EnemyType[\"ELITE\"] = \"elite\";\n    EnemyType[\"BOSS\"] = \"boss\";\n})(EnemyType || (EnemyType = {}));\nclass Enemy extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    calculateExperienceReward() {\n        const baseExp = {\n            [\"dummy\"]: 5,\n            [\"grunt\"]: 10,\n            [\"elite\"]: 25,\n            [\"boss\"]: 100\n        };\n        return baseExp[this.type] * this.level;\n    }\n    calculateAggroRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 5,\n            [\"elite\"]: 8,\n            [\"boss\"]: 12\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 1.5,\n            [\"elite\"]: 2,\n            [\"boss\"]: 3\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackDamage() {\n        const baseDamage = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 15,\n            [\"elite\"]: 25,\n            [\"boss\"]: 50\n        };\n        return baseDamage[this.type] * this.level;\n    }\n    calculateAttackCooldown() {\n        const baseCooldown = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 2,\n            [\"elite\"]: 1.5,\n            [\"boss\"]: 1\n        };\n        return baseCooldown[this.type];\n    }\n    calculateMovementSpeed() {\n        const baseSpeed = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 3,\n            [\"elite\"]: 0,\n            [\"boss\"]: 2.5\n        };\n        return baseSpeed[this.type];\n    }\n    canAttack(currentTime) {\n        if (!this.isAggressive || this.isDead || this.attackDamage === 0) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    takeDamage() {\n    // This will be handled by the Health component\n    // This method is for enemy-specific damage reactions\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.deathTime = currentTime;\n    }\n    canRespawnNow(currentTime) {\n        if (!this.canRespawn || !this.isDead) {\n            return false;\n        }\n        return currentTime - this.deathTime >= this.respawnTime;\n    }\n    respawn() {\n        this.isDead = false;\n        this.deathTime = 0;\n        this.lastAttackTime = 0;\n        // Clear freeze status on respawn\n        this.unfreeze();\n        // Clear venom status on respawn\n        this.removeVenom();\n    }\n    freeze(duration, currentTime) {\n        if (this.isDead) return; // Can't freeze dead enemies\n        this.isFrozen = true;\n        this.freezeStartTime = currentTime;\n        this.freezeDuration = duration;\n        // Set movement speed to 0 when frozen\n        this.movementSpeed = 0;\n    }\n    unfreeze() {\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        // Restore original movement speed\n        this.movementSpeed = this.originalMovementSpeed;\n    }\n    updateFreezeStatus(currentTime) {\n        if (!this.isFrozen) return;\n        const elapsed = currentTime - this.freezeStartTime;\n        if (elapsed >= this.freezeDuration) {\n            this.unfreeze();\n        }\n    }\n    canMove() {\n        return !this.isFrozen && !this.isDead;\n    }\n    applyVenom(duration, damagePerSecond, currentTime) {\n        if (this.isDead) return; // Can't apply venom to dead enemies\n        this.isVenomous = true;\n        this.venomStartTime = currentTime;\n        this.venomDuration = duration;\n        this.venomDamagePerSecond = damagePerSecond;\n        this.lastVenomDamageTime = currentTime;\n    }\n    removeVenom() {\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    updateVenomStatus(currentTime) {\n        if (!this.isVenomous) return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n        const elapsed = currentTime - this.venomStartTime;\n        if (elapsed >= this.venomDuration) {\n            this.removeVenom();\n            return {\n                shouldDealDamage: false,\n                damage: 0\n            };\n        }\n        // Check if we should deal damage (every second)\n        const timeSinceLastDamage = currentTime - this.lastVenomDamageTime;\n        if (timeSinceLastDamage >= 1.0) {\n            this.lastVenomDamageTime = currentTime;\n            return {\n                shouldDealDamage: true,\n                damage: this.venomDamagePerSecond\n            };\n        }\n        return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n    }\n    applySunderStack(currentTime) {\n        if (this.isDead) return; // Can't apply sunder to dead enemies\n        // Check if existing stacks have expired\n        if (this.sunderStacks > 0 && currentTime - this.sunderLastApplied > this.sunderDuration) {\n            this.sunderStacks = 0;\n        }\n        // Add new stack (max 3)\n        if (this.sunderStacks < 3) {\n            this.sunderStacks++;\n        }\n        // Update timing\n        this.sunderLastApplied = currentTime;\n    }\n    getSunderStacks() {\n        return this.sunderStacks;\n    }\n    clearSunderStacks() {\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n    }\n    updateSunderStatus(currentTime) {\n        if (this.sunderStacks <= 0) return;\n        const elapsed = currentTime - this.sunderLastApplied;\n        if (elapsed >= this.sunderDuration) {\n            this.clearSunderStacks();\n        }\n    }\n    setLevel(newLevel) {\n        this.level = Math.max(1, newLevel);\n        this.experienceReward = this.calculateExperienceReward();\n        this.attackDamage = this.calculateAttackDamage();\n    }\n    getDisplayName() {\n        const typeNames = {\n            [\"dummy\"]: \"Training Dummy\",\n            [\"grunt\"]: \"Grunt\",\n            [\"elite\"]: \"Elite\",\n            [\"boss\"]: \"Boss\"\n        };\n        return \"\".concat(typeNames[this.type], \" (Lv.\").concat(this.level, \")\");\n    }\n    reset() {\n        this.type = \"dummy\";\n        this.level = 1;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = false;\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30;\n        this.canRespawn = true;\n        this.enabled = true;\n        // Reset freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Reset venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n        // Reset sunder stacks\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n    }\n    clone() {\n        const clone = new Enemy(this.type, this.level);\n        clone.experienceReward = this.experienceReward;\n        clone.isAggressive = this.isAggressive;\n        clone.aggroRange = this.aggroRange;\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.movementSpeed = this.movementSpeed;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.respawnTime = this.respawnTime;\n        clone.canRespawn = this.canRespawn;\n        // Clone freeze status\n        clone.isFrozen = this.isFrozen;\n        clone.freezeStartTime = this.freezeStartTime;\n        clone.freezeDuration = this.freezeDuration;\n        clone.originalMovementSpeed = this.originalMovementSpeed;\n        // Clone venom status\n        clone.isVenomous = this.isVenomous;\n        clone.venomStartTime = this.venomStartTime;\n        clone.venomDuration = this.venomDuration;\n        clone.venomDamagePerSecond = this.venomDamagePerSecond;\n        clone.lastVenomDamageTime = this.lastVenomDamageTime;\n        // Clone sunder stacks\n        clone.sunderStacks = this.sunderStacks;\n        clone.sunderLastApplied = this.sunderLastApplied;\n        return clone;\n    }\n    constructor(type = \"dummy\", level = 1){\n        super();\n        this.componentType = \"Enemy\" // Instance identifier\n        ;\n        this.type = type;\n        this.level = level;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = type !== \"dummy\";\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30; // 30 seconds default respawn time\n        this.canRespawn = true;\n        // Initialize freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Initialize venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n        // Initialize sunder stacks\n        this.sunderStacks = 0;\n        this.sunderLastApplied = 0;\n        this.sunderDuration = 10.0; // 10 seconds\n    }\n}\nEnemy.componentType = \"Enemy\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9FbmVteS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBaUQ7QUFDWDs7VUFFMUJDOzs7OztHQUFBQSxjQUFBQTtBQU9MLE1BQU1DLGNBQWNGLDhDQUFTQTtJQTRFMUJHLDRCQUFvQztRQUMxQyxNQUFNQyxVQUFVO1lBQ2QsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUN4QztJQUVRQyxzQkFBOEI7UUFDcEMsTUFBTUMsWUFBWTtZQUNoQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsU0FBUyxDQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDO0lBQzdCO0lBRVFJLHVCQUErQjtRQUNyQyxNQUFNRCxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDSCxJQUFJLENBQUM7SUFDN0I7SUFFUUssd0JBQWdDO1FBQ3RDLE1BQU1DLGFBQWE7WUFDakIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLFVBQVUsQ0FBQyxJQUFJLENBQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUMzQztJQUVRTSwwQkFBa0M7UUFDeEMsTUFBTUMsZUFBZTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsWUFBWSxDQUFDLElBQUksQ0FBQ1IsSUFBSSxDQUFDO0lBQ2hDO0lBRVFTLHlCQUFpQztRQUN2QyxNQUFNQyxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDVixJQUFJLENBQUM7SUFDN0I7SUFFT1csVUFBVUMsV0FBbUIsRUFBVztRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDQyxZQUFZLElBQUksSUFBSSxDQUFDQyxNQUFNLElBQUksSUFBSSxDQUFDQyxZQUFZLEtBQUssR0FBRztZQUNoRSxPQUFPO1FBQ1Q7UUFDQSxPQUFPLGNBQWUsSUFBSSxDQUFDQyxjQUFjLElBQUssSUFBSSxDQUFDQyxjQUFjO0lBQ25FO0lBRU9DLGNBQWNOLFdBQW1CLEVBQVE7UUFDOUMsSUFBSSxDQUFDSSxjQUFjLEdBQUdKO0lBQ3hCO0lBRU9PLGFBQW1CO0lBQ3hCLCtDQUErQztJQUMvQyxxREFBcUQ7SUFDdkQ7SUFFT0MsSUFBSVIsV0FBbUIsRUFBUTtRQUNwQyxJQUFJLENBQUNFLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ08sU0FBUyxHQUFHVDtJQUNuQjtJQUVPVSxjQUFjVixXQUFtQixFQUFXO1FBQ2pELElBQUksQ0FBQyxJQUFJLENBQUNXLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQ1QsTUFBTSxFQUFFO1lBQ3BDLE9BQU87UUFDVDtRQUNBLE9BQU8sY0FBZSxJQUFJLENBQUNPLFNBQVMsSUFBSyxJQUFJLENBQUNHLFdBQVc7SUFDM0Q7SUFFT0MsVUFBZ0I7UUFDckIsSUFBSSxDQUFDWCxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNPLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNMLGNBQWMsR0FBRztRQUN0QixpQ0FBaUM7UUFDakMsSUFBSSxDQUFDVSxRQUFRO1FBQ2IsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQ0MsV0FBVztJQUNsQjtJQUVPQyxPQUFPQyxRQUFnQixFQUFFakIsV0FBbUIsRUFBUTtRQUN6RCxJQUFJLElBQUksQ0FBQ0UsTUFBTSxFQUFFLFFBQVEsNEJBQTRCO1FBRXJELElBQUksQ0FBQ2dCLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLGVBQWUsR0FBR25CO1FBQ3ZCLElBQUksQ0FBQ29CLGNBQWMsR0FBR0g7UUFDdEIsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0ksYUFBYSxHQUFHO0lBQ3ZCO0lBRU9QLFdBQWlCO1FBQ3RCLElBQUksQ0FBQ0ksUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLGtDQUFrQztRQUNsQyxJQUFJLENBQUNDLGFBQWEsR0FBRyxJQUFJLENBQUNDLHFCQUFxQjtJQUNqRDtJQUVPQyxtQkFBbUJ2QixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQyxJQUFJLENBQUNrQixRQUFRLEVBQUU7UUFFcEIsTUFBTU0sVUFBVXhCLGNBQWMsSUFBSSxDQUFDbUIsZUFBZTtRQUNsRCxJQUFJSyxXQUFXLElBQUksQ0FBQ0osY0FBYyxFQUFFO1lBQ2xDLElBQUksQ0FBQ04sUUFBUTtRQUNmO0lBQ0Y7SUFFT1csVUFBbUI7UUFDeEIsT0FBTyxDQUFDLElBQUksQ0FBQ1AsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDaEIsTUFBTTtJQUN2QztJQUVPd0IsV0FBV1QsUUFBZ0IsRUFBRVUsZUFBdUIsRUFBRTNCLFdBQW1CLEVBQVE7UUFDdEYsSUFBSSxJQUFJLENBQUNFLE1BQU0sRUFBRSxRQUFRLG9DQUFvQztRQUU3RCxJQUFJLENBQUMwQixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUc3QjtRQUN0QixJQUFJLENBQUM4QixhQUFhLEdBQUdiO1FBQ3JCLElBQUksQ0FBQ2Msb0JBQW9CLEdBQUdKO1FBQzVCLElBQUksQ0FBQ0ssbUJBQW1CLEdBQUdoQztJQUM3QjtJQUVPZSxjQUFvQjtRQUN6QixJQUFJLENBQUNhLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7SUFDN0I7SUFFT0Msa0JBQWtCakMsV0FBbUIsRUFBaUQ7UUFDM0YsSUFBSSxDQUFDLElBQUksQ0FBQzRCLFVBQVUsRUFBRSxPQUFPO1lBQUVNLGtCQUFrQjtZQUFPQyxRQUFRO1FBQUU7UUFFbEUsTUFBTVgsVUFBVXhCLGNBQWMsSUFBSSxDQUFDNkIsY0FBYztRQUNqRCxJQUFJTCxXQUFXLElBQUksQ0FBQ00sYUFBYSxFQUFFO1lBQ2pDLElBQUksQ0FBQ2YsV0FBVztZQUNoQixPQUFPO2dCQUFFbUIsa0JBQWtCO2dCQUFPQyxRQUFRO1lBQUU7UUFDOUM7UUFFQSxnREFBZ0Q7UUFDaEQsTUFBTUMsc0JBQXNCcEMsY0FBYyxJQUFJLENBQUNnQyxtQkFBbUI7UUFDbEUsSUFBSUksdUJBQXVCLEtBQUs7WUFDOUIsSUFBSSxDQUFDSixtQkFBbUIsR0FBR2hDO1lBQzNCLE9BQU87Z0JBQUVrQyxrQkFBa0I7Z0JBQU1DLFFBQVEsSUFBSSxDQUFDSixvQkFBb0I7WUFBQztRQUNyRTtRQUVBLE9BQU87WUFBRUcsa0JBQWtCO1lBQU9DLFFBQVE7UUFBRTtJQUM5QztJQUVPRSxpQkFBaUJyQyxXQUFtQixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDRSxNQUFNLEVBQUUsUUFBUSxxQ0FBcUM7UUFFOUQsd0NBQXdDO1FBQ3hDLElBQUksSUFBSSxDQUFDb0MsWUFBWSxHQUFHLEtBQUssY0FBZSxJQUFJLENBQUNDLGlCQUFpQixHQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO1lBQ3pGLElBQUksQ0FBQ0YsWUFBWSxHQUFHO1FBQ3RCO1FBRUEsd0JBQXdCO1FBQ3hCLElBQUksSUFBSSxDQUFDQSxZQUFZLEdBQUcsR0FBRztZQUN6QixJQUFJLENBQUNBLFlBQVk7UUFDbkI7UUFFQSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR3ZDO0lBQzNCO0lBRU95QyxrQkFBMEI7UUFDL0IsT0FBTyxJQUFJLENBQUNILFlBQVk7SUFDMUI7SUFFT0ksb0JBQTBCO1FBQy9CLElBQUksQ0FBQ0osWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDM0I7SUFFT0ksbUJBQW1CM0MsV0FBbUIsRUFBUTtRQUNuRCxJQUFJLElBQUksQ0FBQ3NDLFlBQVksSUFBSSxHQUFHO1FBRTVCLE1BQU1kLFVBQVV4QixjQUFjLElBQUksQ0FBQ3VDLGlCQUFpQjtRQUNwRCxJQUFJZixXQUFXLElBQUksQ0FBQ2dCLGNBQWMsRUFBRTtZQUNsQyxJQUFJLENBQUNFLGlCQUFpQjtRQUN4QjtJQUNGO0lBRU9FLFNBQVNDLFFBQWdCLEVBQVE7UUFDdEMsSUFBSSxDQUFDeEQsS0FBSyxHQUFHeUQsS0FBS0MsR0FBRyxDQUFDLEdBQUdGO1FBQ3pCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUcsSUFBSSxDQUFDOUQseUJBQXlCO1FBQ3RELElBQUksQ0FBQ2lCLFlBQVksR0FBRyxJQUFJLENBQUNWLHFCQUFxQjtJQUNoRDtJQUVPd0QsaUJBQXlCO1FBQzlCLE1BQU1DLFlBQVk7WUFDaEIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU8sR0FBK0IsT0FBNUJBLFNBQVMsQ0FBQyxJQUFJLENBQUM5RCxJQUFJLENBQUMsRUFBQyxTQUFrQixPQUFYLElBQUksQ0FBQ0MsS0FBSyxFQUFDO0lBQ25EO0lBRU84RCxRQUFjO1FBQ25CLElBQUksQ0FBQy9ELElBQUk7UUFDVCxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQzJELGdCQUFnQixHQUFHLElBQUksQ0FBQzlELHlCQUF5QjtRQUN0RCxJQUFJLENBQUNlLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNtRCxVQUFVLEdBQUcsSUFBSSxDQUFDOUQsbUJBQW1CO1FBQzFDLElBQUksQ0FBQytELFdBQVcsR0FBRyxJQUFJLENBQUM3RCxvQkFBb0I7UUFDNUMsSUFBSSxDQUFDVyxZQUFZLEdBQUcsSUFBSSxDQUFDVixxQkFBcUI7UUFDOUMsSUFBSSxDQUFDWSxjQUFjLEdBQUcsSUFBSSxDQUFDVix1QkFBdUI7UUFDbEQsSUFBSSxDQUFDUyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDaUIsYUFBYSxHQUFHLElBQUksQ0FBQ3hCLHNCQUFzQjtRQUNoRCxJQUFJLENBQUNLLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ08sU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0csV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0QsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQzJDLE9BQU8sR0FBRztRQUVmLHNCQUFzQjtRQUN0QixJQUFJLENBQUNwQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDRSxxQkFBcUIsR0FBRyxJQUFJLENBQUNELGFBQWE7UUFFL0MscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ08sVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUUzQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDTSxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUMzQjtJQUVPZ0IsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUl0RSxNQUFNLElBQUksQ0FBQ0csSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSztRQUM3Q2tFLE1BQU1QLGdCQUFnQixHQUFHLElBQUksQ0FBQ0EsZ0JBQWdCO1FBQzlDTyxNQUFNdEQsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtRQUN0Q3NELE1BQU1ILFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVU7UUFDbENHLE1BQU1GLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENFLE1BQU1wRCxZQUFZLEdBQUcsSUFBSSxDQUFDQSxZQUFZO1FBQ3RDb0QsTUFBTWxELGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNrRCxNQUFNbkQsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYztRQUMxQ21ELE1BQU1sQyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhO1FBQ3hDa0MsTUFBTXJELE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU07UUFDMUJxRCxNQUFNOUMsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQzhDLE1BQU0zQyxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXO1FBQ3BDMkMsTUFBTTVDLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVU7UUFFbEMsc0JBQXNCO1FBQ3RCNEMsTUFBTXJDLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDOUJxQyxNQUFNcEMsZUFBZSxHQUFHLElBQUksQ0FBQ0EsZUFBZTtRQUM1Q29DLE1BQU1uQyxjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDbUMsTUFBTWpDLHFCQUFxQixHQUFHLElBQUksQ0FBQ0EscUJBQXFCO1FBRXhELHFCQUFxQjtRQUNyQmlDLE1BQU0zQixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVO1FBQ2xDMkIsTUFBTTFCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUMwQixNQUFNekIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3lCLE1BQU14QixvQkFBb0IsR0FBRyxJQUFJLENBQUNBLG9CQUFvQjtRQUN0RHdCLE1BQU12QixtQkFBbUIsR0FBRyxJQUFJLENBQUNBLG1CQUFtQjtRQUVwRCxzQkFBc0I7UUFDdEJ1QixNQUFNakIsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWTtRQUN0Q2lCLE1BQU1oQixpQkFBaUIsR0FBRyxJQUFJLENBQUNBLGlCQUFpQjtRQUVoRCxPQUFPZ0I7SUFDVDtJQXJVQUMsWUFDRXBFLGNBQWlDLEVBQ2pDQyxRQUFnQixDQUFDLENBQ2pCO1FBQ0EsS0FBSzthQXRDU29FLGdCQUFnQixRQUFTLHNCQUFzQjs7UUF3QzdELElBQUksQ0FBQ3JFLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMyRCxnQkFBZ0IsR0FBRyxJQUFJLENBQUM5RCx5QkFBeUI7UUFDdEQsSUFBSSxDQUFDZSxZQUFZLEdBQUdiO1FBQ3BCLElBQUksQ0FBQ2dFLFVBQVUsR0FBRyxJQUFJLENBQUM5RCxtQkFBbUI7UUFDMUMsSUFBSSxDQUFDK0QsV0FBVyxHQUFHLElBQUksQ0FBQzdELG9CQUFvQjtRQUM1QyxJQUFJLENBQUNXLFlBQVksR0FBRyxJQUFJLENBQUNWLHFCQUFxQjtRQUM5QyxJQUFJLENBQUNZLGNBQWMsR0FBRyxJQUFJLENBQUNWLHVCQUF1QjtRQUNsRCxJQUFJLENBQUNTLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNpQixhQUFhLEdBQUcsSUFBSSxDQUFDeEIsc0JBQXNCO1FBQ2hELElBQUksQ0FBQ0ssTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDTyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRyxXQUFXLEdBQUcsSUFBSSxrQ0FBa0M7UUFDekQsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFFbEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ08sUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0UscUJBQXFCLEdBQUcsSUFBSSxDQUFDRCxhQUFhO1FBRS9DLDBCQUEwQjtRQUMxQixJQUFJLENBQUNPLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7UUFFM0IsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ00sWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsTUFBTSxhQUFhO0lBQzNDO0FBZ1NGO0FBMVdhdkQsTUFDWXdFLGdCQUFnQixRQUFTLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvRW5lbXkudHM/M2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmVteSBjb21wb25lbnQgZm9yIGlkZW50aWZ5aW5nIGVuZW15IGVudGl0aWVzXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBFbmVteVR5cGUge1xuICBEVU1NWSA9ICdkdW1teScsXG4gIEdSVU5UID0gJ2dydW50JyxcbiAgRUxJVEUgPSAnZWxpdGUnLFxuICBCT1NTID0gJ2Jvc3MnXG59XG5cbmV4cG9ydCBjbGFzcyBFbmVteSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHR5cGU6IEVuZW15VHlwZTtcbiAgcHVibGljIGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyBleHBlcmllbmNlUmV3YXJkOiBudW1iZXI7XG4gIHB1YmxpYyBpc0FnZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBhZ2dyb1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tSYW5nZTogbnVtYmVyO1xuICBwdWJsaWMgYXR0YWNrRGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tDb29sZG93bjogbnVtYmVyO1xuICBwdWJsaWMgbGFzdEF0dGFja1RpbWU6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcmVzcGF3blRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNhblJlc3Bhd246IGJvb2xlYW47XG4gIFxuICAvLyBGcmVlemUgc3RhdHVzIGVmZmVjdFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcmVlemVTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGZyZWV6ZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvcmlnaW5hbE1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgXG4gIC8vIFZlbm9tIGRlYnVmZiBlZmZlY3RcbiAgcHVibGljIGlzVmVub21vdXM6IGJvb2xlYW47XG4gIHB1YmxpYyB2ZW5vbVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EYW1hZ2VQZXJTZWNvbmQ6IG51bWJlcjtcbiAgcHVibGljIGxhc3RWZW5vbURhbWFnZVRpbWU6IG51bWJlcjtcbiAgXG4gIC8vIFN1bmRlciBzdGFja3MgZWZmZWN0XG4gIHB1YmxpYyBzdW5kZXJTdGFja3M6IG51bWJlcjtcbiAgcHVibGljIHN1bmRlckxhc3RBcHBsaWVkOiBudW1iZXI7XG4gIHB1YmxpYyBzdW5kZXJEdXJhdGlvbjogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IEVuZW15VHlwZSA9IEVuZW15VHlwZS5EVU1NWSxcbiAgICBsZXZlbDogbnVtYmVyID0gMVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuaXNBZ2dyZXNzaXZlID0gdHlwZSAhPT0gRW5lbXlUeXBlLkRVTU1ZO1xuICAgIHRoaXMuYWdncm9SYW5nZSA9IHRoaXMuY2FsY3VsYXRlQWdncm9SYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0Nvb2xkb3duKCk7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5jYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5yZXNwYXduVGltZSA9IDMwOyAvLyAzMCBzZWNvbmRzIGRlZmF1bHQgcmVzcGF3biB0aW1lXG4gICAgdGhpcy5jYW5SZXNwYXduID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGZyZWV6ZSBzdGF0dXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZnJlZXplRHVyYXRpb24gPSAwO1xuICAgIHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkID0gdGhpcy5tb3ZlbWVudFNwZWVkO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgdmVub20gc3RhdHVzXG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgc3VuZGVyIHN0YWNrc1xuICAgIHRoaXMuc3VuZGVyU3RhY2tzID0gMDtcbiAgICB0aGlzLnN1bmRlckxhc3RBcHBsaWVkID0gMDtcbiAgICB0aGlzLnN1bmRlckR1cmF0aW9uID0gMTAuMDsgLy8gMTAgc2Vjb25kc1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZUV4cCA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiA1LFxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDEwLFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDI1LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMTAwXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZUV4cFt0aGlzLnR5cGVdICogdGhpcy5sZXZlbDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQWdncm9SYW5nZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VSYW5nZSA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGFnZ3JvXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogNSxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiA4LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMTJcbiAgICB9O1xuICAgIHJldHVybiBiYXNlUmFuZ2VbdGhpcy50eXBlXTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQXR0YWNrUmFuZ2UoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlUmFuZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBhdHRhY2tcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAxLjUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMixcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDNcbiAgICB9O1xuICAgIHJldHVybiBiYXNlUmFuZ2VbdGhpcy50eXBlXTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZURhbWFnZSA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGRlYWwgZGFtYWdlXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMTUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMjUsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiA1MFxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VEYW1hZ2VbdGhpcy50eXBlXSAqIHRoaXMubGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja0Nvb2xkb3duKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZUNvb2xkb3duID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgYXR0YWNrXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMixcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAxLjUsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAxXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZUNvb2xkb3duW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU1vdmVtZW50U3BlZWQoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlU3BlZWQgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBtb3ZlXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMyxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAwLCAvLyBFbGl0ZSBlbmVtaWVzIGFyZSBzdGF0aW9uYXJ5IGxpa2UgdHJhaW5pbmcgZHVtbWllc1xuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMi41XG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVNwZWVkW3RoaXMudHlwZV07XG4gIH1cblxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBZ2dyZXNzaXZlIHx8IHRoaXMuaXNEZWFkIHx8IHRoaXMuYXR0YWNrRGFtYWdlID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RBdHRhY2tUaW1lKSA+PSB0aGlzLmF0dGFja0Nvb2xkb3duO1xuICB9XG5cbiAgcHVibGljIHBlcmZvcm1BdHRhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHB1YmxpYyB0YWtlRGFtYWdlKCk6IHZvaWQge1xuICAgIC8vIFRoaXMgd2lsbCBiZSBoYW5kbGVkIGJ5IHRoZSBIZWFsdGggY29tcG9uZW50XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgZm9yIGVuZW15LXNwZWNpZmljIGRhbWFnZSByZWFjdGlvbnNcbiAgfVxuXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHVibGljIGNhblJlc3Bhd25Ob3coY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5jYW5SZXNwYXduIHx8ICF0aGlzLmlzRGVhZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5kZWF0aFRpbWUpID49IHRoaXMucmVzcGF3blRpbWU7XG4gIH1cblxuICBwdWJsaWMgcmVzcGF3bigpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICAvLyBDbGVhciBmcmVlemUgc3RhdHVzIG9uIHJlc3Bhd25cbiAgICB0aGlzLnVuZnJlZXplKCk7XG4gICAgLy8gQ2xlYXIgdmVub20gc3RhdHVzIG9uIHJlc3Bhd25cbiAgICB0aGlzLnJlbW92ZVZlbm9tKCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBmcmVlemUoZHVyYXRpb246IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBmcmVlemUgZGVhZCBlbmVtaWVzXG4gICAgXG4gICAgdGhpcy5pc0Zyb3plbiA9IHRydWU7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgLy8gU2V0IG1vdmVtZW50IHNwZWVkIHRvIDAgd2hlbiBmcm96ZW5cbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdW5mcmVlemUoKTogdm9pZCB7XG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIG1vdmVtZW50IHNwZWVkXG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5vcmlnaW5hbE1vdmVtZW50U3BlZWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVGcmVlemVTdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc0Zyb3plbikgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMuZnJlZXplRHVyYXRpb24pIHtcbiAgICAgIHRoaXMudW5mcmVlemUoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHB1YmxpYyBjYW5Nb3ZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5pc0Zyb3plbiAmJiAhdGhpcy5pc0RlYWQ7XG4gIH1cbiAgXG4gIHB1YmxpYyBhcHBseVZlbm9tKGR1cmF0aW9uOiBudW1iZXIsIGRhbWFnZVBlclNlY29uZDogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEZWFkKSByZXR1cm47IC8vIENhbid0IGFwcGx5IHZlbm9tIHRvIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIHRoaXMuaXNWZW5vbW91cyA9IHRydWU7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSBkYW1hZ2VQZXJTZWNvbmQ7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyByZW1vdmVWZW5vbSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzVmVub21vdXMgPSBmYWxzZTtcbiAgICB0aGlzLnZlbm9tU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSAwO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IDA7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVWZW5vbVN0YXR1cyhjdXJyZW50VGltZTogbnVtYmVyKTogeyBzaG91bGREZWFsRGFtYWdlOiBib29sZWFuOyBkYW1hZ2U6IG51bWJlciB9IHtcbiAgICBpZiAoIXRoaXMuaXNWZW5vbW91cykgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogZmFsc2UsIGRhbWFnZTogMCB9O1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMudmVub21TdGFydFRpbWU7XG4gICAgaWYgKGVsYXBzZWQgPj0gdGhpcy52ZW5vbUR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnJlbW92ZVZlbm9tKCk7XG4gICAgICByZXR1cm4geyBzaG91bGREZWFsRGFtYWdlOiBmYWxzZSwgZGFtYWdlOiAwIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBkZWFsIGRhbWFnZSAoZXZlcnkgc2Vjb25kKVxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZTtcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSAxLjApIHtcbiAgICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogdHJ1ZSwgZGFtYWdlOiB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IGZhbHNlLCBkYW1hZ2U6IDAgfTtcbiAgfVxuICBcbiAgcHVibGljIGFwcGx5U3VuZGVyU3RhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBhcHBseSBzdW5kZXIgdG8gZGVhZCBlbmVtaWVzXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhY2tzIGhhdmUgZXhwaXJlZFxuICAgIGlmICh0aGlzLnN1bmRlclN0YWNrcyA+IDAgJiYgKGN1cnJlbnRUaW1lIC0gdGhpcy5zdW5kZXJMYXN0QXBwbGllZCkgPiB0aGlzLnN1bmRlckR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnN1bmRlclN0YWNrcyA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBuZXcgc3RhY2sgKG1heCAzKVxuICAgIGlmICh0aGlzLnN1bmRlclN0YWNrcyA8IDMpIHtcbiAgICAgIHRoaXMuc3VuZGVyU3RhY2tzKys7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB0aW1pbmdcbiAgICB0aGlzLnN1bmRlckxhc3RBcHBsaWVkID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXRTdW5kZXJTdGFja3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdW5kZXJTdGFja3M7XG4gIH1cbiAgXG4gIHB1YmxpYyBjbGVhclN1bmRlclN0YWNrcygpOiB2b2lkIHtcbiAgICB0aGlzLnN1bmRlclN0YWNrcyA9IDA7XG4gICAgdGhpcy5zdW5kZXJMYXN0QXBwbGllZCA9IDA7XG4gIH1cbiAgXG4gIHB1YmxpYyB1cGRhdGVTdW5kZXJTdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnN1bmRlclN0YWNrcyA8PSAwKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5zdW5kZXJMYXN0QXBwbGllZDtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aGlzLnN1bmRlckR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmNsZWFyU3VuZGVyU3RhY2tzKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldExldmVsKG5ld0xldmVsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxldmVsID0gTWF0aC5tYXgoMSwgbmV3TGV2ZWwpO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tEYW1hZ2UoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHR5cGVOYW1lcyA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAnVHJhaW5pbmcgRHVtbXknLFxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06ICdHcnVudCcsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogJ0VsaXRlJyxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106ICdCb3NzJ1xuICAgIH07XG4gICAgcmV0dXJuIGAke3R5cGVOYW1lc1t0aGlzLnR5cGVdfSAoTHYuJHt0aGlzLmxldmVsfSlgO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IEVuZW15VHlwZS5EVU1NWTtcbiAgICB0aGlzLmxldmVsID0gMTtcbiAgICB0aGlzLmV4cGVyaWVuY2VSZXdhcmQgPSB0aGlzLmNhbGN1bGF0ZUV4cGVyaWVuY2VSZXdhcmQoKTtcbiAgICB0aGlzLmlzQWdncmVzc2l2ZSA9IGZhbHNlO1xuICAgIHRoaXMuYWdncm9SYW5nZSA9IHRoaXMuY2FsY3VsYXRlQWdncm9SYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0Nvb2xkb3duKCk7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gdGhpcy5jYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5yZXNwYXduVGltZSA9IDMwO1xuICAgIHRoaXMuY2FuUmVzcGF3biA9IHRydWU7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBSZXNldCBmcmVlemUgc3RhdHVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBSZXNldCB2ZW5vbSBzdGF0dXNcbiAgICB0aGlzLmlzVmVub21vdXMgPSBmYWxzZTtcbiAgICB0aGlzLnZlbm9tU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudmVub21EYW1hZ2VQZXJTZWNvbmQgPSAwO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IDA7XG4gICAgXG4gICAgLy8gUmVzZXQgc3VuZGVyIHN0YWNrc1xuICAgIHRoaXMuc3VuZGVyU3RhY2tzID0gMDtcbiAgICB0aGlzLnN1bmRlckxhc3RBcHBsaWVkID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBFbmVteSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRW5lbXkodGhpcy50eXBlLCB0aGlzLmxldmVsKTtcbiAgICBjbG9uZS5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5leHBlcmllbmNlUmV3YXJkO1xuICAgIGNsb25lLmlzQWdncmVzc2l2ZSA9IHRoaXMuaXNBZ2dyZXNzaXZlO1xuICAgIGNsb25lLmFnZ3JvUmFuZ2UgPSB0aGlzLmFnZ3JvUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUubW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICBjbG9uZS5yZXNwYXduVGltZSA9IHRoaXMucmVzcGF3blRpbWU7XG4gICAgY2xvbmUuY2FuUmVzcGF3biA9IHRoaXMuY2FuUmVzcGF3bjtcbiAgICBcbiAgICAvLyBDbG9uZSBmcmVlemUgc3RhdHVzXG4gICAgY2xvbmUuaXNGcm96ZW4gPSB0aGlzLmlzRnJvemVuO1xuICAgIGNsb25lLmZyZWV6ZVN0YXJ0VGltZSA9IHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGNsb25lLmZyZWV6ZUR1cmF0aW9uID0gdGhpcy5mcmVlemVEdXJhdGlvbjtcbiAgICBjbG9uZS5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBDbG9uZSB2ZW5vbSBzdGF0dXNcbiAgICBjbG9uZS5pc1Zlbm9tb3VzID0gdGhpcy5pc1Zlbm9tb3VzO1xuICAgIGNsb25lLnZlbm9tU3RhcnRUaW1lID0gdGhpcy52ZW5vbVN0YXJ0VGltZTtcbiAgICBjbG9uZS52ZW5vbUR1cmF0aW9uID0gdGhpcy52ZW5vbUR1cmF0aW9uO1xuICAgIGNsb25lLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZDtcbiAgICBjbG9uZS5sYXN0VmVub21EYW1hZ2VUaW1lID0gdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lO1xuICAgIFxuICAgIC8vIENsb25lIHN1bmRlciBzdGFja3NcbiAgICBjbG9uZS5zdW5kZXJTdGFja3MgPSB0aGlzLnN1bmRlclN0YWNrcztcbiAgICBjbG9uZS5zdW5kZXJMYXN0QXBwbGllZCA9IHRoaXMuc3VuZGVyTGFzdEFwcGxpZWQ7XG4gICAgXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiRW5lbXlUeXBlIiwiRW5lbXkiLCJjYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkIiwiYmFzZUV4cCIsInR5cGUiLCJsZXZlbCIsImNhbGN1bGF0ZUFnZ3JvUmFuZ2UiLCJiYXNlUmFuZ2UiLCJjYWxjdWxhdGVBdHRhY2tSYW5nZSIsImNhbGN1bGF0ZUF0dGFja0RhbWFnZSIsImJhc2VEYW1hZ2UiLCJjYWxjdWxhdGVBdHRhY2tDb29sZG93biIsImJhc2VDb29sZG93biIsImNhbGN1bGF0ZU1vdmVtZW50U3BlZWQiLCJiYXNlU3BlZWQiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWdncmVzc2l2ZSIsImlzRGVhZCIsImF0dGFja0RhbWFnZSIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwidGFrZURhbWFnZSIsImRpZSIsImRlYXRoVGltZSIsImNhblJlc3Bhd25Ob3ciLCJjYW5SZXNwYXduIiwicmVzcGF3blRpbWUiLCJyZXNwYXduIiwidW5mcmVlemUiLCJyZW1vdmVWZW5vbSIsImZyZWV6ZSIsImR1cmF0aW9uIiwiaXNGcm96ZW4iLCJmcmVlemVTdGFydFRpbWUiLCJmcmVlemVEdXJhdGlvbiIsIm1vdmVtZW50U3BlZWQiLCJvcmlnaW5hbE1vdmVtZW50U3BlZWQiLCJ1cGRhdGVGcmVlemVTdGF0dXMiLCJlbGFwc2VkIiwiY2FuTW92ZSIsImFwcGx5VmVub20iLCJkYW1hZ2VQZXJTZWNvbmQiLCJpc1Zlbm9tb3VzIiwidmVub21TdGFydFRpbWUiLCJ2ZW5vbUR1cmF0aW9uIiwidmVub21EYW1hZ2VQZXJTZWNvbmQiLCJsYXN0VmVub21EYW1hZ2VUaW1lIiwidXBkYXRlVmVub21TdGF0dXMiLCJzaG91bGREZWFsRGFtYWdlIiwiZGFtYWdlIiwidGltZVNpbmNlTGFzdERhbWFnZSIsImFwcGx5U3VuZGVyU3RhY2siLCJzdW5kZXJTdGFja3MiLCJzdW5kZXJMYXN0QXBwbGllZCIsInN1bmRlckR1cmF0aW9uIiwiZ2V0U3VuZGVyU3RhY2tzIiwiY2xlYXJTdW5kZXJTdGFja3MiLCJ1cGRhdGVTdW5kZXJTdGF0dXMiLCJzZXRMZXZlbCIsIm5ld0xldmVsIiwiTWF0aCIsIm1heCIsImV4cGVyaWVuY2VSZXdhcmQiLCJnZXREaXNwbGF5TmFtZSIsInR5cGVOYW1lcyIsInJlc2V0IiwiYWdncm9SYW5nZSIsImF0dGFja1JhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Enemy.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Health.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Health.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Health: function() { return /* binding */ Health; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _Shield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n// Health component for damage and healing\n\n\nclass Health extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    takeDamage(amount) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000, entity = arguments.length > 2 ? arguments[2] : void 0, bypassInvulnerability = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        if (this.isDead || !bypassInvulnerability && this.isInvulnerable || amount <= 0) {\n            return false;\n        }\n        let finalDamage = amount;\n        // Check if entity has a shield component and absorb damage through it first\n        if (entity) {\n            const shield = entity.getComponent(_Shield__WEBPACK_IMPORTED_MODULE_1__.Shield);\n            if (shield) {\n                finalDamage = shield.absorbDamage(amount);\n            }\n        }\n        // Apply remaining damage to health\n        if (finalDamage > 0) {\n            this.currentHealth = Math.max(0, this.currentHealth - finalDamage);\n            this.lastDamageTime = currentTime;\n            // Start invulnerability period\n            this.isInvulnerable = true;\n            this.invulnerabilityTimer = this.invulnerabilityDuration;\n            // Check if dead\n            if (this.currentHealth <= 0) {\n                this.isDead = true;\n            }\n        }\n        return true;\n    }\n    heal(amount) {\n        if (this.isDead || amount <= 0) {\n            return false;\n        }\n        const oldHealth = this.currentHealth;\n        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);\n        return this.currentHealth > oldHealth;\n    }\n    setMaxHealth(newMaxHealth) {\n        const healthRatio = this.getHealthRatio();\n        this.maxHealth = Math.max(1, newMaxHealth);\n        this.currentHealth = Math.floor(this.maxHealth * healthRatio);\n    }\n    getHealthRatio() {\n        return this.maxHealth > 0 ? this.currentHealth / this.maxHealth : 0;\n    }\n    getHealthPercentage() {\n        return this.getHealthRatio() * 100;\n    }\n    isFullHealth() {\n        return this.currentHealth >= this.maxHealth;\n    }\n    isLowHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.25;\n        return this.getHealthRatio() <= threshold;\n    }\n    isCriticalHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.1;\n        return this.getHealthRatio() <= threshold;\n    }\n    revive(healthAmount) {\n        this.isDead = false;\n        this.currentHealth = healthAmount !== undefined ? Math.min(this.maxHealth, healthAmount) : this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    update(deltaTime) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000;\n        // Update invulnerability timer\n        if (this.isInvulnerable) {\n            this.invulnerabilityTimer -= deltaTime;\n            if (this.invulnerabilityTimer <= 0) {\n                this.isInvulnerable = false;\n                this.invulnerabilityTimer = 0;\n            }\n        }\n        // Handle regeneration\n        if (this.canRegenerate && !this.isDead && !this.isFullHealth()) {\n            const timeSinceLastDamage = currentTime - this.lastDamageTime;\n            if (timeSinceLastDamage >= this.regenerationDelay) {\n                this.heal(this.regenerationRate * deltaTime);\n            }\n        }\n    }\n    setInvulnerable(duration) {\n        this.isInvulnerable = true;\n        this.invulnerabilityTimer = duration;\n    }\n    removeInvulnerability() {\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    enableRegeneration() {\n        let rate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n        this.canRegenerate = true;\n        this.regenerationRate = rate;\n        this.regenerationDelay = delay;\n    }\n    disableRegeneration() {\n        this.canRegenerate = false;\n    }\n    reset() {\n        this.currentHealth = this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5;\n        this.regenerationDelay = 3;\n        this.lastDamageTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Health(this.maxHealth);\n        clone.currentHealth = this.currentHealth;\n        clone.isInvulnerable = this.isInvulnerable;\n        clone.invulnerabilityDuration = this.invulnerabilityDuration;\n        clone.invulnerabilityTimer = this.invulnerabilityTimer;\n        clone.isDead = this.isDead;\n        clone.canRegenerate = this.canRegenerate;\n        clone.regenerationRate = this.regenerationRate;\n        clone.regenerationDelay = this.regenerationDelay;\n        clone.lastDamageTime = this.lastDamageTime;\n        return clone;\n    }\n    constructor(maxHealth = 100){\n        super();\n        this.componentType = \"Health\" // Instance identifier\n        ;\n        this.maxHealth = maxHealth;\n        this.currentHealth = maxHealth; // Always start with full health\n        this.isInvulnerable = false;\n        this.invulnerabilityDuration = 0.5; // 0.5 seconds of invulnerability after damage\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5; // Health per second\n        this.regenerationDelay = 3; // Seconds after damage before regeneration starts\n        this.lastDamageTime = 0;\n    }\n}\nHealth.componentType = \"Health\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQ0o7QUFDSjtBQUUzQixNQUFNRSxlQUFlRiw4Q0FBU0E7SUE2QjVCRyxXQUFXQyxNQUFjLEVBQTBHO1lBQXhHQyxjQUFBQSxpRUFBc0JDLEtBQUtDLEdBQUcsS0FBSyxNQUFNQyx1REFBY0Msd0JBQUFBLGlFQUFpQztRQUN4SCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFLLENBQUNELHlCQUF5QixJQUFJLENBQUNFLGNBQWMsSUFBS1AsVUFBVSxHQUFHO1lBQ2pGLE9BQU87UUFDVDtRQUVBLElBQUlRLGNBQWNSO1FBRWxCLDRFQUE0RTtRQUM1RSxJQUFJSSxRQUFRO1lBQ1YsTUFBTUssU0FBU0wsT0FBT00sWUFBWSxDQUFDYiwyQ0FBTUE7WUFDekMsSUFBSVksUUFBUTtnQkFDVkQsY0FBY0MsT0FBT0UsWUFBWSxDQUFDWDtZQUNwQztRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlRLGNBQWMsR0FBRztZQUNuQixJQUFJLENBQUNJLGFBQWEsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDRixhQUFhLEdBQUdKO1lBQ3RELElBQUksQ0FBQ08sY0FBYyxHQUFHZDtZQUV0QiwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDTSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRyxJQUFJLENBQUNDLHVCQUF1QjtZQUV4RCxnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNMLGFBQWEsSUFBSSxHQUFHO2dCQUMzQixJQUFJLENBQUNOLE1BQU0sR0FBRztZQUNoQjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRU9ZLEtBQUtsQixNQUFjLEVBQVc7UUFDbkMsSUFBSSxJQUFJLENBQUNNLE1BQU0sSUFBSU4sVUFBVSxHQUFHO1lBQzlCLE9BQU87UUFDVDtRQUVBLE1BQU1tQixZQUFZLElBQUksQ0FBQ1As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LENBQUNELG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1YsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDK0IsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUcsR0FBRyxvQkFBb0I7UUFDL0MsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRyxHQUFHLGtEQUFrRDtRQUM5RSxJQUFJLENBQUN4QixjQUFjLEdBQUc7SUFDeEI7QUFpSkY7QUE1S2FqQixPQUNZc0QsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHM/NWY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggY29tcG9uZW50IGZvciBkYW1hZ2UgYW5kIGhlYWxpbmdcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5pbXBvcnQgeyBTaGllbGQgfSBmcm9tICcuL1NoaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGggZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0hlYWx0aCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIGN1cnJlbnRIZWFsdGg6IG51bWJlcjtcbiAgcHVibGljIG1heEhlYWx0aDogbnVtYmVyO1xuICBwdWJsaWMgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW47XG4gIHB1YmxpYyBpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaW52dWxuZXJhYmlsaXR5VGltZXI6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGNhblJlZ2VuZXJhdGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZWdlbmVyYXRpb25SYXRlOiBudW1iZXI7XG4gIHB1YmxpYyByZWdlbmVyYXRpb25EZWxheTogbnVtYmVyO1xuICBwdWJsaWMgbGFzdERhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhIZWFsdGg6IG51bWJlciA9IDEwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5tYXhIZWFsdGggPSBtYXhIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gbWF4SGVhbHRoOyAvLyBBbHdheXMgc3RhcnQgd2l0aCBmdWxsIGhlYWx0aFxuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gMC41OyAvLyAwLjUgc2Vjb25kcyBvZiBpbnZ1bG5lcmFiaWxpdHkgYWZ0ZXIgZGFtYWdlXG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1OyAvLyBIZWFsdGggcGVyIHNlY29uZFxuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzOyAvLyBTZWNvbmRzIGFmdGVyIGRhbWFnZSBiZWZvcmUgcmVnZW5lcmF0aW9uIHN0YXJ0c1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIHRha2VEYW1hZ2UoYW1vdW50OiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpIC8gMTAwMCwgZW50aXR5PzogYW55LCBieXBhc3NJbnZ1bG5lcmFiaWxpdHk6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzRGVhZCB8fCAoIWJ5cGFzc0ludnVsbmVyYWJpbGl0eSAmJiB0aGlzLmlzSW52dWxuZXJhYmxlKSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmaW5hbERhbWFnZSA9IGFtb3VudDtcblxuICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgYSBzaGllbGQgY29tcG9uZW50IGFuZCBhYnNvcmIgZGFtYWdlIHRocm91Z2ggaXQgZmlyc3RcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIGZpbmFsRGFtYWdlID0gc2hpZWxkLmFic29yYkRhbWFnZShhbW91bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHJlbWFpbmluZyBkYW1hZ2UgdG8gaGVhbHRoXG4gICAgaWYgKGZpbmFsRGFtYWdlID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50SGVhbHRoIC0gZmluYWxEYW1hZ2UpO1xuICAgICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBpbnZ1bG5lcmFiaWxpdHkgcGVyaW9kXG4gICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuXG4gICAgICAvLyBDaGVjayBpZiBkZWFkXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGhlYWwoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5taW4odGhpcy5tYXhIZWFsdGgsIHRoaXMuY3VycmVudEhlYWx0aCArIGFtb3VudCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+IG9sZEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXhIZWFsdGgobmV3TWF4SGVhbHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBoZWFsdGhSYXRpbyA9IHRoaXMuZ2V0SGVhbHRoUmF0aW8oKTtcbiAgICB0aGlzLm1heEhlYWx0aCA9IE1hdGgubWF4KDEsIG5ld01heEhlYWx0aCk7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5mbG9vcih0aGlzLm1heEhlYWx0aCAqIGhlYWx0aFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFsdGhSYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm1heEhlYWx0aCA+IDAgPyB0aGlzLmN1cnJlbnRIZWFsdGggLyB0aGlzLm1heEhlYWx0aCA6IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0SGVhbHRoUGVyY2VudGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgKiAxMDA7XG4gIH1cblxuICBwdWJsaWMgaXNGdWxsSGVhbHRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFsdGggPj0gdGhpcy5tYXhIZWFsdGg7XG4gIH1cblxuICBwdWJsaWMgaXNMb3dIZWFsdGgodGhyZXNob2xkOiBudW1iZXIgPSAwLjI1KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSA8PSB0aHJlc2hvbGQ7XG4gIH1cblxuICBwdWJsaWMgaXNDcml0aWNhbEhlYWx0aCh0aHJlc2hvbGQ6IG51bWJlciA9IDAuMSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgPD0gdGhyZXNob2xkO1xuICB9XG5cbiAgcHVibGljIHJldml2ZShoZWFsdGhBbW91bnQ/OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IGhlYWx0aEFtb3VudCAhPT0gdW5kZWZpbmVkID8gXG4gICAgICBNYXRoLm1pbih0aGlzLm1heEhlYWx0aCwgaGVhbHRoQW1vdW50KSA6IFxuICAgICAgdGhpcy5tYXhIZWFsdGg7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlciA9IERhdGUubm93KCkgLyAxMDAwKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGludnVsbmVyYWJpbGl0eSB0aW1lclxuICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XG4gICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIGlmICh0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVnZW5lcmF0aW9uXG4gICAgaWYgKHRoaXMuY2FuUmVnZW5lcmF0ZSAmJiAhdGhpcy5pc0RlYWQgJiYgIXRoaXMuaXNGdWxsSGVhbHRoKCkpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5KSB7XG4gICAgICAgIHRoaXMuaGVhbCh0aGlzLnJlZ2VuZXJhdGlvblJhdGUgKiBkZWx0YVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnZ1bG5lcmFibGUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSB0cnVlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSBkdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVJbnZ1bG5lcmFiaWxpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVJlZ2VuZXJhdGlvbihyYXRlOiBudW1iZXIgPSA1LCBkZWxheTogbnVtYmVyID0gMyk6IHZvaWQge1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IHRydWU7XG4gICAgdGhpcy5yZWdlbmVyYXRpb25SYXRlID0gcmF0ZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBwdWJsaWMgZGlzYWJsZVJlZ2VuZXJhdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1O1xuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogSGVhbHRoIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBIZWFsdGgodGhpcy5tYXhIZWFsdGgpO1xuICAgIGNsb25lLmN1cnJlbnRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgY2xvbmUuaXNJbnZ1bG5lcmFibGUgPSB0aGlzLmlzSW52dWxuZXJhYmxlO1xuICAgIGNsb25lLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gdGhpcy5pbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjtcbiAgICBjbG9uZS5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXI7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuY2FuUmVnZW5lcmF0ZSA9IHRoaXMuY2FuUmVnZW5lcmF0ZTtcbiAgICBjbG9uZS5yZWdlbmVyYXRpb25SYXRlID0gdGhpcy5yZWdlbmVyYXRpb25SYXRlO1xuICAgIGNsb25lLnJlZ2VuZXJhdGlvbkRlbGF5ID0gdGhpcy5yZWdlbmVyYXRpb25EZWxheTtcbiAgICBjbG9uZS5sYXN0RGFtYWdlVGltZSA9IHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiSGVhbHRoIiwidGFrZURhbWFnZSIsImFtb3VudCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVudGl0eSIsImJ5cGFzc0ludnVsbmVyYWJpbGl0eSIsImlzRGVhZCIsImlzSW52dWxuZXJhYmxlIiwiZmluYWxEYW1hZ2UiLCJzaGllbGQiLCJnZXRDb21wb25lbnQiLCJhYnNvcmJEYW1hZ2UiLCJjdXJyZW50SGVhbHRoIiwiTWF0aCIsIm1heCIsImxhc3REYW1hZ2VUaW1lIiwiaW52dWxuZXJhYmlsaXR5VGltZXIiLCJpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbiIsImhlYWwiLCJvbGRIZWFsdGgiLCJtaW4iLCJtYXhIZWFsdGgiLCJzZXRNYXhIZWFsdGgiLCJuZXdNYXhIZWFsdGgiLCJoZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiZmxvb3IiLCJnZXRIZWFsdGhQZXJjZW50YWdlIiwiaXNGdWxsSGVhbHRoIiwiaXNMb3dIZWFsdGgiLCJ0aHJlc2hvbGQiLCJpc0NyaXRpY2FsSGVhbHRoIiwicmV2aXZlIiwiaGVhbHRoQW1vdW50IiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiY2FuUmVnZW5lcmF0ZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJyZWdlbmVyYXRpb25EZWxheSIsInJlZ2VuZXJhdGlvblJhdGUiLCJzZXRJbnZ1bG5lcmFibGUiLCJkdXJhdGlvbiIsInJlbW92ZUludnVsbmVyYWJpbGl0eSIsImVuYWJsZVJlZ2VuZXJhdGlvbiIsInJhdGUiLCJkZWxheSIsImRpc2FibGVSZWdlbmVyYXRpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Health.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/HealthBar.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/HealthBar.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBar: function() { return /* binding */ HealthBar; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Health bar component for rendering health bars above entities\n\n\nclass HealthBar extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    createHealthBarMeshes() {\n        this.group = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group();\n        // Create border (slightly larger than background)\n        const borderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width + this.borderWidth * 2, this.height + this.borderWidth * 2);\n        const borderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.borderColor,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.borderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(borderGeometry, borderMaterial);\n        this.borderMesh.position.z = -0.001; // Slightly behind\n        this.group.add(this.borderMesh);\n        // Create background\n        const backgroundGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const backgroundMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.backgroundColor,\n            transparent: true,\n            opacity: 0.7\n        });\n        this.backgroundMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(backgroundGeometry, backgroundMaterial);\n        this.group.add(this.backgroundMesh);\n        // Create health bar (starts full width)\n        const healthGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const healthMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.healthColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        this.healthMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(healthGeometry, healthMaterial);\n        this.healthMesh.position.z = 0.001; // Slightly in front\n        this.group.add(this.healthMesh);\n        // Make health bar always face camera\n        this.group.lookAt(0, 0, 1);\n    }\n    updateHealthBar(healthRatio, cameraPosition, worldPosition, deltaTime) {\n        this.currentHealthRatio = Math.max(0, Math.min(1, healthRatio));\n        // Animate health bar changes\n        if (Math.abs(this.lastHealthRatio - this.currentHealthRatio) > 0.01) {\n            this.lastHealthRatio = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this.lastHealthRatio, this.currentHealthRatio, this.animationSpeed * deltaTime);\n        } else {\n            this.lastHealthRatio = this.currentHealthRatio;\n        }\n        // Update health bar width and position\n        this.updateHealthMesh();\n        // Update health bar color based on health ratio\n        this.updateHealthColor();\n        // Update visibility based on distance and health\n        this.updateVisibility(cameraPosition, worldPosition);\n        // Update position and rotation to face camera\n        this.updatePositionAndRotation(cameraPosition, worldPosition);\n        // Update damage flash\n        this.updateDamageFlash(deltaTime);\n    }\n    updateHealthMesh() {\n        // Update scale to represent health\n        this.healthMesh.scale.x = this.lastHealthRatio;\n        // Adjust position so health bar shrinks from right to left\n        const offsetX = this.width * (1 - this.lastHealthRatio) / 2;\n        this.healthMesh.position.x = -offsetX;\n    }\n    updateHealthColor() {\n        let color;\n        if (this.currentHealthRatio <= this.criticalHealthThreshold) {\n            color = this.criticalHealthColor;\n        } else if (this.currentHealthRatio <= this.lowHealthThreshold) {\n            // Interpolate between low health and critical health colors\n            const t = (this.currentHealthRatio - this.criticalHealthThreshold) / (this.lowHealthThreshold - this.criticalHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.criticalHealthColor, this.lowHealthColor, t);\n        } else {\n            // Interpolate between health and low health colors\n            const t = (this.currentHealthRatio - this.lowHealthThreshold) / (1 - this.lowHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.lowHealthColor, this.healthColor, t);\n        }\n        this.healthMesh.material.color.copy(color);\n    }\n    updateVisibility(cameraPosition, worldPosition) {\n        // Calculate distance to camera\n        const distance = cameraPosition.distanceTo(worldPosition);\n        // Determine if should be visible\n        let shouldBeVisible = distance <= this.fadeDistance;\n        // Hide when full health if configured\n        if (!this.showWhenFull && this.currentHealthRatio >= 0.99) {\n            shouldBeVisible = false;\n        }\n        // Update visibility\n        this.isVisible = shouldBeVisible;\n        this.group.visible = this.isVisible;\n        // Fade based on distance\n        if (this.isVisible && distance > this.fadeDistance * 0.7) {\n            const fadeRatio = 1 - (distance - this.fadeDistance * 0.7) / (this.fadeDistance * 0.3);\n            const opacity = Math.max(0.1, fadeRatio);\n            this.backgroundMesh.material.opacity = opacity * 0.7;\n            this.healthMesh.material.opacity = opacity * 0.9;\n            this.borderMesh.material.opacity = opacity * 0.8;\n        } else if (this.isVisible) {\n            this.backgroundMesh.material.opacity = 0.7;\n            this.healthMesh.material.opacity = 0.9;\n            this.borderMesh.material.opacity = 0.8;\n        }\n    }\n    updatePositionAndRotation(cameraPosition, worldPosition) {\n        // Position health bar above entity\n        const barPosition = worldPosition.clone().add(this.offset);\n        this.group.position.copy(barPosition);\n        // Make health bar face camera\n        this.group.lookAt(cameraPosition);\n    }\n    updateDamageFlash(deltaTime) {\n        if (this.damageFlashTimer > 0) {\n            this.damageFlashTimer -= deltaTime;\n            // Flash effect - make health bar brighter\n            const flashIntensity = this.damageFlashTimer / this.damageFlashDuration;\n            const flashColor = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            // Mix current color with white for flash effect\n            const currentColor = this.healthMesh.material.color.clone();\n            currentColor.lerp(flashColor, flashIntensity * 0.5);\n            this.healthMesh.material.color.copy(currentColor);\n        }\n    }\n    triggerDamageFlash() {\n        this.damageFlashTimer = this.damageFlashDuration;\n    }\n    setHealthRatio(ratio) {\n        const oldRatio = this.currentHealthRatio;\n        this.currentHealthRatio = Math.max(0, Math.min(1, ratio));\n        // Trigger damage flash if health decreased\n        if (this.currentHealthRatio < oldRatio) {\n            this.triggerDamageFlash();\n        }\n    }\n    getGroup() {\n        return this.group;\n    }\n    dispose() {\n        // Clean up geometries and materials\n        this.backgroundMesh.geometry.dispose();\n        this.backgroundMesh.material.dispose();\n        this.healthMesh.geometry.dispose();\n        this.healthMesh.material.dispose();\n        this.borderMesh.geometry.dispose();\n        this.borderMesh.material.dispose();\n        // Remove from parent if it has one\n        if (this.group.parent) {\n            this.group.parent.remove(this.group);\n        }\n    }\n    reset() {\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.isVisible = true;\n        this.damageFlashTimer = 0;\n        this.enabled = true;\n        // Reset visual state\n        this.updateHealthMesh();\n        this.updateHealthColor();\n    }\n    clone() {\n        const config = {\n            width: this.width,\n            height: this.height,\n            offset: this.offset.clone(),\n            backgroundColor: this.backgroundColor.clone(),\n            healthColor: this.healthColor.clone(),\n            lowHealthColor: this.lowHealthColor.clone(),\n            criticalHealthColor: this.criticalHealthColor.clone(),\n            borderColor: this.borderColor.clone(),\n            borderWidth: this.borderWidth,\n            showWhenFull: this.showWhenFull,\n            fadeDistance: this.fadeDistance,\n            lowHealthThreshold: this.lowHealthThreshold,\n            criticalHealthThreshold: this.criticalHealthThreshold\n        };\n        return new HealthBar(config);\n    }\n    constructor(config = {}){\n        var _config_offset, _config_backgroundColor, _config_healthColor, _config_lowHealthColor, _config_criticalHealthColor, _config_borderColor;\n        super();\n        this.componentType = \"HealthBar\" // Instance identifier\n        ;\n        // Configuration\n        this.width = config.width || 1.0;\n        this.height = config.height || 0.1;\n        this.offset = ((_config_offset = config.offset) === null || _config_offset === void 0 ? void 0 : _config_offset.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0);\n        this.backgroundColor = ((_config_backgroundColor = config.backgroundColor) === null || _config_backgroundColor === void 0 ? void 0 : _config_backgroundColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x333333);\n        this.healthColor = ((_config_healthColor = config.healthColor) === null || _config_healthColor === void 0 ? void 0 : _config_healthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x00ff00);\n        this.lowHealthColor = ((_config_lowHealthColor = config.lowHealthColor) === null || _config_lowHealthColor === void 0 ? void 0 : _config_lowHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xffff00);\n        this.criticalHealthColor = ((_config_criticalHealthColor = config.criticalHealthColor) === null || _config_criticalHealthColor === void 0 ? void 0 : _config_criticalHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xff0000);\n        this.borderColor = ((_config_borderColor = config.borderColor) === null || _config_borderColor === void 0 ? void 0 : _config_borderColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);\n        this.borderWidth = config.borderWidth || 0.02;\n        this.showWhenFull = config.showWhenFull !== undefined ? config.showWhenFull : false;\n        this.fadeDistance = config.fadeDistance || 20;\n        this.lowHealthThreshold = config.lowHealthThreshold || 0.5;\n        this.criticalHealthThreshold = config.criticalHealthThreshold || 0.25;\n        // State\n        this.isVisible = true;\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.animationSpeed = 5.0; // How fast health bar animates\n        this.damageFlashTimer = 0;\n        this.damageFlashDuration = 0.2;\n        // Create rendering objects\n        this.createHealthBarMeshes();\n    }\n}\nHealthBar.componentType = \"HealthBar\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQzJEO0FBQ3JGO0FBa0IvQixNQUFNUSxrQkFBa0JELDhDQUFTQTtJQTZEOUJFLHdCQUE4QjtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJUix1REFBS0E7UUFFdEIsa0RBQWtEO1FBQ2xELE1BQU1TLGlCQUFpQixJQUFJUCwrREFBYUEsQ0FDdEMsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxXQUFXLEdBQUc7UUFFbkMsTUFBTUUsaUJBQWlCLElBQUlWLG1FQUFpQkEsQ0FBQztZQUMzQ1csT0FBTyxJQUFJLENBQUNDLFdBQVc7WUFDdkJDLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSWpCLHNEQUFJQSxDQUFDUSxnQkFBZ0JJO1FBQzNDLElBQUksQ0FBQ0ssVUFBVSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBRyxDQUFDLE9BQU8sa0JBQWtCO1FBQ3ZELElBQUksQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUMsSUFBSSxDQUFDSCxVQUFVO1FBRTlCLG9CQUFvQjtRQUNwQixNQUFNSSxxQkFBcUIsSUFBSXBCLCtEQUFhQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNwRSxNQUFNVyxxQkFBcUIsSUFBSXBCLG1FQUFpQkEsQ0FBQztZQUMvQ1csT0FBTyxJQUFJLENBQUNVLGVBQWU7WUFDM0JSLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSXhCLHNEQUFJQSxDQUFDcUIsb0JBQW9CQztRQUNuRCxJQUFJLENBQUNmLEtBQUssQ0FBQ2EsR0FBRyxDQUFDLElBQUksQ0FBQ0ksY0FB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LEdBQUc7UUFDdkIsSUFBSSxDQUFDRSxjQUFjLEdBQUcsS0FBSywrQkFBK0I7UUFDMUQsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBRztRQUUzQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbEUscUJBQXFCO0lBQzVCO0FBcU9GO0FBaFNhRCxVQUNZbUYsZ0JBQWdCLFlBQWEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHM/MzQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgR3JvdXAsIE1lc2gsIFBsYW5lR2VvbWV0cnksIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRoVXRpbHMsIE1hdGVyaWFsIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQmFyQ29uZmlnIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgb2Zmc2V0PzogVmVjdG9yMztcbiAgYmFja2dyb3VuZENvbG9yPzogQ29sb3I7XG4gIGhlYWx0aENvbG9yPzogQ29sb3I7XG4gIGxvd0hlYWx0aENvbG9yPzogQ29sb3I7XG4gIGNyaXRpY2FsSGVhbHRoQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyV2lkdGg/OiBudW1iZXI7XG4gIHNob3dXaGVuRnVsbD86IGJvb2xlYW47XG4gIGZhZGVEaXN0YW5jZT86IG51bWJlcjtcbiAgbG93SGVhbHRoVGhyZXNob2xkPzogbnVtYmVyO1xuICBjcml0aWNhbEhlYWx0aFRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGhCYXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoQmFyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzO1xuICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGhlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGxvd0hlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGNyaXRpY2FsSGVhbHRoQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyV2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHNob3dXaGVuRnVsbDogYm9vbGVhbjtcbiAgcHVibGljIGZhZGVEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgbG93SGVhbHRoVGhyZXNob2xkOiBudW1iZXI7XG4gIHB1YmxpYyBjcml0aWNhbEhlYWx0aFRocmVzaG9sZDogbnVtYmVyO1xuXG4gIC8vIFJlbmRlcmluZyBvYmplY3RzXG4gIHB1YmxpYyBncm91cCE6IEdyb3VwO1xuICBwdWJsaWMgYmFja2dyb3VuZE1lc2ghOiBNZXNoO1xuICBwdWJsaWMgaGVhbHRoTWVzaCE6IE1lc2g7XG4gIHB1YmxpYyBib3JkZXJNZXNoITogTWVzaDtcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc1Zpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyBjdXJyZW50SGVhbHRoUmF0aW86IG51bWJlcjtcbiAgcHVibGljIGxhc3RIZWFsdGhSYXRpbzogbnVtYmVyO1xuICBwdWJsaWMgYW5pbWF0aW9uU3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoVGltZXI6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoRHVyYXRpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhlYWx0aEJhckNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxLjA7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IDAuMTtcbiAgICB0aGlzLm9mZnNldCA9IGNvbmZpZy5vZmZzZXQ/LmNsb25lKCkgfHwgbmV3IFZlY3RvcjMoMCwgMS41LCAwKTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I/LmNsb25lKCkgfHwgbmV3IENvbG9yKDB4MzMzMzMzKTtcbiAgICB0aGlzLmhlYWx0aENvbG9yID0gY29uZmlnLmhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweDAwZmYwMCk7XG4gICAgdGhpcy5sb3dIZWFsdGhDb2xvciA9IGNvbmZpZy5sb3dIZWFsdGhDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHhmZmZmMDApO1xuICAgIHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvciA9IGNvbmZpZy5jcml0aWNhbEhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweGZmMDAwMCk7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZy5ib3JkZXJDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMC4wMjtcbiAgICB0aGlzLnNob3dXaGVuRnVsbCA9IGNvbmZpZy5zaG93V2hlbkZ1bGwgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zaG93V2hlbkZ1bGwgOiBmYWxzZTtcbiAgICB0aGlzLmZhZGVEaXN0YW5jZSA9IGNvbmZpZy5mYWRlRGlzdGFuY2UgfHwgMjA7XG4gICAgdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQgPSBjb25maWcubG93SGVhbHRoVGhyZXNob2xkIHx8IDAuNTtcbiAgICB0aGlzLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkID0gY29uZmlnLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIHx8IDAuMjU7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmxhc3RIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gNS4wOyAvLyBIb3cgZmFzdCBoZWFsdGggYmFyIGFuaW1hdGVzXG4gICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyID0gMDtcbiAgICB0aGlzLmRhbWFnZUZsYXNoRHVyYXRpb24gPSAwLjI7XG5cbiAgICAvLyBDcmVhdGUgcmVuZGVyaW5nIG9iamVjdHNcbiAgICB0aGlzLmNyZWF0ZUhlYWx0aEJhck1lc2hlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVIZWFsdGhCYXJNZXNoZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgLy8gQ3JlYXRlIGJvcmRlciAoc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gYmFja2dyb3VuZClcbiAgICBjb25zdCBib3JkZXJHZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KFxuICAgICAgdGhpcy53aWR0aCArIHRoaXMuYm9yZGVyV2lkdGggKiAyLCBcbiAgICAgIHRoaXMuaGVpZ2h0ICsgdGhpcy5ib3JkZXJXaWR0aCAqIDJcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlck1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgdGhpcy5ib3JkZXJNZXNoID0gbmV3IE1lc2goYm9yZGVyR2VvbWV0cnksIGJvcmRlck1hdGVyaWFsKTtcbiAgICB0aGlzLmJvcmRlck1lc2gucG9zaXRpb24ueiA9IC0wLjAwMTsgLy8gU2xpZ2h0bHkgYmVoaW5kXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5ib3JkZXJNZXNoKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgYmFja2dyb3VuZEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goYmFja2dyb3VuZEdlb21ldHJ5LCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuYmFja2dyb3VuZE1lc2gpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWx0aCBiYXIgKHN0YXJ0cyBmdWxsIHdpZHRoKVxuICAgIGNvbnN0IGhlYWx0aEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhlYWx0aE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5oZWFsdGhDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC45XG4gICAgfSk7XG4gICAgdGhpcy5oZWFsdGhNZXNoID0gbmV3IE1lc2goaGVhbHRoR2VvbWV0cnksIGhlYWx0aE1hdGVyaWFsKTtcbiAgICB0aGlzLmhlYWx0aE1lc2gucG9zaXRpb24ueiA9IDAuMDAxOyAvLyBTbGlnaHRseSBpbiBmcm9udFxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuaGVhbHRoTWVzaCk7XG5cbiAgICAvLyBNYWtlIGhlYWx0aCBiYXIgYWx3YXlzIGZhY2UgY2FtZXJhXG4gICAgdGhpcy5ncm91cC5sb29rQXQoMCwgMCwgMSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSGVhbHRoQmFyKFxuICAgIGhlYWx0aFJhdGlvOiBudW1iZXIsIFxuICAgIGNhbWVyYVBvc2l0aW9uOiBWZWN0b3IzLCBcbiAgICB3b3JsZFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRlbHRhVGltZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaGVhbHRoUmF0aW8pKTtcblxuICAgIC8vIEFuaW1hdGUgaGVhbHRoIGJhciBjaGFuZ2VzXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEhlYWx0aFJhdGlvIC0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8pID4gMC4wMSkge1xuICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8sIFxuICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbywgXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW87XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBjb2xvciBiYXNlZCBvbiBoZWFsdGggcmF0aW9cbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbG9yKCk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KGNhbWVyYVBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gdG8gZmFjZSBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGRhbWFnZSBmbGFzaFxuICAgIHRoaXMudXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoTWVzaCgpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc2NhbGUgdG8gcmVwcmVzZW50IGhlYWx0aFxuICAgIHRoaXMuaGVhbHRoTWVzaC5zY2FsZS54ID0gdGhpcy5sYXN0SGVhbHRoUmF0aW87XG4gICAgXG4gICAgLy8gQWRqdXN0IHBvc2l0aW9uIHNvIGhlYWx0aCBiYXIgc2hyaW5rcyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggKiAoMSAtIHRoaXMubGFzdEhlYWx0aFJhdGlvKSkgLyAyO1xuICAgIHRoaXMuaGVhbHRoTWVzaC5wb3NpdGlvbi54ID0gLW9mZnNldFg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhlYWx0aENvbG9yKCk6IHZvaWQge1xuICAgIGxldCBjb2xvcjogQ29sb3I7XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIDw9IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIGNvbG9yID0gdGhpcy5jcml0aWNhbEhlYWx0aENvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPD0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gbG93IGhlYWx0aCBhbmQgY3JpdGljYWwgaGVhbHRoIGNvbG9yc1xuICAgICAgY29uc3QgdCA9ICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyAtIHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKHRoaXMubG93SGVhbHRoVGhyZXNob2xkIC0gdGhpcy5jcml0aWNhbEhlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5jcml0aWNhbEhlYWx0aENvbG9yLCB0aGlzLmxvd0hlYWx0aENvbG9yLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBoZWFsdGggYW5kIGxvdyBoZWFsdGggY29sb3JzXG4gICAgICBjb25zdCB0ID0gKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIC0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKDEgLSB0aGlzLmxvd0hlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5sb3dIZWFsdGhDb2xvciwgdGhpcy5oZWFsdGhDb2xvciwgdCk7XG4gICAgfVxuXG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY29weShjb2xvcik7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2FtZXJhXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmFQb3NpdGlvbi5kaXN0YW5jZVRvKHdvcmxkUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiBzaG91bGQgYmUgdmlzaWJsZVxuICAgIGxldCBzaG91bGRCZVZpc2libGUgPSBkaXN0YW5jZSA8PSB0aGlzLmZhZGVEaXN0YW5jZTtcbiAgICBcbiAgICAvLyBIaWRlIHdoZW4gZnVsbCBoZWFsdGggaWYgY29uZmlndXJlZFxuICAgIGlmICghdGhpcy5zaG93V2hlbkZ1bGwgJiYgdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPj0gMC45OSkge1xuICAgICAgc2hvdWxkQmVWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpc2liaWxpdHlcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHNob3VsZEJlVmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcblxuICAgIC8vIEZhZGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZGlzdGFuY2UgPiB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykge1xuICAgICAgY29uc3QgZmFkZVJhdGlvID0gMSAtICgoZGlzdGFuY2UgLSB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykgLyAodGhpcy5mYWRlRGlzdGFuY2UgKiAwLjMpKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjEsIGZhZGVSYXRpbyk7XG4gICAgICBcbiAgICAgICh0aGlzLmJhY2tncm91bmRNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gb3BhY2l0eSAqIDAuNztcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSBvcGFjaXR5ICogMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IG9wYWNpdHkgKiAwLjg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgKHRoaXMuYmFja2dyb3VuZE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSAwLjc7XG4gICAgICAodGhpcy5oZWFsdGhNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuODtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQb3NpdGlvbiBoZWFsdGggYmFyIGFib3ZlIGVudGl0eVxuICAgIGNvbnN0IGJhclBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5ncm91cC5wb3NpdGlvbi5jb3B5KGJhclBvc2l0aW9uKTtcblxuICAgIC8vIE1ha2UgaGVhbHRoIGJhciBmYWNlIGNhbWVyYVxuICAgIHRoaXMuZ3JvdXAubG9va0F0KGNhbWVyYVBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYW1hZ2VGbGFzaFRpbWVyID4gMCkge1xuICAgICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIFxuICAgICAgLy8gRmxhc2ggZWZmZWN0IC0gbWFrZSBoZWFsdGggYmFyIGJyaWdodGVyXG4gICAgICBjb25zdCBmbGFzaEludGVuc2l0eSA9IHRoaXMuZGFtYWdlRmxhc2hUaW1lciAvIHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZsYXNoQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIE1peCBjdXJyZW50IGNvbG9yIHdpdGggd2hpdGUgZm9yIGZsYXNoIGVmZmVjdFxuICAgICAgY29uc3QgY3VycmVudENvbG9yID0gKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY2xvbmUoKTtcbiAgICAgIGN1cnJlbnRDb2xvci5sZXJwKGZsYXNoQ29sb3IsIGZsYXNoSW50ZW5zaXR5ICogMC41KTtcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLmNvcHkoY3VycmVudENvbG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJpZ2dlckRhbWFnZUZsYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlRmxhc2hUaW1lciA9IHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFsdGhSYXRpbyhyYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkUmF0aW8gPSB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbztcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhdGlvKSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkYW1hZ2UgZmxhc2ggaWYgaGVhbHRoIGRlY3JlYXNlZFxuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA8IG9sZFJhdGlvKSB7XG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VGbGFzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRHcm91cCgpOiBHcm91cCB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAodGhpcy5iYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuaGVhbHRoTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuYm9yZGVyTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBpZiBpdCBoYXMgb25lXG4gICAgaWYgKHRoaXMuZ3JvdXAucGFyZW50KSB7XG4gICAgICB0aGlzLmdyb3VwLnBhcmVudC5yZW1vdmUodGhpcy5ncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRhbWFnZUZsYXNoVGltZXIgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgdmlzdWFsIHN0YXRlXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb2xvcigpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEhlYWx0aEJhciB7XG4gICAgY29uc3QgY29uZmlnOiBIZWFsdGhCYXJDb25maWcgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLmNsb25lKCksXG4gICAgICBoZWFsdGhDb2xvcjogdGhpcy5oZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgbG93SGVhbHRoQ29sb3I6IHRoaXMubG93SGVhbHRoQ29sb3IuY2xvbmUoKSxcbiAgICAgIGNyaXRpY2FsSGVhbHRoQ29sb3I6IHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IuY2xvbmUoKSxcbiAgICAgIGJvcmRlcldpZHRoOiB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgc2hvd1doZW5GdWxsOiB0aGlzLnNob3dXaGVuRnVsbCxcbiAgICAgIGZhZGVEaXN0YW5jZTogdGhpcy5mYWRlRGlzdGFuY2UsXG4gICAgICBsb3dIZWFsdGhUaHJlc2hvbGQ6IHRoaXMubG93SGVhbHRoVGhyZXNob2xkLFxuICAgICAgY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQ6IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGRcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBuZXcgSGVhbHRoQmFyKGNvbmZpZyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJHcm91cCIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNYXRoVXRpbHMiLCJDb21wb25lbnQiLCJIZWFsdGhCYXIiLCJjcmVhdGVIZWFsdGhCYXJNZXNoZXMiLCJncm91cCIsImJvcmRlckdlb21ldHJ5Iiwid2lkdGgiLCJib3JkZXJXaWR0aCIsImhlaWdodCIsImJvcmRlck1hdGVyaWFsIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImJvcmRlck1lc2giLCJwb3NpdGlvbiIsInoiLCJhZGQiLCJiYWNrZ3JvdW5kR2VvbWV0cnkiLCJiYWNrZ3JvdW5kTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kTWVzaCIsImhlYWx0aEdlb21ldHJ5IiwiaGVhbHRoTWF0ZXJpYWwiLCJoZWFsdGhDb2xvciIsImhlYWx0aE1lc2giLCJsb29rQXQiLCJ1cGRhdGVIZWFsdGhCYXIiLCJoZWFsdGhSYXRpbyIsImNhbWVyYVBvc2l0aW9uIiwid29ybGRQb3NpdGlvbiIsImRlbHRhVGltZSIsImN1cnJlbnRIZWFsdGhSYXRpbyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhYnMiLCJsYXN0SGVhbHRoUmF0aW8iLCJsZXJwIiwiYW5pbWF0aW9uU3BlZWQiLCJ1cGRhdGVIZWFsdGhNZXNoIiwidXBkYXRlSGVhbHRoQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5IiwidXBkYXRlUG9zaXRpb25BbmRSb3RhdGlvbiIsInVwZGF0ZURhbWFnZUZsYXNoIiwic2NhbGUiLCJ4Iiwib2Zmc2V0WCIsImNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIiwiY3JpdGljYWxIZWFsdGhDb2xvciIsImxvd0hlYWx0aFRocmVzaG9sZCIsInQiLCJsZXJwQ29sb3JzIiwibG93SGVhbHRoQ29sb3IiLCJtYXRlcmlhbCIsImNvcHkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJzaG91bGRCZVZpc2libGUiLCJmYWRlRGlzdGFuY2UiLCJzaG93V2hlbkZ1bGwiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwiZmFkZVJhdGlvIiwiYmFyUG9zaXRpb24iLCJjbG9uZSIsIm9mZnNldCIsImRhbWFnZUZsYXNoVGltZXIiLCJmbGFzaEludGVuc2l0eSIsImRhbWFnZUZsYXNoRHVyYXRpb24iLCJmbGFzaENvbG9yIiwiY3VycmVudENvbG9yIiwidHJpZ2dlckRhbWFnZUZsYXNoIiwic2V0SGVhbHRoUmF0aW8iLCJyYXRpbyIsIm9sZFJhdGlvIiwiZ2V0R3JvdXAiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJwYXJlbnQiLCJyZW1vdmUiLCJyZXNldCIsImVuYWJsZWQiLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/HealthBar.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Interpolation.ts":
/*!*********************************************!*\
  !*** ./src/ecs/components/Interpolation.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterpolationBuffer: function() { return /* binding */ InterpolationBuffer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/**\n * Entity Interpolation System for Smooth Multiplayer Movement\n *\n * This system implements client-side prediction and entity interpolation to provide\n * smooth movement in multiplayer games, eliminating jerky position updates from server snapshots.\n *\n * Features:\n * - Linear interpolation (LERP) between server states\n * - Extrapolation for missing server updates\n * - Configurable interpolation delay and buffer size\n * - Automatic fallback to direct updates if interpolation fails\n *\n * Usage:\n * 1. Add InterpolationBuffer component to entities that need smooth movement\n * 2. Add InterpolationSystem to your ECS World\n * 3. Call addServerState() whenever you receive server position updates\n * 4. The InterpolationSystem will automatically handle smooth position/rotation updates\n *\n * Debug: Use window.getInterpolationStats() in browser console to monitor performance\n */ \n\nclass InterpolationBuffer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    /**\n   * Add a new server state to the interpolation buffer\n   */ addServerState(position, rotation, timestamp) {\n        const serverTimestamp = timestamp || Date.now();\n        const newState = {\n            timestamp: serverTimestamp,\n            position: position.clone(),\n            rotation: rotation.clone()\n        };\n        // Calculate velocity if we have a previous state\n        if (this.buffer.length > 0) {\n            const lastState = this.buffer[this.buffer.length - 1];\n            const timeDiff = (serverTimestamp - lastState.timestamp) / 1000; // Convert to seconds\n            if (timeDiff > 0) {\n                newState.velocity = position.clone().sub(lastState.position).divideScalar(timeDiff);\n                // Calculate angular velocity (simplified - could be improved)\n                const angleDiff = rotation.angleTo(lastState.rotation);\n                newState.angularVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, angleDiff / timeDiff, 0);\n            }\n        }\n        // Add to buffer\n        this.buffer.push(newState);\n        // Remove old states to maintain buffer size\n        while(this.buffer.length > this.maxBufferSize){\n            this.buffer.shift();\n        }\n        // Update interpolation state\n        this.updateInterpolationState(serverTimestamp);\n    }\n    /**\n   * Update the current interpolation state\n   */ updateInterpolationState(currentTime) {\n        if (this.buffer.length < 2) {\n            // Not enough states for interpolation\n            if (this.buffer.length === 1) {\n                this.currentState = {\n                    ...this.buffer[0]\n                };\n            }\n            return;\n        }\n        // Find the two states to interpolate between\n        const renderTime = currentTime - this.interpolationDelay;\n        let beforeState = null;\n        let afterState = null;\n        for(let i = 0; i < this.buffer.length - 1; i++){\n            if (this.buffer[i].timestamp <= renderTime && this.buffer[i + 1].timestamp >= renderTime) {\n                beforeState = this.buffer[i];\n                afterState = this.buffer[i + 1];\n                break;\n            }\n        }\n        if (beforeState && afterState) {\n            // We have states to interpolate between\n            this.currentState = beforeState;\n            this.targetState = afterState;\n            this.interpolationStartTime = currentTime;\n            this.interpolationDuration = afterState.timestamp - beforeState.timestamp;\n            this.extrapolationStartTime = 0; // Reset extrapolation\n        } else if (this.buffer.length > 0) {\n            // No states to interpolate - use extrapolation\n            const latestState = this.buffer[this.buffer.length - 1];\n            if (latestState.velocity) {\n                this.lastVelocity.copy(latestState.velocity);\n                this.extrapolationStartTime = currentTime;\n            }\n        }\n    }\n    /**\n   * Get the interpolated position at the current render time\n   */ getInterpolatedPosition(currentTime) {\n        if (!this.currentState || !this.targetState) {\n            // No interpolation available - use latest state or extrapolation\n            if (this.buffer.length > 0) {\n                const latestState = this.buffer[this.buffer.length - 1];\n                if (this.extrapolationStartTime > 0 && latestState.velocity) {\n                    const extrapolationTime = (currentTime - this.extrapolationStartTime) / 1000;\n                    const maxTime = this.maxExtrapolationTime / 1000;\n                    if (extrapolationTime < maxTime) {\n                        // Extrapolate position\n                        return latestState.position.clone().add(latestState.velocity.clone().multiplyScalar(extrapolationTime));\n                    }\n                }\n                return latestState.position.clone();\n            }\n            return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        }\n        // Calculate interpolation factor\n        const elapsed = currentTime - this.interpolationStartTime;\n        let t = elapsed / this.interpolationDuration;\n        // Clamp t between 0 and 1\n        t = Math.max(0, Math.min(1, t));\n        // Linear interpolation between current and target states\n        const interpolatedPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        interpolatedPosition.lerpVectors(this.currentState.position, this.targetState.position, t);\n        return interpolatedPosition;\n    }\n    /**\n   * Get the interpolated rotation at the current render time\n   */ getInterpolatedRotation(currentTime) {\n        if (!this.currentState || !this.targetState) {\n            // No interpolation available - use latest state\n            if (this.buffer.length > 0) {\n                return this.buffer[this.buffer.length - 1].rotation.clone();\n            }\n            return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        }\n        // Calculate interpolation factor\n        const elapsed = currentTime - this.interpolationStartTime;\n        let t = elapsed / this.interpolationDuration;\n        t = Math.max(0, Math.min(1, t));\n        // Spherical linear interpolation for rotations\n        const interpolatedRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        interpolatedRotation.copy(this.currentState.rotation);\n        interpolatedRotation.slerp(this.targetState.rotation, t);\n        return interpolatedRotation;\n    }\n    /**\n   * Get the interpolated transform (position and rotation) at the current render time\n   */ getInterpolatedTransform(currentTime) {\n        return {\n            position: this.getInterpolatedPosition(currentTime),\n            rotation: this.getInterpolatedRotation(currentTime)\n        };\n    }\n    /**\n   * Check if we're currently extrapolating (no recent server updates)\n   */ isExtrapolating(currentTime) {\n        return this.extrapolationStartTime > 0 && currentTime - this.extrapolationStartTime < this.maxExtrapolationTime;\n    }\n    /**\n   * Get buffer statistics for debugging\n   */ getBufferStats() {\n        return {\n            bufferSize: this.buffer.length,\n            maxBufferSize: this.maxBufferSize,\n            interpolationDelay: this.interpolationDelay,\n            isInterpolating: this.currentState !== null && this.targetState !== null,\n            isExtrapolating: this.extrapolationStartTime > 0,\n            latestTimestamp: this.buffer.length > 0 ? this.buffer[this.buffer.length - 1].timestamp : null\n        };\n    }\n    /**\n   * Clear the interpolation buffer\n   */ clearBuffer() {\n        this.buffer.length = 0;\n        this.currentState = null;\n        this.targetState = null;\n        this.interpolationStartTime = 0;\n        this.extrapolationStartTime = 0;\n    }\n    reset() {\n        this.clearBuffer();\n        this.lastVelocity.set(0, 0, 0);\n        this.lastAngularVelocity.set(0, 0, 0);\n        this.enabled = true;\n    }\n    constructor(){\n        super();\n        this.componentType = \"InterpolationBuffer\";\n        // Buffer to store recent server states\n        this.buffer = [];\n        this.maxBufferSize = 10 // Keep last 10 states for interpolation\n        ;\n        this.interpolationDelay = 100 // ms delay for interpolation (100ms = ~6-7 frames at 60fps)\n        ;\n        // Current interpolation state\n        this.currentState = null;\n        this.targetState = null;\n        this.interpolationStartTime = 0;\n        this.interpolationDuration = 0;\n        // Extrapolation settings\n        this.lastVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.lastAngularVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.extrapolationStartTime = 0;\n        this.maxExtrapolationTime = 500 // Max time to extrapolate before snapping (500ms)\n        ;\n    }\n}\nInterpolationBuffer.componentType = \"InterpolationBuffer\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQzJEO0FBQ3RCO0FBVS9CLE1BQU1HLDRCQUE0QkQsOENBQVNBO0lBeUJoRDs7R0FFQyxHQUNELGVBQXNCRyxRQUFpQixFQUFFQyxRQUFvQixFQUFFQyxTQUFrQixFQUFRO1FBQ3ZGLE1BQU1DLGtCQUFrQkQsYUFBYUUsS0FBS0MsR0FBRztRQUU3QyxNQUFNQyxXQUF3QjtZQUM1QkosV0FBV0M7WUFDWEgsVUFBVUEsU0FBU08sS0FBSztZQUN4Qk4sVUFBVUEsU0FBU00sS0FBSztRQUMxQjtRQUVBLGlEQUFpRDtRQUNqRCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLEdBQUcsR0FBRztZQUMxQixNQUFNQyxZQUFZLElBQUksQ0FBQ0YsTUFBTSxDQUFDLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtZQUNyRCxNQUFNRSxXQUFXLENBQUNSLGtCQUFrQk8sVUFBVVIsU0FBUyxJQUFJLE1BQU0scUJBQXFCO1lBRXRGLElBQUlTLFdBQVcsR0FBRztnQkFDaEJMLFNBQVNNLFFBQVEsR0FBR1osU0FBU08sS0FBSyxHQUFHTSxHQUFHLENBQUNILFVBQVVWLFFBQVEsRUFBRWMsWUFBWSxDQUFDSDtnQkFFMUUsOERBQThEO2dCQUM5RCxNQUFNSSxZQUFZZCxTQUFTZSxPQUFPLENBQUNOLFVBQVVULFFBQVE7Z0JBQ3JESyxTQUFTVyxlQUFlLEdBQUcsSUFBSXRCLHlEQUFPQSxDQUFDLEdBQUdvQixZQUFZSixVQUFVO1lBQ2xFO1FBQ0Y7UUFFQSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDSCxNQUFNLENBQUNVLElBQUksQ0FBQ1o7UUFFakIsNENBQTRDO1FBQzVDLE1BQU8sSUFBSSxDQUFDRSxNQUFNLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNVLGFBQWEs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SUFDaEM7SUFFTzJCLFFBQWM7UUFDbkIsSUFBSSxDQUFDRCxXQUFXO1FBQ2hCLElBQUksQ0FBQ3hCLFlBQVksQ0FBQzBCLEdBQUcsQ0FBQyxHQUFHLEdBQUc7UUFDNUIsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ0QsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUNuQyxJQUFJLENBQUNFLE9BQU8sR0FBRztJQUNqQjtJQXJNQUMsYUFBYztRQUNaLEtBQUs7YUFwQlNDLGdCQUFnQjtRQUVoQyx1Q0FBdUM7YUFDL0J4RCxTQUF3QixFQUFFO2FBQ2pCVyxnQkFBZ0IsR0FBSSx3Q0FBd0M7O2FBQzVETSxxQkFBcUIsSUFBSyw0REFBNEQ7O1FBRXZHLDhCQUE4QjthQUN0QkYsZUFBbUM7YUFDbkNNLGNBQWtDO2FBQ2xDQyx5QkFBeUI7YUFDekJDLHdCQUF3QjtRQUVoQyx5QkFBeUI7YUFDakJHLGVBQXdCLElBQUl2Qyx5REFBT0E7YUFDbkNrRSxzQkFBK0IsSUFBSWxFLHlEQUFPQTthQUMxQ3FDLHlCQUF5QjthQUN6Qk8sdUJBQXVCLElBQUssa0RBQWtEOztJQUl0RjtBQW9NRjtBQTNOYXpDLG9CQUNZa0UsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uLnRzP2FkZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbnRpdHkgSW50ZXJwb2xhdGlvbiBTeXN0ZW0gZm9yIFNtb290aCBNdWx0aXBsYXllciBNb3ZlbWVudFxuICpcbiAqIFRoaXMgc3lzdGVtIGltcGxlbWVudHMgY2xpZW50LXNpZGUgcHJlZGljdGlvbiBhbmQgZW50aXR5IGludGVycG9sYXRpb24gdG8gcHJvdmlkZVxuICogc21vb3RoIG1vdmVtZW50IGluIG11bHRpcGxheWVyIGdhbWVzLCBlbGltaW5hdGluZyBqZXJreSBwb3NpdGlvbiB1cGRhdGVzIGZyb20gc2VydmVyIHNuYXBzaG90cy5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gTGluZWFyIGludGVycG9sYXRpb24gKExFUlApIGJldHdlZW4gc2VydmVyIHN0YXRlc1xuICogLSBFeHRyYXBvbGF0aW9uIGZvciBtaXNzaW5nIHNlcnZlciB1cGRhdGVzXG4gKiAtIENvbmZpZ3VyYWJsZSBpbnRlcnBvbGF0aW9uIGRlbGF5IGFuZCBidWZmZXIgc2l6ZVxuICogLSBBdXRvbWF0aWMgZmFsbGJhY2sgdG8gZGlyZWN0IHVwZGF0ZXMgaWYgaW50ZXJwb2xhdGlvbiBmYWlsc1xuICpcbiAqIFVzYWdlOlxuICogMS4gQWRkIEludGVycG9sYXRpb25CdWZmZXIgY29tcG9uZW50IHRvIGVudGl0aWVzIHRoYXQgbmVlZCBzbW9vdGggbW92ZW1lbnRcbiAqIDIuIEFkZCBJbnRlcnBvbGF0aW9uU3lzdGVtIHRvIHlvdXIgRUNTIFdvcmxkXG4gKiAzLiBDYWxsIGFkZFNlcnZlclN0YXRlKCkgd2hlbmV2ZXIgeW91IHJlY2VpdmUgc2VydmVyIHBvc2l0aW9uIHVwZGF0ZXNcbiAqIDQuIFRoZSBJbnRlcnBvbGF0aW9uU3lzdGVtIHdpbGwgYXV0b21hdGljYWxseSBoYW5kbGUgc21vb3RoIHBvc2l0aW9uL3JvdGF0aW9uIHVwZGF0ZXNcbiAqXG4gKiBEZWJ1ZzogVXNlIHdpbmRvdy5nZXRJbnRlcnBvbGF0aW9uU3RhdHMoKSBpbiBicm93c2VyIGNvbnNvbGUgdG8gbW9uaXRvciBwZXJmb3JtYW5jZVxuICovXG5pbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VydmVyU3RhdGUge1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgcG9zaXRpb246IFZlY3RvcjM7XG4gIHJvdGF0aW9uOiBRdWF0ZXJuaW9uO1xuICB2ZWxvY2l0eT86IFZlY3RvcjM7XG4gIGFuZ3VsYXJWZWxvY2l0eT86IFZlY3RvcjM7XG59XG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uQnVmZmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0ludGVycG9sYXRpb25CdWZmZXInO1xuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdJbnRlcnBvbGF0aW9uQnVmZmVyJztcblxuICAvLyBCdWZmZXIgdG8gc3RvcmUgcmVjZW50IHNlcnZlciBzdGF0ZXNcbiAgcHJpdmF0ZSBidWZmZXI6IFNlcnZlclN0YXRlW10gPSBbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhCdWZmZXJTaXplID0gMTA7IC8vIEtlZXAgbGFzdCAxMCBzdGF0ZXMgZm9yIGludGVycG9sYXRpb25cbiAgcHJpdmF0ZSByZWFkb25seSBpbnRlcnBvbGF0aW9uRGVsYXkgPSAxMDA7IC8vIG1zIGRlbGF5IGZvciBpbnRlcnBvbGF0aW9uICgxMDBtcyA9IH42LTcgZnJhbWVzIGF0IDYwZnBzKVxuXG4gIC8vIEN1cnJlbnQgaW50ZXJwb2xhdGlvbiBzdGF0ZVxuICBwcml2YXRlIGN1cnJlbnRTdGF0ZTogU2VydmVyU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSB0YXJnZXRTdGF0ZTogU2VydmVyU3RhdGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uU3RhcnRUaW1lID0gMDtcbiAgcHJpdmF0ZSBpbnRlcnBvbGF0aW9uRHVyYXRpb24gPSAwO1xuXG4gIC8vIEV4dHJhcG9sYXRpb24gc2V0dGluZ3NcbiAgcHJpdmF0ZSBsYXN0VmVsb2NpdHk6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGxhc3RBbmd1bGFyVmVsb2NpdHk6IFZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGV4dHJhcG9sYXRpb25TdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIG1heEV4dHJhcG9sYXRpb25UaW1lID0gNTAwOyAvLyBNYXggdGltZSB0byBleHRyYXBvbGF0ZSBiZWZvcmUgc25hcHBpbmcgKDUwMG1zKVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHNlcnZlciBzdGF0ZSB0byB0aGUgaW50ZXJwb2xhdGlvbiBidWZmZXJcbiAgICovXG4gIHB1YmxpYyBhZGRTZXJ2ZXJTdGF0ZShwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHNlcnZlclRpbWVzdGFtcCA9IHRpbWVzdGFtcCB8fCBEYXRlLm5vdygpO1xuXG4gICAgY29uc3QgbmV3U3RhdGU6IFNlcnZlclN0YXRlID0ge1xuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24uY2xvbmUoKSxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbi5jbG9uZSgpXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSB2ZWxvY2l0eSBpZiB3ZSBoYXZlIGEgcHJldmlvdXMgc3RhdGVcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB0aW1lRGlmZiA9IChzZXJ2ZXJUaW1lc3RhbXAgLSBsYXN0U3RhdGUudGltZXN0YW1wKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuXG4gICAgICBpZiAodGltZURpZmYgPiAwKSB7XG4gICAgICAgIG5ld1N0YXRlLnZlbG9jaXR5ID0gcG9zaXRpb24uY2xvbmUoKS5zdWIobGFzdFN0YXRlLnBvc2l0aW9uKS5kaXZpZGVTY2FsYXIodGltZURpZmYpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbmd1bGFyIHZlbG9jaXR5IChzaW1wbGlmaWVkIC0gY291bGQgYmUgaW1wcm92ZWQpXG4gICAgICAgIGNvbnN0IGFuZ2xlRGlmZiA9IHJvdGF0aW9uLmFuZ2xlVG8obGFzdFN0YXRlLnJvdGF0aW9uKTtcbiAgICAgICAgbmV3U3RhdGUuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgYW5nbGVEaWZmIC8gdGltZURpZmYsIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBidWZmZXJcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKG5ld1N0YXRlKTtcblxuICAgIC8vIFJlbW92ZSBvbGQgc3RhdGVzIHRvIG1haW50YWluIGJ1ZmZlciBzaXplXG4gICAgd2hpbGUgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgdGhpcy5idWZmZXIuc2hpZnQoKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgaW50ZXJwb2xhdGlvbiBzdGF0ZVxuICAgIHRoaXMudXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlKHNlcnZlclRpbWVzdGFtcCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IGludGVycG9sYXRpb24gc3RhdGVcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgMikge1xuICAgICAgLy8gTm90IGVub3VnaCBzdGF0ZXMgZm9yIGludGVycG9sYXRpb25cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB7IC4uLnRoaXMuYnVmZmVyWzBdIH07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgdHdvIHN0YXRlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG4gICAgY29uc3QgcmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5pbnRlcnBvbGF0aW9uRGVsYXk7XG4gICAgbGV0IGJlZm9yZVN0YXRlOiBTZXJ2ZXJTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBhZnRlclN0YXRlOiBTZXJ2ZXJTdGF0ZSB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcltpXS50aW1lc3RhbXAgPD0gcmVuZGVyVGltZSAmJiB0aGlzLmJ1ZmZlcltpICsgMV0udGltZXN0YW1wID49IHJlbmRlclRpbWUpIHtcbiAgICAgICAgYmVmb3JlU3RhdGUgPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgYWZ0ZXJTdGF0ZSA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlZm9yZVN0YXRlICYmIGFmdGVyU3RhdGUpIHtcbiAgICAgIC8vIFdlIGhhdmUgc3RhdGVzIHRvIGludGVycG9sYXRlIGJldHdlZW5cbiAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gYmVmb3JlU3RhdGU7XG4gICAgICB0aGlzLnRhcmdldFN0YXRlID0gYWZ0ZXJTdGF0ZTtcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uRHVyYXRpb24gPSBhZnRlclN0YXRlLnRpbWVzdGFtcCAtIGJlZm9yZVN0YXRlLnRpbWVzdGFtcDtcbiAgICAgIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA9IDA7IC8vIFJlc2V0IGV4dHJhcG9sYXRpb25cbiAgICB9IGVsc2UgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIE5vIHN0YXRlcyB0byBpbnRlcnBvbGF0ZSAtIHVzZSBleHRyYXBvbGF0aW9uXG4gICAgICBjb25zdCBsYXRlc3RTdGF0ZSA9IHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhdGVzdFN0YXRlLnZlbG9jaXR5KSB7XG4gICAgICAgIHRoaXMubGFzdFZlbG9jaXR5LmNvcHkobGF0ZXN0U3RhdGUudmVsb2NpdHkpO1xuICAgICAgICB0aGlzLmV4dHJhcG9sYXRpb25TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgcG9zaXRpb24gYXQgdGhlIGN1cnJlbnQgcmVuZGVyIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRJbnRlcnBvbGF0ZWRQb3NpdGlvbihjdXJyZW50VGltZTogbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSB8fCAhdGhpcy50YXJnZXRTdGF0ZSkge1xuICAgICAgLy8gTm8gaW50ZXJwb2xhdGlvbiBhdmFpbGFibGUgLSB1c2UgbGF0ZXN0IHN0YXRlIG9yIGV4dHJhcG9sYXRpb25cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdFN0YXRlID0gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA+IDAgJiYgbGF0ZXN0U3RhdGUudmVsb2NpdHkpIHtcbiAgICAgICAgICBjb25zdCBleHRyYXBvbGF0aW9uVGltZSA9IChjdXJyZW50VGltZSAtIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSkgLyAxMDAwO1xuICAgICAgICAgIGNvbnN0IG1heFRpbWUgPSB0aGlzLm1heEV4dHJhcG9sYXRpb25UaW1lIC8gMTAwMDtcblxuICAgICAgICAgIGlmIChleHRyYXBvbGF0aW9uVGltZSA8IG1heFRpbWUpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhcG9sYXRlIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0U3RhdGUucG9zaXRpb24uY2xvbmUoKS5hZGQoXG4gICAgICAgICAgICAgIGxhdGVzdFN0YXRlLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZXh0cmFwb2xhdGlvblRpbWUpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXRlc3RTdGF0ZS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZTtcbiAgICBsZXQgdCA9IGVsYXBzZWQgLyB0aGlzLmludGVycG9sYXRpb25EdXJhdGlvbjtcblxuICAgIC8vIENsYW1wIHQgYmV0d2VlbiAwIGFuZCAxXG4gICAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcblxuICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gY3VycmVudCBhbmQgdGFyZ2V0IHN0YXRlc1xuICAgIGNvbnN0IGludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBpbnRlcnBvbGF0ZWRQb3NpdGlvbi5sZXJwVmVjdG9ycyh0aGlzLmN1cnJlbnRTdGF0ZS5wb3NpdGlvbiwgdGhpcy50YXJnZXRTdGF0ZS5wb3NpdGlvbiwgdCk7XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgcm90YXRpb24gYXQgdGhlIGN1cnJlbnQgcmVuZGVyIHRpbWVcbiAgICovXG4gIHB1YmxpYyBnZXRJbnRlcnBvbGF0ZWRSb3RhdGlvbihjdXJyZW50VGltZTogbnVtYmVyKTogUXVhdGVybmlvbiB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRTdGF0ZSB8fCAhdGhpcy50YXJnZXRTdGF0ZSkge1xuICAgICAgLy8gTm8gaW50ZXJwb2xhdGlvbiBhdmFpbGFibGUgLSB1c2UgbGF0ZXN0IHN0YXRlXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5idWZmZXIubGVuZ3RoIC0gMV0ucm90YXRpb24uY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZTtcbiAgICBsZXQgdCA9IGVsYXBzZWQgLyB0aGlzLmludGVycG9sYXRpb25EdXJhdGlvbjtcbiAgICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuXG4gICAgLy8gU3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciByb3RhdGlvbnNcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgaW50ZXJwb2xhdGVkUm90YXRpb24uY29weSh0aGlzLmN1cnJlbnRTdGF0ZS5yb3RhdGlvbik7XG4gICAgaW50ZXJwb2xhdGVkUm90YXRpb24uc2xlcnAodGhpcy50YXJnZXRTdGF0ZS5yb3RhdGlvbiwgdCk7XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkUm90YXRpb247XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcnBvbGF0ZWQgdHJhbnNmb3JtIChwb3NpdGlvbiBhbmQgcm90YXRpb24pIGF0IHRoZSBjdXJyZW50IHJlbmRlciB0aW1lXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB7IHBvc2l0aW9uOiBWZWN0b3IzOyByb3RhdGlvbjogUXVhdGVybmlvbiB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHRoaXMuZ2V0SW50ZXJwb2xhdGVkUG9zaXRpb24oY3VycmVudFRpbWUpLFxuICAgICAgcm90YXRpb246IHRoaXMuZ2V0SW50ZXJwb2xhdGVkUm90YXRpb24oY3VycmVudFRpbWUpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3ZSdyZSBjdXJyZW50bHkgZXh0cmFwb2xhdGluZyAobm8gcmVjZW50IHNlcnZlciB1cGRhdGVzKVxuICAgKi9cbiAgcHVibGljIGlzRXh0cmFwb2xhdGluZyhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0cmFwb2xhdGlvblN0YXJ0VGltZSA+IDAgJiZcbiAgICAgICAgICAgKGN1cnJlbnRUaW1lIC0gdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lKSA8IHRoaXMubWF4RXh0cmFwb2xhdGlvblRpbWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlciBzdGF0aXN0aWNzIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIHB1YmxpYyBnZXRCdWZmZXJTdGF0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnVmZmVyU2l6ZTogdGhpcy5idWZmZXIubGVuZ3RoLFxuICAgICAgbWF4QnVmZmVyU2l6ZTogdGhpcy5tYXhCdWZmZXJTaXplLFxuICAgICAgaW50ZXJwb2xhdGlvbkRlbGF5OiB0aGlzLmludGVycG9sYXRpb25EZWxheSxcbiAgICAgIGlzSW50ZXJwb2xhdGluZzogdGhpcy5jdXJyZW50U3RhdGUgIT09IG51bGwgJiYgdGhpcy50YXJnZXRTdGF0ZSAhPT0gbnVsbCxcbiAgICAgIGlzRXh0cmFwb2xhdGluZzogdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lID4gMCxcbiAgICAgIGxhdGVzdFRpbWVzdGFtcDogdGhpcy5idWZmZXIubGVuZ3RoID4gMCA/IHRoaXMuYnVmZmVyW3RoaXMuYnVmZmVyLmxlbmd0aCAtIDFdLnRpbWVzdGFtcCA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBpbnRlcnBvbGF0aW9uIGJ1ZmZlclxuICAgKi9cbiAgcHVibGljIGNsZWFyQnVmZmVyKCk6IHZvaWQge1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50U3RhdGUgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U3RhdGUgPSBudWxsO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvblN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5leHRyYXBvbGF0aW9uU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyQnVmZmVyKCk7XG4gICAgdGhpcy5sYXN0VmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGFzdEFuZ3VsYXJWZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiQ29tcG9uZW50IiwiSW50ZXJwb2xhdGlvbkJ1ZmZlciIsImFkZFNlcnZlclN0YXRlIiwicG9zaXRpb24iLCJyb3RhdGlvbiIsInRpbWVzdGFtcCIsInNlcnZlclRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJuZXdTdGF0ZSIsImNsb25lIiwiYnVmZmVyIiwibGVuZ3RoIiwibGFzdFN0YXRlIiwidGltZURpZmYiLCJ2ZWxvY2l0eSIsInN1YiIsImRpdmlkZVNjYWxhciIsImFuZ2xlRGlmZiIsImFuZ2xlVG8iLCJhbmd1bGFyVmVsb2NpdHkiLCJwdXNoIiwibWF4QnVmZmVyU2l6ZSIsInNoaWZ0IiwidXBkYXRlSW50ZXJwb2xhdGlvblN0YXRlIiwiY3VycmVudFRpbWUiLCJjdXJyZW50U3RhdGUiLCJyZW5kZXJUaW1lIiwiaW50ZXJwb2xhdGlvbkRlbGF5IiwiYmVmb3JlU3RhdGUiLCJhZnRlclN0YXRlIiwiaSIsInRhcmdldFN0YXRlIiwiaW50ZXJwb2xhdGlvblN0YXJ0VGltZSIsImludGVycG9sYXRpb25EdXJhdGlvbiIsImV4dHJhcG9sYXRpb25TdGFydFRpbWUiLCJsYXRlc3RTdGF0ZSIsImxhc3RWZWxvY2l0eSIsImNvcHkiLCJnZXRJbnRlcnBvbGF0ZWRQb3NpdGlvbiIsImV4dHJhcG9sYXRpb25UaW1lIiwibWF4VGltZSIsIm1heEV4dHJhcG9sYXRpb25UaW1lIiwiYWRkIiwibXVsdGlwbHlTY2FsYXIiLCJlbGFwc2VkIiwidCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJpbnRlcnBvbGF0ZWRQb3NpdGlvbiIsImxlcnBWZWN0b3JzIiwiZ2V0SW50ZXJwb2xhdGVkUm90YXRpb24iLCJpbnRlcnBvbGF0ZWRSb3RhdGlvbiIsInNsZXJwIiwiZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwiaXNFeHRyYXBvbGF0aW5nIiwiZ2V0QnVmZmVyU3RhdHMiLCJidWZmZXJTaXplIiwiaXNJbnRlcnBvbGF0aW5nIiwibGF0ZXN0VGltZXN0YW1wIiwiY2xlYXJCdWZmZXIiLCJyZXNldCIsInNldCIsImxhc3RBbmd1bGFyVmVsb2NpdHkiLCJlbmFibGVkIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Interpolation.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Movement.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Movement.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Movement: function() { return /* binding */ Movement; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Movement component for velocity and movement properties\n\n\nclass Movement extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    addForce(force) {\n        this.acceleration.add(force);\n    }\n    addImpulse(impulse) {\n        this.velocity.add(impulse);\n    }\n    jump() {\n        if (this.canJump && (this.isGrounded || this.canFly)) {\n            this.velocity.y = this.jumpForce;\n            this.isGrounded = false;\n        }\n    }\n    setMoveDirection(direction) {\n        let strength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n        this.moveDirection.copy(direction).normalize();\n        this.inputStrength = Math.max(0, Math.min(1, strength));\n    }\n    freeze(duration) {\n        const currentTime = Date.now();\n        this.isFrozen = true;\n        this.frozenUntil = currentTime + duration;\n    // console.log(`🧊 Player frozen for ${duration}ms until ${this.frozenUntil} (current: ${currentTime})`);\n    }\n    slow(duration) {\n        let speedMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n        const currentTime = Date.now();\n        this.isSlowed = true;\n        this.slowedUntil = currentTime + duration;\n        this.movementSpeedMultiplier = speedMultiplier;\n    // console.log(`🐌 Player slowed to ${speedMultiplier * 100}% speed for ${duration}ms until ${this.slowedUntil}`);\n    }\n    updateDebuffs() {\n        const currentTime = Date.now();\n        // Check frozen state\n        if (this.isFrozen && currentTime >= this.frozenUntil) {\n            this.isFrozen = false;\n            this.frozenUntil = 0;\n        }\n        // Check slowed state\n        if (this.isSlowed && currentTime >= this.slowedUntil) {\n            this.isSlowed = false;\n            this.slowedUntil = 0;\n            this.movementSpeedMultiplier = 1.0;\n        }\n    }\n    getEffectiveMaxSpeed() {\n        if (this.isFrozen) {\n            return 0; // Completely frozen\n        }\n        return this.maxSpeed * this.movementSpeedMultiplier;\n    }\n    startDash(direction, currentPosition, currentTime) {\n        // Check if already dashing\n        if (this.isDashing) {\n            return false;\n        }\n        // Find first available charge\n        const availableChargeIndex = this.dashCharges.findIndex((charge)=>charge.isAvailable);\n        if (availableChargeIndex === -1) {\n            return false; // No charges available\n        }\n        // Start the dash\n        this.isDashing = true;\n        this.dashDirection.copy(direction).normalize();\n        this.dashStartTime = currentTime;\n        this.dashStartPosition.copy(currentPosition);\n        // Consume the charge\n        this.dashCharges[availableChargeIndex].isAvailable = false;\n        this.dashCharges[availableChargeIndex].cooldownStartTime = currentTime;\n        // Set cooldown timer for this specific charge (6 seconds)\n        setTimeout(()=>{\n            this.dashCharges[availableChargeIndex].isAvailable = true;\n            this.dashCharges[availableChargeIndex].cooldownStartTime = null;\n        }, 6000); // 6 second cooldown\n        return true;\n    }\n    updateDash(currentTime) {\n        if (!this.isDashing) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.dashStartTime;\n        const progress = Math.min(elapsed / this.dashDuration, 1);\n        if (progress >= 1) {\n            // Dash complete\n            this.isDashing = false;\n            const finalPosition = this.dashStartPosition.clone().add(this.dashDirection.clone().multiplyScalar(this.dashDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad, same as old implementation)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.dashDirection.clone().multiplyScalar(this.dashDistance * easeOutQuad);\n        const newPosition = this.dashStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelDash() {\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n    }\n    stop() {\n        this.velocity.set(0, 0, 0);\n        this.acceleration.set(0, 0, 0);\n        this.moveDirection.set(0, 0, 0);\n        this.inputStrength = 0;\n    }\n    getSpeed() {\n        return this.velocity.length();\n    }\n    getHorizontalSpeed() {\n        return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);\n    }\n    isMoving() {\n        return this.getSpeed() > 0.01;\n    }\n    isMovingHorizontally() {\n        return this.getHorizontalSpeed() > 0.01;\n    }\n    isFalling() {\n        return this.velocity.y < -0.1;\n    }\n    isRising() {\n        return this.velocity.y > 0.1;\n    }\n    getAvailableDashCharges() {\n        return this.dashCharges.filter((charge)=>charge.isAvailable).length;\n    }\n    getDashChargeStatus() {\n        const currentTime = Date.now() / 1000;\n        return this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownRemaining: charge.cooldownStartTime ? Math.max(0, 6 - (currentTime - charge.cooldownStartTime)) : 0\n            }));\n    }\n    startCharge(direction, currentPosition, currentTime) {\n        // Check if already charging or dashing\n        if (this.isCharging || this.isDashing) {\n            return false;\n        }\n        // Start the charge\n        this.isCharging = true;\n        this.chargeDirection.copy(direction).normalize();\n        this.chargeStartTime = currentTime;\n        this.chargeStartPosition.copy(currentPosition);\n        return true;\n    }\n    updateCharge(currentTime) {\n        if (!this.isCharging) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.chargeStartTime;\n        const progress = Math.min(elapsed / this.chargeDuration, 1);\n        if (progress >= 1) {\n            // Charge complete\n            this.isCharging = false;\n            const finalPosition = this.chargeStartPosition.clone().add(this.chargeDirection.clone().multiplyScalar(this.chargeDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.chargeDirection.clone().multiplyScalar(this.chargeDistance * easeOutQuad);\n        const newPosition = this.chargeStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelCharge() {\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n    }\n    clampVelocity() {\n        // Get effective max speed (considering debuffs)\n        const effectiveMaxSpeed = this.getEffectiveMaxSpeed();\n        // Clamp horizontal velocity to effective max speed\n        const horizontalVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.velocity.x, 0, this.velocity.z);\n        const horizontalSpeed = horizontalVelocity.length();\n        if (horizontalSpeed > effectiveMaxSpeed) {\n            if (effectiveMaxSpeed === 0) {\n                // Completely frozen - stop all horizontal movement\n                this.velocity.x = 0;\n                this.velocity.z = 0;\n            } else {\n                horizontalVelocity.normalize().multiplyScalar(effectiveMaxSpeed);\n                this.velocity.x = horizontalVelocity.x;\n                this.velocity.z = horizontalVelocity.z;\n            }\n        }\n    }\n    applyFriction(deltaTime) {\n        if (!this.canMove) return;\n        // Apply friction to horizontal movement\n        const frictionForce = Math.pow(this.friction, deltaTime);\n        this.velocity.x *= frictionForce;\n        this.velocity.z *= frictionForce;\n        // Stop very small velocities to prevent jitter\n        if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;\n        if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;\n    }\n    applyGravity(deltaTime) {\n        if (!this.canFly) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.velocity) {\n            this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.velocity.set(0, 0, 0);\n        }\n        if (!this.acceleration) {\n            this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.acceleration.set(0, 0, 0);\n        }\n        if (!this.moveDirection) {\n            this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.moveDirection.set(0, 0, 0);\n        }\n        this.inputStrength = 0;\n        this.isGrounded = false;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        this.maxSpeed = 5.0;\n        this.friction = 0.8;\n        this.jumpForce = 20.0;\n        this.gravity = -12.5;\n        this.enabled = true;\n        // Reset debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Reset dash properties\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35;\n        this.dashDistance = 4;\n        this.dashStartPosition.set(0, 0, 0);\n        // Reset dash charges\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Reset charge properties\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35;\n        this.chargeDistance = 9;\n        this.chargeStartPosition.set(0, 0, 0);\n    }\n    clone() {\n        const clone = new Movement(this.maxSpeed, this.friction, this.jumpForce, this.gravity);\n        clone.velocity.copy(this.velocity);\n        clone.acceleration.copy(this.acceleration);\n        clone.moveDirection.copy(this.moveDirection);\n        clone.inputStrength = this.inputStrength;\n        clone.isGrounded = this.isGrounded;\n        clone.canMove = this.canMove;\n        clone.canJump = this.canJump;\n        clone.canFly = this.canFly;\n        // Clone debuff states\n        clone.isFrozen = this.isFrozen;\n        clone.frozenUntil = this.frozenUntil;\n        clone.isSlowed = this.isSlowed;\n        clone.slowedUntil = this.slowedUntil;\n        clone.movementSpeedMultiplier = this.movementSpeedMultiplier;\n        // Clone dash properties\n        clone.isDashing = this.isDashing;\n        clone.dashDirection.copy(this.dashDirection);\n        clone.dashStartTime = this.dashStartTime;\n        clone.dashDuration = this.dashDuration;\n        clone.dashDistance = this.dashDistance;\n        clone.dashStartPosition.copy(this.dashStartPosition);\n        // Clone dash charges\n        clone.maxDashCharges = this.maxDashCharges;\n        clone.dashCharges = this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownStartTime: charge.cooldownStartTime\n            }));\n        // Clone charge properties\n        clone.isCharging = this.isCharging;\n        clone.chargeDirection.copy(this.chargeDirection);\n        clone.chargeStartTime = this.chargeStartTime;\n        clone.chargeDuration = this.chargeDuration;\n        clone.chargeDistance = this.chargeDistance;\n        clone.chargeStartPosition.copy(this.chargeStartPosition);\n        return clone;\n    }\n    constructor(maxSpeed = 3.75, friction = 0.8, jumpForce = 20.0, gravity = -12.5){\n        super();\n        this.componentType = \"Movement\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.maxSpeed = maxSpeed;\n        this.friction = friction;\n        this.isGrounded = false;\n        this.jumpForce = jumpForce;\n        this.gravity = gravity;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        // Initialize debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.inputStrength = 0;\n        // Initialize dash properties\n        this.isDashing = false;\n        this.dashDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35; // 350ms dash duration (same as old implementation)\n        this.dashDistance = 4; // Increased from 3.125 for more noticeable dash\n        this.dashStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize multiple dash charges (3 charges, each with 6s cooldown)\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Initialize sword charge properties\n        this.isCharging = false;\n        this.chargeDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35; // 350ms charge duration\n        this.chargeDistance = 9; // Sword charge distance\n        this.chargeStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nMovement.componentType = \"Movement\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFBMEQ7QUFDVjtBQUNWO0FBRS9CLE1BQU1FLGlCQUFpQkQsOENBQVNBO0lBd0c5QkUsU0FBU0MsS0FBYyxFQUFRO1FBQ3BDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUNGO0lBQ3hCO0lBRU9HLFdBQVdDLE9BQWdCLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxRQUFRLENBQUNILEdBQUcsQ0FBQ0U7SUFDcEI7SUFFT0UsT0FBYTtRQUNsQixJQUFJLElBQUksQ0FBQ0MsT0FBTyxJQUFLLEtBQUksQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ3BELElBQUksQ0FBQ0osUUFBUSxDQUFDSyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1lBQ2hDLElBQUksQ0FBQ0gsVUFBVSxHQUFHO1FBQ3BCO0lBQ0Y7SUFFT0ksaUJBQWlCQyxTQUFrQixFQUFnQztZQUE5QkMsV0FBQUEsaUVBQW1CO1FBQzdELElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNILFdBQVdJLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR1A7SUFDL0M7SUFFT1EsT0FBT0MsUUFBZ0IsRUFBUTtRQUNwQyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO1FBQzVCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixjQUFjRDtJQUNqQyx5R0FBeUc7SUFDM0c7SUFFT00sS0FBS04sUUFBZ0IsRUFBdUM7WUFBckNPLGtCQUFBQSxpRUFBMEI7UUFDdEQsTUFBTU4sY0FBY0MsS0FBS0MsR0FBRztRQUM1QixJQUFJLENBQUNLLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR1IsY0FBY0Q7UUFD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QSxDQUFDLEdBQUcsR0FBRztRQUN2QyxJQUFJLENBQUNzQixhQUFhLEdBQUc7UUFFckIsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ3FCLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNNLGFBQWEsR0FBRyxJQUFJakQseURBQU9BLENBQUMsR0FBRyxHQUFHO1FBQ3ZDLElBQUksQ0FBQ2tELGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNTLFlBQVksR0FBRyxNQUFNLG1EQUFtRDtRQUM3RSxJQUFJLENBQUNJLFlBQVksR0FBRyxHQUFHLGdEQUFnRDtRQUN2RSxJQUFJLENBQUNaLGlCQUFpQixHQUFHLElBQUluRCx5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFFM0Msc0VBQXNFO1FBQ3RFLElBQUksQ0FBQzRHLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUMvRCxXQUFXLEdBQUdnRSxNQUFNQyxJQUFJLENBQUM7WUFBRXZDLFFBQVEsSUFBSSxDQUFDcUMsY0FBYztRQUFDLEdBQUcsSUFBTztnQkFDcEU1RCxhQUFhO2dCQUNiSSxtQkFBbUI7WUFDckI7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDa0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUl2Rix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDekMsSUFBSSxDQUFDd0YsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0csY0FBYyxHQUFHLE1BQU0sd0JBQXdCO1FBQ3BELElBQUksQ0FBQ0MsY0FBYyxHQUFHLEdBQUcsd0JBQXdCO1FBQ2pELElBQUksQ0FBQ0gsbUJBQW1CLEdBQUcsSUFBSXpGLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztJQUMvQztBQXFXRjtBQTNjYUUsU0FDWThHLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQudHM/MThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb3ZlbWVudCBjb21wb25lbnQgZm9yIHZlbG9jaXR5IGFuZCBtb3ZlbWVudCBwcm9wZXJ0aWVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBNb3ZlbWVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgYWNjZWxlcmF0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgbWF4U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGZyaWN0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBpc0dyb3VuZGVkOiBib29sZWFuO1xuICBwdWJsaWMganVtcEZvcmNlOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgZmxhZ3NcbiAgcHVibGljIGNhbk1vdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBjYW5KdW1wOiBib29sZWFuO1xuICBwdWJsaWMgY2FuRmx5OiBib29sZWFuO1xuXG4gIC8vIERlYnVmZiBzdGF0ZXMgZm9yIFBWUFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcm96ZW5VbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgaXNTbG93ZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyBzbG93ZWRVbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgbW92ZW1lbnRTcGVlZE11bHRpcGxpZXI6IG51bWJlcjtcblxuICAvLyBJbnB1dC1iYXNlZCBtb3ZlbWVudFxuICBwdWJsaWMgbW92ZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGlucHV0U3RyZW5ndGg6IG51bWJlcjtcblxuICAvLyBEYXNoL1ZhdWx0IHN5c3RlbVxuICBwdWJsaWMgaXNEYXNoaW5nOiBib29sZWFuO1xuICBwdWJsaWMgZGFzaERpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGRhc2hTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGRhc2hEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgZGFzaERpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBkYXNoU3RhcnRQb3NpdGlvbjogVmVjdG9yMztcbiAgXG4gIC8vIE11bHRpcGxlIGRhc2ggY2hhcmdlcyBzeXN0ZW1cbiAgcHVibGljIGRhc2hDaGFyZ2VzOiBBcnJheTx7XG4gICAgaXNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgY29vbGRvd25TdGFydFRpbWU6IG51bWJlciB8IG51bGw7XG4gIH0+O1xuICBwdWJsaWMgbWF4RGFzaENoYXJnZXM6IG51bWJlcjtcblxuICAvLyBTd29yZCBDaGFyZ2UgYWJpbGl0eSBzeXN0ZW0gKHNlcGFyYXRlIGZyb20gZGFzaGVzKVxuICBwdWJsaWMgaXNDaGFyZ2luZzogYm9vbGVhbjtcbiAgcHVibGljIGNoYXJnZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGNoYXJnZVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgY2hhcmdlRHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGNoYXJnZURpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBjaGFyZ2VTdGFydFBvc2l0aW9uOiBWZWN0b3IzO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1heFNwZWVkOiBudW1iZXIgPSAzLjc1LFxuICAgIGZyaWN0aW9uOiBudW1iZXIgPSAwLjgsXG4gICAganVtcEZvcmNlOiBudW1iZXIgPSAyMC4wLFxuICAgIGdyYXZpdHk6IG51bWJlciA9IC0xMi41XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5tYXhTcGVlZCA9IG1heFNwZWVkO1xuICAgIHRoaXMuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBGb3JjZSA9IGp1bXBGb3JjZTtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICAgIFxuICAgIHRoaXMuY2FuTW92ZSA9IHRydWU7XG4gICAgdGhpcy5jYW5KdW1wID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkZseSA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgIFxuICAgIHRoaXMubW92ZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuaW5wdXRTdHJlbmd0aCA9IDA7XG5cbiAgICAvLyBJbml0aWFsaXplIGRhc2ggcHJvcGVydGllc1xuICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRhc2hEdXJhdGlvbiA9IDAuMzU7IC8vIDM1MG1zIGRhc2ggZHVyYXRpb24gKHNhbWUgYXMgb2xkIGltcGxlbWVudGF0aW9uKVxuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDsgLy8gSW5jcmVhc2VkIGZyb20gMy4xMjUgZm9yIG1vcmUgbm90aWNlYWJsZSBkYXNoXG4gICAgdGhpcy5kYXNoU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgbXVsdGlwbGUgZGFzaCBjaGFyZ2VzICgzIGNoYXJnZXMsIGVhY2ggd2l0aCA2cyBjb29sZG93bilcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIEluaXRpYWxpemUgc3dvcmQgY2hhcmdlIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTsgLy8gMzUwbXMgY2hhcmdlIGR1cmF0aW9uXG4gICAgdGhpcy5jaGFyZ2VEaXN0YW5jZSA9IDk7IC8vIFN3b3JkIGNoYXJnZSBkaXN0YW5jZVxuICAgIHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGFkZEZvcmNlKGZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24uYWRkKGZvcmNlKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRJbXB1bHNlKGltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LmFkZChpbXB1bHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBqdW1wKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbkp1bXAgJiYgKHRoaXMuaXNHcm91bmRlZCB8fCB0aGlzLmNhbkZseSkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuanVtcEZvcmNlO1xuICAgICAgdGhpcy5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldE1vdmVEaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzLCBzdHJlbmd0aDogbnVtYmVyID0gMS4wKTogdm9pZCB7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzdHJlbmd0aCkpO1xuICB9XG5cbiAgcHVibGljIGZyZWV6ZShkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSBjdXJyZW50VGltZSArIGR1cmF0aW9uO1xuICAgIC8vIGNvbnNvbGUubG9nKGDwn6eKIFBsYXllciBmcm96ZW4gZm9yICR7ZHVyYXRpb259bXMgdW50aWwgJHt0aGlzLmZyb3plblVudGlsfSAoY3VycmVudDogJHtjdXJyZW50VGltZX0pYCk7XG4gIH1cblxuICBwdWJsaWMgc2xvdyhkdXJhdGlvbjogbnVtYmVyLCBzcGVlZE11bHRpcGxpZXI6IG51bWJlciA9IDAuNSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzU2xvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbjtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gc3BlZWRNdWx0aXBsaWVyO1xuICAgIC8vIGNvbnNvbGUubG9nKGDwn5CMIFBsYXllciBzbG93ZWQgdG8gJHtzcGVlZE11bHRpcGxpZXIgKiAxMDB9JSBzcGVlZCBmb3IgJHtkdXJhdGlvbn1tcyB1bnRpbCAke3RoaXMuc2xvd2VkVW50aWx9YCk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGVidWZmcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZnJvemVuIHN0YXRlXG4gICAgaWYgKHRoaXMuaXNGcm96ZW4gJiYgY3VycmVudFRpbWUgPj0gdGhpcy5mcm96ZW5VbnRpbCkge1xuICAgICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgdGhpcy5mcm96ZW5VbnRpbCA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHNsb3dlZCBzdGF0ZVxuICAgIGlmICh0aGlzLmlzU2xvd2VkICYmIGN1cnJlbnRUaW1lID49IHRoaXMuc2xvd2VkVW50aWwpIHtcbiAgICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2xvd2VkVW50aWwgPSAwO1xuICAgICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDEuMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RWZmZWN0aXZlTWF4U3BlZWQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Zyb3plbikge1xuICAgICAgcmV0dXJuIDA7IC8vIENvbXBsZXRlbHkgZnJvemVuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1heFNwZWVkICogdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydERhc2goZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0Rhc2hpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGZpcnN0IGF2YWlsYWJsZSBjaGFyZ2VcbiAgICBjb25zdCBhdmFpbGFibGVDaGFyZ2VJbmRleCA9IHRoaXMuZGFzaENoYXJnZXMuZmluZEluZGV4KGNoYXJnZSA9PiBjaGFyZ2UuaXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVDaGFyZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gY2hhcmdlcyBhdmFpbGFibGVcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGFzaFxuICAgIHRoaXMuaXNEYXNoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY29weShjdXJyZW50UG9zaXRpb24pO1xuXG4gICAgLy8gQ29uc3VtZSB0aGUgY2hhcmdlXG4gICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5jb29sZG93blN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgLy8gU2V0IGNvb2xkb3duIHRpbWVyIGZvciB0aGlzIHNwZWNpZmljIGNoYXJnZSAoNiBzZWNvbmRzKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uY29vbGRvd25TdGFydFRpbWUgPSBudWxsO1xuICAgIH0sIDYwMDApOyAvLyA2IHNlY29uZCBjb29sZG93blxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGFzaChjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzRGFzaGluZykge1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uOiBudWxsIH07XG4gICAgfVxuXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuZGFzaER1cmF0aW9uLCAxKTtcblxuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAvLyBEYXNoIGNvbXBsZXRlXG4gICAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgZmluYWxQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuYWRkKHRoaXMuZGFzaERpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuZGFzaERpc3RhbmNlKSk7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiB0cnVlLCBuZXdQb3NpdGlvbjogZmluYWxQb3NpdGlvbiB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IHBvc2l0aW9uIHVzaW5nIGVhc2luZyAoZWFzZS1vdXQgcXVhZCwgc2FtZSBhcyBvbGQgaW1wbGVtZW50YXRpb24pXG4gICAgY29uc3QgZWFzZU91dFF1YWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAyKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmRhc2hEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmRhc2hEaXN0YW5jZSAqIGVhc2VPdXRRdWFkKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKS5hZGQoZGlzcGxhY2VtZW50KTtcblxuICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbiB9O1xuICB9XG5cbiAgcHVibGljIGNhbmNlbERhc2goKTogdm9pZCB7XG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuICB9XG5cbiAgcHVibGljIGdldFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkubGVuZ3RoKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SG9yaXpvbnRhbFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnZlbG9jaXR5LnggKiB0aGlzLnZlbG9jaXR5LnggKyB0aGlzLnZlbG9jaXR5LnogKiB0aGlzLnZlbG9jaXR5LnopO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldFNwZWVkKCkgPiAwLjAxO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nSG9yaXpvbnRhbGx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhvcml6b250YWxTcGVlZCgpID4gMC4wMTtcbiAgfVxuXG4gIHB1YmxpYyBpc0ZhbGxpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA8IC0wLjE7XG4gIH1cblxuICBwdWJsaWMgaXNSaXNpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA+IDAuMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdmFpbGFibGVEYXNoQ2hhcmdlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLmZpbHRlcihjaGFyZ2UgPT4gY2hhcmdlLmlzQXZhaWxhYmxlKS5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGFzaENoYXJnZVN0YXR1cygpOiBBcnJheTx7IGlzQXZhaWxhYmxlOiBib29sZWFuOyBjb29sZG93blJlbWFpbmluZzogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLm1hcChjaGFyZ2UgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiBjaGFyZ2UuaXNBdmFpbGFibGUsXG4gICAgICBjb29sZG93blJlbWFpbmluZzogY2hhcmdlLmNvb2xkb3duU3RhcnRUaW1lIFxuICAgICAgICA/IE1hdGgubWF4KDAsIDYgLSAoY3VycmVudFRpbWUgLSBjaGFyZ2UuY29vbGRvd25TdGFydFRpbWUpKVxuICAgICAgICA6IDBcbiAgICB9KSk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRDaGFyZ2UoZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGNoYXJnaW5nIG9yIGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0NoYXJnaW5nIHx8IHRoaXMuaXNEYXNoaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGNoYXJnZVxuICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkoY3VycmVudFBvc2l0aW9uKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUNoYXJnZShjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbjogbnVsbCB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuY2hhcmdlU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuY2hhcmdlRHVyYXRpb24sIDEpO1xuXG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgIC8vIENoYXJnZSBjb21wbGV0ZVxuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBmaW5hbFBvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgLmFkZCh0aGlzLmNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuY2hhcmdlRGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IHRydWUsIG5ld1Bvc2l0aW9uOiBmaW5hbFBvc2l0aW9uIH07XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb24gdXNpbmcgZWFzaW5nIChlYXNlLW91dCBxdWFkKVxuICAgIGNvbnN0IGVhc2VPdXRRdWFkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMik7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmNoYXJnZURpc3RhbmNlICogZWFzZU91dFF1YWQpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKCkuYWRkKGRpc3BsYWNlbWVudCk7XG5cbiAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb24gfTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxDaGFyZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbGFtcFZlbG9jaXR5KCk6IHZvaWQge1xuICAgIC8vIEdldCBlZmZlY3RpdmUgbWF4IHNwZWVkIChjb25zaWRlcmluZyBkZWJ1ZmZzKVxuICAgIGNvbnN0IGVmZmVjdGl2ZU1heFNwZWVkID0gdGhpcy5nZXRFZmZlY3RpdmVNYXhTcGVlZCgpO1xuICAgIFxuICAgIC8vIENsYW1wIGhvcml6b250YWwgdmVsb2NpdHkgdG8gZWZmZWN0aXZlIG1heCBzcGVlZFxuICAgIGNvbnN0IGhvcml6b250YWxWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKHRoaXMudmVsb2NpdHkueCwgMCwgdGhpcy52ZWxvY2l0eS56KTtcbiAgICBjb25zdCBob3Jpem9udGFsU3BlZWQgPSBob3Jpem9udGFsVmVsb2NpdHkubGVuZ3RoKCk7XG4gICAgXG4gICAgaWYgKGhvcml6b250YWxTcGVlZCA+IGVmZmVjdGl2ZU1heFNwZWVkKSB7XG4gICAgICBpZiAoZWZmZWN0aXZlTWF4U3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBmcm96ZW4gLSBzdG9wIGFsbCBob3Jpem9udGFsIG1vdmVtZW50XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3Jpem9udGFsVmVsb2NpdHkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZWZmZWN0aXZlTWF4U3BlZWQpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSBob3Jpem9udGFsVmVsb2NpdHkueDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS56ID0gaG9yaXpvbnRhbFZlbG9jaXR5Lno7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFwcGx5RnJpY3Rpb24oZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuTW92ZSkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgZnJpY3Rpb24gdG8gaG9yaXpvbnRhbCBtb3ZlbWVudFxuICAgIGNvbnN0IGZyaWN0aW9uRm9yY2UgPSBNYXRoLnBvdyh0aGlzLmZyaWN0aW9uLCBkZWx0YVRpbWUpO1xuICAgIHRoaXMudmVsb2NpdHkueCAqPSBmcmljdGlvbkZvcmNlO1xuICAgIHRoaXMudmVsb2NpdHkueiAqPSBmcmljdGlvbkZvcmNlO1xuXG4gICAgLy8gU3RvcCB2ZXJ5IHNtYWxsIHZlbG9jaXRpZXMgdG8gcHJldmVudCBqaXR0ZXJcbiAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eS54KSA8IDAuMDEpIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueikgPCAwLjAxKSB0aGlzLnZlbG9jaXR5LnogPSAwO1xuICB9XG5cbiAgcHVibGljIGFwcGx5R3Jhdml0eShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jYW5GbHkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSArPSB0aGlzLmdyYXZpdHkgKiBkZWx0YVRpbWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIC8vIEVuc3VyZSBWZWN0b3IzIG9iamVjdHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgaWYgKCF0aGlzLnZlbG9jaXR5KSB7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXRoaXMuYWNjZWxlcmF0aW9uKSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tb3ZlRGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gMDtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbk1vdmUgPSB0cnVlO1xuICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgdGhpcy5jYW5GbHkgPSBmYWxzZTtcbiAgICB0aGlzLm1heFNwZWVkID0gNS4wO1xuICAgIHRoaXMuZnJpY3Rpb24gPSAwLjg7XG4gICAgdGhpcy5qdW1wRm9yY2UgPSAyMC4wO1xuICAgIHRoaXMuZ3Jhdml0eSA9IC0xMi41O1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvLyBSZXNldCBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuXG4gICAgLy8gUmVzZXQgZGFzaCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kYXNoRHVyYXRpb24gPSAwLjM1O1xuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDtcbiAgICB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBSZXNldCBkYXNoIGNoYXJnZXNcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIFJlc2V0IGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTtcbiAgICB0aGlzLmNoYXJnZURpc3RhbmNlID0gOTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IE1vdmVtZW50IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBNb3ZlbWVudCh0aGlzLm1heFNwZWVkLCB0aGlzLmZyaWN0aW9uLCB0aGlzLmp1bXBGb3JjZSwgdGhpcy5ncmF2aXR5KTtcbiAgICBjbG9uZS52ZWxvY2l0eS5jb3B5KHRoaXMudmVsb2NpdHkpO1xuICAgIGNsb25lLmFjY2VsZXJhdGlvbi5jb3B5KHRoaXMuYWNjZWxlcmF0aW9uKTtcbiAgICBjbG9uZS5tb3ZlRGlyZWN0aW9uLmNvcHkodGhpcy5tb3ZlRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5pbnB1dFN0cmVuZ3RoID0gdGhpcy5pbnB1dFN0cmVuZ3RoO1xuICAgIGNsb25lLmlzR3JvdW5kZWQgPSB0aGlzLmlzR3JvdW5kZWQ7XG4gICAgY2xvbmUuY2FuTW92ZSA9IHRoaXMuY2FuTW92ZTtcbiAgICBjbG9uZS5jYW5KdW1wID0gdGhpcy5jYW5KdW1wO1xuICAgIGNsb25lLmNhbkZseSA9IHRoaXMuY2FuRmx5O1xuXG4gICAgLy8gQ2xvbmUgZGVidWZmIHN0YXRlc1xuICAgIGNsb25lLmlzRnJvemVuID0gdGhpcy5pc0Zyb3plbjtcbiAgICBjbG9uZS5mcm96ZW5VbnRpbCA9IHRoaXMuZnJvemVuVW50aWw7XG4gICAgY2xvbmUuaXNTbG93ZWQgPSB0aGlzLmlzU2xvd2VkO1xuICAgIGNsb25lLnNsb3dlZFVudGlsID0gdGhpcy5zbG93ZWRVbnRpbDtcbiAgICBjbG9uZS5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXI7XG5cbiAgICAvLyBDbG9uZSBkYXNoIHByb3BlcnRpZXNcbiAgICBjbG9uZS5pc0Rhc2hpbmcgPSB0aGlzLmlzRGFzaGluZztcbiAgICBjbG9uZS5kYXNoRGlyZWN0aW9uLmNvcHkodGhpcy5kYXNoRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5kYXNoU3RhcnRUaW1lID0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNsb25lLmRhc2hEdXJhdGlvbiA9IHRoaXMuZGFzaER1cmF0aW9uO1xuICAgIGNsb25lLmRhc2hEaXN0YW5jZSA9IHRoaXMuZGFzaERpc3RhbmNlO1xuICAgIGNsb25lLmRhc2hTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5kYXNoU3RhcnRQb3NpdGlvbik7XG4gICAgXG4gICAgLy8gQ2xvbmUgZGFzaCBjaGFyZ2VzXG4gICAgY2xvbmUubWF4RGFzaENoYXJnZXMgPSB0aGlzLm1heERhc2hDaGFyZ2VzO1xuICAgIGNsb25lLmRhc2hDaGFyZ2VzID0gdGhpcy5kYXNoQ2hhcmdlcy5tYXAoY2hhcmdlID0+ICh7XG4gICAgICBpc0F2YWlsYWJsZTogY2hhcmdlLmlzQXZhaWxhYmxlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IGNoYXJnZS5jb29sZG93blN0YXJ0VGltZVxuICAgIH0pKTtcblxuICAgIC8vIENsb25lIGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgY2xvbmUuaXNDaGFyZ2luZyA9IHRoaXMuaXNDaGFyZ2luZztcbiAgICBjbG9uZS5jaGFyZ2VEaXJlY3Rpb24uY29weSh0aGlzLmNoYXJnZURpcmVjdGlvbik7XG4gICAgY2xvbmUuY2hhcmdlU3RhcnRUaW1lID0gdGhpcy5jaGFyZ2VTdGFydFRpbWU7XG4gICAgY2xvbmUuY2hhcmdlRHVyYXRpb24gPSB0aGlzLmNoYXJnZUR1cmF0aW9uO1xuICAgIGNsb25lLmNoYXJnZURpc3RhbmNlID0gdGhpcy5jaGFyZ2VEaXN0YW5jZTtcbiAgICBjbG9uZS5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb21wb25lbnQiLCJNb3ZlbWVudCIsImFkZEZvcmNlIiwiZm9yY2UiLCJhY2NlbGVyYXRpb24iLCJhZGQiLCJhZGRJbXB1bHNlIiwiaW1wdWxzZSIsInZlbG9jaXR5IiwianVtcCIsImNhbkp1bXAiLCJpc0dyb3VuZGVkIiwiY2FuRmx5IiwieSIsImp1bXBGb3JjZSIsInNldE1vdmVEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJzdHJlbmd0aCIsIm1vdmVEaXJlY3Rpb24iLCJjb3B5Iiwibm9ybWFsaXplIiwiaW5wdXRTdHJlbmd0aCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmcmVlemUiLCJkdXJhdGlvbiIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImlzRnJvemVuIiwiZnJvemVuVW50aWwiLCJzbG93Iiwic3BlZWRNdWx0aXBsaWVyIiwiaXNTbG93ZWQiLCJzbG93ZWRVbnRpbCIsIm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyIiwidXBkYXRlRGVidWZmcyIsImdldEVmZmVjdGl2ZU1heFNwZWVkIiwibWF4U3BlZWQiLCJzdGFydERhc2giLCJjdXJyZW50UG9zaXRpb24iLCJpc0Rhc2hpbmciLCJhdmFpbGFibGVDaGFyZ2VJbmRleCIsImRhc2hDaGFyZ2VzIiwiZmluZEluZGV4IiwiY2hhcmdlIiwiaXNBdmFpbGFibGUiLCJkYXNoRGlyZWN0aW9uIiwiZGFzaFN0YXJ0VGltZSIsImRhc2hTdGFydFBvc2l0aW9uIiwiY29vbGRvd25TdGFydFRpbWUiLCJzZXRUaW1lb3V0IiwidXBkYXRlRGFzaCIsImlzQ29tcGxldGUiLCJuZXdQb3NpdGlvbiIsImVsYXBzZWQiLCJwcm9ncmVzcyIsImRhc2hEdXJhdGlvbiIsImZpbmFsUG9zaXRpb24iLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwiZGFzaERpc3RhbmNlIiwiZWFzZU91dFF1YWQiLCJwb3ciLCJkaXNwbGFjZW1lbnQiLCJjYW5jZWxEYXNoIiwic2V0Iiwic3RvcCIsImdldFNwZWVkIiwibGVuZ3RoIiwiZ2V0SG9yaXpvbnRhbFNwZWVkIiwic3FydCIsIngiLCJ6IiwiaXNNb3ZpbmciLCJpc01vdmluZ0hvcml6b250YWxseSIsImlzRmFsbGluZyIsImlzUmlzaW5nIiwiZ2V0QXZhaWxhYmxlRGFzaENoYXJnZXMiLCJmaWx0ZXIiLCJnZXREYXNoQ2hhcmdlU3RhdHVzIiwibWFwIiwiY29vbGRvd25SZW1haW5pbmciLCJzdGFydENoYXJnZSIsImlzQ2hhcmdpbmciLCJjaGFyZ2VEaXJlY3Rpb24iLCJjaGFyZ2VTdGFydFRpbWUiLCJjaGFyZ2VTdGFydFBvc2l0aW9uIiwidXBkYXRlQ2hhcmdlIiwiY2hhcmdlRHVyYXRpb24iLCJjaGFyZ2VEaXN0YW5jZSIsImNhbmNlbENoYXJnZSIsImNsYW1wVmVsb2NpdHkiLCJlZmZlY3RpdmVNYXhTcGVlZCIsImhvcml6b250YWxWZWxvY2l0eSIsImhvcml6b250YWxTcGVlZCIsImFwcGx5RnJpY3Rpb24iLCJkZWx0YVRpbWUiLCJjYW5Nb3ZlIiwiZnJpY3Rpb25Gb3JjZSIsImZyaWN0aW9uIiwiYWJzIiwiYXBwbHlHcmF2aXR5IiwiZ3Jhdml0eSIsInJlc2V0IiwiZW5hYmxlZCIsIm1heERhc2hDaGFyZ2VzIiwiQXJyYXkiLCJmcm9tIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Movement.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Projectile.ts":
/*!******************************************!*\
  !*** ./src/ecs/components/Projectile.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: function() { return /* binding */ Projectile; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Projectile component for bullets, spells, and other projectiles\n\n\nclass Projectile extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setDirection(direction) {\n        this.velocity.copy(direction).normalize().multiplyScalar(this.speed);\n    }\n    addGravity(gravity) {\n        this.gravity = gravity;\n    }\n    setPiercing(piercing) {\n        this.piercing = piercing;\n    }\n    setExplosive(radius) {\n        this.explosionRadius = radius;\n    }\n    setBouncing(maxBounces) {\n        this.maxBounces = maxBounces;\n    }\n    setMaxDistance(maxDistance) {\n        this.maxDistance = maxDistance;\n    }\n    setStartPosition(position) {\n        this.startPosition.copy(position);\n    }\n    setHoming(targetEntityId) {\n        let homingStrength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.8, maxTurnRate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Math.PI;\n        this.targetEntityId = targetEntityId;\n        this.homingStrength = Math.max(0, Math.min(1, homingStrength)); // Clamp between 0 and 1\n        this.maxTurnRate = maxTurnRate;\n    }\n    disableHoming() {\n        this.targetEntityId = null;\n        this.homingStrength = 0;\n    }\n    hasHitTarget(entityId) {\n        return this.hitTargets.has(entityId);\n    }\n    addHitTarget(entityId) {\n        this.hitTargets.add(entityId);\n    }\n    canHitTarget(entityId) {\n        // Can't hit owner\n        if (entityId === this.owner) return false;\n        // If piercing, can hit targets multiple times\n        if (this.piercing) return true;\n        // Otherwise, can only hit each target once\n        return !this.hasHitTarget(entityId);\n    }\n    isExpired() {\n        return this.lifetime >= this.maxLifetime || this.distanceTraveled >= this.maxDistance;\n    }\n    canBounce() {\n        return this.bounces < this.maxBounces;\n    }\n    bounce(normal) {\n        if (!this.canBounce()) return;\n        // Reflect velocity off the surface normal\n        const reflection = this.velocity.clone().reflect(normal);\n        this.velocity.copy(reflection);\n        this.bounces++;\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        // Track distance traveled\n        const distanceThisFrame = this.velocity.length() * deltaTime;\n        this.distanceTraveled += distanceThisFrame;\n        // Apply gravity if enabled\n        if (this.gravity !== 0) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    getPosition(transform) {\n        return transform.clone();\n    }\n    getPredictedPosition(transform, deltaTime) {\n        const predicted = transform.clone();\n        predicted.add(this.velocity.clone().multiplyScalar(deltaTime));\n        return predicted;\n    }\n    reset() {\n        this.velocity.set(0, 0, 0);\n        this.speed = 20;\n        this.damage = 10;\n        this.lifetime = 0;\n        this.maxLifetime = 5;\n        this.piercing = false;\n        this.hitTargets.clear();\n        this.explosionRadius = 0;\n        this.gravity = 0;\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = -1;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity;\n        this.startPosition.set(0, 0, 0);\n        this.targetEntityId = null;\n        this.homingStrength = 0;\n        this.maxTurnRate = Math.PI;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Projectile(this.speed, this.damage, this.maxLifetime, this.owner);\n        clone.velocity.copy(this.velocity);\n        clone.lifetime = this.lifetime;\n        clone.piercing = this.piercing;\n        clone.hitTargets = new Set(this.hitTargets);\n        clone.explosionRadius = this.explosionRadius;\n        clone.gravity = this.gravity;\n        clone.bounces = this.bounces;\n        clone.maxBounces = this.maxBounces;\n        clone.distanceTraveled = this.distanceTraveled;\n        clone.maxDistance = this.maxDistance;\n        clone.startPosition.copy(this.startPosition);\n        clone.targetEntityId = this.targetEntityId;\n        clone.homingStrength = this.homingStrength;\n        clone.maxTurnRate = this.maxTurnRate;\n        return clone;\n    }\n    constructor(speed = 20, damage = 10, maxLifetime = 5, owner = -1){\n        super();\n        this.componentType = \"Projectile\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.speed = speed;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = maxLifetime;\n        this.piercing = false;\n        this.hitTargets = new Set();\n        this.explosionRadius = 0;\n        this.gravity = 0; // Most projectiles ignore gravity\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = owner;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity; // Default to no distance limit\n        this.startPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize homing properties\n        this.targetEntityId = null;\n        this.homingStrength = 0; // Default to no homing\n        this.maxTurnRate = Math.PI; // Default to 180 degrees per second turn rate\n    }\n}\nProjectile.componentType = \"Projectile\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRS9CLE1BQU1FLG1CQUFtQkQsOENBQVNBO0lBc0RoQ0UsYUFBYUMsU0FBa0IsRUFBUTtRQUM1QyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixXQUFXRyxTQUFTLEdBQUdDLGNBQWMsQ0FBQyxJQUFJLENBQUNDLEtBQUs7SUFDckU7SUFFT0MsV0FBV0MsT0FBZSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVPQyxZQUFZQyxRQUFpQixFQUFRO1FBQzFDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNsQjtJQUVPQyxhQUFhQyxNQUFjLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO0lBQ3pCO0lBRU9FLFlBQVlDLFVBQWtCLEVBQVE7UUFDM0MsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBRU9DLGVBQWVDLFdBQW1CLEVBQVE7UUFDL0MsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3JCO0lBRU9DLGlCQUFpQkMsUUFBaUIsRUFBUTtRQUMvQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ2pCLElBQUksQ0FBQ2dCO0lBQzFCO0lBRU9FLFVBQVVDLGNBQXNCLEVBQXFFO1lBQW5FQyxpQkFBQUEsaUVBQXlCLEtBQUtDLGNBQUFBLGlFQUFzQkMsS0FBS0MsRUFBRTtRQUNsRyxJQUFJLENBQUNKLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxjQUFjLEdBQUdFLEtBQUtFLEdBQUcsQ0FBQyxHQUFHRixLQUFLRyxHQUFHLENBQUMsR0FBR0wsa0JBQWtCLHdCQUF3QjtRQUN4RixJQUFJLENBQUNDLFdBQVcsR0FBR0E7SUFDckI7SUFFT0ssZ0JBQXNCO1FBQzNCLElBQUksQ0FBQ1AsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxH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QUksQ0FBQ2hFLFFBQVEsR0FBRyxJQUFJTCx5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDbEMsSUFBSSxDQUFDUyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDc0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3JCLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDOUIsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ3NCLFVBQVUsR0FBRyxJQUFJZ0M7UUFDdEIsSUFBSSxDQUFDbkQsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0wsT0FBTyxHQUFHLEdBQUcsa0NBQWtDO1FBQ3BELElBQUksQ0FBQ21DLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQzVCLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNzQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDSSxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUN4QixXQUFXLEdBQUc2QyxVQUFVLCtCQUErQjtRQUM1RCxJQUFJLENBQUMxQyxhQUFhLEdBQUcsSUFBSXZCLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztRQUV2QywrQkFBK0I7UUFDL0IsSUFBSSxDQUFDeUIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEdBQUcsdUJBQXVCO1FBQ2hELElBQUksQ0FBQ0MsV0FBVyxHQUFHQyxLQUFLQyxFQUFFLEVBQUUsOENBQThDO0lBQzVFO0FBNElGO0FBaE1hM0IsV0FDWW1FLGdCQUFnQixhQUFjLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZS50cz83MDYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2plY3RpbGUgY29tcG9uZW50IGZvciBidWxsZXRzLCBzcGVsbHMsIGFuZCBvdGhlciBwcm9qZWN0aWxlc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgUHJvamVjdGlsZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdQcm9qZWN0aWxlJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Byb2plY3RpbGUnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB2ZWxvY2l0eTogVmVjdG9yMztcbiAgcHVibGljIHNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyBkYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGxpZmV0aW1lOiBudW1iZXI7XG4gIHB1YmxpYyBtYXhMaWZldGltZTogbnVtYmVyO1xuICBwdWJsaWMgcGllcmNpbmc6IGJvb2xlYW47XG4gIHB1YmxpYyBoaXRUYXJnZXRzOiBTZXQ8bnVtYmVyPjsgLy8gRW50aXR5IElEcyB0aGF0IGhhdmUgYmVlbiBoaXRcbiAgcHVibGljIGV4cGxvc2lvblJhZGl1czogbnVtYmVyO1xuICBwdWJsaWMgZ3Jhdml0eTogbnVtYmVyO1xuICBwdWJsaWMgYm91bmNlczogbnVtYmVyO1xuICBwdWJsaWMgbWF4Qm91bmNlczogbnVtYmVyO1xuICBwdWJsaWMgb3duZXI6IG51bWJlcjsgLy8gRW50aXR5IElEIG9mIHRoZSBvd25lclxuICBwdWJsaWMgZGlzdGFuY2VUcmF2ZWxlZDogbnVtYmVyOyAvLyBUcmFjayBkaXN0YW5jZSB0cmF2ZWxlZFxuICBwdWJsaWMgbWF4RGlzdGFuY2U6IG51bWJlcjsgLy8gTWF4aW11bSBkaXN0YW5jZSBiZWZvcmUgZXhwaXJpbmdcbiAgcHVibGljIHN0YXJ0UG9zaXRpb246IFZlY3RvcjM7IC8vIFN0YXJ0aW5nIHBvc2l0aW9uIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gIC8vIEhvbWluZyBwcm9wZXJ0aWVzXG4gIHB1YmxpYyB0YXJnZXRFbnRpdHlJZDogbnVtYmVyIHwgbnVsbDsgLy8gRW50aXR5IElEIHRvIGhvbWUgdG93YXJkc1xuICBwdWJsaWMgaG9taW5nU3RyZW5ndGg6IG51bWJlcjsgLy8gSG93IHN0cm9uZ2x5IGl0IGhvbWVzICgwLTEpXG4gIHB1YmxpYyBtYXhUdXJuUmF0ZTogbnVtYmVyOyAvLyBNYXhpbXVtIHJhZGlhbnMgcGVyIHNlY29uZCB0aGUgcHJvamVjdGlsZSBjYW4gdHVyblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNwZWVkOiBudW1iZXIgPSAyMCxcbiAgICBkYW1hZ2U6IG51bWJlciA9IDEwLFxuICAgIG1heExpZmV0aW1lOiBudW1iZXIgPSA1LFxuICAgIG93bmVyOiBudW1iZXIgPSAtMVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgdGhpcy5kYW1hZ2UgPSBkYW1hZ2U7XG4gICAgdGhpcy5saWZldGltZSA9IDA7XG4gICAgdGhpcy5tYXhMaWZldGltZSA9IG1heExpZmV0aW1lO1xuICAgIHRoaXMucGllcmNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmhpdFRhcmdldHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5leHBsb3Npb25SYWRpdXMgPSAwO1xuICAgIHRoaXMuZ3Jhdml0eSA9IDA7IC8vIE1vc3QgcHJvamVjdGlsZXMgaWdub3JlIGdyYXZpdHlcbiAgICB0aGlzLmJvdW5jZXMgPSAwO1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IDA7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5OyAvLyBEZWZhdWx0IHRvIG5vIGRpc3RhbmNlIGxpbWl0XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGhvbWluZyBwcm9wZXJ0aWVzXG4gICAgdGhpcy50YXJnZXRFbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5ob21pbmdTdHJlbmd0aCA9IDA7IC8vIERlZmF1bHQgdG8gbm8gaG9taW5nXG4gICAgdGhpcy5tYXhUdXJuUmF0ZSA9IE1hdGguUEk7IC8vIERlZmF1bHQgdG8gMTgwIGRlZ3JlZXMgcGVyIHNlY29uZCB0dXJuIHJhdGVcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zcGVlZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkR3Jhdml0eShncmF2aXR5OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICB9XG5cbiAgcHVibGljIHNldFBpZXJjaW5nKHBpZXJjaW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5waWVyY2luZyA9IHBpZXJjaW5nO1xuICB9XG5cbiAgcHVibGljIHNldEV4cGxvc2l2ZShyYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gcmFkaXVzO1xuICB9XG5cbiAgcHVibGljIHNldEJvdW5jaW5nKG1heEJvdW5jZXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IG1heEJvdW5jZXM7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF4RGlzdGFuY2UobWF4RGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTdGFydFBvc2l0aW9uKHBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICB9XG5cbiAgcHVibGljIHNldEhvbWluZyh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBob21pbmdTdHJlbmd0aDogbnVtYmVyID0gMC44LCBtYXhUdXJuUmF0ZTogbnVtYmVyID0gTWF0aC5QSSk6IHZvaWQge1xuICAgIHRoaXMudGFyZ2V0RW50aXR5SWQgPSB0YXJnZXRFbnRpdHlJZDtcbiAgICB0aGlzLmhvbWluZ1N0cmVuZ3RoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaG9taW5nU3RyZW5ndGgpKTsgLy8gQ2xhbXAgYmV0d2VlbiAwIGFuZCAxXG4gICAgdGhpcy5tYXhUdXJuUmF0ZSA9IG1heFR1cm5SYXRlO1xuICB9XG5cbiAgcHVibGljIGRpc2FibGVIb21pbmcoKTogdm9pZCB7XG4gICAgdGhpcy50YXJnZXRFbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5ob21pbmdTdHJlbmd0aCA9IDA7XG4gIH1cblxuICBwdWJsaWMgaGFzSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUYXJnZXRzLmhhcyhlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhpdFRhcmdldHMuYWRkKGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5IaXRUYXJnZXQoZW50aXR5SWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIENhbid0IGhpdCBvd25lclxuICAgIGlmIChlbnRpdHlJZCA9PT0gdGhpcy5vd25lcikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIElmIHBpZXJjaW5nLCBjYW4gaGl0IHRhcmdldHMgbXVsdGlwbGUgdGltZXNcbiAgICBpZiAodGhpcy5waWVyY2luZykgcmV0dXJuIHRydWU7XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlLCBjYW4gb25seSBoaXQgZWFjaCB0YXJnZXQgb25jZVxuICAgIHJldHVybiAhdGhpcy5oYXNIaXRUYXJnZXQoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGlzRXhwaXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5saWZldGltZSA+PSB0aGlzLm1heExpZmV0aW1lIHx8IHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCA+PSB0aGlzLm1heERpc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIGNhbkJvdW5jZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuY2VzIDwgdGhpcy5tYXhCb3VuY2VzO1xuICB9XG5cbiAgcHVibGljIGJvdW5jZShub3JtYWw6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuQm91bmNlKCkpIHJldHVybjtcbiAgICBcbiAgICAvLyBSZWZsZWN0IHZlbG9jaXR5IG9mZiB0aGUgc3VyZmFjZSBub3JtYWxcbiAgICBjb25zdCByZWZsZWN0aW9uID0gdGhpcy52ZWxvY2l0eS5jbG9uZSgpLnJlZmxlY3Qobm9ybWFsKTtcbiAgICB0aGlzLnZlbG9jaXR5LmNvcHkocmVmbGVjdGlvbik7XG4gICAgdGhpcy5ib3VuY2VzKys7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5saWZldGltZSArPSBkZWx0YVRpbWU7XG4gICAgXG4gICAgLy8gVHJhY2sgZGlzdGFuY2UgdHJhdmVsZWRcbiAgICBjb25zdCBkaXN0YW5jZVRoaXNGcmFtZSA9IHRoaXMudmVsb2NpdHkubGVuZ3RoKCkgKiBkZWx0YVRpbWU7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGVkICs9IGRpc3RhbmNlVGhpc0ZyYW1lO1xuICAgIFxuICAgIC8vIEFwcGx5IGdyYXZpdHkgaWYgZW5hYmxlZFxuICAgIGlmICh0aGlzLmdyYXZpdHkgIT09IDApIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSArPSB0aGlzLmdyYXZpdHkgKiBkZWx0YVRpbWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFBvc2l0aW9uKHRyYW5zZm9ybTogVmVjdG9yMyk6IFZlY3RvcjMge1xuICAgIHJldHVybiB0cmFuc2Zvcm0uY2xvbmUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQcmVkaWN0ZWRQb3NpdGlvbih0cmFuc2Zvcm06IFZlY3RvcjMsIGRlbHRhVGltZTogbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgY29uc3QgcHJlZGljdGVkID0gdHJhbnNmb3JtLmNsb25lKCk7XG4gICAgcHJlZGljdGVkLmFkZCh0aGlzLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lKSk7XG4gICAgcmV0dXJuIHByZWRpY3RlZDtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLnNwZWVkID0gMjA7XG4gICAgdGhpcy5kYW1hZ2UgPSAxMDtcbiAgICB0aGlzLmxpZmV0aW1lID0gMDtcbiAgICB0aGlzLm1heExpZmV0aW1lID0gNTtcbiAgICB0aGlzLnBpZXJjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5oaXRUYXJnZXRzLmNsZWFyKCk7XG4gICAgdGhpcy5leHBsb3Npb25SYWRpdXMgPSAwO1xuICAgIHRoaXMuZ3Jhdml0eSA9IDA7XG4gICAgdGhpcy5ib3VuY2VzID0gMDtcbiAgICB0aGlzLm1heEJvdW5jZXMgPSAwO1xuICAgIHRoaXMub3duZXIgPSAtMTtcbiAgICB0aGlzLmRpc3RhbmNlVHJhdmVsZWQgPSAwO1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMudGFyZ2V0RW50aXR5SWQgPSBudWxsO1xuICAgIHRoaXMuaG9taW5nU3RyZW5ndGggPSAwO1xuICAgIHRoaXMubWF4VHVyblJhdGUgPSBNYXRoLlBJO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogUHJvamVjdGlsZSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUHJvamVjdGlsZSh0aGlzLnNwZWVkLCB0aGlzLmRhbWFnZSwgdGhpcy5tYXhMaWZldGltZSwgdGhpcy5vd25lcik7XG4gICAgY2xvbmUudmVsb2NpdHkuY29weSh0aGlzLnZlbG9jaXR5KTtcbiAgICBjbG9uZS5saWZldGltZSA9IHRoaXMubGlmZXRpbWU7XG4gICAgY2xvbmUucGllcmNpbmcgPSB0aGlzLnBpZXJjaW5nO1xuICAgIGNsb25lLmhpdFRhcmdldHMgPSBuZXcgU2V0KHRoaXMuaGl0VGFyZ2V0cyk7XG4gICAgY2xvbmUuZXhwbG9zaW9uUmFkaXVzID0gdGhpcy5leHBsb3Npb25SYWRpdXM7XG4gICAgY2xvbmUuZ3Jhdml0eSA9IHRoaXMuZ3Jhdml0eTtcbiAgICBjbG9uZS5ib3VuY2VzID0gdGhpcy5ib3VuY2VzO1xuICAgIGNsb25lLm1heEJvdW5jZXMgPSB0aGlzLm1heEJvdW5jZXM7XG4gICAgY2xvbmUuZGlzdGFuY2VUcmF2ZWxlZCA9IHRoaXMuZGlzdGFuY2VUcmF2ZWxlZDtcbiAgICBjbG9uZS5tYXhEaXN0YW5jZSA9IHRoaXMubWF4RGlzdGFuY2U7XG4gICAgY2xvbmUuc3RhcnRQb3NpdGlvbi5jb3B5KHRoaXMuc3RhcnRQb3NpdGlvbik7XG4gICAgY2xvbmUudGFyZ2V0RW50aXR5SWQgPSB0aGlzLnRhcmdldEVudGl0eUlkO1xuICAgIGNsb25lLmhvbWluZ1N0cmVuZ3RoID0gdGhpcy5ob21pbmdTdHJlbmd0aDtcbiAgICBjbG9uZS5tYXhUdXJuUmF0ZSA9IHRoaXMubWF4VHVyblJhdGU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbXBvbmVudCIsIlByb2plY3RpbGUiLCJzZXREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJ2ZWxvY2l0eSIsImNvcHkiLCJub3JtYWxpemUiLCJtdWx0aXBseVNjYWxhciIsInNwZWVkIiwiYWRkR3Jhdml0eSIsImdyYXZpdHkiLCJzZXRQaWVyY2luZyIsInBpZXJjaW5nIiwic2V0RXhwbG9zaXZlIiwicmFkaXVzIiwiZXhwbG9zaW9uUmFkaXVzIiwic2V0Qm91bmNpbmciLCJtYXhCb3VuY2VzIiwic2V0TWF4RGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsInNldFN0YXJ0UG9zaXRpb24iLCJwb3NpdGlvbiIsInN0YXJ0UG9zaXRpb24iLCJzZXRIb21pbmciLCJ0YXJnZXRFbnRpdHlJZCIsImhvbWluZ1N0cmVuZ3RoIiwibWF4VHVyblJhdGUiLCJNYXRoIiwiUEkiLCJtYXgiLCJtaW4iLCJkaXNhYmxlSG9taW5nIiwiaGFzSGl0VGFyZ2V0IiwiZW50aXR5SWQiLCJoaXRUYXJnZXRzIiwiaGFzIiwiYWRkSGl0VGFyZ2V0IiwiYWRkIiwiY2FuSGl0VGFyZ2V0Iiwib3duZXIiLCJpc0V4cGlyZWQiLCJsaWZldGltZSIsIm1heExpZmV0aW1lIiwiZGlzdGFuY2VUcmF2ZWxlZCIsImNhbkJvdW5jZSIsImJvdW5jZXMiLCJib3VuY2UiLCJub3JtYWwiLCJyZWZsZWN0aW9uIiwiY2xvbmUiLCJyZWZsZWN0IiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiZGlzdGFuY2VUaGlzRnJhbWUiLCJsZW5ndGgiLCJ5IiwiZ2V0UG9zaXRpb24iLCJ0cmFuc2Zvcm0iLCJnZXRQcmVkaWN0ZWRQb3NpdGlvbiIsInByZWRpY3RlZCIsInJlc2V0Iiwic2V0IiwiZGFtYWdlIiwiY2xlYXIiLCJJbmZpbml0eSIsImVuYWJsZWQiLCJTZXQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Projectile.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Renderer.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Renderer.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Renderer component for 3D rendering data\n\n\nclass Renderer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setGeometry(geometry) {\n        if (this.geometry && this.geometry !== geometry) {\n            this.geometry.dispose();\n        }\n        this.geometry = geometry;\n        this.needsUpdate = true;\n    }\n    setMaterial(material) {\n        if (this.material && this.material !== material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n        }\n        this.material = material;\n        this.needsUpdate = true;\n    }\n    createMesh() {\n        if (!this.geometry || !this.material) {\n            return null;\n        }\n        if (this.mesh) {\n            this.disposeMesh();\n        }\n        this.mesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, this.material);\n        this.mesh.castShadow = this.castShadow;\n        this.mesh.receiveShadow = this.receiveShadow;\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        this.needsUpdate = false;\n        return this.mesh;\n    }\n    updateMesh() {\n        if (!this.mesh) return;\n        // Handle shadow properties for both Mesh and Group\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = this.castShadow;\n            this.mesh.receiveShadow = this.receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            // Apply shadow properties to all meshes in the group\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = this.castShadow;\n                    child.receiveShadow = this.receiveShadow;\n                }\n            });\n        }\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        if (this.needsUpdate && this.geometry && this.material && this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.geometry = this.geometry;\n            this.mesh.material = this.material;\n            this.needsUpdate = false;\n        }\n    }\n    setVisible(visible) {\n        this.visible = visible;\n        if (this.mesh) {\n            this.mesh.visible = visible;\n        }\n    }\n    setCastShadow(castShadow) {\n        this.castShadow = castShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = castShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = castShadow;\n                }\n            });\n        }\n    }\n    setReceiveShadow(receiveShadow) {\n        this.receiveShadow = receiveShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.receiveShadow = receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.receiveShadow = receiveShadow;\n                }\n            });\n        }\n    }\n    // Animation methods\n    setupAnimations(animations) {\n        if (!this.mesh) return;\n        this.animations = animations;\n        if (animations.length > 0) {\n            this.animationMixer = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(this.mesh);\n        }\n    }\n    playAnimation(name) {\n        let loop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, fadeTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n        if (!this.animationMixer) return null;\n        const clip = this.animations.find((clip)=>clip.name === name);\n        if (!clip) return null;\n        // Stop current animation\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n        }\n        // Start new animation\n        const action = this.animationMixer.clipAction(clip);\n        action.setLoop(loop ? _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat : _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopOnce, loop ? Infinity : 1);\n        action.fadeIn(fadeTime);\n        action.play();\n        this.currentAnimation = action;\n        return action;\n    }\n    stopAnimation() {\n        let fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n            this.currentAnimation = null;\n        }\n    }\n    updateAnimations(deltaTime) {\n        if (this.animationMixer) {\n            this.animationMixer.update(deltaTime);\n        }\n    }\n    // Instancing methods\n    setupInstancing(instancedMesh, instanceId) {\n        this.isInstanced = true;\n        this.instancedMesh = instancedMesh;\n        this.instanceId = instanceId;\n    }\n    updateInstanceMatrix(matrix) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    setInstanceVisible(visible) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            // For instanced meshes, we can hide instances by scaling them to 0\n            const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            this.instancedMesh.getMatrixAt(this.instanceId, matrix);\n            if (!visible) {\n                matrix.scale(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\n            }\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    disposeMesh() {\n        if (this.mesh) {\n            if (this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            this.mesh = null;\n        }\n    }\n    dispose() {\n        this.disposeMesh();\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n            this.material = null;\n        }\n        if (this.animationMixer) {\n            this.animationMixer.stopAllAction();\n            this.animationMixer = null;\n        }\n        this.animations = [];\n        this.currentAnimation = null;\n        this.instancedMesh = null;\n    }\n    reset() {\n        this.dispose();\n        this.castShadow = true;\n        this.receiveShadow = true;\n        this.frustumCulled = true;\n        this.visible = true;\n        this.renderOrder = 0;\n        this.needsUpdate = true;\n        this.isInstanced = false;\n        this.instanceId = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Renderer({\n            castShadow: this.castShadow,\n            receiveShadow: this.receiveShadow,\n            frustumCulled: this.frustumCulled,\n            visible: this.visible,\n            renderOrder: this.renderOrder\n        });\n        // Note: We don't clone the actual geometry/material/mesh as they should be shared\n        // The cloned component will need to have its geometry and material set separately\n        return clone;\n    }\n    constructor(options = {}){\n        super();\n        this.componentType = \"Renderer\" // Instance identifier\n        ;\n        this.mesh = null;\n        this.geometry = null;\n        this.material = null;\n        // Animation properties\n        this.animationMixer = null;\n        this.animations = [];\n        this.currentAnimation = null;\n        // Instancing support\n        this.isInstanced = false;\n        this.instancedMesh = null;\n        this.instanceId = -1;\n        var _options_castShadow;\n        this.castShadow = (_options_castShadow = options.castShadow) !== null && _options_castShadow !== void 0 ? _options_castShadow : true;\n        var _options_receiveShadow;\n        this.receiveShadow = (_options_receiveShadow = options.receiveShadow) !== null && _options_receiveShadow !== void 0 ? _options_receiveShadow : true;\n        var _options_frustumCulled;\n        this.frustumCulled = (_options_frustumCulled = options.frustumCulled) !== null && _options_frustumCulled !== void 0 ? _options_frustumCulled : true;\n        var _options_visible;\n        this.visible = (_options_visible = options.visible) !== null && _options_visible !== void 0 ? _options_visible : true;\n        var _options_renderOrder;\n        this.renderOrder = (_options_renderOrder = options.renderOrder) !== null && _options_renderOrder !== void 0 ? _options_renderOrder : 0;\n        this.needsUpdate = true;\n    }\n}\nRenderer.componentType = \"Renderer\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQ0FBMkM7QUFDMEk7QUFDL0k7QUFVL0IsTUFBTVEsaUJBQWlCRCw4Q0FBU0E7SUFrQzlCRSxZQUFZQyxRQUF3QixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUtBLFVBQVU7WUFDL0MsSUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQU87UUFDdkI7UUFDQSxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxXQUFXLEdBQUc7SUFDckI7SUFFT0MsWUFBWUMsUUFBK0IsRUFBUTtRQUN4RCxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLQSxVQUFVO1lBQy9DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDQSxRQUFRLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVAsT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0csUUFBUSxDQUFDSCxPQUFPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixXQUFXLEdBQUc7SUFDckI7SUFFT08sYUFBMEI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNNLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ0MsV0FBVztRQUNsQjtRQUVBLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlwQixzREFBSUEsQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRSxJQUFJLENBQUNJLFFBQVE7UUFDakQsSUFBSSxDQUFDTSxJQUFJLENBQUNFLFVBQVUs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LENBQUFBLHlCQUFBQSxRQUFRakQsYUFBYSxjQUFyQmlELG9DQUFBQSx5QkFBeUI7WUFDL0JBO1FBQWYsSUFBSSxDQUFDaEQsT0FBTyxHQUFHZ0QsQ0FBQUEsbUJBQUFBLFFBQVFoRCxPQUFPLGNBQWZnRCw4QkFBQUEsbUJBQW1CO1lBQ2ZBO1FBQW5CLElBQUksQ0FBQy9DLFdBQVcsR0FBRytDLENBQUFBLHVCQUFBQSxRQUFRL0MsV0FBVyxjQUFuQitDLGtDQUFBQSx1QkFBdUI7UUFDMUMsSUFBSSxDQUFDN0QsV0FBVyxHQUFHO0lBQ3JCO0FBK09GO0FBL1FhSixTQUNZa0UsZ0JBQWdCLFdBQVksMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cz9lMjc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlcmVyIGNvbXBvbmVudCBmb3IgM0QgcmVuZGVyaW5nIGRhdGFcbmltcG9ydCB7IE1lc2gsIEdyb3VwLCBCdWZmZXJHZW9tZXRyeSwgTWF0ZXJpYWwsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25BY3Rpb24sIEluc3RhbmNlZE1lc2gsIExvb3BSZXBlYXQsIExvb3BPbmNlLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyT3B0aW9ucyB7XG4gIGNhc3RTaGFkb3c/OiBib29sZWFuO1xuICByZWNlaXZlU2hhZG93PzogYm9vbGVhbjtcbiAgZnJ1c3R1bUN1bGxlZD86IGJvb2xlYW47XG4gIHZpc2libGU/OiBib29sZWFuO1xuICByZW5kZXJPcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgbWVzaDogTWVzaCB8IEdyb3VwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnZW9tZXRyeTogQnVmZmVyR2VvbWV0cnkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbCB8IE1hdGVyaWFsW10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhc3RTaGFkb3c6IGJvb2xlYW47XG4gIHB1YmxpYyByZWNlaXZlU2hhZG93OiBib29sZWFuO1xuICBwdWJsaWMgZnJ1c3R1bUN1bGxlZDogYm9vbGVhbjtcbiAgcHVibGljIHZpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJPcmRlcjogbnVtYmVyO1xuICBwdWJsaWMgbmVlZHNVcGRhdGU6IGJvb2xlYW47XG5cbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgcHVibGljIGFuaW1hdGlvbk1peGVyOiBBbmltYXRpb25NaXhlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgYW5pbWF0aW9uczogQW5pbWF0aW9uQ2xpcFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50QW5pbWF0aW9uOiBBbmltYXRpb25BY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvLyBJbnN0YW5jaW5nIHN1cHBvcnRcbiAgcHVibGljIGlzSW5zdGFuY2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBpbnN0YW5jZUlkOiBudW1iZXIgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IG9wdGlvbnMuY2FzdFNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IG9wdGlvbnMucmVjZWl2ZVNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IG9wdGlvbnMuZnJ1c3R1bUN1bGxlZCA/PyB0cnVlO1xuICAgIHRoaXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSBvcHRpb25zLnJlbmRlck9yZGVyID8/IDA7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0R2VvbWV0cnkoZ2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF0ZXJpYWwobWF0ZXJpYWw6IE1hdGVyaWFsIHwgTWF0ZXJpYWxbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICYmIHRoaXMubWF0ZXJpYWwgIT09IG1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNZXNoKCk6IE1lc2ggfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMubWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgICB0aGlzLm1lc2gucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICB0aGlzLm1lc2guZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICB0aGlzLm1lc2gucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1lc2g7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlTWVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIHNoYWRvdyBwcm9wZXJ0aWVzIGZvciBib3RoIE1lc2ggYW5kIEdyb3VwXG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgICAgdGhpcy5tZXNoLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lc2ggaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgLy8gQXBwbHkgc2hhZG93IHByb3BlcnRpZXMgdG8gYWxsIG1lc2hlcyBpbiB0aGUgZ3JvdXBcbiAgICAgIHRoaXMubWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5tZXNoLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdGhpcy5tZXNoLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIGlmICh0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5tYXRlcmlhbCAmJiB0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICB0aGlzLm1lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldENhc3RTaGFkb3coY2FzdFNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFJlY2VpdmVTaGFkb3cocmVjZWl2ZVNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9uIG1ldGhvZHNcbiAgcHVibGljIHNldHVwQW5pbWF0aW9ucyhhbmltYXRpb25zOiBBbmltYXRpb25DbGlwW10pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHRoaXMubWVzaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHBsYXlBbmltYXRpb24obmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuID0gdHJ1ZSwgZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IEFuaW1hdGlvbkFjdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25NaXhlcikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjbGlwID0gdGhpcy5hbmltYXRpb25zLmZpbmQoY2xpcCA9PiBjbGlwLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghY2xpcCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLmZhZGVPdXQoZmFkZVRpbWUpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGlvbk1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG4gICAgYWN0aW9uLnNldExvb3AobG9vcCA/IExvb3BSZXBlYXQgOiBMb29wT25jZSwgbG9vcCA/IEluZmluaXR5IDogMSk7XG4gICAgYWN0aW9uLmZhZGVJbihmYWRlVGltZSk7XG4gICAgYWN0aW9uLnBsYXkoKTtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcHVibGljIHN0b3BBbmltYXRpb24oZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5mYWRlT3V0KGZhZGVUaW1lKTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbnMoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnN0YW5jaW5nIG1ldGhvZHNcbiAgcHVibGljIHNldHVwSW5zdGFuY2luZyhpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoLCBpbnN0YW5jZUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RhbmNlZE1lc2ggPSBpbnN0YW5jZWRNZXNoO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSW5zdGFuY2VNYXRyaXgobWF0cml4OiBNYXRyaXg0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdGhpcy5pbnN0YW5jZWRNZXNoICYmIHRoaXMuaW5zdGFuY2VJZCA+PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB0aGlzLmluc3RhbmNlZE1lc2ggJiYgdGhpcy5pbnN0YW5jZUlkID49IDApIHtcbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgbWVzaGVzLCB3ZSBjYW4gaGlkZSBpbnN0YW5jZXMgYnkgc2NhbGluZyB0aGVtIHRvIDBcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgXG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgbWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KHRoaXMuaW5zdGFuY2VJZCwgbWF0cml4KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2VNZXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGlmICh0aGlzLm1lc2gucGFyZW50KSB7XG4gICAgICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcblxuICAgIGlmICh0aGlzLmdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2VkTWVzaCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gLTE7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBSZW5kZXJlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgY2FzdFNoYWRvdzogdGhpcy5jYXN0U2hhZG93LFxuICAgICAgcmVjZWl2ZVNoYWRvdzogdGhpcy5yZWNlaXZlU2hhZG93LFxuICAgICAgZnJ1c3R1bUN1bGxlZDogdGhpcy5mcnVzdHVtQ3VsbGVkLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgcmVuZGVyT3JkZXI6IHRoaXMucmVuZGVyT3JkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9uZSB0aGUgYWN0dWFsIGdlb21ldHJ5L21hdGVyaWFsL21lc2ggYXMgdGhleSBzaG91bGQgYmUgc2hhcmVkXG4gICAgLy8gVGhlIGNsb25lZCBjb21wb25lbnQgd2lsbCBuZWVkIHRvIGhhdmUgaXRzIGdlb21ldHJ5IGFuZCBtYXRlcmlhbCBzZXQgc2VwYXJhdGVseVxuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJHcm91cCIsIkFuaW1hdGlvbk1peGVyIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJDb21wb25lbnQiLCJSZW5kZXJlciIsInNldEdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibmVlZHNVcGRhdGUiLCJzZXRNYXRlcmlhbCIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNyZWF0ZU1lc2giLCJtZXNoIiwiZGlzcG9zZU1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ2aXNpYmxlIiwicmVuZGVyT3JkZXIiLCJ1cGRhdGVNZXNoIiwidHJhdmVyc2UiLCJjaGlsZCIsInNldFZpc2libGUiLCJzZXRDYXN0U2hhZG93Iiwic2V0UmVjZWl2ZVNoYWRvdyIsInNldHVwQW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJsZW5ndGgiLCJhbmltYXRpb25NaXhlciIsInBsYXlBbmltYXRpb24iLCJuYW1lIiwibG9vcCIsImZhZGVUaW1lIiwiY2xpcCIsImZpbmQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmFkZU91dCIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzZXRMb29wIiwiSW5maW5pdHkiLCJmYWRlSW4iLCJwbGF5Iiwic3RvcEFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbnMiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJzZXR1cEluc3RhbmNpbmciLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VJZCIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4Iiwic2V0SW5zdGFuY2VWaXNpYmxlIiwiZ2V0TWF0cml4QXQiLCJzY2FsZSIsInBhcmVudCIsInJlbW92ZSIsInN0b3BBbGxBY3Rpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Renderer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Shield.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Shield.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shield: function() { return /* binding */ Shield; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n\nclass Shield extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /**\n   * Absorb damage with the shield. Returns the amount of damage that passed through.\n   */ absorbDamage(damage) {\n        if (this.currentShield <= 0) {\n            return damage; // No shield left, all damage passes through\n        }\n        const damageAbsorbed = Math.min(damage, this.currentShield);\n        this.currentShield -= damageAbsorbed;\n        this.lastDamageTime = Date.now();\n        this.isRegenerating = false;\n        // Return the damage that wasn't absorbed\n        return damage - damageAbsorbed;\n    }\n    /**\n   * Update shield regeneration based on delta time\n   */ update(deltaTime) {\n        if (this.currentShield >= this.maxShield) {\n            this.isRegenerating = false;\n            return;\n        }\n        const timeSinceLastDamage = (Date.now() - this.lastDamageTime) / 1000;\n        if (timeSinceLastDamage >= this.regenDelay) {\n            if (!this.isRegenerating) {\n                this.isRegenerating = true;\n            }\n            const regenAmount = this.regenRate * deltaTime;\n            this.currentShield = Math.min(this.maxShield, this.currentShield + regenAmount);\n        }\n    }\n    /**\n   * Get shield percentage (0-1)\n   */ getShieldPercentage() {\n        return this.maxShield > 0 ? this.currentShield / this.maxShield : 0;\n    }\n    /**\n   * Check if shield is at full capacity\n   */ isFullShield() {\n        return this.currentShield >= this.maxShield;\n    }\n    /**\n   * Check if shield is completely depleted\n   */ isShieldDepleted() {\n        return this.currentShield <= 0;\n    }\n    /**\n   * Instantly restore shield to full (for testing or special abilities)\n   */ restoreShield() {\n        this.currentShield = this.maxShield;\n        this.isRegenerating = false;\n    }\n    /**\n   * Set shield values (useful for multiplayer sync)\n   */ setShield(current, max) {\n        this.currentShield = Math.max(0, Math.min(max, current));\n        this.maxShield = max;\n    }\n    /**\n   * Reset shield to initial state (required by Component interface)\n   */ reset() {\n        this.currentShield = this.maxShield;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n        this.enabled = true;\n    }\n    constructor(maxShield = 200, regenRate = 20, regenDelay = 5){\n        super();\n        this.componentType = \"Shield\" // Instance identifier\n        ;\n        this.maxShield = maxShield;\n        this.currentShield = maxShield;\n        this.regenRate = regenRate;\n        this.regenDelay = regenDelay;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n    }\n}\nShield.componentType = \"Shield\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFL0IsTUFBTUMsZUFBZUQsOENBQVNBO0lBb0JuQzs7R0FFQyxHQUNELGFBQW9CRyxNQUFjLEVBQVU7UUFDMUMsSUFBSSxJQUFJLENBQUNDLGFBQWEsSUFBSSxHQUFHO1lBQzNCLE9BQU9ELFFBQVEsNENBQTRDO1FBQzdEO1FBRUEsTUFBTUUsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUNKLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1FBQzFELElBQUksQ0FBQ0EsYUFBYSxJQUFJQztRQUN0QixJQUFJLENBQUNHLGNBQWMsR0FBR0MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUV0Qix5Q0FBeUM7UUFDekMsT0FBT1IsU0FBU0U7SUFDbEI7SUFFQTs7R0FFQyxHQUNELE9BQWNRLFNBQWlCLEVBQVE7UUFDckMsSUFBSSxJQUFJLENBQUNULGFBQWEsSUFBSSxJQUFJLENBQUNVLFNBQVMsRUFBRTtZQUN4QyxJQUFJLENBQUNILGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTUksc0JBQXNCLENBQUNOLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNGLGNBQWMsSUFBSTtRQUVqRSxJQUFJTyx1QkFBdUIsSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0wsY0FBYyxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRztZQUN4QjtZQUVBLE1BQU1NLGNBQWMsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1lBQ3JDLElBQUksQ0FBQ1QsYUFBYSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxTQUFTLEVBQUUsSUFBSSxDQUFDVixhQUFhLEdBQUdhO1FBQ3JFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUFxQztRQUNuQyxPQUFPLElBQUksQ0FBQ0gsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTLEdBQUc7SUFDcEU7SUFFQTs7R0FFQyxHQUNELGVBQStCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVixhQUFhLElBQUksSUFBSSxDQUFDVSxTQUFTO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxtQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUNWLGFBQWEsSUFBSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsZ0JBQTZCO1FBQzNCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ1UsU0FBUztRQUNuQyxJQUFJLENBQUNILGNBQWMsR0FBRztJQUN4QjtJQUVBOztHQUVDLEdBQ0QsVUFBaUJhLE9BQWUsRUFBRUMsR0FBVyxFQUFRO1FBQ25ELElBQUksQ0FBQ3JCLGFBQWEsR0FBR0UsS0FBS21CLEdBQUcsQ0FBQyxHQUFHbkIsS0FBS0MsR0FBRyxDQUFDa0IsS0FBS0Q7UUFDL0MsSUFBSSxDQUFDVixTQUFTLEdBQUdXO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxRQUFxQjtRQUNuQixJQUFJLENBQUNyQixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTO1FBQ25DLElBQUksQ0FBQ04sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2dCLE9BQU8sR0FBRztJQUNqQjtJQTdGQUMsWUFBWWQsWUFBb0IsR0FBRyxFQUFFSSxZQUFvQixFQUFFLEVBQUVGLGFBQXFCLENBQUMsQ0FBRTtRQUNuRixLQUFLO2FBVFNhLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFVOUQsSUFBSSxDQUFDZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHVTtRQUNyQixJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ1IsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3hCO0FBc0ZGO0FBeEdhVixPQUNZNEIsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHM/MmM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgU2hpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1NoaWVsZCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdTaGllbGQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBtYXhTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIGN1cnJlbnRTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuUmF0ZTogbnVtYmVyOyAvLyBTaGllbGQgcmVnZW5lcmF0ZWQgcGVyIHNlY29uZFxuICBwdWJsaWMgcmVnZW5EZWxheTogbnVtYmVyOyAvLyBTZWNvbmRzIGJlZm9yZSByZWdlbiBzdGFydHNcbiAgcHVibGljIGxhc3REYW1hZ2VUaW1lOiBudW1iZXI7IC8vIFRpbWVzdGFtcCBvZiBsYXN0IGRhbWFnZSB0YWtlblxuICBwdWJsaWMgaXNSZWdlbmVyYXRpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWF4U2hpZWxkOiBudW1iZXIgPSAyMDAsIHJlZ2VuUmF0ZTogbnVtYmVyID0gMjAsIHJlZ2VuRGVsYXk6IG51bWJlciA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4U2hpZWxkO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IG1heFNoaWVsZDtcbiAgICB0aGlzLnJlZ2VuUmF0ZSA9IHJlZ2VuUmF0ZTtcbiAgICB0aGlzLnJlZ2VuRGVsYXkgPSByZWdlbkRlbGF5O1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnNvcmIgZGFtYWdlIHdpdGggdGhlIHNoaWVsZC4gUmV0dXJucyB0aGUgYW1vdW50IG9mIGRhbWFnZSB0aGF0IHBhc3NlZCB0aHJvdWdoLlxuICAgKi9cbiAgcHVibGljIGFic29yYkRhbWFnZShkYW1hZ2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA8PSAwKSB7XG4gICAgICByZXR1cm4gZGFtYWdlOyAvLyBObyBzaGllbGQgbGVmdCwgYWxsIGRhbWFnZSBwYXNzZXMgdGhyb3VnaFxuICAgIH1cblxuICAgIGNvbnN0IGRhbWFnZUFic29yYmVkID0gTWF0aC5taW4oZGFtYWdlLCB0aGlzLmN1cnJlbnRTaGllbGQpO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCAtPSBkYW1hZ2VBYnNvcmJlZDtcbiAgICB0aGlzLmxhc3REYW1hZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhbWFnZSB0aGF0IHdhc24ndCBhYnNvcmJlZFxuICAgIHJldHVybiBkYW1hZ2UgLSBkYW1hZ2VBYnNvcmJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2hpZWxkIHJlZ2VuZXJhdGlvbiBiYXNlZCBvbiBkZWx0YSB0aW1lXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA+PSB0aGlzLm1heFNoaWVsZCkge1xuICAgICAgdGhpcy5pc1JlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdERhbWFnZVRpbWUpIC8gMTAwMDtcbiAgICBcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuRGVsYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlZ2VuZXJhdGluZykge1xuICAgICAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVnZW5BbW91bnQgPSB0aGlzLnJlZ2VuUmF0ZSAqIGRlbHRhVGltZTtcbiAgICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWluKHRoaXMubWF4U2hpZWxkLCB0aGlzLmN1cnJlbnRTaGllbGQgKyByZWdlbkFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzaGllbGQgcGVyY2VudGFnZSAoMC0xKVxuICAgKi9cbiAgcHVibGljIGdldFNoaWVsZFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTaGllbGQgPiAwID8gdGhpcy5jdXJyZW50U2hpZWxkIC8gdGhpcy5tYXhTaGllbGQgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNoaWVsZCBpcyBhdCBmdWxsIGNhcGFjaXR5XG4gICAqL1xuICBwdWJsaWMgaXNGdWxsU2hpZWxkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPj0gdGhpcy5tYXhTaGllbGQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2hpZWxkIGlzIGNvbXBsZXRlbHkgZGVwbGV0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NoaWVsZERlcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50bHkgcmVzdG9yZSBzaGllbGQgdG8gZnVsbCAoZm9yIHRlc3Rpbmcgb3Igc3BlY2lhbCBhYmlsaXRpZXMpXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZVNoaWVsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTaGllbGQgPSB0aGlzLm1heFNoaWVsZDtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNoaWVsZCB2YWx1ZXMgKHVzZWZ1bCBmb3IgbXVsdGlwbGF5ZXIgc3luYylcbiAgICovXG4gIHB1YmxpYyBzZXRTaGllbGQoY3VycmVudDogbnVtYmVyLCBtYXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgY3VycmVudCkpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHNoaWVsZCB0byBpbml0aWFsIHN0YXRlIChyZXF1aXJlZCBieSBDb21wb25lbnQgaW50ZXJmYWNlKVxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IHRoaXMubWF4U2hpZWxkO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiYWJzb3JiRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFNoaWVsZCIsImRhbWFnZUFic29yYmVkIiwiTWF0aCIsIm1pbiIsImxhc3REYW1hZ2VUaW1lIiwiRGF0ZSIsIm5vdyIsImlzUmVnZW5lcmF0aW5nIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwibWF4U2hpZWxkIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuRGVsYXkiLCJyZWdlbkFtb3VudCIsInJlZ2VuUmF0ZSIsImdldFNoaWVsZFBlcmNlbnRhZ2UiLCJpc0Z1bGxTaGllbGQiLCJpc1NoaWVsZERlcGxldGVkIiwicmVzdG9yZVNoaWVsZCIsInNldFNoaWVsZCIsImN1cnJlbnQiLCJtYXgiLCJyZXNldCIsImVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Shield.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/SummonedUnit.ts":
/*!********************************************!*\
  !*** ./src/ecs/components/SummonedUnit.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SummonedUnit: function() { return /* binding */ SummonedUnit; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// SummonedUnit component for PVP tower minions\n\nclass SummonedUnit extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    isExpired(currentTime) {\n        return this.isDead || currentTime - this.summonTime >= this.lifetime;\n    }\n    getDisplayName() {\n        return \"Unit (\".concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.unitId = \"\";\n        this.attackRange = 4;\n        this.attackDamage = 15;\n        this.attackCooldown = 1.0;\n        this.lastAttackTime = 0;\n        this.maxHealth = 500;\n        this.moveSpeed = 2.5;\n        this.targetPosition = null;\n        this.currentTarget = null;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.summonTime = Date.now() / 1000;\n        this.lifetime = 120;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new SummonedUnit(this.ownerId, this.unitId, this.targetPosition);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.maxHealth = this.maxHealth;\n        clone.moveSpeed = this.moveSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.summonTime = this.summonTime;\n        clone.lifetime = this.lifetime;\n        return clone;\n    }\n    constructor(ownerId = \"\", unitId = \"\", targetPosition = null){\n        super();\n        this.componentType = \"SummonedUnit\";\n        this.ownerId = ownerId;\n        this.unitId = unitId;\n        // Combat configuration\n        this.attackRange = 4; // 4 unit attack range as specified\n        this.attackDamage = 15; // 15 damage per hit as specified\n        this.attackCooldown = 1.0; // 1 second between attacks\n        this.lastAttackTime = 0;\n        this.maxHealth = 500; // 500 HP as specified\n        // Movement configuration\n        this.moveSpeed = 2.5; // Moderate movement speed\n        this.targetPosition = targetPosition;\n        this.currentTarget = null;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        // Summon properties\n        this.summonTime = Date.now() / 1000; // Current time in seconds\n        this.lifetime = 120; // 2 minutes lifetime\n    }\n}\nSummonedUnit.componentType = \"SummonedUnit\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQ0FBK0M7QUFDVDtBQUUvQixNQUFNQyxxQkFBcUJELDhDQUFTQTtJQWlFbENFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLFVBQVVoQixXQUFtQixFQUFXO1FBQzdDLE9BQU8sSUFBSSxDQUFDRSxNQUFNLElBQUksY0FBZSxJQUFJLENBQUNlLFVBQVUsSUFBSyxJQUFJLENBQUNDLFFBQVE7SUFDeEU7SUFFT0MsaUJBQXlCO1FBQzlCLE9BQU8sU0FBc0IsT0FB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QUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ2EsU0FBUyxHQUFHO1FBRWpCLG9CQUFvQjtRQUNwQixJQUFJLENBQUNFLFVBQVUsR0FBR1csS0FBS0MsR0FBRyxLQUFLLE1BQU0sMEJBQTBCO1FBQy9ELElBQUksQ0FBQ1gsUUFBUSxHQUFHLEtBQUsscUJBQXFCO0lBQzVDO0FBbUZGO0FBbEphcEIsYUFDWW1DLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvU3VtbW9uZWRVbml0LnRzPzVjOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3VtbW9uZWRVbml0IGNvbXBvbmVudCBmb3IgUFZQIHRvd2VyIG1pbmlvbnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBTdW1tb25lZFVuaXQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnU3VtbW9uZWRVbml0JztcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnU3VtbW9uZWRVbml0JztcblxuICAvLyBPd25lcnNoaXAgYW5kIGlkZW50aWZpY2F0aW9uXG4gIHB1YmxpYyBvd25lcklkOiBzdHJpbmc7IC8vIFBsYXllciBJRCB3aG8gb3ducyB0aGlzIHVuaXRcbiAgcHVibGljIHVuaXRJZDogc3RyaW5nOyAvLyBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyB1bml0XG5cbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgbWF4SGVhbHRoOiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgcHJvcGVydGllc1xuICBwdWJsaWMgbW92ZVNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyB0YXJnZXRQb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0gfCBudWxsOyAvLyBQb3NpdGlvbiB0byBtb3ZlIHRvd2FyZHNcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldCAodW5pdCBvciB0b3dlcilcbiAgcHVibGljIGxhc3RUYXJnZXRTZWFyY2hUaW1lOiBudW1iZXI7XG4gIHB1YmxpYyB0YXJnZXRTZWFyY2hDb29sZG93bjogbnVtYmVyOyAvLyBIb3cgb2Z0ZW4gdG8gc2VhcmNoIGZvciB0YXJnZXRzXG5cbiAgLy8gU3RhdGVcbiAgcHVibGljIGlzQWN0aXZlOiBib29sZWFuO1xuICBwdWJsaWMgaXNEZWFkOiBib29sZWFuO1xuICBwdWJsaWMgZGVhdGhUaW1lOiBudW1iZXI7XG5cbiAgLy8gU3VtbW9uIHByb3BlcnRpZXNcbiAgcHVibGljIHN1bW1vblRpbWU6IG51bWJlcjsgLy8gV2hlbiB0aGlzIHVuaXQgd2FzIHN1bW1vbmVkXG4gIHB1YmxpYyBsaWZldGltZTogbnVtYmVyOyAvLyBIb3cgbG9uZyB0aGlzIHVuaXQgbGl2ZXMgKGluIHNlY29uZHMpXG5cbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdW5pdElkOiBzdHJpbmcgPSAnJyxcbiAgICB0YXJnZXRQb3NpdGlvbjogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgejogbnVtYmVyIH0gfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vd25lcklkID0gb3duZXJJZDtcbiAgICB0aGlzLnVuaXRJZCA9IHVuaXRJZDtcblxuICAgIC8vIENvbWJhdCBjb25maWd1cmF0aW9uXG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IDQ7IC8vIDQgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxNTsgLy8gMTUgZGFtYWdlIHBlciBoaXQgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IDEuMDsgLy8gMSBzZWNvbmQgYmV0d2VlbiBhdHRhY2tzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tYXhIZWFsdGggPSA1MDA7IC8vIDUwMCBIUCBhcyBzcGVjaWZpZWRcblxuICAgIC8vIE1vdmVtZW50IGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLm1vdmVTcGVlZCA9IDIuNTsgLy8gTW9kZXJhdGUgbW92ZW1lbnQgc3BlZWRcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb247XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41OyAvLyBTZWFyY2ggZm9yIHRhcmdldHMgZXZlcnkgMC41IHNlY29uZHNcblxuICAgIC8vIFN0YXRlXG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG5cbiAgICAvLyBTdW1tb24gcHJvcGVydGllc1xuICAgIHRoaXMuc3VtbW9uVGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDdXJyZW50IHRpbWUgaW4gc2Vjb25kc1xuICAgIHRoaXMubGlmZXRpbWUgPSAxMjA7IC8vIDIgbWludXRlcyBsaWZldGltZVxuICB9XG5cbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8IHRoaXMuaXNEZWFkIHx8ICF0aGlzLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEF0dGFja1RpbWUpID49IHRoaXMuYXR0YWNrQ29vbGRvd247XG4gIH1cblxuICBwdWJsaWMgcGVyZm9ybUF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHVibGljIGNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lKSA+PSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVRhcmdldFNlYXJjaChjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgcHVibGljIHNldFRhcmdldCh0YXJnZXRFbnRpdHlJZDogbnVtYmVyIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldEVudGl0eUlkO1xuICB9XG5cbiAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jbGVhclRhcmdldCgpO1xuICB9XG5cbiAgcHVibGljIGlzRXhwaXJlZChjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWFkIHx8IChjdXJyZW50VGltZSAtIHRoaXMuc3VtbW9uVGltZSkgPj0gdGhpcy5saWZldGltZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVW5pdCAoJHt0aGlzLm93bmVySWR9KWA7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5vd25lcklkID0gJyc7XG4gICAgdGhpcy51bml0SWQgPSAnJztcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gNDtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IDE1O1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSAxLjA7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5tYXhIZWFsdGggPSA1MDA7XG4gICAgdGhpcy5tb3ZlU3BlZWQgPSAyLjU7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41O1xuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMuc3VtbW9uVGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHRoaXMubGlmZXRpbWUgPSAxMjA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBTdW1tb25lZFVuaXQge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFN1bW1vbmVkVW5pdCh0aGlzLm93bmVySWQsIHRoaXMudW5pdElkLCB0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICBjbG9uZS5hdHRhY2tSYW5nZSA9IHRoaXMuYXR0YWNrUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrRGFtYWdlID0gdGhpcy5hdHRhY2tEYW1hZ2U7XG4gICAgY2xvbmUuYXR0YWNrQ29vbGRvd24gPSB0aGlzLmF0dGFja0Nvb2xkb3duO1xuICAgIGNsb25lLmxhc3RBdHRhY2tUaW1lID0gdGhpcy5sYXN0QXR0YWNrVGltZTtcbiAgICBjbG9uZS5tYXhIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICBjbG9uZS5tb3ZlU3BlZWQgPSB0aGlzLm1vdmVTcGVlZDtcbiAgICBjbG9uZS5jdXJyZW50VGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0O1xuICAgIGNsb25lLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZTtcbiAgICBjbG9uZS50YXJnZXRTZWFyY2hDb29sZG93biA9IHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd247XG4gICAgY2xvbmUuaXNBY3RpdmUgPSB0aGlzLmlzQWN0aXZlO1xuICAgIGNsb25lLmlzRGVhZCA9IHRoaXMuaXNEZWFkO1xuICAgIGNsb25lLmRlYXRoVGltZSA9IHRoaXMuZGVhdGhUaW1lO1xuICAgIGNsb25lLnN1bW1vblRpbWUgPSB0aGlzLnN1bW1vblRpbWU7XG4gICAgY2xvbmUubGlmZXRpbWUgPSB0aGlzLmxpZmV0aW1lO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIlN1bW1vbmVkVW5pdCIsImNhbkF0dGFjayIsImN1cnJlbnRUaW1lIiwiaXNBY3RpdmUiLCJpc0RlYWQiLCJjdXJyZW50VGFyZ2V0IiwibGFzdEF0dGFja1RpbWUiLCJhdHRhY2tDb29sZG93biIsInBlcmZvcm1BdHRhY2siLCJjYW5TZWFyY2hGb3JUYXJnZXRzIiwibGFzdFRhcmdldFNlYXJjaFRpbWUiLCJ0YXJnZXRTZWFyY2hDb29sZG93biIsInVwZGF0ZVRhcmdldFNlYXJjaCIsInNldFRhcmdldCIsInRhcmdldEVudGl0eUlkIiwiY2xlYXJUYXJnZXQiLCJkaWUiLCJkZWF0aFRpbWUiLCJpc0V4cGlyZWQiLCJzdW1tb25UaW1lIiwibGlmZXRpbWUiLCJnZXREaXNwbGF5TmFtZSIsIm93bmVySWQiLCJyZXNldCIsInVuaXRJZCIsImF0dGFja1JhbmdlIiwiYXR0YWNrRGFtYWdlIiwibWF4SGVhbHRoIiwibW92ZVNwZWVkIiwidGFyZ2V0UG9zaXRpb24iLCJEYXRlIiwibm93IiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Tower.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Tower.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: function() { return /* binding */ Tower; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Tower component for PVP home base towers\n\nclass Tower extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    getDisplayName() {\n        return \"Tower \".concat(this.towerIndex + 1, \" (Owner: \").concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.towerIndex = 0;\n        this.attackRange = 10;\n        this.attackDamage = 25;\n        this.attackCooldown = 1.5;\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20;\n        this.currentTarget = null;\n        this.targetSearchRange = 9;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Tower(this.ownerId, this.towerIndex);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.projectileSpeed = this.projectileSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.targetSearchRange = this.targetSearchRange;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        return clone;\n    }\n    constructor(ownerId = \"\", towerIndex = 0){\n        super();\n        this.componentType = \"Tower\";\n        this.ownerId = ownerId;\n        this.towerIndex = towerIndex;\n        // Combat configuration\n        this.attackRange = 13.5; // attack range \n        this.attackDamage = 100; // 25 damage per arrow\n        this.attackCooldown = 1.5; // 1.5 seconds between shots\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20; // Speed of tower arrows\n        // Targeting configuration\n        this.currentTarget = null;\n        this.targetSearchRange = this.attackRange + 1; // Search slightly beyond attack range\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n    }\n}\nTower.componentType = \"Tower\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEyQztBQUNMO0FBRS9CLE1BQU1DLGNBQWNELDhDQUFTQTtJQXNEM0JFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLGlCQUF5QjtRQUM5QixPQUFPLFNBQXdDLE9BQS9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEdBQUUsYUFBd0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztJQUM5RDtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNuQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDb0IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZixvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDUyxPQUFPLEdBQUc7SUFDakI7SUFFT0MsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUkzQixNQUFNLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUNELFVBQVU7UUFDckRRLE1BQU1MLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENLLE1BQU1KLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdENJLE1BQU1wQixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDb0IsTUFBTXJCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNxQixNQUFNSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzVDRyxNQUFNdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NCLE1BQU1GLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hERSxNQUFNakIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERpQixNQUFNaEIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERnQixNQUFNeEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUM5QndCLE1BQU12QixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzFCdUIsTUFBTVYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxPQUFPVTtJQUNUO0lBbkdBQyxZQUNFUixVQUFrQixFQUFFLEVBQ3BCRCxhQUFxQixDQUFDLENBQ3RCO1FBQ0EsS0FBSzthQTVCU1UsZ0JBQWdCO1FBOEI5QixJQUFJLENBQUNULE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFFbEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0csV0FBVyxHQUFHLE1BQU0sZ0JBQWdCO1FBQ3pDLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEtBQUssc0JBQXNCO1FBQy9DLElBQUksQ0FBQ2hCLGNBQWMsR0FBRyxLQUFLLDRCQUE0QjtRQUN2RCxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSx3QkFBd0I7UUFFbkQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ25CLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUNILFdBQVcsR0FBRyxHQUFHLHNDQUFzQztRQUNyRixJQUFJLENBQUNaLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSyx1Q0FBdUM7UUFFeEUsUUFBUTtRQUNSLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7SUFDbkI7QUEwRUY7QUE5SGFqQixNQUNZNkIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cz9iNmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIGNvbXBvbmVudCBmb3IgUFZQIGhvbWUgYmFzZSB0b3dlcnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUb3dlcic7XG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Rvd2VyJztcbiAgXG4gIC8vIFRvd2VyIG93bmVyc2hpcCBhbmQgaWRlbnRpZmljYXRpb25cbiAgcHVibGljIG93bmVySWQ6IHN0cmluZzsgLy8gUGxheWVyIElEIHdobyBvd25zIHRoaXMgdG93ZXJcbiAgcHVibGljIHRvd2VySW5kZXg6IG51bWJlcjsgLy8gVG93ZXIgaW5kZXggKDAgZm9yIGZpcnN0IHBsYXllciwgMSBmb3Igc2Vjb25kLCBldGMuKVxuICBcbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcHJvamVjdGlsZVNwZWVkOiBudW1iZXI7XG4gIFxuICAvLyBUYXJnZXRpbmdcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldFxuICBwdWJsaWMgdGFyZ2V0U2VhcmNoUmFuZ2U6IG51bWJlcjsgLy8gUmFuZ2UgdG8gc2VhcmNoIGZvciBuZXcgdGFyZ2V0c1xuICBwdWJsaWMgbGFzdFRhcmdldFNlYXJjaFRpbWU6IG51bWJlcjtcbiAgcHVibGljIHRhcmdldFNlYXJjaENvb2xkb3duOiBudW1iZXI7IC8vIEhvdyBvZnRlbiB0byBzZWFyY2ggZm9yIHRhcmdldHNcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdG93ZXJJbmRleDogbnVtYmVyID0gMFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy50b3dlckluZGV4ID0gdG93ZXJJbmRleDtcbiAgICBcbiAgICAvLyBDb21iYXQgY29uZmlndXJhdGlvblxuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSAxMy41OyAvLyBhdHRhY2sgcmFuZ2UgXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxMDA7IC8vIDI1IGRhbWFnZSBwZXIgYXJyb3dcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gMS41OyAvLyAxLjUgc2Vjb25kcyBiZXR3ZWVuIHNob3RzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDsgLy8gU3BlZWQgb2YgdG93ZXIgYXJyb3dzXG4gICAgXG4gICAgLy8gVGFyZ2V0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlICsgMTsgLy8gU2VhcmNoIHNsaWdodGx5IGJleW9uZCBhdHRhY2sgcmFuZ2VcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41OyAvLyBTZWFyY2ggZm9yIHRhcmdldHMgZXZlcnkgMC41IHNlY29uZHNcbiAgICBcbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc0RlYWQgfHwgIXRoaXMuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuICBcbiAgcHVibGljIHBlcmZvcm1BdHRhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuICBcbiAgcHVibGljIGNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lKSA+PSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRUYXJnZXQodGFyZ2V0RW50aXR5SWQ6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRFbnRpdHlJZDtcbiAgfVxuICBcbiAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cbiAgXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmNsZWFyVGFyZ2V0KCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVG93ZXIgJHt0aGlzLnRvd2VySW5kZXggKyAxfSAoT3duZXI6ICR7dGhpcy5vd25lcklkfSlgO1xuICB9XG4gIFxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5vd25lcklkID0gJyc7XG4gICAgdGhpcy50b3dlckluZGV4ID0gMDtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gMTA7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAyNTtcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gMS41O1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMucHJvamVjdGlsZVNwZWVkID0gMjA7XG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaFJhbmdlID0gOTtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41O1xuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBjbG9uZSgpOiBUb3dlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgVG93ZXIodGhpcy5vd25lcklkLCB0aGlzLnRvd2VySW5kZXgpO1xuICAgIGNsb25lLmF0dGFja1JhbmdlID0gdGhpcy5hdHRhY2tSYW5nZTtcbiAgICBjbG9uZS5hdHRhY2tEYW1hZ2UgPSB0aGlzLmF0dGFja0RhbWFnZTtcbiAgICBjbG9uZS5hdHRhY2tDb29sZG93biA9IHRoaXMuYXR0YWNrQ29vbGRvd247XG4gICAgY2xvbmUubGFzdEF0dGFja1RpbWUgPSB0aGlzLmxhc3RBdHRhY2tUaW1lO1xuICAgIGNsb25lLnByb2plY3RpbGVTcGVlZCA9IHRoaXMucHJvamVjdGlsZVNwZWVkO1xuICAgIGNsb25lLmN1cnJlbnRUYXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXQ7XG4gICAgY2xvbmUudGFyZ2V0U2VhcmNoUmFuZ2UgPSB0aGlzLnRhcmdldFNlYXJjaFJhbmdlO1xuICAgIGNsb25lLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gdGhpcy5sYXN0VGFyZ2V0U2VhcmNoVGltZTtcbiAgICBjbG9uZS50YXJnZXRTZWFyY2hDb29sZG93biA9IHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd247XG4gICAgY2xvbmUuaXNBY3RpdmUgPSB0aGlzLmlzQWN0aXZlO1xuICAgIGNsb25lLmlzRGVhZCA9IHRoaXMuaXNEZWFkO1xuICAgIGNsb25lLmRlYXRoVGltZSA9IHRoaXMuZGVhdGhUaW1lO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIlRvd2VyIiwiY2FuQXR0YWNrIiwiY3VycmVudFRpbWUiLCJpc0FjdGl2ZSIsImlzRGVhZCIsImN1cnJlbnRUYXJnZXQiLCJsYXN0QXR0YWNrVGltZSIsImF0dGFja0Nvb2xkb3duIiwicGVyZm9ybUF0dGFjayIsImNhblNlYXJjaEZvclRhcmdldHMiLCJsYXN0VGFyZ2V0U2VhcmNoVGltZSIsInRhcmdldFNlYXJjaENvb2xkb3duIiwidXBkYXRlVGFyZ2V0U2VhcmNoIiwic2V0VGFyZ2V0IiwidGFyZ2V0RW50aXR5SWQiLCJjbGVhclRhcmdldCIsImRpZSIsImRlYXRoVGltZSIsImdldERpc3BsYXlOYW1lIiwidG93ZXJJbmRleCIsIm93bmVySWQiLCJyZXNldCIsImF0dGFja1JhbmdlIiwiYXR0YWNrRGFtYWdlIiwicHJvamVjdGlsZVNwZWVkIiwidGFyZ2V0U2VhcmNoUmFuZ2UiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Tower.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Transform.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/Transform.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Transform component for position, rotation, and scale\n\n\nclass Transform extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    translate(x, y, z) {\n        this.position.x += x;\n        this.position.y += y;\n        this.position.z += z;\n        this.markMatrixDirty();\n    }\n    rotate(x, y, z) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    lookAt(target) {\n        let up = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.lookAt(this.position, target, up);\n        this.quaternion.setFromRotationMatrix(matrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.markMatrixDirty();\n    }\n    getForward() {\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    getRight() {\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    getUp() {\n        const up = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n    getWorldPosition() {\n        this.updateWorldMatrix();\n        const worldPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldPosition.setFromMatrixPosition(this.worldMatrix);\n        return worldPosition;\n    }\n    getWorldRotation() {\n        this.updateWorldMatrix();\n        const worldQuaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        worldQuaternion.setFromRotationMatrix(this.worldMatrix);\n        return worldQuaternion;\n    }\n    getWorldScale() {\n        this.updateWorldMatrix();\n        const worldScale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldScale.setFromMatrixScale(this.worldMatrix);\n        return worldScale;\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixNeedsUpdate = false;\n    }\n    updateWorldMatrix() {\n        if (this.matrixNeedsUpdate) {\n            this.updateMatrix();\n        }\n        if (this.parent) {\n            this.parent.updateWorldMatrix();\n            this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.matrix);\n        } else {\n            this.worldMatrix.copy(this.matrix);\n        }\n    }\n    addChild(child) {\n        if (child.parent) {\n            child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.children.push(child);\n    }\n    removeChild(child) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n            child.parent = null;\n        }\n    }\n    removeFromParent() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    }\n    updateQuaternion() {\n        this.quaternion.setFromEuler(this.rotation);\n    }\n    markMatrixDirty() {\n        this.matrixNeedsUpdate = true;\n        // Mark all children as dirty too\n        for (const child of this.children){\n            child.markMatrixDirty();\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.position) {\n            this.position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.position.set(0, 0, 0);\n        }\n        if (!this.rotation) {\n            this.rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0);\n        } else {\n            this.rotation.set(0, 0, 0);\n        }\n        if (!this.scale) {\n            this.scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        } else {\n            this.scale.set(1, 1, 1);\n        }\n        if (!this.quaternion) {\n            this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        } else {\n            this.quaternion.set(0, 0, 0, 1);\n        }\n        if (!this.matrix) {\n            this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.matrix.identity();\n        }\n        if (!this.worldMatrix) {\n            this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.worldMatrix.identity();\n        }\n        this.matrixNeedsUpdate = true;\n        // Clear parent-child relationships\n        this.removeFromParent();\n        while(this.children.length > 0){\n            this.removeChild(this.children[0]);\n        }\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Transform(this.position, this.rotation, this.scale);\n        clone.quaternion.copy(this.quaternion);\n        return clone;\n    }\n    constructor(position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0), scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)){\n        super();\n        this.componentType = \"Transform\" // Instance identifier\n        ;\n        this.matrixNeedsUpdate = true;\n        // Parent-child relationships\n        this.parent = null;\n        this.children = [];\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.updateQuaternion();\n    }\n}\nTransform.componentType = \"Transform\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0RBQXdEO0FBQ29CO0FBQ3RDO0FBRS9CLE1BQU1LLGtCQUFrQkQsOENBQVNBO0lBa0MvQkUsWUFBWUMsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT0MsWUFBWU4sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNLLFFBQVEsQ0FBQ0gsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT0ksU0FBU1QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNyRCxJQUFJLENBQUNRLEtBQUssQ0FBQ04sR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUNyQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT00sVUFBVVgsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN0RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0QsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT08sT0FBT1osQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNuRCxJQUFJLENBQUNLLFFBQVEsQ0FBQ1AsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNPLFFBQVEsQ0FBQ04sQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJQTtRQUNuQixJQUFJ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QkFBZ0IsWUFBYSxzQkFBc0I7O2FBUzVEcEIsb0JBQW9CO1FBRTNCLDZCQUE2QjthQUN0QkMsU0FBMkI7YUFDM0JNLFdBQXdCLEVBQUU7UUFTL0IsSUFBSSxDQUFDMUMsUUFBUSxHQUFHQSxTQUFTcUQsS0FBSztRQUM5QixJQUFJLENBQUNqRCxRQUFRLEdBQUdBLFNBQVNpRCxLQUFLO1FBQzlCLElBQUksQ0FBQzlDLEtBQUssR0FBR0EsTUFBTThDLEtBQUs7UUFDeEIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHLElBQUl0Qiw0REFBVUE7UUFDaEMsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlwQix5REFBT0E7UUFDekIsSUFBSSxDQUFDa0MsV0FBVyxHQUFHLElBQUlsQyx5REFBT0E7UUFFOUIsSUFBSSxDQUFDWSxnQkFBZ0I7SUFDdkI7QUE0TEY7QUE1TmFWLFVBQ1k0RCxnQkFBZ0IsWUFBYSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybS50cz9mY2JhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zZm9ybSBjb21wb25lbnQgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5kIHNjYWxlXG5pbXBvcnQgeyBWZWN0b3IzLCBFdWxlciwgUXVhdGVybmlvbiwgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1RyYW5zZm9ybSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUcmFuc2Zvcm0nOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHVibGljIHJvdGF0aW9uOiBFdWxlcjtcbiAgcHVibGljIHNjYWxlOiBWZWN0b3IzO1xuICBwdWJsaWMgcXVhdGVybmlvbjogUXVhdGVybmlvbjtcblxuICAvLyBDYWNoZWQgbWF0cmljZXMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBtYXRyaXg6IE1hdHJpeDQ7XG4gIHB1YmxpYyB3b3JsZE1hdHJpeDogTWF0cml4NDtcbiAgcHVibGljIG1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBQYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICBwdWJsaWMgcGFyZW50OiBUcmFuc2Zvcm0gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBUcmFuc2Zvcm1bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgcm90YXRpb246IEV1bGVyID0gbmV3IEV1bGVyKDAsIDAsIDApLFxuICAgIHNjYWxlOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSlcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUuY2xvbmUoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRSb3RhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy51cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTY2FsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zY2FsZS5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2xhdGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24ueCArPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSArPSB5O1xuICAgIHRoaXMucG9zaXRpb24ueiArPSB6O1xuICAgIHRoaXMubWFya01hdHJpeERpcnR5KCk7XG4gIH1cblxuICBwdWJsaWMgcm90YXRlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJvdGF0aW9uLnggKz0geDtcbiAgICB0aGlzLnJvdGF0aW9uLnkgKz0geTtcbiAgICB0aGlzLnJvdGF0aW9uLnogKz0gejtcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGxvb2tBdCh0YXJnZXQ6IFZlY3RvcjMsIHVwOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCkpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIG1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB1cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGdldEZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldFJpZ2h0KCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgcmlnaHQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldFVwKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgdXAuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHVwO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUG9zaXRpb24oKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUm90YXRpb24oKTogUXVhdGVybmlvbiB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgd29ybGRRdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICByZXR1cm4gd29ybGRRdWF0ZXJuaW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkU2NhbGUoKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFNjYWxlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdHJpeE5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICAgIHRoaXMud29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChjaGlsZDogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVhdGVybmlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMucm90YXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrTWF0cml4RGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gTWFyayBhbGwgY2hpbGRyZW4gYXMgZGlydHkgdG9vXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5tYXJrTWF0cml4RGlydHkoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5yb3RhdGlvbikge1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLndvcmxkTWF0cml4KSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JsZE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogVHJhbnNmb3JtIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbiwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgY2xvbmUucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkV1bGVyIiwiUXVhdGVybmlvbiIsIk1hdHJpeDQiLCJDb21wb25lbnQiLCJUcmFuc2Zvcm0iLCJzZXRQb3NpdGlvbiIsIngiLCJ5IiwieiIsInBvc2l0aW9uIiwic2V0IiwibWFya01hdHJpeERpcnR5Iiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsInVwZGF0ZVF1YXRlcm5pb24iLCJzZXRTY2FsZSIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwibG9va0F0IiwidGFyZ2V0IiwidXAiLCJtYXRyaXgiLCJxdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4Iiwic2V0RnJvbVF1YXRlcm5pb24iLCJnZXRGb3J3YXJkIiwiZm9yd2FyZCIsImFwcGx5UXVhdGVybmlvbiIsImdldFJpZ2h0IiwicmlnaHQiLCJnZXRVcCIsImdldFdvcmxkUG9zaXRpb24iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIndvcmxkUG9zaXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJ3b3JsZE1hdHJpeCIsImdldFdvcmxkUm90YXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJnZXRXb3JsZFNjYWxlIiwid29ybGRTY2FsZSIsInNldEZyb21NYXRyaXhTY2FsZSIsInVwZGF0ZU1hdHJpeCIsImNvbXBvc2UiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInBhcmVudCIsIm11bHRpcGx5TWF0cmljZXMiLCJjb3B5IiwiYWRkQ2hpbGQiLCJjaGlsZCIsInJlbW92ZUNoaWxkIiwiY2hpbGRyZW4iLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRnJvbVBhcmVudCIsInNldEZyb21FdWxlciIsInJlc2V0IiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Transform.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CameraSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CameraSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSystem: function() { return /* binding */ CameraSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/MathUtils */ \"(app-pages-browser)/./src/utils/MathUtils.ts\");\n// Camera system for third-person camera controls\n\n\n\n\nclass CameraSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setTarget(entity) {\n        this.target = entity;\n    }\n    setConfig(config) {\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.spherical.radius = this.config.distance;\n    }\n    update(entities, deltaTime) {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) return;\n        // Handle mouse input for camera rotation\n        this.handleMouseInput();\n        // Update target position\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        // Calculate camera position based on spherical coordinates\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        // Smooth camera movement\n        this.currentPosition.lerp(this.targetPosition, this.config.smoothing);\n        this.currentLookAt.lerp(this.targetLookAt, this.config.smoothing);\n        // Update camera\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    handleMouseInput() {\n        const mouseDelta = this.inputManager.getMouseDelta();\n        // Only rotate camera when right mouse button is held down\n        if ((mouseDelta.x !== 0 || mouseDelta.y !== 0) && this.isRightMouseDown) {\n            // Update spherical coordinates based on mouse movement\n            this.spherical.theta -= mouseDelta.x * this.config.mouseSensitivity;\n            this.spherical.phi -= mouseDelta.y * this.config.mouseSensitivity; // Inverted Y for natural camera feel\n            // Clamp phi to prevent camera flipping\n            this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.phi, this.config.minPolarAngle, this.config.maxPolarAngle);\n            // Normalize theta\n            this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(this.spherical.theta);\n        }\n    }\n    setupEventListeners() {\n        // Mouse button events for camera rotation\n        this.inputManager.on(\"mouseDown\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = true;\n            }\n        });\n        this.inputManager.on(\"mouseUp\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = false;\n            }\n        });\n        // Mouse wheel for zoom - only add listener once\n        if (!this.wheelListenerAdded) {\n            this.inputManager.on(\"wheel\", (param)=>{\n                let { deltaY } = param;\n                this.spherical.radius += deltaY * 0.01;\n                this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.radius, 2, this.config.maxDistance);\n            });\n            this.wheelListenerAdded = true;\n        }\n    }\n    setupInitialPosition() {\n        this.currentPosition.setFromSpherical(this.spherical);\n        this.currentLookAt.set(0, this.config.height, 0);\n        this.targetPosition.copy(this.currentPosition);\n        this.targetLookAt.copy(this.currentLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    // Utility methods\n    getCameraDirection() {\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        return direction;\n    }\n    getCameraRight() {\n        const direction = this.getCameraDirection();\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        right.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n        right.normalize();\n        return right;\n    }\n    getCameraForward() {\n        const right = this.getCameraRight();\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        forward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), right);\n        forward.normalize();\n        return forward;\n    }\n    getDistance() {\n        return this.spherical.radius;\n    }\n    setDistance(distance) {\n        this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(distance, 2, this.config.maxDistance);\n    }\n    getHorizontalAngle() {\n        return this.spherical.theta;\n    }\n    getVerticalAngle() {\n        return this.spherical.phi;\n    }\n    setAngles(horizontal, vertical) {\n        this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(horizontal);\n        this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(vertical, this.config.minPolarAngle, this.config.maxPolarAngle);\n    }\n    resetCamera() {\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3;\n        this.spherical.theta = 0;\n        this.setupInitialPosition();\n    }\n    snapToTarget() {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform || !targetTransform.position) return;\n        // Safety check: ensure position is properly initialized\n        if (targetTransform.position.x === undefined || targetTransform.position.y === undefined || targetTransform.position.z === undefined) {\n            return;\n        }\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        this.currentPosition.copy(this.targetPosition);\n        this.currentLookAt.copy(this.targetLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    getCamera() {\n        return this.camera;\n    }\n    constructor(camera, inputManager, config){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform\n        ];\n        this.target = null;\n        // Camera configuration\n        this.config = {\n            distance: 10,\n            height: 5,\n            mouseSensitivity: 0.005,\n            smoothing: 0.1,\n            minPolarAngle: Math.PI / 3.5,\n            maxPolarAngle: Math.PI / 2.5,\n            maxDistance: 11.5\n        };\n        // Camera state\n        this.spherical = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Spherical(10, Math.PI / 3, 0);\n        this.targetPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.targetLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Mouse state for camera rotation\n        this.isRightMouseDown = false;\n        this.wheelListenerAdded = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.priority = 900; // Run late, after movement\n        if (config) {\n            this.config = {\n                ...this.config,\n                ...config\n            };\n        }\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3; // Start at 60 degrees\n        this.spherical.theta = 0;\n        this.setupEventListeners();\n        this.setupInitialPosition();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NhbWVyYVN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlEQUFpRDtBQUM2QjtBQUN4QztBQUVpQjtBQUVUO0FBWXZDLE1BQU1LLHFCQUFxQkgsK0NBQU1BO0lBOEMvQkksVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNoQjtJQUVPRSxVQUFVQyxNQUE2QixFQUFRO1FBQ3BELElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07WUFBRSxHQUFHQSxNQUFNO1FBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtJQUM5QztJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNSLE1BQU0sRUFBRTtRQUVsQixNQUFNUyxrQkFBa0IsSUFBSSxDQUFDVCxNQUFNLENBQUNVLFlBQVksQ0FBQ2YsZ0VBQVNBO1FBQzFELElBQUksQ0FBQ2MsaUJBQWlCO1FBRXRCLHlDQUF5QztRQUN6QyxJQUFJLENBQUNFLGdCQUFnQjtRQUVyQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksQ0FBQ0osZ0JBQWdCSyxRQUFRO1FBQy9DLElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxDQUFDLElBQUksSUFBSSxDQUFDYixNQUFNLENBQUNjLE1BQU07UUFFekMsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNmLFNBQVM7UUFDbkQsSUFBSSxDQUFDYyxjQUFjLENBQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFlBQVk7UUFFekMseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1EsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDSixjQUFjLEVBQUUsSUFB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QyxRQUFRLEdBQUcsS0FBSywyQkFBMkI7UUFFaEQsSUFBSXJFLFFBQVE7WUFDVixJQUFJLENBQUNBLE1BQU0sR0FBRztnQkFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtnQkFBRSxHQUFHQSxNQUFNO1lBQUM7UUFDNUM7UUFFQSxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxRQUFRO1FBQzVDLElBQUksQ0FBQ0YsU0FBUyxDQUFDOEIsR0FBRyxHQUFHOEIsS0FBS0MsRUFBRSxHQUFHLEdBQUcsc0JBQXNCO1FBQ3hELElBQUksQ0FBQzdELFNBQVMsQ0FBQzRCLEtBQUssR0FBRztRQUV2QixJQUFJLENBQUNPLG1CQUFtQjtRQUN4QixJQUFJLENBQUNNLG9CQUFvQjtJQUMzQjtBQWdMRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9DYW1lcmFTeXN0ZW0udHM/Y2RmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYW1lcmEgc3lzdGVtIGZvciB0aGlyZC1wZXJzb24gY2FtZXJhIGNvbnRyb2xzXG5pbXBvcnQgeyBQZXJzcGVjdGl2ZUNhbWVyYSwgU3BoZXJpY2FsLCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgSW5wdXRNYW5hZ2VyIH0gZnJvbSAnQC9jb3JlL0lucHV0TWFuYWdlcic7XG5pbXBvcnQgeyBNYXRoVXRpbHMgfSBmcm9tICdAL3V0aWxzL01hdGhVdGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FtZXJhQ29uZmlnIHtcbiAgZGlzdGFuY2U6IG51bWJlcjtcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIG1vdXNlU2Vuc2l0aXZpdHk6IG51bWJlcjtcbiAgc21vb3RoaW5nOiBudW1iZXI7XG4gIG1pblBvbGFyQW5nbGU6IG51bWJlcjtcbiAgbWF4UG9sYXJBbmdsZTogbnVtYmVyO1xuICBtYXhEaXN0YW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FtZXJhU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm1dO1xuICBwcml2YXRlIGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmE7XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgdGFyZ2V0OiBFbnRpdHkgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIENhbWVyYSBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgY29uZmlnOiBDYW1lcmFDb25maWcgPSB7XG4gICAgZGlzdGFuY2U6IDEwLFxuICAgIGhlaWdodDogNSxcbiAgICBtb3VzZVNlbnNpdGl2aXR5OiAwLjAwNSwgLy8gSW5jcmVhc2VkIGZvciBiZXR0ZXIgcmVzcG9uc2l2ZW5lc3NcbiAgICBzbW9vdGhpbmc6IDAuMSxcbiAgICBtaW5Qb2xhckFuZ2xlOiBNYXRoLlBJIC8gMy41LCAvLyBQcmV2ZW50IGNhbWVyYSBmcm9tIGdvaW5nIGFib3ZlIGhvcml6b25cbiAgICBtYXhQb2xhckFuZ2xlOiBNYXRoLlBJIC8gMi41LCAvLyBQcmV2ZW50IGNhbWVyYSBmcm9tIGxvb2tpbmcgdW5kZXJuZWF0aCB0aGUgbWFwXG4gICAgbWF4RGlzdGFuY2U6IDExLjUsXG4gIH07XG5cbiAgLy8gQ2FtZXJhIHN0YXRlXG4gIHByaXZhdGUgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgxMCwgTWF0aC5QSSAvIDMsIDApO1xuICBwcml2YXRlIHRhcmdldFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBjdXJyZW50UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIGN1cnJlbnRMb29rQXQgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIHRhcmdldExvb2tBdCA9IG5ldyBWZWN0b3IzKCk7XG4gIFxuICAvLyBNb3VzZSBzdGF0ZSBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gIHByaXZhdGUgaXNSaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICBwcml2YXRlIHdoZWVsTGlzdGVuZXJBZGRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGNhbWVyYTogUGVyc3BlY3RpdmVDYW1lcmEsIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyLCBjb25maWc/OiBQYXJ0aWFsPENhbWVyYUNvbmZpZz4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gaW5wdXRNYW5hZ2VyO1xuICAgIHRoaXMucHJpb3JpdHkgPSA5MDA7IC8vIFJ1biBsYXRlLCBhZnRlciBtb3ZlbWVudFxuXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoLlBJIC8gMzsgLy8gU3RhcnQgYXQgNjAgZGVncmVlc1xuICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhID0gMDtcblxuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRUYXJnZXQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICB0aGlzLnRhcmdldCA9IGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb25maWcoY29uZmlnOiBQYXJ0aWFsPENhbWVyYUNvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IHRoaXMuY29uZmlnLmRpc3RhbmNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0pIHJldHVybjtcblxuICAgIC8vIEhhbmRsZSBtb3VzZSBpbnB1dCBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gICAgdGhpcy5oYW5kbGVNb3VzZUlucHV0KCk7XG5cbiAgICAvLyBVcGRhdGUgdGFyZ2V0IHBvc2l0aW9uXG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGFyZ2V0TG9va0F0LnkgKz0gdGhpcy5jb25maWcuaGVpZ2h0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIGNhbWVyYSBwb3NpdGlvbiBiYXNlZCBvbiBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLnNldEZyb21TcGhlcmljYWwodGhpcy5zcGhlcmljYWwpO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uYWRkKHRoaXMudGFyZ2V0TG9va0F0KTtcblxuICAgIC8vIFNtb290aCBjYW1lcmEgbW92ZW1lbnRcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5sZXJwKHRoaXMudGFyZ2V0UG9zaXRpb24sIHRoaXMuY29uZmlnLnNtb290aGluZyk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LmxlcnAodGhpcy50YXJnZXRMb29rQXQsIHRoaXMuY29uZmlnLnNtb290aGluZyk7XG5cbiAgICAvLyBVcGRhdGUgY2FtZXJhXG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy5jYW1lcmEubG9va0F0KHRoaXMuY3VycmVudExvb2tBdCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1vdXNlSW5wdXQoKTogdm9pZCB7XG4gICAgY29uc3QgbW91c2VEZWx0YSA9IHRoaXMuaW5wdXRNYW5hZ2VyLmdldE1vdXNlRGVsdGEoKTtcbiAgICBcbiAgICAvLyBPbmx5IHJvdGF0ZSBjYW1lcmEgd2hlbiByaWdodCBtb3VzZSBidXR0b24gaXMgaGVsZCBkb3duXG4gICAgaWYgKChtb3VzZURlbHRhLnggIT09IDAgfHwgbW91c2VEZWx0YS55ICE9PSAwKSAmJiB0aGlzLmlzUmlnaHRNb3VzZURvd24pIHtcbiAgICAgIC8vIFVwZGF0ZSBzcGhlcmljYWwgY29vcmRpbmF0ZXMgYmFzZWQgb24gbW91c2UgbW92ZW1lbnRcbiAgICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhIC09IG1vdXNlRGVsdGEueCAqIHRoaXMuY29uZmlnLm1vdXNlU2Vuc2l0aXZpdHk7XG4gICAgICB0aGlzLnNwaGVyaWNhbC5waGkgLT0gbW91c2VEZWx0YS55ICogdGhpcy5jb25maWcubW91c2VTZW5zaXRpdml0eTsgLy8gSW52ZXJ0ZWQgWSBmb3IgbmF0dXJhbCBjYW1lcmEgZmVlbFxuXG4gICAgICAvLyBDbGFtcCBwaGkgdG8gcHJldmVudCBjYW1lcmEgZmxpcHBpbmdcbiAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSA9IE1hdGhVdGlscy5jbGFtcChcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucGhpLFxuICAgICAgICB0aGlzLmNvbmZpZy5taW5Qb2xhckFuZ2xlLFxuICAgICAgICB0aGlzLmNvbmZpZy5tYXhQb2xhckFuZ2xlXG4gICAgICApO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhldGFcbiAgICAgIHRoaXMuc3BoZXJpY2FsLnRoZXRhID0gTWF0aFV0aWxzLm5vcm1hbGl6ZUFuZ2xlKHRoaXMuc3BoZXJpY2FsLnRoZXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgLy8gTW91c2UgYnV0dG9uIGV2ZW50cyBmb3IgY2FtZXJhIHJvdGF0aW9uXG4gICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ21vdXNlRG93bicsICh7IGJ1dHRvbiB9KSA9PiB7XG4gICAgICBpZiAoYnV0dG9uID09PSAyKSB7IC8vIFJpZ2h0IG1vdXNlIGJ1dHRvblxuICAgICAgICB0aGlzLmlzUmlnaHRNb3VzZURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ21vdXNlVXAnLCAoeyBidXR0b24gfSkgPT4ge1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMikgeyAvLyBSaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgdGhpcy5pc1JpZ2h0TW91c2VEb3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNb3VzZSB3aGVlbCBmb3Igem9vbSAtIG9ubHkgYWRkIGxpc3RlbmVyIG9uY2VcbiAgICBpZiAoIXRoaXMud2hlZWxMaXN0ZW5lckFkZGVkKSB7XG4gICAgICB0aGlzLmlucHV0TWFuYWdlci5vbignd2hlZWwnLCAoeyBkZWx0YVkgfSkgPT4ge1xuICAgICAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgKz0gZGVsdGFZICogMC4wMTtcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gTWF0aFV0aWxzLmNsYW1wKHRoaXMuc3BoZXJpY2FsLnJhZGl1cywgMiwgdGhpcy5jb25maWcubWF4RGlzdGFuY2UpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLndoZWVsTGlzdGVuZXJBZGRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEluaXRpYWxQb3NpdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLmN1cnJlbnRMb29rQXQuc2V0KDAsIHRoaXMuY29uZmlnLmhlaWdodCwgMCk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5jb3B5KHRoaXMuY3VycmVudFBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC5jb3B5KHRoaXMuY3VycmVudExvb2tBdCk7XG4gICAgXG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy5jYW1lcmEubG9va0F0KHRoaXMuY3VycmVudExvb2tBdCk7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHVibGljIGdldENhbWVyYURpcmVjdGlvbigpOiBWZWN0b3IzIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmFSaWdodCgpOiBWZWN0b3IzIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldENhbWVyYURpcmVjdGlvbigpO1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYUZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLmdldENhbWVyYVJpZ2h0KCk7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgZm9yd2FyZC5jcm9zc1ZlY3RvcnMobmV3IFZlY3RvcjMoMCwgMSwgMCksIHJpZ2h0KTtcbiAgICBmb3J3YXJkLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldERpc3RhbmNlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnJhZGl1cztcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXN0YW5jZShkaXN0YW5jZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gTWF0aFV0aWxzLmNsYW1wKGRpc3RhbmNlLCAyLCB0aGlzLmNvbmZpZy5tYXhEaXN0YW5jZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SG9yaXpvbnRhbEFuZ2xlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnRoZXRhO1xuICB9XG5cbiAgcHVibGljIGdldFZlcnRpY2FsQW5nbGUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zcGhlcmljYWwucGhpO1xuICB9XG5cbiAgcHVibGljIHNldEFuZ2xlcyhob3Jpem9udGFsOiBudW1iZXIsIHZlcnRpY2FsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IE1hdGhVdGlscy5ub3JtYWxpemVBbmdsZShob3Jpem9udGFsKTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICB2ZXJ0aWNhbCxcbiAgICAgIHRoaXMuY29uZmlnLm1pblBvbGFyQW5nbGUsXG4gICAgICB0aGlzLmNvbmZpZy5tYXhQb2xhckFuZ2xlXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldENhbWVyYSgpOiB2b2lkIHtcbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoLlBJIC8gMztcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IDA7XG4gICAgdGhpcy5zZXR1cEluaXRpYWxQb3NpdGlvbigpO1xuICB9XG5cbiAgcHVibGljIHNuYXBUb1RhcmdldCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMudGFyZ2V0KSByZXR1cm47XG5cbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0aGlzLnRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXRhcmdldFRyYW5zZm9ybSB8fCAhdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKSByZXR1cm47XG5cbiAgICAvLyBTYWZldHkgY2hlY2s6IGVuc3VyZSBwb3NpdGlvbiBpcyBwcm9wZXJseSBpbml0aWFsaXplZFxuICAgIGlmICh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24ueCA9PT0gdW5kZWZpbmVkIHx8IFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24ueSA9PT0gdW5kZWZpbmVkIHx8IFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24ueiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGFyZ2V0TG9va0F0LnkgKz0gdGhpcy5jb25maWcuaGVpZ2h0O1xuXG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLmFkZCh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5jb3B5KHRoaXMudGFyZ2V0UG9zaXRpb24pO1xuICAgIHRoaXMuY3VycmVudExvb2tBdC5jb3B5KHRoaXMudGFyZ2V0TG9va0F0KTtcblxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYSgpOiBQZXJzcGVjdGl2ZUNhbWVyYSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU3BoZXJpY2FsIiwiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIk1hdGhVdGlscyIsIkNhbWVyYVN5c3RlbSIsInNldFRhcmdldCIsImVudGl0eSIsInRhcmdldCIsInNldENvbmZpZyIsImNvbmZpZyIsInNwaGVyaWNhbCIsInJhZGl1cyIsImRpc3RhbmNlIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJ0YXJnZXRUcmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoYW5kbGVNb3VzZUlucHV0IiwidGFyZ2V0TG9va0F0IiwiY29weSIsInBvc2l0aW9uIiwieSIsImhlaWdodCIsInRhcmdldFBvc2l0aW9uIiwic2V0RnJvbVNwaGVyaWNhbCIsImFkZCIsImN1cnJlbnRQb3NpdGlvbiIsImxlcnAiLCJzbW9vdGhpbmciLCJjdXJyZW50TG9va0F0IiwiY2FtZXJhIiwibG9va0F0IiwibW91c2VEZWx0YSIsImlucHV0TWFuYWdlciIsImdldE1vdXNlRGVsdGEiLCJ4IiwiaXNSaWdodE1vdXNlRG93biIsInRoZXRhIiwibW91c2VTZW5zaXRpdml0eSIsInBoaSIsImNsYW1wIiwibWluUG9sYXJBbmdsZSIsIm1heFBvbGFyQW5nbGUiLCJub3JtYWxpemVBbmdsZSIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJvbiIsImJ1dHRvbiIsIndoZWVsTGlzdGVuZXJBZGRlZCIsImRlbHRhWSIsIm1heERpc3RhbmNlIiwic2V0dXBJbml0aWFsUG9zaXRpb24iLCJzZXQiLCJnZXRDYW1lcmFEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJnZXRXb3JsZERpcmVjdGlvbiIsImdldENhbWVyYVJpZ2h0IiwicmlnaHQiLCJjcm9zc1ZlY3RvcnMiLCJub3JtYWxpemUiLCJnZXRDYW1lcmFGb3J3YXJkIiwiZm9yd2FyZCIsImdldERpc3RhbmNlIiwic2V0RGlzdGFuY2UiLCJnZXRIb3Jpem9udGFsQW5nbGUiLCJnZXRWZXJ0aWNhbEFuZ2xlIiwic2V0QW5nbGVzIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwicmVzZXRDYW1lcmEiLCJNYXRoIiwiUEkiLCJzbmFwVG9UYXJnZXQiLCJ1bmRlZmluZWQiLCJ6IiwiZ2V0Q2FtZXJhIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CameraSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CollisionSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/CollisionSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionSystem: function() { return /* binding */ CollisionSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/SpatialHash */ \"(app-pages-browser)/./src/utils/SpatialHash.ts\");\n// Collision system for efficient collision detection and response\n\n\n\n\n\n\nclass CollisionSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for trigger detection and broad phase\n        this.updateSpatialHash(entities);\n        this.detectCollisions(entities);\n        this.processCollisionCallbacks();\n        // Also resolve collisions in update() to ensure immediate response\n        this.resolveCollisions();\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics collision response\n        this.resolveCollisions();\n    }\n    updateSpatialHash(entities) {\n        // Update spatial hash with current entity positions\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) {\n                this.spatialHash.remove(entity);\n                continue;\n            }\n            // Update collider bounds\n            collider.updateBounds(transform.getWorldPosition());\n            // Update spatial hash\n            this.spatialHash.update(entity, collider.bounds);\n        }\n    }\n    detectCollisions(entities) {\n        this.collisionPairs.length = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        const processedPairs = new Set();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) continue;\n            // Query spatial hash for potential collisions\n            const candidates = this.spatialHash.query(collider.bounds);\n            for (const candidate of candidates){\n                const otherEntity = candidate.entity;\n                // Skip self\n                if (entity.id === otherEntity.id) continue;\n                // Create unique pair key (smaller ID first)\n                const pairKey = entity.id < otherEntity.id ? \"\".concat(entity.id, \"-\").concat(otherEntity.id) : \"\".concat(otherEntity.id, \"-\").concat(entity.id);\n                // Skip if already processed this pair\n                if (processedPairs.has(pairKey)) continue;\n                processedPairs.add(pairKey);\n                const otherTransform = otherEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const otherCollider = otherEntity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n                if (!(otherTransform === null || otherTransform === void 0 ? void 0 : otherTransform.enabled) || !(otherCollider === null || otherCollider === void 0 ? void 0 : otherCollider.enabled)) continue;\n                // Check if colliders can collide\n                if (!collider.canCollideWith(otherCollider)) continue;\n                this.collisionChecks++;\n                // Precise collision detection\n                if (collider.intersects(otherCollider, transform.getWorldPosition(), otherTransform.getWorldPosition())) {\n                    this.actualCollisions++;\n                    // Debug logging for pillar collisions\n                    if (collider.layer === 2 && otherCollider.layer === 16 || collider.layer === 16 && otherCollider.layer === 2) {}\n                    const pair = {\n                        entityA: entity,\n                        entityB: otherEntity,\n                        colliderA: collider,\n                        colliderB: otherCollider\n                    };\n                    this.collisionPairs.push(pair);\n                }\n            }\n        }\n    }\n    processCollisionCallbacks() {\n        const currentCollisions = new Map();\n        // Process current collisions\n        for (const pair of this.collisionPairs){\n            const pairKey = pair.entityA.id < pair.entityB.id ? \"\".concat(pair.entityA.id, \"-\").concat(pair.entityB.id) : \"\".concat(pair.entityB.id, \"-\").concat(pair.entityA.id);\n            currentCollisions.set(pairKey, pair);\n            // Check if this is a new collision\n            if (!this.activeCollisions.has(pairKey)) {\n                // New collision - trigger enter events\n                this.triggerCollisionEnter(pair);\n            } else {\n                // Ongoing collision - trigger stay events\n                this.triggerCollisionStay(pair);\n            }\n        }\n        // Check for collisions that ended\n        this.activeCollisions.forEach((pair, pairKey)=>{\n            if (!currentCollisions.has(pairKey)) {\n                // Collision ended - trigger exit events\n                this.triggerCollisionExit(pair);\n            }\n        });\n        // Update active collisions\n        this.activeCollisions = currentCollisions;\n    }\n    triggerCollisionEnter(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerEnter, _pair_colliderA, _pair_colliderB_onTriggerEnter, _pair_colliderB;\n            (_pair_colliderA_onTriggerEnter = (_pair_colliderA = pair.colliderA).onTriggerEnter) === null || _pair_colliderA_onTriggerEnter === void 0 ? void 0 : _pair_colliderA_onTriggerEnter.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerEnter = (_pair_colliderB = pair.colliderB).onTriggerEnter) === null || _pair_colliderB_onTriggerEnter === void 0 ? void 0 : _pair_colliderB_onTriggerEnter.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionEnter, _pair_colliderA1, _pair_colliderB_onCollisionEnter, _pair_colliderB1;\n            (_pair_colliderA_onCollisionEnter = (_pair_colliderA1 = pair.colliderA).onCollisionEnter) === null || _pair_colliderA_onCollisionEnter === void 0 ? void 0 : _pair_colliderA_onCollisionEnter.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionEnter = (_pair_colliderB1 = pair.colliderB).onCollisionEnter) === null || _pair_colliderB_onCollisionEnter === void 0 ? void 0 : _pair_colliderB_onCollisionEnter.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionStay(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerStay, _pair_colliderA, _pair_colliderB_onTriggerStay, _pair_colliderB;\n            (_pair_colliderA_onTriggerStay = (_pair_colliderA = pair.colliderA).onTriggerStay) === null || _pair_colliderA_onTriggerStay === void 0 ? void 0 : _pair_colliderA_onTriggerStay.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerStay = (_pair_colliderB = pair.colliderB).onTriggerStay) === null || _pair_colliderB_onTriggerStay === void 0 ? void 0 : _pair_colliderB_onTriggerStay.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionStay, _pair_colliderA1, _pair_colliderB_onCollisionStay, _pair_colliderB1;\n            (_pair_colliderA_onCollisionStay = (_pair_colliderA1 = pair.colliderA).onCollisionStay) === null || _pair_colliderA_onCollisionStay === void 0 ? void 0 : _pair_colliderA_onCollisionStay.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionStay = (_pair_colliderB1 = pair.colliderB).onCollisionStay) === null || _pair_colliderB_onCollisionStay === void 0 ? void 0 : _pair_colliderB_onCollisionStay.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionExit(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerExit, _pair_colliderA, _pair_colliderB_onTriggerExit, _pair_colliderB;\n            (_pair_colliderA_onTriggerExit = (_pair_colliderA = pair.colliderA).onTriggerExit) === null || _pair_colliderA_onTriggerExit === void 0 ? void 0 : _pair_colliderA_onTriggerExit.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerExit = (_pair_colliderB = pair.colliderB).onTriggerExit) === null || _pair_colliderB_onTriggerExit === void 0 ? void 0 : _pair_colliderB_onTriggerExit.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionExit, _pair_colliderA1, _pair_colliderB_onCollisionExit, _pair_colliderB1;\n            (_pair_colliderA_onCollisionExit = (_pair_colliderA1 = pair.colliderA).onCollisionExit) === null || _pair_colliderA_onCollisionExit === void 0 ? void 0 : _pair_colliderA_onCollisionExit.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionExit = (_pair_colliderB1 = pair.colliderB).onCollisionExit) === null || _pair_colliderB_onCollisionExit === void 0 ? void 0 : _pair_colliderB_onCollisionExit.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    resolveCollisions() {\n        // Resolve physical collisions (non-trigger)\n        for (const pair of this.collisionPairs){\n            if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n                continue; // Skip triggers\n            }\n            this.resolveCollision(pair);\n        }\n    }\n    resolveCollision(pair) {\n        const transformA = pair.entityA.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const transformB = pair.entityB.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const posA = transformA.getWorldPosition();\n        const posB = transformB.getWorldPosition();\n        // Calculate separation vector with safety checks\n        if (!posA || !posA.clone || !posB || !posB.clone) {\n            return;\n        }\n        const separation = posA.clone().sub(posB);\n        const distance = separation.length();\n        if (distance === 0) {\n            // Objects are at exact same position, separate along Y axis\n            separation.set(0, 1, 0);\n        } else {\n            separation.normalize();\n        }\n        // Calculate required separation distance\n        let requiredSeparation = 0;\n        if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"sphere\") {\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"cylinder\") {\n            // Player (sphere) vs Pillar (cylinder) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"cylinder\" && pair.colliderB.type === \"sphere\") {\n            // Pillar (cylinder) vs Player (sphere) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else {\n            // For other shapes, use a simple approximation\n            const radiusA = this.getApproximateRadius(pair.colliderA);\n            const radiusB = this.getApproximateRadius(pair.colliderB);\n            requiredSeparation = radiusA + radiusB;\n        }\n        const overlap = requiredSeparation - distance;\n        if (overlap > 0) {\n            // Debug logging for pillar collisions\n            if (pair.colliderA.layer === 2 && pair.colliderB.layer === 16 || pair.colliderA.layer === 16 && pair.colliderB.layer === 2) {}\n            // For static objects (like pillars), apply stronger separation to prevent penetration\n            let separationMultiplier = 1.0;\n            if (pair.colliderA.isStatic || pair.colliderB.isStatic) {\n                separationMultiplier = 1.1; // 10% extra separation for static objects\n            }\n            // Separate objects - use enhanced separation for static objects\n            const separationVector = separation.multiplyScalar(overlap * separationMultiplier);\n            // Check if entities have Movement components for intelligent separation distribution\n            const movementA = pair.entityA.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            const movementB = pair.entityB.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Determine separation distribution based on Movement components and static status\n            let separationFactorA = 0.5; // Default: split separation equally\n            let separationFactorB = 0.5;\n            if (pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // A is static, B moves - B takes all separation\n                separationFactorA = 0;\n                separationFactorB = 1;\n            } else if (!pair.colliderA.isStatic && pair.colliderB.isStatic) {\n                // B is static, A moves - A takes all separation\n                separationFactorA = 1;\n                separationFactorB = 0;\n            } else if (!pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // Both non-static - check for PVP scenario (both players)\n                const isPlayerA = pair.colliderA.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER;\n                const isPlayerB = pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER || pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.ENEMY;\n                if (isPlayerA && isPlayerB) {\n                    // PVP collision: check canMove property for fair collision resolution\n                    const canMoveA = movementA ? movementA.canMove : false;\n                    const canMoveB = movementB ? movementB.canMove : false;\n                    if (canMoveA && canMoveB) {\n                        // Both players can move - equal distribution for fair gameplay\n                        separationFactorA = 0.5;\n                        separationFactorB = 0.5;\n                    } else if (canMoveA && !canMoveB) {\n                        // Only A can move (local player), B is position-synced (remote player)\n                        separationFactorA = 1.0;\n                        separationFactorB = 0.0;\n                    } else if (!canMoveA && canMoveB) {\n                        // Only B can move (local player), A is position-synced (remote player)\n                        separationFactorA = 0.0;\n                        separationFactorB = 1.0;\n                    } else {\n                        // Neither can move - no separation (shouldn't happen in PVP)\n                        separationFactorA = 0.0;\n                        separationFactorB = 0.0;\n                    }\n                } else {\n                    // Non-PVP collision - distribute based on Movement components\n                    if (movementA && !movementB) {\n                        // A has Movement, B doesn't\n                        separationFactorA = 0.8;\n                        separationFactorB = 0.2;\n                    } else if (!movementA && movementB) {\n                        // B has Movement, A doesn't\n                        separationFactorA = 0.2;\n                        separationFactorB = 0.8;\n                    }\n                // If both have Movement or neither has Movement, use equal distribution (0.5, 0.5)\n                }\n            }\n            // Apply separation with calculated factors\n            if (separationFactorA > 0 && separationVector && separationVector.clone) {\n                const separationA = separationVector.clone().multiplyScalar(separationFactorA);\n                transformA.translate(separationA.x, separationA.y, separationA.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementA && pair.colliderB.isStatic && movementA.velocity && movementA.velocity.clone && separation && separation.clone) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementA.velocity.clone().projectOnVector(separation.clone().negate());\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementA.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n            if (separationFactorB > 0) {\n                const separationB = separationVector.clone().multiplyScalar(-separationFactorB);\n                transformB.translate(separationB.x, separationB.y, separationB.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementB && pair.colliderA.isStatic) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementB.velocity.clone().projectOnVector(separation);\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementB.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n        }\n    }\n    getApproximateRadius(collider) {\n        switch(collider.type){\n            case \"sphere\":\n                return collider.radius;\n            case \"box\":\n                return Math.max(collider.size.x, collider.size.y, collider.size.z) * 0.5;\n            case \"capsule\":\n            case \"cylinder\":\n                return Math.max(collider.radius, collider.height * 0.5);\n            default:\n                return 0.5;\n        }\n    }\n    // Utility methods for other systems\n    queryColliders(bounds) {\n        const entries = this.spatialHash.query(bounds);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersRadius(center, radius) {\n        const entries = this.spatialHash.queryRadius(center, radius);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersPoint(point) {\n        const entries = this.spatialHash.queryPoint(point);\n        return entries.map((entry)=>entry.entity);\n    }\n    getCollidersInLayer(layer, bounds) {\n        const candidates = bounds ? this.spatialHash.query(bounds) : Array.from(this.spatialHash[\"entityCells\"].keys()).map((id)=>{\n            const entries = this.spatialHash.query(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3().setFromCenterAndSize(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1000, 1000, 1000)));\n            return entries.find((e)=>e.entity.id === id);\n        }).filter(Boolean);\n        return candidates.filter((entry)=>{\n            const collider = entry.entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            return collider && collider.layer === layer;\n        }).map((entry)=>entry.entity);\n    }\n    // Performance and debugging\n    getPerformanceStats() {\n        return {\n            collisionChecks: this.collisionChecks,\n            actualCollisions: this.actualCollisions,\n            activeCollisions: this.activeCollisions.size,\n            spatialHashStats: this.spatialHash.getStats()\n        };\n    }\n    onEntityRemoved(entity) {\n        // Clean up spatial hash when entity is removed\n        this.spatialHash.remove(entity);\n        // Remove from active collisions\n        const keysToRemove = [];\n        this.activeCollisions.forEach((pair, key)=>{\n            if (pair.entityA.id === entity.id || pair.entityB.id === entity.id) {\n                keysToRemove.push(key);\n            }\n        });\n        for (const key of keysToRemove){\n            this.activeCollisions.delete(key);\n        }\n    }\n    onDisable() {\n        this.spatialHash.clear();\n        this.activeCollisions.clear();\n        this.collisionPairs.length = 0;\n    }\n    constructor(cellSize = 5){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider\n        ];\n        this.collisionPairs = [];\n        this.activeCollisions = new Map() // Track ongoing collisions\n        ;\n        // Performance tracking\n        this.lastUpdateTime = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        this.priority = 15; // Run before movement but after input\n        this.spatialHash = new _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__.SpatialHash(cellSize);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBQ1o7QUFDVDtBQUVVO0FBQ0Y7QUFDZ0I7QUFDbkI7QUFTM0MsTUFBTVEsd0JBQXdCTixzREFBYUE7SUFpQnpDTyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDhEQUE4RDtRQUM5RCxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtRQUN2QixJQUFJLENBQUNHLGdCQUFnQixDQUFDSDtRQUN0QixJQUFJLENBQUNJLHlCQUF5QjtRQUM5QixtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDeEI7SUFFT0MsWUFBWU4sUUFBa0IsRUFBRU8sY0FBc0IsRUFBUTtRQUNuRSw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDRixpQkFBaUI7SUFDeEI7SUFFUUgsa0JBQWtCRixRQUFrQixFQUFRO1FBQ2xELG9EQUFvRDtRQUNwRCxLQUFLLE1BQU1RLFVBQVVSLFNBQVU7WUFDN0IsTUFBTVMsWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixXQUFXSCxPQUFPRSxZQUFZLENBQUNmLDhEQUFRQTtZQUU3QyxJQUFJLENBQUNjLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUNOO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCRyxTQUFTSSxZQUFZLENBQUNOLFVBQVVPLGdCQUFnQjtZQUVoRCxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDSCxXQUFXLENBQUNkLE1BQU0sQ0FBQ1MsUUFBUUcsU0FBU00sTUFBTTtRQUNqRDtJQUNGO0lBRVFkLGlCQUFpQkgsUUFBa0IsRUFBUTtRQUNqRCxJQUFJLENBQUNrQixjQUFjLENBQUNDLE1BQU0sR0FBRztRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FB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RixNQUFNLENBQUNEO1FBQy9CO0lBQ0Y7SUFFT0UsWUFBa0I7UUFDdkIsSUFBSSxDQUFDckgsV0FBVyxDQUFDc0gsS0FBSztRQUN0QixJQUFJLENBQUNyRixnQkFBZ0IsQ0FBQ3FGLEtBQUs7UUFDM0IsSUFBSSxDQUFDakgsY0FBYyxDQUFDQyxNQUFNLEdBQUc7SUFDL0I7SUF2WkFpSCxZQUFZQyxXQUFtQixDQUFDLENBQUU7UUFDaEMsS0FBSzthQVhTQyxxQkFBcUI7WUFBQzdJLGdFQUFTQTtZQUFFRSw4REFBUUE7U0FBQzthQUVsRHVCLGlCQUFrQyxFQUFFO2FBQ3BDNEIsbUJBQW1CLElBQUlGLE1BQThCLDJCQUEyQjs7UUFFeEYsdUJBQXVCO2FBQ2YyRixpQkFBaUI7YUFDakJuSCxrQkFBa0I7YUFDbEJDLG1CQUFtQjtRQUl6QixJQUFJLENBQUNtSCxRQUFRLEdBQUcsSUFBSSxzQ0FBc0M7UUFDMUQsSUFBSSxDQUFDM0gsV0FBVyxHQUFHLElBQUloQiwyREFBV0EsQ0FBQ3dJO0lBQ3JDO0FBb1pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cz9jOWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbGxpc2lvbiBzeXN0ZW0gZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxuaW1wb3J0IHsgVmVjdG9yMywgQm94MyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBTcGF0aWFsSGFzaCB9IGZyb20gJ0AvdXRpbHMvU3BhdGlhbEhhc2gnO1xuXG5pbnRlcmZhY2UgQ29sbGlzaW9uUGFpciB7XG4gIGVudGl0eUE6IEVudGl0eTtcbiAgZW50aXR5QjogRW50aXR5O1xuICBjb2xsaWRlckE6IENvbGxpZGVyO1xuICBjb2xsaWRlckI6IENvbGxpZGVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBDb2xsaWRlcl07XG4gIHByaXZhdGUgc3BhdGlhbEhhc2g6IFNwYXRpYWxIYXNoO1xuICBwcml2YXRlIGNvbGxpc2lvblBhaXJzOiBDb2xsaXNpb25QYWlyW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7IC8vIFRyYWNrIG9uZ29pbmcgY29sbGlzaW9uc1xuICBcbiAgLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgY29sbGlzaW9uQ2hlY2tzID0gMDtcbiAgcHJpdmF0ZSBhY3R1YWxDb2xsaXNpb25zID0gMDtcblxuICBjb25zdHJ1Y3RvcihjZWxsU2l6ZTogbnVtYmVyID0gNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDE1OyAvLyBSdW4gYmVmb3JlIG1vdmVtZW50IGJ1dCBhZnRlciBpbnB1dFxuICAgIHRoaXMuc3BhdGlhbEhhc2ggPSBuZXcgU3BhdGlhbEhhc2goY2VsbFNpemUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB0cmlnZ2VyIGRldGVjdGlvbiBhbmQgYnJvYWQgcGhhc2VcbiAgICB0aGlzLnVwZGF0ZVNwYXRpYWxIYXNoKGVudGl0aWVzKTtcbiAgICB0aGlzLmRldGVjdENvbGxpc2lvbnMoZW50aXRpZXMpO1xuICAgIHRoaXMucHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcygpO1xuICAgIC8vIEFsc28gcmVzb2x2ZSBjb2xsaXNpb25zIGluIHVwZGF0ZSgpIHRvIGVuc3VyZSBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzIGNvbGxpc2lvbiByZXNwb25zZVxuICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3BhdGlhbEhhc2goZW50aXRpZXM6IEVudGl0eVtdKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaCB3aXRoIGN1cnJlbnQgZW50aXR5IHBvc2l0aW9uc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWNvbGxpZGVyLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xsaWRlciBib3VuZHNcbiAgICAgIGNvbGxpZGVyLnVwZGF0ZUJvdW5kcyh0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaFxuICAgICAgdGhpcy5zcGF0aWFsSGFzaC51cGRhdGUoZW50aXR5LCBjb2xsaWRlci5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0Q29sbGlzaW9ucyhlbnRpdGllczogRW50aXR5W10pOiB2b2lkIHtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb2xsaXNpb25DaGVja3MgPSAwO1xuICAgIHRoaXMuYWN0dWFsQ29sbGlzaW9ucyA9IDA7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRQYWlycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhY29sbGlkZXIuZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFF1ZXJ5IHNwYXRpYWwgaGFzaCBmb3IgcG90ZW50aWFsIGNvbGxpc2lvbnNcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KGNvbGxpZGVyLmJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJFbnRpdHkgPSBjYW5kaWRhdGUuZW50aXR5O1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IG90aGVyRW50aXR5LmlkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDcmVhdGUgdW5pcXVlIHBhaXIga2V5IChzbWFsbGVyIElEIGZpcnN0KVxuICAgICAgICBjb25zdCBwYWlyS2V5ID0gZW50aXR5LmlkIDwgb3RoZXJFbnRpdHkuaWQgPyBcbiAgICAgICAgICBgJHtlbnRpdHkuaWR9LSR7b3RoZXJFbnRpdHkuaWR9YCA6IFxuICAgICAgICAgIGAke290aGVyRW50aXR5LmlkfS0ke2VudGl0eS5pZH1gO1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBwYWlyXG4gICAgICAgIGlmIChwcm9jZXNzZWRQYWlycy5oYXMocGFpcktleSkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9jZXNzZWRQYWlycy5hZGQocGFpcktleSk7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJUcmFuc2Zvcm0gPSBvdGhlckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDb2xsaWRlciA9IG90aGVyRW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgICAgaWYgKCFvdGhlclRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhb3RoZXJDb2xsaWRlcj8uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgY29sbGlkZXJzIGNhbiBjb2xsaWRlXG4gICAgICAgIGlmICghY29sbGlkZXIuY2FuQ29sbGlkZVdpdGgob3RoZXJDb2xsaWRlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ2hlY2tzKys7XG5cbiAgICAgICAgLy8gUHJlY2lzZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIGlmIChjb2xsaWRlci5pbnRlcnNlY3RzKG90aGVyQ29sbGlkZXIsIHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCksIG90aGVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKSkpIHtcbiAgICAgICAgICB0aGlzLmFjdHVhbENvbGxpc2lvbnMrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgICAgIGlmICgoY29sbGlkZXIubGF5ZXIgPT09IDIgJiYgb3RoZXJDb2xsaWRlci5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgICAgICAoY29sbGlkZXIubGF5ZXIgPT09IDE2ICYmIG90aGVyQ29sbGlkZXIubGF5ZXIgPT09IDIpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhaXI6IENvbGxpc2lvblBhaXIgPSB7XG4gICAgICAgICAgICBlbnRpdHlBOiBlbnRpdHksXG4gICAgICAgICAgICBlbnRpdHlCOiBvdGhlckVudGl0eSxcbiAgICAgICAgICAgIGNvbGxpZGVyQTogY29sbGlkZXIsXG4gICAgICAgICAgICBjb2xsaWRlckI6IG90aGVyQ29sbGlkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7XG5cbiAgICAvLyBQcm9jZXNzIGN1cnJlbnQgY29sbGlzaW9uc1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLmNvbGxpc2lvblBhaXJzKSB7XG4gICAgICBjb25zdCBwYWlyS2V5ID0gcGFpci5lbnRpdHlBLmlkIDwgcGFpci5lbnRpdHlCLmlkID8gXG4gICAgICAgIGAke3BhaXIuZW50aXR5QS5pZH0tJHtwYWlyLmVudGl0eUIuaWR9YCA6IFxuICAgICAgICBgJHtwYWlyLmVudGl0eUIuaWR9LSR7cGFpci5lbnRpdHlBLmlkfWA7XG5cbiAgICAgIGN1cnJlbnRDb2xsaXNpb25zLnNldChwYWlyS2V5LCBwYWlyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5hY3RpdmVDb2xsaXNpb25zLmhhcyhwYWlyS2V5KSkge1xuICAgICAgICAvLyBOZXcgY29sbGlzaW9uIC0gdHJpZ2dlciBlbnRlciBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmdvaW5nIGNvbGxpc2lvbiAtIHRyaWdnZXIgc3RheSBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uU3RheShwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB0aGF0IGVuZGVkXG4gICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmZvckVhY2goKHBhaXIsIHBhaXJLZXkpID0+IHtcbiAgICAgIGlmICghY3VycmVudENvbGxpc2lvbnMuaGFzKHBhaXJLZXkpKSB7XG4gICAgICAgIC8vIENvbGxpc2lvbiBlbmRlZCAtIHRyaWdnZXIgZXhpdCBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRXhpdChwYWlyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucyA9IGN1cnJlbnRDb2xsaXNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25UcmlnZ2VyRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckVudGVyPy4ocGFpci5jb2xsaWRlckEsIHBhaXIuZW50aXR5QSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbGxpc2lvbiBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25TdGF5KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25TdGF5Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvblN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25FeGl0KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25FeGl0Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvbkV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb25zKCk6IHZvaWQge1xuICAgIC8vIFJlc29sdmUgcGh5c2ljYWwgY29sbGlzaW9ucyAobm9uLXRyaWdnZXIpXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuY29sbGlzaW9uUGFpcnMpIHtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRyaWdnZXJzXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwYWlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb24ocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybUEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IHRyYW5zZm9ybUIgPSBwYWlyLmVudGl0eUIuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuXG4gICAgY29uc3QgcG9zQSA9IHRyYW5zZm9ybUEuZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBvc0IgPSB0cmFuc2Zvcm1CLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgIC8vIENhbGN1bGF0ZSBzZXBhcmF0aW9uIHZlY3RvciB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICBpZiAoIXBvc0EgfHwgIXBvc0EuY2xvbmUgfHwgIXBvc0IgfHwgIXBvc0IuY2xvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VwYXJhdGlvbiA9IHBvc0EuY2xvbmUoKS5zdWIocG9zQik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzZXBhcmF0aW9uLmxlbmd0aCgpO1xuXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAvLyBPYmplY3RzIGFyZSBhdCBleGFjdCBzYW1lIHBvc2l0aW9uLCBzZXBhcmF0ZSBhbG9uZyBZIGF4aXNcbiAgICAgIHNlcGFyYXRpb24uc2V0KDAsIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXBhcmF0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBzZXBhcmF0aW9uIGRpc3RhbmNlXG4gICAgbGV0IHJlcXVpcmVkU2VwYXJhdGlvbiA9IDA7XG4gICAgXG4gICAgaWYgKHBhaXIuY29sbGlkZXJBLnR5cGUgPT09ICdzcGhlcmUnICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnc3BoZXJlJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnY3lsaW5kZXInKSB7XG4gICAgICAvLyBQbGF5ZXIgKHNwaGVyZSkgdnMgUGlsbGFyIChjeWxpbmRlcikgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnY3lsaW5kZXInICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICAvLyBQaWxsYXIgKGN5bGluZGVyKSB2cyBQbGF5ZXIgKHNwaGVyZSkgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdGhlciBzaGFwZXMsIHVzZSBhIHNpbXBsZSBhcHByb3hpbWF0aW9uXG4gICAgICBjb25zdCByYWRpdXNBID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQSk7XG4gICAgICBjb25zdCByYWRpdXNCID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQik7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGFwID0gcmVxdWlyZWRTZXBhcmF0aW9uIC0gZGlzdGFuY2U7XG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgaWYgKChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMiAmJiBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgIChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMTYgJiYgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IDIpKSB7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBzdGF0aWMgb2JqZWN0cyAobGlrZSBwaWxsYXJzKSwgYXBwbHkgc3Ryb25nZXIgc2VwYXJhdGlvbiB0byBwcmV2ZW50IHBlbmV0cmF0aW9uXG4gICAgICBsZXQgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjA7XG4gICAgICBpZiAocGFpci5jb2xsaWRlckEuaXNTdGF0aWMgfHwgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjE7IC8vIDEwJSBleHRyYSBzZXBhcmF0aW9uIGZvciBzdGF0aWMgb2JqZWN0c1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXBhcmF0ZSBvYmplY3RzIC0gdXNlIGVuaGFuY2VkIHNlcGFyYXRpb24gZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICBjb25zdCBzZXBhcmF0aW9uVmVjdG9yID0gc2VwYXJhdGlvbi5tdWx0aXBseVNjYWxhcihvdmVybGFwICogc2VwYXJhdGlvbk11bHRpcGxpZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdGllcyBoYXZlIE1vdmVtZW50IGNvbXBvbmVudHMgZm9yIGludGVsbGlnZW50IHNlcGFyYXRpb24gZGlzdHJpYnV0aW9uXG4gICAgICBjb25zdCBtb3ZlbWVudEEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGNvbnN0IG1vdmVtZW50QiA9IHBhaXIuZW50aXR5Qi5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgc2VwYXJhdGlvbiBkaXN0cmlidXRpb24gYmFzZWQgb24gTW92ZW1lbnQgY29tcG9uZW50cyBhbmQgc3RhdGljIHN0YXR1c1xuICAgICAgbGV0IHNlcGFyYXRpb25GYWN0b3JBID0gMC41OyAvLyBEZWZhdWx0OiBzcGxpdCBzZXBhcmF0aW9uIGVxdWFsbHlcbiAgICAgIGxldCBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuNTtcbiAgICAgIFxuICAgICAgaWYgKHBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmICFwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBBIGlzIHN0YXRpYywgQiBtb3ZlcyAtIEIgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBCIGlzIHN0YXRpYywgQSBtb3ZlcyAtIEEgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAxO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiAhcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gQm90aCBub24tc3RhdGljIC0gY2hlY2sgZm9yIFBWUCBzY2VuYXJpbyAoYm90aCBwbGF5ZXJzKVxuICAgICAgICBjb25zdCBpc1BsYXllckEgPSBwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSO1xuICAgICAgICBjb25zdCBpc1BsYXllckIgPSBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHx8IHBhaXIuY29sbGlkZXJCLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1BsYXllckEgJiYgaXNQbGF5ZXJCKSB7XG4gICAgICAgICAgLy8gUFZQIGNvbGxpc2lvbjogY2hlY2sgY2FuTW92ZSBwcm9wZXJ0eSBmb3IgZmFpciBjb2xsaXNpb24gcmVzb2x1dGlvblxuICAgICAgICAgIGNvbnN0IGNhbk1vdmVBID0gbW92ZW1lbnRBID8gbW92ZW1lbnRBLmNhbk1vdmUgOiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjYW5Nb3ZlQiA9IG1vdmVtZW50QiA/IG1vdmVtZW50Qi5jYW5Nb3ZlIDogZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBsYXllcnMgY2FuIG1vdmUgLSBlcXVhbCBkaXN0cmlidXRpb24gZm9yIGZhaXIgZ2FtZXBsYXlcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC41O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5Nb3ZlQSAmJiAhY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgQSBjYW4gbW92ZSAobG9jYWwgcGxheWVyKSwgQiBpcyBwb3NpdGlvbi1zeW5jZWQgKHJlbW90ZSBwbGF5ZXIpXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDEuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC4wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBPbmx5IEIgY2FuIG1vdmUgKGxvY2FsIHBsYXllciksIEEgaXMgcG9zaXRpb24tc3luY2VkIChyZW1vdGUgcGxheWVyKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDEuMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVpdGhlciBjYW4gbW92ZSAtIG5vIHNlcGFyYXRpb24gKHNob3VsZG4ndCBoYXBwZW4gaW4gUFZQKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLVBWUCBjb2xsaXNpb24gLSBkaXN0cmlidXRlIGJhc2VkIG9uIE1vdmVtZW50IGNvbXBvbmVudHNcbiAgICAgICAgICBpZiAobW92ZW1lbnRBICYmICFtb3ZlbWVudEIpIHtcbiAgICAgICAgICAgIC8vIEEgaGFzIE1vdmVtZW50LCBCIGRvZXNuJ3RcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC44O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjI7XG4gICAgICAgICAgfSBlbHNlIGlmICghbW92ZW1lbnRBICYmIG1vdmVtZW50Qikge1xuICAgICAgICAgICAgLy8gQiBoYXMgTW92ZW1lbnQsIEEgZG9lc24ndFxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjI7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYm90aCBoYXZlIE1vdmVtZW50IG9yIG5laXRoZXIgaGFzIE1vdmVtZW50LCB1c2UgZXF1YWwgZGlzdHJpYnV0aW9uICgwLjUsIDAuNSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBzZXBhcmF0aW9uIHdpdGggY2FsY3VsYXRlZCBmYWN0b3JzXG4gICAgICBpZiAoc2VwYXJhdGlvbkZhY3RvckEgPiAwICYmIHNlcGFyYXRpb25WZWN0b3IgJiYgc2VwYXJhdGlvblZlY3Rvci5jbG9uZSkge1xuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQSA9IHNlcGFyYXRpb25WZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzZXBhcmF0aW9uRmFjdG9yQSk7XG4gICAgICAgIHRyYW5zZm9ybUEudHJhbnNsYXRlKHNlcGFyYXRpb25BLngsIHNlcGFyYXRpb25BLnksIHNlcGFyYXRpb25BLnopO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBzdG9wIG1vdmVtZW50IHZlbG9jaXR5IGZvciBwbGF5ZXIgd2hlbiBoaXR0aW5nIHN0YXRpYyBvYmplY3RzXG4gICAgICAgIGlmIChtb3ZlbWVudEEgJiYgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMgJiYgbW92ZW1lbnRBLnZlbG9jaXR5ICYmIG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSAmJiBzZXBhcmF0aW9uICYmIHNlcGFyYXRpb24uY2xvbmUpIHtcbiAgICAgICAgICAvLyBQcm9qZWN0IHZlbG9jaXR5IHRvIHJlbW92ZSBjb21wb25lbnQgdG93YXJkcyB0aGUgc3RhdGljIG9iamVjdFxuICAgICAgICAgIGNvbnN0IHZlbG9jaXR5VG93YXJkc1N0YXRpYyA9IG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSgpLnByb2plY3RPblZlY3RvcihzZXBhcmF0aW9uLmNsb25lKCkubmVnYXRlKCkpO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEEudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzZXBhcmF0aW9uRmFjdG9yQiA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbkIgPSBzZXBhcmF0aW9uVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLXNlcGFyYXRpb25GYWN0b3JCKTtcbiAgICAgICAgdHJhbnNmb3JtQi50cmFuc2xhdGUoc2VwYXJhdGlvbkIueCwgc2VwYXJhdGlvbkIueSwgc2VwYXJhdGlvbkIueik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHN0b3AgbW92ZW1lbnQgdmVsb2NpdHkgZm9yIHBsYXllciB3aGVuIGhpdHRpbmcgc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKG1vdmVtZW50QiAmJiBwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYykge1xuICAgICAgICAgIC8vIFByb2plY3QgdmVsb2NpdHkgdG8gcmVtb3ZlIGNvbXBvbmVudCB0b3dhcmRzIHRoZSBzdGF0aWMgb2JqZWN0XG4gICAgICAgICAgY29uc3QgdmVsb2NpdHlUb3dhcmRzU3RhdGljID0gbW92ZW1lbnRCLnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHNlcGFyYXRpb24pO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEIudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcHByb3hpbWF0ZVJhZGl1cyhjb2xsaWRlcjogQ29sbGlkZXIpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoY29sbGlkZXIudHlwZSkge1xuICAgICAgY2FzZSAnc3BoZXJlJzpcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyLnJhZGl1cztcbiAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjb2xsaWRlci5zaXplLngsIGNvbGxpZGVyLnNpemUueSwgY29sbGlkZXIuc2l6ZS56KSAqIDAuNTtcbiAgICAgIGNhc2UgJ2NhcHN1bGUnOlxuICAgICAgY2FzZSAnY3lsaW5kZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sbGlkZXIucmFkaXVzLCBjb2xsaWRlci5oZWlnaHQgKiAwLjUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG90aGVyIHN5c3RlbXNcbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzKGJvdW5kczogQm94Myk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShib3VuZHMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUmFkaXVzKGNlbnRlcjogVmVjdG9yMywgcmFkaXVzOiBudW1iZXIpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlSYWRpdXMoY2VudGVyLCByYWRpdXMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUG9pbnQocG9pbnQ6IFZlY3RvcjMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlQb2ludChwb2ludCk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sbGlkZXJzSW5MYXllcihsYXllcjogQ29sbGlzaW9uTGF5ZXIsIGJvdW5kcz86IEJveDMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGJvdW5kcyA/IHRoaXMuc3BhdGlhbEhhc2gucXVlcnkoYm91bmRzKSA6IEFycmF5LmZyb20odGhpcy5zcGF0aWFsSGFzaFsnZW50aXR5Q2VsbHMnXS5rZXlzKCkpLm1hcChpZCA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShuZXcgQm94MygpLnNldEZyb21DZW50ZXJBbmRTaXplKG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKDEwMDAsIDEwMDAsIDEwMDApKSk7XG4gICAgICByZXR1cm4gZW50cmllcy5maW5kKGUgPT4gZS5lbnRpdHkuaWQgPT09IGlkKTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgYW55W107XG5cbiAgICByZXR1cm4gY2FuZGlkYXRlc1xuICAgICAgLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50cnkuZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIHJldHVybiBjb2xsaWRlciAmJiBjb2xsaWRlci5sYXllciA9PT0gbGF5ZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgLy8gUGVyZm9ybWFuY2UgYW5kIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7XG4gICAgY29sbGlzaW9uQ2hlY2tzOiBudW1iZXI7XG4gICAgYWN0dWFsQ29sbGlzaW9uczogbnVtYmVyO1xuICAgIGFjdGl2ZUNvbGxpc2lvbnM6IG51bWJlcjtcbiAgICBzcGF0aWFsSGFzaFN0YXRzOiBhbnk7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xsaXNpb25DaGVja3M6IHRoaXMuY29sbGlzaW9uQ2hlY2tzLFxuICAgICAgYWN0dWFsQ29sbGlzaW9uczogdGhpcy5hY3R1YWxDb2xsaXNpb25zLFxuICAgICAgYWN0aXZlQ29sbGlzaW9uczogdGhpcy5hY3RpdmVDb2xsaXNpb25zLnNpemUsXG4gICAgICBzcGF0aWFsSGFzaFN0YXRzOiB0aGlzLnNwYXRpYWxIYXNoLmdldFN0YXRzKClcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIHNwYXRpYWwgaGFzaCB3aGVuIGVudGl0eSBpcyByZW1vdmVkXG4gICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIGNvbnN0IGtleXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuZm9yRWFjaCgocGFpciwga2V5KSA9PiB7XG4gICAgICBpZiAocGFpci5lbnRpdHlBLmlkID09PSBlbnRpdHkuaWQgfHwgcGFpci5lbnRpdHlCLmlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuc3BhdGlhbEhhc2guY2xlYXIoKTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJTcGF0aWFsSGFzaCIsIkNvbGxpc2lvblN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidXBkYXRlU3BhdGlhbEhhc2giLCJkZXRlY3RDb2xsaXNpb25zIiwicHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcyIsInJlc29sdmVDb2xsaXNpb25zIiwiZml4ZWRVcGRhdGUiLCJmaXhlZERlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsImNvbGxpZGVyIiwiZW5hYmxlZCIsInNwYXRpYWxIYXNoIiwicmVtb3ZlIiwidXBkYXRlQm91bmRzIiwiZ2V0V29ybGRQb3NpdGlvbiIsImJvdW5kcyIsImNvbGxpc2lvblBhaXJzIiwibGVuZ3RoIiwiY29sbGlzaW9uQ2hlY2tzIiwiYWN0dWFsQ29sbGlzaW9ucyIsInByb2Nlc3NlZFBhaXJzIiwiU2V0IiwiY2FuZGlkYXRlcyIsInF1ZXJ5IiwiY2FuZGlkYXRlIiwib3RoZXJFbnRpdHkiLCJpZCIsInBhaXJLZXkiLCJoYXMiLCJhZGQiLCJvdGhlclRyYW5zZm9ybSIsIm90aGVyQ29sbGlkZXIiLCJjYW5Db2xsaWRlV2l0aCIsImludGVyc2VjdHMiLCJsYXllciIsInBhaXIiLCJlbnRpdHlBIiwiZW50aXR5QiIsImNvbGxpZGVyQSIsImNvbGxpZGVyQiIsInB1c2giLCJjdXJyZW50Q29sbGlzaW9ucyIsIk1hcCIsInNldCIsImFjdGl2ZUNvbGxpc2lvbnMiLCJ0cmlnZ2VyQ29sbGlzaW9uRW50ZXIiLCJ0cmlnZ2VyQ29sbGlzaW9uU3RheSIsImZvckVhY2giLCJ0cmlnZ2VyQ29sbGlzaW9uRXhpdCIsImlzVHJpZ2dlciIsIm9uVHJpZ2dlckVudGVyIiwib25Db2xsaXNpb25FbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvbkNvbGxpc2lvblN0YXkiLCJvblRyaWdnZXJFeGl0Iiwib25Db2xsaXNpb25FeGl0IiwicmVzb2x2ZUNvbGxpc2lvbiIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwicG9zQSIsInBvc0IiLCJjbG9uZSIsInNlcGFyYXRpb24iLCJzdWIiLCJkaXN0YW5jZSIsIm5vcm1hbGl6ZSIsInJlcXVpcmVkU2VwYXJhdGlvbiIsInR5cGUiLCJyYWRpdXMiLCJyYWRpdXNBIiwiZ2V0QXBwcm94aW1hdGVSYWRpdXMiLCJyYWRpdXNCIiwib3ZlcmxhcCIsInNlcGFyYXRpb25NdWx0aXBsaWVyIiwiaXNTdGF0aWMiLCJzZXBhcmF0aW9uVmVjdG9yIiwibXVsdGlwbHlTY2FsYXIiLCJtb3ZlbWVudEEiLCJtb3ZlbWVudEIiLCJzZXBhcmF0aW9uRmFjdG9yQSIsInNlcGFyYXRpb25GYWN0b3JCIiwiaXNQbGF5ZXJBIiwiUExBWUVSIiwiaXNQbGF5ZXJCIiwiRU5FTVkiLCJjYW5Nb3ZlQSIsImNhbk1vdmUiLCJjYW5Nb3ZlQiIsInNlcGFyYXRpb25BIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwidmVsb2NpdHkiLCJ2ZWxvY2l0eVRvd2FyZHNTdGF0aWMiLCJwcm9qZWN0T25WZWN0b3IiLCJuZWdhdGUiLCJzZXBhcmF0aW9uQiIsIk1hdGgiLCJtYXgiLCJzaXplIiwiaGVpZ2h0IiwicXVlcnlDb2xsaWRlcnMiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJxdWVyeUNvbGxpZGVyc1JhZGl1cyIsImNlbnRlciIsInF1ZXJ5UmFkaXVzIiwicXVlcnlDb2xsaWRlcnNQb2ludCIsInBvaW50IiwicXVlcnlQb2ludCIsImdldENvbGxpZGVyc0luTGF5ZXIiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJmaW5kIiwiZSIsImZpbHRlciIsIkJvb2xlYW4iLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwic3BhdGlhbEhhc2hTdGF0cyIsImdldFN0YXRzIiwib25FbnRpdHlSZW1vdmVkIiwia2V5c1RvUmVtb3ZlIiwia2V5IiwiZGVsZXRlIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsImNlbGxTaXplIiwicmVxdWlyZWRDb21wb25lbnRzIiwibGFzdFVwZGF0ZVRpbWUiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CollisionSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CombatSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CombatSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CombatSystem: function() { return /* binding */ CombatSystem; }\n/* harmony export */ });\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/core/DamageCalculator */ \"(app-pages-browser)/./src/core/DamageCalculator.ts\");\n/* harmony import */ var _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/DamageNumberManager */ \"(app-pages-browser)/./src/utils/DamageNumberManager.ts\");\n// Combat system for handling damage, healing, and combat mechanics\n\n\n\n\n\n\n\n\n\nclass CombatSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_0__.System {\n    // Throttled logging to reduce spam\n    shouldLogDamage() {\n        const now = Date.now();\n        if (now - this.lastDamageLogTime > this.damageLogThrottle) {\n            this.lastDamageLogTime = now;\n            return true;\n        }\n        return false;\n    }\n    // Set callback for routing enemy damage to multiplayer server\n    setEnemyDamageCallback(callback) {\n        this.onEnemyDamageCallback = callback;\n    }\n    // Set callback for routing player damage to multiplayer server (PVP)\n    setPlayerDamageCallback(callback) {\n        this.onPlayerDamageCallback = callback;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000;\n        // Update health components (regeneration, invulnerability timers)\n        this.updateHealthComponents(entities, deltaTime, currentTime);\n        // Process damage queue\n        this.processDamageQueue(currentTime);\n        // Process heal queue\n        this.processHealQueue(currentTime);\n        // Handle death and respawn\n        this.handleDeathAndRespawn(entities, currentTime);\n        // Cleanup old damage numbers\n        this.damageNumberManager.cleanup();\n        // Clear processed queues\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n    }\n    updateHealthComponents(entities, deltaTime, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            // Skip if required Health component is missing\n            if (!health || !health.enabled) continue;\n            // Update health component (handles regeneration and invulnerability)\n            health.update(deltaTime, currentTime);\n            // Update shield component if it exists\n            const shield = entity.getComponent(_ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__.Shield);\n            if (shield) {\n                shield.update(deltaTime);\n            }\n            // Update freeze status for enemies\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (enemy) {\n                enemy.updateFreezeStatus(currentTime);\n            }\n        }\n    }\n    processDamageQueue(currentTime) {\n        for (const damageEvent of this.damageQueue){\n            this.applyDamage(damageEvent, currentTime);\n        }\n    }\n    processHealQueue(currentTime) {\n        for (const healEvent of this.healQueue){\n            this.applyHealing(healEvent, currentTime);\n        }\n    }\n    applyDamage(damageEvent, currentTime) {\n        const { target, damage: baseDamage, source, damageType } = damageEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        // Debug: Log all damage events for charge damage\n        if (damageType === \"charge\") {\n            const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            const summonedUnitComponent = target.getComponent(SummonedUnit);\n            const summonedUnit = summonedUnitComponent ? summonedUnitComponent : null;\n            const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : summonedUnit ? \"SummonedUnit(\".concat(summonedUnit.getDisplayName(), \")\") : \"Player(\".concat(target.id, \")\");\n        }\n        // Check if target is an enemy - if so, route damage through multiplayer\n        const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy && this.onEnemyDamageCallback) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route enemy damage through multiplayer server instead of applying locally\n            // console.log(`🌐 Routing ${actualDamage} damage to enemy ${target.id} through multiplayer server`);\n            this.onEnemyDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            // Log for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            return; // Don't apply damage locally for enemies\n        }\n        // Check if target is a summoned unit - treat like enemy (apply damage locally)\n        const summonedUnitComponent = target.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            // Cast to proper type\n            const summonedUnit = summonedUnitComponent;\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Apply damage locally (pass entity so Health can use Shield component)\n            const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n            if (damageDealt) {\n                this.totalDamageDealt += actualDamage;\n                // Check if source is a summoned unit - if so, skip damage numbers to reduce visual clutter\n                const sourceSummonedUnit = source ? source.getComponent(SummonedUnit) : null;\n                const shouldShowDamageNumbers = !sourceSummonedUnit; // Show numbers unless source is a summoned unit\n                if (shouldShowDamageNumbers) {\n                    // Create damage number at target position for damage from players/enemies\n                    const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n                    if (transform) {\n                        const position = transform.getWorldPosition();\n                        // Only create damage number if position is valid\n                        if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                            // Offset slightly above the target\n                            position.y += 2;\n                            this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType || \"melee\");\n                        }\n                    }\n                }\n                // Log for debugging (throttled to reduce spam)\n                if (this.shouldLogDamage()) {\n                    const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                    const targetName = summonedUnit.getDisplayName();\n                    const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                // console.log(`⚔️ ${sourceName} dealt ${actualDamage}${critText} ${damageType || 'damage'} to ${targetName} (${health.currentHealth}/${health.maxHealth} HP)`);\n                }\n                // Check if target died\n                if (health.isDead) {\n                    this.handleEntityDeath(target, source, currentTime);\n                }\n                // Trigger damage effects\n                this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n            }\n            return; // Damage applied locally for summoned units\n        }\n        // Check if target is a player in PVP mode - if so, route damage through multiplayer\n        // Also prevent self-damage in PVP (source hitting themselves)\n        if (!enemy && this.onPlayerDamageCallback && source && source.id !== target.id) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            // Route player damage through multiplayer server for PVP (let receiver handle shields)\n            if (this.shouldLogDamage()) {\n            // console.log(`⚔️ Routing ${damageResult.damage} PVP ${damageType || 'damage'} to player ${target.id} through multiplayer server`);\n            }\n            this.onPlayerDamageCallback(target.id.toString(), damageResult.damage, damageType); // Send damage, let receiver handle shields\n            // Create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    position.y += 1.5;\n                    // Add slight position offset for delayed damage (like sabres right hit) to prevent overlap\n                    if (damageType === \"sabres_right\") {\n                        position.x += 0.3; // Slight offset to the right for the right sabre\n                    }\n                    this.damageNumberManager.addDamageNumber(damageResult.damage, damageResult.isCritical, position, damageType || \"pvp\");\n                } else {\n                // console.warn('⚠️ Skipping PVP damage number creation - invalid position:', position);\n                }\n            }\n            // Log for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Player \".concat(source.id) : \"Unknown\";\n                const targetName = \"Player \".concat(target.id);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            // console.log(`⚔️ ${sourceName} dealt ${damageResult.damage}${critText} PVP ${damageType || 'damage'} to ${targetName} (routed to server)`);\n            }\n            return; // Don't apply damage locally for PVP players\n        }\n        // For non-enemies and non-summoned units (like players in non-PVP mode), apply damage locally as before\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n        const actualDamage = damageResult.damage;\n        // Apply damage (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    // Offset slightly above the target\n                    position.y += 3;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                } else {\n                // console.warn('⚠️ Skipping damage number creation - invalid position:', position);\n                }\n            }\n            // Log damage for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                const targetName = this.getEntityDisplayName(target);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            // console.log(`💥 ${sourceName} dealt ${actualDamage}${critText} ${damageType || 'damage'} to ${targetName} (${health.currentHealth}/${health.maxHealth} HP)`);\n            }\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n    }\n    applyHealing(healEvent, currentTime) {\n        const { target, amount, source } = healEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Apply healing\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            // Log healing for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            // console.log(`💚 ${sourceName} healed ${targetName} for ${amount} HP (${health.currentHealth}/${health.maxHealth} HP)`);\n            // Trigger healing effects\n            this.triggerHealingEffects(target, amount, source);\n        }\n    }\n    handleEntityDeath(entity, killer, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            enemy.die(currentTime || Date.now() / 1000);\n            this.enemiesKilled++;\n            // console.log(`💀 ${enemy.getDisplayName()} has been defeated!`);\n            // Award experience to killer if it's a player\n            if (killer) {\n                this.awardExperience(killer, enemy.experienceReward);\n            }\n            // Trigger death effects\n            this.triggerDeathEffects(entity, killer);\n        }\n        // Handle SummonedUnit death\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        const summonedUnitComponent = entity.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            const summonedUnit = summonedUnitComponent;\n            summonedUnit.die(currentTime || Date.now() / 1000);\n            // console.log(`💀 ${summonedUnit.getDisplayName()} has been defeated!`);\n            // Trigger death effects for summoned units\n            this.triggerDeathEffects(entity, killer);\n        }\n        this.deadEntities.push(entity);\n    }\n    handleDeathAndRespawn(entities, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (!health || !enemy) continue;\n            // Handle respawn for enemies\n            if (enemy.isDead && enemy.canRespawnNow(currentTime)) {\n                this.respawnEnemy(entity, enemy, health);\n            }\n        }\n    }\n    respawnEnemy(entity, enemy, health) {\n        // Respawn the enemy\n        enemy.respawn();\n        health.revive();\n        // console.log(`🔄 ${enemy.getDisplayName()} has respawned!`);\n        // Trigger respawn effects\n        this.triggerRespawnEffects(entity);\n    }\n    triggerDamageEffects(target, damage, source, damageType, isCritical) {\n        // This can be extended to trigger particle effects, screen shake, etc.\n        // For now, we'll just handle basic effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            // Could trigger damage number popup, blood effects, etc.\n            // For now, just log the position where damage occurred\n            const critText = isCritical ? \" (CRITICAL)\" : \"\";\n        // console.log(`🎯 Damage effect${critText} at position:`, transform.position);\n        }\n        // Handle special projectile effects\n        if (damageType === \"projectile\" && source) {\n            var _sourceRenderer_mesh_userData, _sourceRenderer_mesh;\n            const sourceRenderer = source.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            if (sourceRenderer === null || sourceRenderer === void 0 ? void 0 : (_sourceRenderer_mesh = sourceRenderer.mesh) === null || _sourceRenderer_mesh === void 0 ? void 0 : (_sourceRenderer_mesh_userData = _sourceRenderer_mesh.userData) === null || _sourceRenderer_mesh_userData === void 0 ? void 0 : _sourceRenderer_mesh_userData.isBarrageArrow) {\n                // console.log(`🏹 Barrage arrow hit detected, applying slow effect to target ${target.id}`);\n                const targetMovement = target.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n                if (targetMovement) {\n                    targetMovement.slow(5000, 0.5); // 5 seconds, 50% speed\n                // console.log(`🐌 Applied 50% slow for 5 seconds to target ${target.id}`);\n                }\n            }\n        }\n    }\n    triggerHealingEffects(target, amount, source) {\n        // This can be extended to trigger healing particle effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(`✨ Healing effect at position:`, transform.position);\n        }\n    }\n    triggerDeathEffects(entity, killer) {\n        // This can be extended to trigger death animations, loot drops, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(`💀 Death effect at position:`, transform.position);\n        }\n    }\n    triggerRespawnEffects(entity) {\n        // This can be extended to trigger respawn animations, effects, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n        // console.log(`🌟 Respawn effect at position:`, transform.position);\n        }\n    }\n    awardExperience(entity, experience) {\n    // This would integrate with a progression system\n    // console.log(`⭐ Entity ${entity.id} gained ${experience} experience!`);\n    }\n    getEntityDisplayName(entity) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            return enemy.getDisplayName();\n        }\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        const summonedUnitComponent = entity.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            const summonedUnit = summonedUnitComponent;\n            return summonedUnit.getDisplayName();\n        }\n        // Could check for other components that provide names\n        return \"Entity \".concat(entity.id);\n    }\n    // Public API for other systems to queue damage and healing\n    queueDamage(target, damage, source, damageType) {\n        this.damageQueue.push({\n            target,\n            damage,\n            source,\n            damageType,\n            timestamp: Date.now() / 1000\n        });\n    }\n    queueHealing(target, amount, source) {\n        this.healQueue.push({\n            target,\n            amount,\n            source,\n            timestamp: Date.now() / 1000\n        });\n    }\n    // Immediate damage/healing (bypasses queue)\n    dealDamageImmediate(target, damage, source, damageType) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        // Import SummonedUnit component dynamically to avoid circular dependency\n        const SummonedUnit = (__webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\").SummonedUnit);\n        // Check if target is a summoned unit - skip damage numbers only if source is also a summoned unit\n        const summonedUnitComponent = target.getComponent(SummonedUnit);\n        if (summonedUnitComponent) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n            const actualDamage = damageResult.damage;\n            const currentTime = Date.now() / 1000;\n            const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n            if (damageDealt) {\n                this.totalDamageDealt += actualDamage;\n                // Check if source is a summoned unit - if so, skip damage numbers to reduce visual clutter\n                const sourceSummonedUnit = source ? source.getComponent(SummonedUnit) : null;\n                const shouldShowDamageNumbers = !sourceSummonedUnit; // Show numbers unless source is a summoned unit\n                if (shouldShowDamageNumbers) {\n                    // Create damage number at target position for damage from players/enemies\n                    const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n                    if (transform) {\n                        const position = transform.getWorldPosition();\n                        // Offset slightly above the target\n                        position.y += 1.5;\n                        this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                    }\n                }\n                if (health.isDead) {\n                    this.handleEntityDeath(target, source, currentTime);\n                }\n                this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n            }\n            return damageDealt;\n        }\n        // Calculate actual damage with critical hit mechanics\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n        const actualDamage = damageResult.damage;\n        const currentTime = Date.now() / 1000;\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Offset slightly above the target\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n        return damageDealt;\n    }\n    healImmediate(target, amount, source) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            this.triggerHealingEffects(target, amount, source);\n        }\n        return healingDone;\n    }\n    // Utility methods\n    isEntityDead(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.isDead : false;\n    }\n    getEntityHealthRatio(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.getHealthRatio() : 0;\n    }\n    canEntityTakeDamage(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? !health.isDead && !health.isInvulnerable : false;\n    }\n    // Statistics and debugging\n    getCombatStats() {\n        return {\n            totalDamageDealt: this.totalDamageDealt,\n            totalHealingDone: this.totalHealingDone,\n            enemiesKilled: this.enemiesKilled,\n            queuedDamageEvents: this.damageQueue.length,\n            queuedHealEvents: this.healQueue.length\n        };\n    }\n    resetStats() {\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n    }\n    // Damage numbers management\n    getDamageNumbers() {\n        return this.damageNumberManager.getDamageNumbers();\n    }\n    removeDamageNumber(id) {\n        this.damageNumberManager.removeDamageNumber(id);\n    }\n    onDisable() {\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n        this.damageNumberManager.clear();\n        this.resetStats();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health\n        ];\n        this.damageQueue = [];\n        this.healQueue = [];\n        this.deadEntities = [];\n        // Combat statistics\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n        // Log throttling to reduce spam\n        this.lastDamageLogTime = 0;\n        this.damageLogThrottle = 100 // Only log every 100ms\n        ;\n        this.world = world;\n        this.damageNumberManager = new _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__.DamageNumberManager();\n        this.priority = 25; // Run after collision detection\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQW1FO0FBQzdCO0FBRVc7QUFDQTtBQUNGO0FBQ1E7QUFDRjtBQUNBO0FBRW1CO0FBQ047QUFpQjNELE1BQU1TLHFCQUFxQlQsK0NBQU1BO0lBOEJ0QyxtQ0FBbUM7SUFDM0JVLGtCQUEyQjtRQUNqQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLElBQUlBLE1BQU0sSUFBSSxDQUFDRSxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQixFQUFFO1lBQ3pELElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdGO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDhEQUE4RDtJQUN2REksdUJBQXVCQyxRQUFtRCxFQUFRO1FBQ3ZGLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRUEscUVBQXFFO0lBQzlERSx3QkFBd0JGLFFBQXlFLEVBQVE7UUFDOUcsSUFBSSxDQUFDRyxzQkFBc0IsR0FBR0g7SUFDaEM7SUFFT0ksT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxNQUFNQyxjQUFjWCxLQUFLRCxHQUFHLEtBQUs7UUFFakMsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ2Esc0JBQXNCLENBQUNILFVBQVVDLFdBQVdDO1FBRWpELHVCQUF1QjtRQUN2QixJQUFJLENBQUNFLGtCQUFrQixDQUFDRjtRQUV4QixxQkFBcUI7UUFDckIsSUFBSSxDQUFDRyxnQkFBZ0IsQ0FBQ0g7UUFFdEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0kscUJBQXFCLENBQUNOLFVBQVVFO1FBRXJDLDZCQUE2QjtRQUM3QixJQUFJLENBQUNLLG1CQUFtQixDQUFDQyxPQUFPO1FBRWhDLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxN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Q3hCLElBQUksQ0FBQ0ksYUFBYSxHQUFHO0lBQ3ZCO0lBRUEsNEJBQTRCO0lBQ3JCK0IsbUJBQW1CO1FBQ3hCLE9BQU8sSUFBSSxDQUFDM0YsbUJBQW1CLENBQUMyRixnQkFBZ0I7SUFDbEQ7SUFFT0MsbUJBQW1CaEUsRUFBVSxFQUFRO1FBQzFDLElBQUksQ0FBQzVCLG1CQUFtQixDQUFDNEYsa0JBQWtCLENBQUNoRTtJQUM5QztJQUVPaUUsWUFBa0I7UUFDdkIsSUFBSSxDQUFDM0YsV0FBVyxDQUFDQyxNQUFNLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxTQUFTLENBQUNELE1BQU0sR0FBRztRQUN4QixJQUFJLENBQUNFLFlBQVksQ0FBQ0YsTUFBTSxHQUFHO1FBQzNCLElBQUksQ0FBQ0gsbUJBQW1CLENBQUM4RixLQUFLO1FBQzlCLElBQUksQ0FBQ0osVUFBVTtJQUNqQjtJQTFuQkFLLFlBQVlDLEtBQVksQ0FBRTtRQUN4QixLQUFLO2FBdkJTQyxxQkFBcUI7WUFBQzVILDBEQUFNQTtTQUFDO2FBRXJDNkIsY0FBNkIsRUFBRTthQUMvQkUsWUFBeUIsRUFBRTthQUMzQkMsZUFBeUIsRUFBRTtRQUduQyxvQkFBb0I7YUFDWnVDLG1CQUFtQjthQUNuQlksbUJBQW1CO2FBQ25CSSxnQkFBZ0I7UUFReEIsZ0NBQWdDO2FBQ3hCM0Usb0JBQW9CO2FBQ3BCQyxvQkFBb0IsSUFBSyx1QkFBdUI7O1FBSXRELElBQUksQ0FBQzhHLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNoRyxtQkFBbUIsR0FBRyxJQUFJcEIsMkVBQW1CQTtRQUNsRCxJQUFJLENBQUNzSCxRQUFRLEdBQUcsSUFBSSxnQ0FBZ0M7SUFDdEQ7QUFzbkJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cz9hNjBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbWJhdCBzeXN0ZW0gZm9yIGhhbmRsaW5nIGRhbWFnZSwgaGVhbGluZywgYW5kIGNvbWJhdCBtZWNoYW5pY3NcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgSGVhbHRoIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9IZWFsdGgnO1xuaW1wb3J0IHsgU2hpZWxkIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9TaGllbGQnO1xuaW1wb3J0IHsgRW5lbXkgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0VuZW15JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tICdAL2Vjcy9Xb3JsZCc7XG5pbXBvcnQgeyBjYWxjdWxhdGVEYW1hZ2UsIERhbWFnZVJlc3VsdCB9IGZyb20gJ0AvY29yZS9EYW1hZ2VDYWxjdWxhdG9yJztcbmltcG9ydCB7IERhbWFnZU51bWJlck1hbmFnZXIgfSBmcm9tICdAL3V0aWxzL0RhbWFnZU51bWJlck1hbmFnZXInO1xuXG5pbnRlcmZhY2UgRGFtYWdlRXZlbnQge1xuICB0YXJnZXQ6IEVudGl0eTtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIHNvdXJjZT86IEVudGl0eTtcbiAgZGFtYWdlVHlwZT86IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBIZWFsRXZlbnQge1xuICB0YXJnZXQ6IEVudGl0eTtcbiAgYW1vdW50OiBudW1iZXI7XG4gIHNvdXJjZT86IEVudGl0eTtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDb21iYXRTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW0hlYWx0aF07XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIGRhbWFnZVF1ZXVlOiBEYW1hZ2VFdmVudFtdID0gW107XG4gIHByaXZhdGUgaGVhbFF1ZXVlOiBIZWFsRXZlbnRbXSA9IFtdO1xuICBwcml2YXRlIGRlYWRFbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgcHJpdmF0ZSBkYW1hZ2VOdW1iZXJNYW5hZ2VyOiBEYW1hZ2VOdW1iZXJNYW5hZ2VyO1xuICBcbiAgLy8gQ29tYmF0IHN0YXRpc3RpY3NcbiAgcHJpdmF0ZSB0b3RhbERhbWFnZURlYWx0ID0gMDtcbiAgcHJpdmF0ZSB0b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgcHJpdmF0ZSBlbmVtaWVzS2lsbGVkID0gMDtcblxuICAvLyBNdWx0aXBsYXllciBkYW1hZ2UgY2FsbGJhY2sgZm9yIHJvdXRpbmcgZW5lbXkgZGFtYWdlIHRvIHNlcnZlclxuICBwcml2YXRlIG9uRW5lbXlEYW1hZ2VDYWxsYmFjaz86IChlbmVteUlkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkO1xuICBcbiAgLy8gUFZQIGRhbWFnZSBjYWxsYmFjayBmb3Igcm91dGluZyBwbGF5ZXIgZGFtYWdlIHRvIHNlcnZlclxuICBwcml2YXRlIG9uUGxheWVyRGFtYWdlQ2FsbGJhY2s/OiAocGxheWVySWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIsIGRhbWFnZVR5cGU/OiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLy8gTG9nIHRocm90dGxpbmcgdG8gcmVkdWNlIHNwYW1cbiAgcHJpdmF0ZSBsYXN0RGFtYWdlTG9nVGltZSA9IDA7XG4gIHByaXZhdGUgZGFtYWdlTG9nVGhyb3R0bGUgPSAxMDA7IC8vIE9ubHkgbG9nIGV2ZXJ5IDEwMG1zXG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyID0gbmV3IERhbWFnZU51bWJlck1hbmFnZXIoKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMjU7IC8vIFJ1biBhZnRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gIH1cblxuICAvLyBUaHJvdHRsZWQgbG9nZ2luZyB0byByZWR1Y2Ugc3BhbVxuICBwcml2YXRlIHNob3VsZExvZ0RhbWFnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSB0aGlzLmxhc3REYW1hZ2VMb2dUaW1lID4gdGhpcy5kYW1hZ2VMb2dUaHJvdHRsZSkge1xuICAgICAgdGhpcy5sYXN0RGFtYWdlTG9nVGltZSA9IG5vdztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBTZXQgY2FsbGJhY2sgZm9yIHJvdXRpbmcgZW5lbXkgZGFtYWdlIHRvIG11bHRpcGxheWVyIHNlcnZlclxuICBwdWJsaWMgc2V0RW5lbXlEYW1hZ2VDYWxsYmFjayhjYWxsYmFjazogKGVuZW15SWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRW5lbXlEYW1hZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICAvLyBTZXQgY2FsbGJhY2sgZm9yIHJvdXRpbmcgcGxheWVyIGRhbWFnZSB0byBtdWx0aXBsYXllciBzZXJ2ZXIgKFBWUClcbiAgcHVibGljIHNldFBsYXllckRhbWFnZUNhbGxiYWNrKGNhbGxiYWNrOiAocGxheWVySWQ6IHN0cmluZywgZGFtYWdlOiBudW1iZXIsIGRhbWFnZVR5cGU/OiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGNvbXBvbmVudHMgKHJlZ2VuZXJhdGlvbiwgaW52dWxuZXJhYmlsaXR5IHRpbWVycylcbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbXBvbmVudHMoZW50aXRpZXMsIGRlbHRhVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgLy8gUHJvY2VzcyBkYW1hZ2UgcXVldWVcbiAgICB0aGlzLnByb2Nlc3NEYW1hZ2VRdWV1ZShjdXJyZW50VGltZSk7XG5cbiAgICAvLyBQcm9jZXNzIGhlYWwgcXVldWVcbiAgICB0aGlzLnByb2Nlc3NIZWFsUXVldWUoY3VycmVudFRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIGRlYXRoIGFuZCByZXNwYXduXG4gICAgdGhpcy5oYW5kbGVEZWF0aEFuZFJlc3Bhd24oZW50aXRpZXMsIGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIENsZWFudXAgb2xkIGRhbWFnZSBudW1iZXJzXG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmNsZWFudXAoKTtcblxuICAgIC8vIENsZWFyIHByb2Nlc3NlZCBxdWV1ZXNcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVIZWFsdGhDb21wb25lbnRzKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGlmIHJlcXVpcmVkIEhlYWx0aCBjb21wb25lbnQgaXMgbWlzc2luZ1xuICAgICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSBjb250aW51ZTtcblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBjb21wb25lbnQgKGhhbmRsZXMgcmVnZW5lcmF0aW9uIGFuZCBpbnZ1bG5lcmFiaWxpdHkpXG4gICAgICBoZWFsdGgudXBkYXRlKGRlbHRhVGltZSwgY3VycmVudFRpbWUpO1xuXG4gICAgICAvLyBVcGRhdGUgc2hpZWxkIGNvbXBvbmVudCBpZiBpdCBleGlzdHNcbiAgICAgIGNvbnN0IHNoaWVsZCA9IGVudGl0eS5nZXRDb21wb25lbnQoU2hpZWxkKTtcbiAgICAgIGlmIChzaGllbGQpIHtcbiAgICAgICAgc2hpZWxkLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZnJlZXplIHN0YXR1cyBmb3IgZW5lbWllc1xuICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgIGlmIChlbmVteSkge1xuICAgICAgICBlbmVteS51cGRhdGVGcmVlemVTdGF0dXMoY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0RhbWFnZVF1ZXVlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGRhbWFnZUV2ZW50IG9mIHRoaXMuZGFtYWdlUXVldWUpIHtcbiAgICAgIHRoaXMuYXBwbHlEYW1hZ2UoZGFtYWdlRXZlbnQsIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NIZWFsUXVldWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgaGVhbEV2ZW50IG9mIHRoaXMuaGVhbFF1ZXVlKSB7XG4gICAgICB0aGlzLmFwcGx5SGVhbGluZyhoZWFsRXZlbnQsIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFwcGx5RGFtYWdlKGRhbWFnZUV2ZW50OiBEYW1hZ2VFdmVudCwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHsgdGFyZ2V0LCBkYW1hZ2U6IGJhc2VEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSB9ID0gZGFtYWdlRXZlbnQ7XG5cbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm47XG5cbiAgICAvLyBJbXBvcnQgU3VtbW9uZWRVbml0IGNvbXBvbmVudCBkeW5hbWljYWxseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgY29uc3QgU3VtbW9uZWRVbml0ID0gcmVxdWlyZSgnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnKS5TdW1tb25lZFVuaXQ7XG5cbiAgICAvLyBEZWJ1ZzogTG9nIGFsbCBkYW1hZ2UgZXZlbnRzIGZvciBjaGFyZ2UgZGFtYWdlXG4gICAgaWYgKGRhbWFnZVR5cGUgPT09ICdjaGFyZ2UnKSB7XG4gICAgICBjb25zdCBlbmVteSA9IHRhcmdldC5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gc3VtbW9uZWRVbml0Q29tcG9uZW50ID8gc3VtbW9uZWRVbml0Q29tcG9uZW50IGFzIHR5cGVvZiBTdW1tb25lZFVuaXQucHJvdG90eXBlIDogbnVsbDtcbiAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBzdW1tb25lZFVuaXQgPyBgU3VtbW9uZWRVbml0KCR7c3VtbW9uZWRVbml0LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7dGFyZ2V0LmlkfSlgO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbiBlbmVteSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15ICYmIHRoaXMub25FbmVteURhbWFnZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcblxuICAgICAgLy8gUm91dGUgZW5lbXkgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyIGluc3RlYWQgb2YgYXBwbHlpbmcgbG9jYWxseVxuICAgICAgLy8gY29uc29sZS5sb2coYPCfjJAgUm91dGluZyAke2FjdHVhbERhbWFnZX0gZGFtYWdlIHRvIGVuZW15ICR7dGFyZ2V0LmlkfSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlcmApO1xuICAgICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGFjdHVhbERhbWFnZSk7XG5cbiAgICAgIC8vIFN0aWxsIGNyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuXG4gICAgICByZXR1cm47IC8vIERvbid0IGFwcGx5IGRhbWFnZSBsb2NhbGx5IGZvciBlbmVtaWVzXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGEgc3VtbW9uZWQgdW5pdCAtIHRyZWF0IGxpa2UgZW5lbXkgKGFwcGx5IGRhbWFnZSBsb2NhbGx5KVxuICAgIGNvbnN0IHN1bW1vbmVkVW5pdENvbXBvbmVudCA9IHRhcmdldC5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0Q29tcG9uZW50KSB7XG4gICAgICAvLyBDYXN0IHRvIHByb3BlciB0eXBlXG4gICAgICBjb25zdCBzdW1tb25lZFVuaXQgPSBzdW1tb25lZFVuaXRDb21wb25lbnQgYXMgdHlwZW9mIFN1bW1vbmVkVW5pdC5wcm90b3R5cGU7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZGFtYWdlIHdpdGggY3JpdGljYWwgaGl0IG1lY2hhbmljc1xuICAgICAgY29uc3QgZGFtYWdlUmVzdWx0OiBEYW1hZ2VSZXN1bHQgPSBjYWxjdWxhdGVEYW1hZ2UoYmFzZURhbWFnZSk7XG4gICAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgICAvLyBBcHBseSBkYW1hZ2UgbG9jYWxseSAocGFzcyBlbnRpdHkgc28gSGVhbHRoIGNhbiB1c2UgU2hpZWxkIGNvbXBvbmVudClcbiAgICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcblxuICAgICAgaWYgKGRhbWFnZURlYWx0KSB7XG4gICAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc291cmNlIGlzIGEgc3VtbW9uZWQgdW5pdCAtIGlmIHNvLCBza2lwIGRhbWFnZSBudW1iZXJzIHRvIHJlZHVjZSB2aXN1YWwgY2x1dHRlclxuICAgICAgICBjb25zdCBzb3VyY2VTdW1tb25lZFVuaXQgPSBzb3VyY2UgPyBzb3VyY2UuZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCkgOiBudWxsO1xuICAgICAgICBjb25zdCBzaG91bGRTaG93RGFtYWdlTnVtYmVycyA9ICFzb3VyY2VTdW1tb25lZFVuaXQ7IC8vIFNob3cgbnVtYmVycyB1bmxlc3Mgc291cmNlIGlzIGEgc3VtbW9uZWQgdW5pdFxuXG4gICAgICAgIGlmIChzaG91bGRTaG93RGFtYWdlTnVtYmVycykge1xuICAgICAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvbiBmb3IgZGFtYWdlIGZyb20gcGxheWVycy9lbmVtaWVzXG4gICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBPZmZzZXQgc2xpZ2h0bHkgYWJvdmUgdGhlIHRhcmdldFxuICAgICAgICAgICAgICBwb3NpdGlvbi55ICs9IDI7XG4gICAgICAgICAgICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5hZGREYW1hZ2VOdW1iZXIoXG4gICAgICAgICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRhbWFnZVR5cGUgfHwgJ21lbGVlJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nICh0aHJvdHRsZWQgdG8gcmVkdWNlIHNwYW0pXG4gICAgICAgIGlmICh0aGlzLnNob3VsZExvZ0RhbWFnZSgpKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBFbnRpdHkgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgICAgICBjb25zdCB0YXJnZXROYW1lID0gc3VtbW9uZWRVbml0LmdldERpc3BsYXlOYW1lKCk7XG4gICAgICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYOKalO+4jyAke3NvdXJjZU5hbWV9IGRlYWx0ICR7YWN0dWFsRGFtYWdlfSR7Y3JpdFRleHR9ICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAoJHtoZWFsdGguY3VycmVudEhlYWx0aH0vJHtoZWFsdGgubWF4SGVhbHRofSBIUClgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBkaWVkXG4gICAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVFbnRpdHlEZWF0aCh0YXJnZXQsIHNvdXJjZSwgY3VycmVudFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlciBkYW1hZ2UgZWZmZWN0c1xuICAgICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldCwgYWN0dWFsRGFtYWdlLCBzb3VyY2UsIGRhbWFnZVR5cGUsIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuOyAvLyBEYW1hZ2UgYXBwbGllZCBsb2NhbGx5IGZvciBzdW1tb25lZCB1bml0c1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhIHBsYXllciBpbiBQVlAgbW9kZSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIC8vIEFsc28gcHJldmVudCBzZWxmLWRhbWFnZSBpbiBQVlAgKHNvdXJjZSBoaXR0aW5nIHRoZW1zZWx2ZXMpXG4gICAgaWYgKCFlbmVteSAmJiB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sgJiYgc291cmNlICYmIHNvdXJjZS5pZCAhPT0gdGFyZ2V0LmlkKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuXG4gICAgICAvLyBSb3V0ZSBwbGF5ZXIgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyIGZvciBQVlAgKGxldCByZWNlaXZlciBoYW5kbGUgc2hpZWxkcylcbiAgICAgIGlmICh0aGlzLnNob3VsZExvZ0RhbWFnZSgpKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDimpTvuI8gUm91dGluZyAke2RhbWFnZVJlc3VsdC5kYW1hZ2V9IFBWUCAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvIHBsYXllciAke3RhcmdldC5pZH0gdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXJgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25QbGF5ZXJEYW1hZ2VDYWxsYmFjayh0YXJnZXQuaWQudG9TdHJpbmcoKSwgZGFtYWdlUmVzdWx0LmRhbWFnZSwgZGFtYWdlVHlwZSk7IC8vIFNlbmQgZGFtYWdlLCBsZXQgcmVjZWl2ZXIgaGFuZGxlIHNoaWVsZHNcblxuICAgICAgLy8gQ3JlYXRlIGxvY2FsIGRhbWFnZSBudW1iZXJzIGZvciBpbW1lZGlhdGUgdmlzdWFsIGZlZWRiYWNrXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgZGFtYWdlIG51bWJlciBpZiBwb3NpdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAocG9zaXRpb24gJiYgcG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3NpdGlvbi55ICs9IDEuNTtcblxuICAgICAgICAgIC8vIEFkZCBzbGlnaHQgcG9zaXRpb24gb2Zmc2V0IGZvciBkZWxheWVkIGRhbWFnZSAobGlrZSBzYWJyZXMgcmlnaHQgaGl0KSB0byBwcmV2ZW50IG92ZXJsYXBcbiAgICAgICAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ3NhYnJlc19yaWdodCcpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnggKz0gMC4zOyAvLyBTbGlnaHQgb2Zmc2V0IHRvIHRoZSByaWdodCBmb3IgdGhlIHJpZ2h0IHNhYnJlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5kYW1hZ2UsIC8vIFNob3cgdGhlIGZ1bGwgZGFtYWdlIGluIGRhbWFnZSBudW1iZXJzXG4gICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZGFtYWdlVHlwZSB8fCAncHZwJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gU2tpcHBpbmcgUFZQIGRhbWFnZSBudW1iZXIgY3JlYXRpb24gLSBpbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZyAodGhyb3R0bGVkIHRvIHJlZHVjZSBzcGFtKVxuICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nRGFtYWdlKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBQbGF5ZXIgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IGBQbGF5ZXIgJHt0YXJnZXQuaWR9YDtcbiAgICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDimpTvuI8gJHtzb3VyY2VOYW1lfSBkZWFsdCAke2RhbWFnZVJlc3VsdC5kYW1hZ2V9JHtjcml0VGV4dH0gUFZQICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAocm91dGVkIHRvIHNlcnZlcilgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuOyAvLyBEb24ndCBhcHBseSBkYW1hZ2UgbG9jYWxseSBmb3IgUFZQIHBsYXllcnNcbiAgICB9XG5cbiAgICAvLyBGb3Igbm9uLWVuZW1pZXMgYW5kIG5vbi1zdW1tb25lZCB1bml0cyAobGlrZSBwbGF5ZXJzIGluIG5vbi1QVlAgbW9kZSksIGFwcGx5IGRhbWFnZSBsb2NhbGx5IGFzIGJlZm9yZVxuICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG5cbiAgICAvLyBBcHBseSBkYW1hZ2UgKHBhc3MgZW50aXR5IHNvIEhlYWx0aCBjYW4gdXNlIFNoaWVsZCBjb21wb25lbnQpXG4gICAgY29uc3QgZGFtYWdlRGVhbHQgPSBoZWFsdGgudGFrZURhbWFnZShhY3R1YWxEYW1hZ2UsIGN1cnJlbnRUaW1lLCB0YXJnZXQpO1xuXG4gICAgaWYgKGRhbWFnZURlYWx0KSB7XG4gICAgICB0aGlzLnRvdGFsRGFtYWdlRGVhbHQgKz0gYWN0dWFsRGFtYWdlO1xuXG4gICAgICAvLyBDcmVhdGUgZGFtYWdlIG51bWJlciBhdCB0YXJnZXQgcG9zaXRpb25cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBkYW1hZ2UgbnVtYmVyIGlmIHBvc2l0aW9uIGlzIHZhbGlkXG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbi54ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueSAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgICAgcG9zaXRpb24ueSArPSAzO1xuICAgICAgICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5hZGREYW1hZ2VOdW1iZXIoXG4gICAgICAgICAgICBhY3R1YWxEYW1hZ2UsXG4gICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZGFtYWdlVHlwZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gU2tpcHBpbmcgZGFtYWdlIG51bWJlciBjcmVhdGlvbiAtIGludmFsaWQgcG9zaXRpb246JywgcG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIExvZyBkYW1hZ2UgZm9yIGRlYnVnZ2luZyAodGhyb3R0bGVkIHRvIHJlZHVjZSBzcGFtKVxuICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nRGFtYWdlKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBFbnRpdHkgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5KlICR7c291cmNlTmFtZX0gZGVhbHQgJHthY3R1YWxEYW1hZ2V9JHtjcml0VGV4dH0gJHtkYW1hZ2VUeXBlIHx8ICdkYW1hZ2UnfSB0byAke3RhcmdldE5hbWV9ICgke2hlYWx0aC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aC5tYXhIZWFsdGh9IEhQKWApO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgZGllZFxuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFbnRpdHlEZWF0aCh0YXJnZXQsIHNvdXJjZSwgY3VycmVudFRpbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGRhbWFnZSBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldCwgYWN0dWFsRGFtYWdlLCBzb3VyY2UsIGRhbWFnZVR5cGUsIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFwcGx5SGVhbGluZyhoZWFsRXZlbnQ6IEhlYWxFdmVudCwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHsgdGFyZ2V0LCBhbW91bnQsIHNvdXJjZSB9ID0gaGVhbEV2ZW50O1xuICAgIFxuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybjtcblxuICAgIC8vIEFwcGx5IGhlYWxpbmdcbiAgICBjb25zdCBoZWFsaW5nRG9uZSA9IGhlYWx0aC5oZWFsKGFtb3VudCk7XG4gICAgXG4gICAgaWYgKGhlYWxpbmdEb25lKSB7XG4gICAgICB0aGlzLnRvdGFsSGVhbGluZ0RvbmUgKz0gYW1vdW50O1xuICAgICAgXG4gICAgICAvLyBMb2cgaGVhbGluZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5KaICR7c291cmNlTmFtZX0gaGVhbGVkICR7dGFyZ2V0TmFtZX0gZm9yICR7YW1vdW50fSBIUCAoJHtoZWFsdGguY3VycmVudEhlYWx0aH0vJHtoZWFsdGgubWF4SGVhbHRofSBIUClgKTtcblxuICAgICAgLy8gVHJpZ2dlciBoZWFsaW5nIGVmZmVjdHNcbiAgICAgIHRoaXMudHJpZ2dlckhlYWxpbmdFZmZlY3RzKHRhcmdldCwgYW1vdW50LCBzb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRW50aXR5RGVhdGgoZW50aXR5OiBFbnRpdHksIGtpbGxlcj86IEVudGl0eSwgY3VycmVudFRpbWU/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuXG4gICAgaWYgKGVuZW15KSB7XG4gICAgICBlbmVteS5kaWUoY3VycmVudFRpbWUgfHwgRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgdGhpcy5lbmVtaWVzS2lsbGVkKys7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5KAICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIGJlZW4gZGVmZWF0ZWQhYCk7XG5cbiAgICAgIC8vIEF3YXJkIGV4cGVyaWVuY2UgdG8ga2lsbGVyIGlmIGl0J3MgYSBwbGF5ZXJcbiAgICAgIGlmIChraWxsZXIpIHtcbiAgICAgICAgdGhpcy5hd2FyZEV4cGVyaWVuY2Uoa2lsbGVyLCBlbmVteS5leHBlcmllbmNlUmV3YXJkKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpZ2dlciBkZWF0aCBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5LCBraWxsZXIpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBTdW1tb25lZFVuaXQgZGVhdGhcbiAgICBjb25zdCBTdW1tb25lZFVuaXQgPSByZXF1aXJlKCdAL2Vjcy9jb21wb25lbnRzL1N1bW1vbmVkVW5pdCcpLlN1bW1vbmVkVW5pdDtcbiAgICBjb25zdCBzdW1tb25lZFVuaXRDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCk7XG4gICAgaWYgKHN1bW1vbmVkVW5pdENvbXBvbmVudCkge1xuICAgICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gc3VtbW9uZWRVbml0Q29tcG9uZW50IGFzIHR5cGVvZiBTdW1tb25lZFVuaXQucHJvdG90eXBlO1xuICAgICAgc3VtbW9uZWRVbml0LmRpZShjdXJyZW50VGltZSB8fCBEYXRlLm5vdygpIC8gMTAwMCk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5KAICR7c3VtbW9uZWRVbml0LmdldERpc3BsYXlOYW1lKCl9IGhhcyBiZWVuIGRlZmVhdGVkIWApO1xuXG4gICAgICAvLyBUcmlnZ2VyIGRlYXRoIGVmZmVjdHMgZm9yIHN1bW1vbmVkIHVuaXRzXG4gICAgICB0aGlzLnRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5LCBraWxsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZGVhZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzOiBFbnRpdHlbXSwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgXG4gICAgICBpZiAoIWhlYWx0aCB8fCAhZW5lbXkpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBIYW5kbGUgcmVzcGF3biBmb3IgZW5lbWllc1xuICAgICAgaWYgKGVuZW15LmlzRGVhZCAmJiBlbmVteS5jYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLnJlc3Bhd25FbmVteShlbnRpdHksIGVuZW15LCBoZWFsdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzcGF3bkVuZW15KGVudGl0eTogRW50aXR5LCBlbmVteTogRW5lbXksIGhlYWx0aDogSGVhbHRoKTogdm9pZCB7XG4gICAgLy8gUmVzcGF3biB0aGUgZW5lbXlcbiAgICBlbmVteS5yZXNwYXduKCk7XG4gICAgaGVhbHRoLnJldml2ZSgpO1xuICAgIFxuICAgIC8vIGNvbnNvbGUubG9nKGDwn5SEICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIHJlc3Bhd25lZCFgKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIHJlc3Bhd24gZWZmZWN0c1xuICAgIHRoaXMudHJpZ2dlclJlc3Bhd25FZmZlY3RzKGVudGl0eSk7XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldDogRW50aXR5LCBkYW1hZ2U6IG51bWJlciwgc291cmNlPzogRW50aXR5LCBkYW1hZ2VUeXBlPzogc3RyaW5nLCBpc0NyaXRpY2FsPzogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcGFydGljbGUgZWZmZWN0cywgc2NyZWVuIHNoYWtlLCBldGMuXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBoYW5kbGUgYmFzaWMgZWZmZWN0c1xuICAgIFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb3VsZCB0cmlnZ2VyIGRhbWFnZSBudW1iZXIgcG9wdXAsIGJsb29kIGVmZmVjdHMsIGV0Yy5cbiAgICAgIC8vIEZvciBub3csIGp1c3QgbG9nIHRoZSBwb3NpdGlvbiB3aGVyZSBkYW1hZ2Ugb2NjdXJyZWRcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gaXNDcml0aWNhbCA/ICcgKENSSVRJQ0FMKScgOiAnJztcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDwn46vIERhbWFnZSBlZmZlY3Qke2NyaXRUZXh0fSBhdCBwb3NpdGlvbjpgLCB0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGVjaWFsIHByb2plY3RpbGUgZWZmZWN0c1xuICAgIGlmIChkYW1hZ2VUeXBlID09PSAncHJvamVjdGlsZScgJiYgc291cmNlKSB7XG4gICAgICBjb25zdCBzb3VyY2VSZW5kZXJlciA9IHNvdXJjZS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgaWYgKHNvdXJjZVJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNCYXJyYWdlQXJyb3cpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYPCfj7kgQmFycmFnZSBhcnJvdyBoaXQgZGV0ZWN0ZWQsIGFwcGx5aW5nIHNsb3cgZWZmZWN0IHRvIHRhcmdldCAke3RhcmdldC5pZH1gKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TW92ZW1lbnQgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgaWYgKHRhcmdldE1vdmVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0TW92ZW1lbnQuc2xvdyg1MDAwLCAwLjUpOyAvLyA1IHNlY29uZHMsIDUwJSBzcGVlZFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5CMIEFwcGxpZWQgNTAlIHNsb3cgZm9yIDUgc2Vjb25kcyB0byB0YXJnZXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQ6IEVudGl0eSwgYW1vdW50OiBudW1iZXIsIHNvdXJjZT86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgaGVhbGluZyBwYXJ0aWNsZSBlZmZlY3RzXG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDinKggSGVhbGluZyBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5OiBFbnRpdHksIGtpbGxlcj86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgZGVhdGggYW5pbWF0aW9ucywgbG9vdCBkcm9wcywgZXRjLlxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg8J+SgCBEZWF0aCBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZXNwYXduRWZmZWN0cyhlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcmVzcGF3biBhbmltYXRpb25zLCBlZmZlY3RzLCBldGMuXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDwn4yfIFJlc3Bhd24gZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhd2FyZEV4cGVyaWVuY2UoZW50aXR5OiBFbnRpdHksIGV4cGVyaWVuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggYSBwcm9ncmVzc2lvbiBzeXN0ZW1cbiAgICAvLyBjb25zb2xlLmxvZyhg4q2QIEVudGl0eSAke2VudGl0eS5pZH0gZ2FpbmVkICR7ZXhwZXJpZW5jZX0gZXhwZXJpZW5jZSFgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RW50aXR5RGlzcGxheU5hbWUoZW50aXR5OiBFbnRpdHkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15KSB7XG4gICAgICByZXR1cm4gZW5lbXkuZ2V0RGlzcGxheU5hbWUoKTtcbiAgICB9XG5cbiAgICAvLyBJbXBvcnQgU3VtbW9uZWRVbml0IGNvbXBvbmVudCBkeW5hbWljYWxseSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgY29uc3QgU3VtbW9uZWRVbml0ID0gcmVxdWlyZSgnQC9lY3MvY29tcG9uZW50cy9TdW1tb25lZFVuaXQnKS5TdW1tb25lZFVuaXQ7XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gZW50aXR5LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgIGlmIChzdW1tb25lZFVuaXRDb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IHN1bW1vbmVkVW5pdCA9IHN1bW1vbmVkVW5pdENvbXBvbmVudCBhcyB0eXBlb2YgU3VtbW9uZWRVbml0LnByb3RvdHlwZTtcbiAgICAgIHJldHVybiBzdW1tb25lZFVuaXQuZ2V0RGlzcGxheU5hbWUoKTtcbiAgICB9XG5cbiAgICAvLyBDb3VsZCBjaGVjayBmb3Igb3RoZXIgY29tcG9uZW50cyB0aGF0IHByb3ZpZGUgbmFtZXNcbiAgICByZXR1cm4gYEVudGl0eSAke2VudGl0eS5pZH1gO1xuICB9XG5cbiAgLy8gUHVibGljIEFQSSBmb3Igb3RoZXIgc3lzdGVtcyB0byBxdWV1ZSBkYW1hZ2UgYW5kIGhlYWxpbmdcbiAgcHVibGljIHF1ZXVlRGFtYWdlKFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBkYW1hZ2U6IG51bWJlciwgXG4gICAgc291cmNlPzogRW50aXR5LCBcbiAgICBkYW1hZ2VUeXBlPzogc3RyaW5nXG4gICk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlUXVldWUucHVzaCh7XG4gICAgICB0YXJnZXQsXG4gICAgICBkYW1hZ2UsXG4gICAgICBzb3VyY2UsXG4gICAgICBkYW1hZ2VUeXBlLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpIC8gMTAwMFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHF1ZXVlSGVhbGluZyhcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgYW1vdW50OiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eVxuICApOiB2b2lkIHtcbiAgICB0aGlzLmhlYWxRdWV1ZS5wdXNoKHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGFtb3VudCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEltbWVkaWF0ZSBkYW1hZ2UvaGVhbGluZyAoYnlwYXNzZXMgcXVldWUpXG4gIHB1YmxpYyBkZWFsRGFtYWdlSW1tZWRpYXRlKFxuICAgIHRhcmdldDogRW50aXR5LFxuICAgIGRhbWFnZTogbnVtYmVyLFxuICAgIHNvdXJjZT86IEVudGl0eSxcbiAgICBkYW1hZ2VUeXBlPzogc3RyaW5nXG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEltcG9ydCBTdW1tb25lZFVuaXQgY29tcG9uZW50IGR5bmFtaWNhbGx5IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICBjb25zdCBTdW1tb25lZFVuaXQgPSByZXF1aXJlKCdAL2Vjcy9jb21wb25lbnRzL1N1bW1vbmVkVW5pdCcpLlN1bW1vbmVkVW5pdDtcblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhIHN1bW1vbmVkIHVuaXQgLSBza2lwIGRhbWFnZSBudW1iZXJzIG9ubHkgaWYgc291cmNlIGlzIGFsc28gYSBzdW1tb25lZCB1bml0XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0Q29tcG9uZW50ID0gdGFyZ2V0LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgIGlmIChzdW1tb25lZFVuaXRDb21wb25lbnQpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBhY3R1YWwgZGFtYWdlIHdpdGggY3JpdGljYWwgaGl0IG1lY2hhbmljc1xuICAgICAgY29uc3QgZGFtYWdlUmVzdWx0OiBEYW1hZ2VSZXN1bHQgPSBjYWxjdWxhdGVEYW1hZ2UoZGFtYWdlKTtcbiAgICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBjb25zdCBkYW1hZ2VEZWFsdCA9IGhlYWx0aC50YWtlRGFtYWdlKGFjdHVhbERhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG5cbiAgICAgIGlmIChkYW1hZ2VEZWFsdCkge1xuICAgICAgICB0aGlzLnRvdGFsRGFtYWdlRGVhbHQgKz0gYWN0dWFsRGFtYWdlO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHNvdXJjZSBpcyBhIHN1bW1vbmVkIHVuaXQgLSBpZiBzbywgc2tpcCBkYW1hZ2UgbnVtYmVycyB0byByZWR1Y2UgdmlzdWFsIGNsdXR0ZXJcbiAgICAgICAgY29uc3Qgc291cmNlU3VtbW9uZWRVbml0ID0gc291cmNlID8gc291cmNlLmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc2hvdWxkU2hvd0RhbWFnZU51bWJlcnMgPSAhc291cmNlU3VtbW9uZWRVbml0OyAvLyBTaG93IG51bWJlcnMgdW5sZXNzIHNvdXJjZSBpcyBhIHN1bW1vbmVkIHVuaXRcblxuICAgICAgICBpZiAoc2hvdWxkU2hvd0RhbWFnZU51bWJlcnMpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgZGFtYWdlIG51bWJlciBhdCB0YXJnZXQgcG9zaXRpb24gZm9yIGRhbWFnZSBmcm9tIHBsYXllcnMvZW5lbWllc1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAvLyBPZmZzZXQgc2xpZ2h0bHkgYWJvdmUgdGhlIHRhcmdldFxuICAgICAgICAgICAgcG9zaXRpb24ueSArPSAxLjU7XG4gICAgICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgICAgICBhY3R1YWxEYW1hZ2UsXG4gICAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgZGFtYWdlVHlwZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlckRhbWFnZUVmZmVjdHModGFyZ2V0LCBhY3R1YWxEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSwgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGFtYWdlRGVhbHQ7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkYW1hZ2Ugd2l0aCBjcml0aWNhbCBoaXQgbWVjaGFuaWNzXG4gICAgY29uc3QgZGFtYWdlUmVzdWx0OiBEYW1hZ2VSZXN1bHQgPSBjYWxjdWxhdGVEYW1hZ2UoZGFtYWdlKTtcbiAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBjb25zdCBkYW1hZ2VEZWFsdCA9IGhlYWx0aC50YWtlRGFtYWdlKGFjdHVhbERhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG5cbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG5cbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhbWFnZURlYWx0O1xuICB9XG5cbiAgcHVibGljIGhlYWxJbW1lZGlhdGUoXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIGFtb3VudDogbnVtYmVyLCBcbiAgICBzb3VyY2U/OiBFbnRpdHlcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgY29uc3QgaGVhbGluZ0RvbmUgPSBoZWFsdGguaGVhbChhbW91bnQpO1xuICAgIFxuICAgIGlmIChoZWFsaW5nRG9uZSkge1xuICAgICAgdGhpcy50b3RhbEhlYWxpbmdEb25lICs9IGFtb3VudDtcbiAgICAgIHRoaXMudHJpZ2dlckhlYWxpbmdFZmZlY3RzKHRhcmdldCwgYW1vdW50LCBzb3VyY2UpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaGVhbGluZ0RvbmU7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHNcbiAgcHVibGljIGlzRW50aXR5RGVhZChlbnRpdHk6IEVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICByZXR1cm4gaGVhbHRoID8gaGVhbHRoLmlzRGVhZCA6IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldEVudGl0eUhlYWx0aFJhdGlvKGVudGl0eTogRW50aXR5KTogbnVtYmVyIHtcbiAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgcmV0dXJuIGhlYWx0aCA/IGhlYWx0aC5nZXRIZWFsdGhSYXRpbygpIDogMDtcbiAgfVxuXG4gIHB1YmxpYyBjYW5FbnRpdHlUYWtlRGFtYWdlKGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIHJldHVybiBoZWFsdGggPyAoIWhlYWx0aC5pc0RlYWQgJiYgIWhlYWx0aC5pc0ludnVsbmVyYWJsZSkgOiBmYWxzZTtcbiAgfVxuXG4gIC8vIFN0YXRpc3RpY3MgYW5kIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0Q29tYmF0U3RhdHMoKToge1xuICAgIHRvdGFsRGFtYWdlRGVhbHQ6IG51bWJlcjtcbiAgICB0b3RhbEhlYWxpbmdEb25lOiBudW1iZXI7XG4gICAgZW5lbWllc0tpbGxlZDogbnVtYmVyO1xuICAgIHF1ZXVlZERhbWFnZUV2ZW50czogbnVtYmVyO1xuICAgIHF1ZXVlZEhlYWxFdmVudHM6IG51bWJlcjtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsRGFtYWdlRGVhbHQ6IHRoaXMudG90YWxEYW1hZ2VEZWFsdCxcbiAgICAgIHRvdGFsSGVhbGluZ0RvbmU6IHRoaXMudG90YWxIZWFsaW5nRG9uZSxcbiAgICAgIGVuZW1pZXNLaWxsZWQ6IHRoaXMuZW5lbWllc0tpbGxlZCxcbiAgICAgIHF1ZXVlZERhbWFnZUV2ZW50czogdGhpcy5kYW1hZ2VRdWV1ZS5sZW5ndGgsXG4gICAgICBxdWV1ZWRIZWFsRXZlbnRzOiB0aGlzLmhlYWxRdWV1ZS5sZW5ndGhcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHJlc2V0U3RhdHMoKTogdm9pZCB7XG4gICAgdGhpcy50b3RhbERhbWFnZURlYWx0ID0gMDtcbiAgICB0aGlzLnRvdGFsSGVhbGluZ0RvbmUgPSAwO1xuICAgIHRoaXMuZW5lbWllc0tpbGxlZCA9IDA7XG4gIH1cblxuICAvLyBEYW1hZ2UgbnVtYmVycyBtYW5hZ2VtZW50XG4gIHB1YmxpYyBnZXREYW1hZ2VOdW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuZ2V0RGFtYWdlTnVtYmVycygpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZURhbWFnZU51bWJlcihpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLnJlbW92ZURhbWFnZU51bWJlcihpZCk7XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmhlYWxRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVhZEVudGl0aWVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmNsZWFyKCk7XG4gICAgdGhpcy5yZXNldFN0YXRzKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJIZWFsdGgiLCJTaGllbGQiLCJFbmVteSIsIlRyYW5zZm9ybSIsIlJlbmRlcmVyIiwiTW92ZW1lbnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJEYW1hZ2VOdW1iZXJNYW5hZ2VyIiwiQ29tYmF0U3lzdGVtIiwic2hvdWxkTG9nRGFtYWdlIiwibm93IiwiRGF0ZSIsImxhc3REYW1hZ2VMb2dUaW1lIiwiZGFtYWdlTG9nVGhyb3R0bGUiLCJzZXRFbmVteURhbWFnZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvbkVuZW15RGFtYWdlQ2FsbGJhY2siLCJzZXRQbGF5ZXJEYW1hZ2VDYWxsYmFjayIsIm9uUGxheWVyRGFtYWdlQ2FsbGJhY2siLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImN1cnJlbnRUaW1lIiwidXBkYXRlSGVhbHRoQ29tcG9uZW50cyIsInByb2Nlc3NEYW1hZ2VRdWV1ZSIsInByb2Nlc3NIZWFsUXVldWUiLCJoYW5kbGVEZWF0aEFuZFJlc3Bhd24iLCJkYW1hZ2VOdW1iZXJNYW5hZ2VyIiwiY2xlYW51cCIsImRhbWFnZVF1ZXVlIiwibGVuZ3RoIiwiaGVhbFF1ZXVlIiwiZGVhZEVudGl0aWVzIiwiZW50aXR5IiwiaGVhbHRoIiwiZ2V0Q29tcG9uZW50IiwiZW5hYmxlZCIsInNoaWVsZCIsImVuZW15IiwidXBkYXRlRnJlZXplU3RhdHVzIiwiZGFtYWdlRXZlbnQiLCJhcHBseURhbWFnZSIsImhlYWxFdmVudCIsImFwcGx5SGVhbGluZyIsInRhcmdldCIsImRhbWFnZSIsImJhc2VEYW1hZ2UiLCJzb3VyY2UiLCJkYW1hZ2VUeXBlIiwiU3VtbW9uZWRVbml0IiwicmVxdWlyZSIsInN1bW1vbmVkVW5pdENvbXBvbmVudCIsInN1bW1vbmVkVW5pdCIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImlkIiwiZGFtYWdlUmVzdWx0IiwiYWN0dWFsRGFtYWdlIiwidG9TdHJpbmciLCJ0cmFuc2Zvcm0iLCJwb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJ5IiwiYWRkRGFtYWdlTnVtYmVyIiwiaXNDcml0aWNhbCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiZ2V0RW50aXR5RGlzcGxheU5hbWUiLCJjcml0VGV4dCIsImRhbWFnZURlYWx0IiwidGFrZURhbWFnZSIsInRvdGFsRGFtYWdlRGVhbHQiLCJzb3VyY2VTdW1tb25lZFVuaXQiLCJzaG91bGRTaG93RGFtYWdlTnVtYmVycyIsIngiLCJ1bmRlZmluZWQiLCJ6IiwiaXNEZWFkIiwiaGFuZGxlRW50aXR5RGVhdGgiLCJ0cmlnZ2VyRGFtYWdlRWZmZWN0cyIsImFtb3VudCIsImhlYWxpbmdEb25lIiwiaGVhbCIsInRvdGFsSGVhbGluZ0RvbmUiLCJ0cmlnZ2VySGVhbGluZ0VmZmVjdHMiLCJraWxsZXIiLCJkaWUiLCJlbmVtaWVzS2lsbGVkIiwiYXdhcmRFeHBlcmllbmNlIiwiZXhwZXJpZW5jZVJld2FyZCIsInRyaWdnZXJEZWF0aEVmZmVjdHMiLCJwdXNoIiwiY2FuUmVzcGF3bk5vdyIsInJlc3Bhd25FbmVteSIsInJlc3Bhd24iLCJyZXZpdmUiLCJ0cmlnZ2VyUmVzcGF3bkVmZmVjdHMiLCJzb3VyY2VSZW5kZXJlciIsIm1lc2giLCJ1c2VyRGF0YSIsImlzQmFycmFnZUFycm93IiwidGFyZ2V0TW92ZW1lbnQiLCJzbG93IiwiZXhwZXJpZW5jZSIsInF1ZXVlRGFtYWdlIiwidGltZXN0YW1wIiwicXVldWVIZWFsaW5nIiwiZGVhbERhbWFnZUltbWVkaWF0ZSIsImhlYWxJbW1lZGlhdGUiLCJpc0VudGl0eURlYWQiLCJnZXRFbnRpdHlIZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiY2FuRW50aXR5VGFrZURhbWFnZSIsImlzSW52dWxuZXJhYmxlIiwiZ2V0Q29tYmF0U3RhdHMiLCJxdWV1ZWREYW1hZ2VFdmVudHMiLCJxdWV1ZWRIZWFsRXZlbnRzIiwicmVzZXRTdGF0cyIsImdldERhbWFnZU51bWJlcnMiLCJyZW1vdmVEYW1hZ2VOdW1iZXIiLCJvbkRpc2FibGUiLCJjbGVhciIsImNvbnN0cnVjdG9yIiwid29ybGQiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CombatSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ControlSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/ControlSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlSystem: function() { return /* binding */ ControlSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _CombatSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CombatSystem */ \"(app-pages-browser)/./src/systems/CombatSystem.ts\");\n/* harmony import */ var _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/dragon/weapons */ \"(app-pages-browser)/./src/components/dragon/weapons.ts\");\n/* harmony import */ var _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/weapons/DeflectBarrier */ \"(app-pages-browser)/./src/components/weapons/DeflectBarrier.ts\");\n/* harmony import */ var _components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/weapons/FrostNovaManager */ \"(app-pages-browser)/./src/components/weapons/FrostNovaManager.tsx\");\n/* harmony import */ var _components_weapons_StunManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/weapons/StunManager */ \"(app-pages-browser)/./src/components/weapons/StunManager.tsx\");\n/* harmony import */ var _components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/projectiles/CobraShotManager */ \"(app-pages-browser)/./src/components/projectiles/CobraShotManager.tsx\");\n/* harmony import */ var _components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @/components/projectiles/ViperStingManager */ \"(app-pages-browser)/./src/components/projectiles/ViperStingManager.tsx\");\n// Control system for player input handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ControlSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setPlayer(entity) {\n        this.playerEntity = entity;\n    }\n    update(entities, deltaTime) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerTransform || !playerMovement) return;\n        // Update debuff states first\n        if (typeof playerMovement.updateDebuffs === \"function\") {\n            playerMovement.updateDebuffs();\n        }\n        // Clean up expired Sunder stacks periodically\n        this.cleanupSunderStacks();\n        // Handle weapon switching\n        this.handleWeaponSwitching();\n        // Handle dash movement first (overrides regular movement)\n        this.handleDashMovement(playerMovement, playerTransform);\n        // Handle charge movement (overrides regular movement)\n        this.handleChargeMovement(playerMovement, playerTransform);\n        // Handle player movement input (only if not dashing, charging, frozen, or skyfalling)\n        if (!playerMovement.isDashing && !playerMovement.isCharging && !playerMovement.isFrozen && !this.isSkyfalling) {\n            this.handleMovementInput(playerMovement);\n        }\n        // Handle combat input\n        this.handleCombatInput(playerTransform);\n        // Update deflect barrier position if active\n        this.updateDeflectBarrier(playerTransform);\n    }\n    handleMovementInput(movement) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!playerTransform) return;\n        // Check for double-tap dashes first (before processing regular movement)\n        this.checkForDashInput(movement, playerTransform);\n        // Get input direction\n        const inputDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let hasInput = false;\n        // WASD movement\n        if (this.inputManager.isKeyPressed(\"w\")) {\n            inputDirection.z -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"s\")) {\n            inputDirection.z += 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"a\")) {\n            inputDirection.x -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"d\")) {\n            inputDirection.x += 1;\n            hasInput = true;\n        }\n        // Normalize diagonal movement\n        if (inputDirection.length() > 0) {\n            inputDirection.normalize();\n        }\n        // Convert input to world space based on camera orientation\n        if (hasInput) {\n            const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(cameraDirection);\n            // Get camera's right vector\n            const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n            // Get camera's forward vector (projected on XZ plane)\n            const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n            // Transform input direction to world space\n            const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            worldDirection.addScaledVector(cameraRight, inputDirection.x);\n            worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n            worldDirection.normalize();\n            movement.setMoveDirection(worldDirection, 1.0);\n        } else {\n            movement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n        }\n        // Handle jumping\n        if (this.inputManager.isKeyPressed(\" \")) {\n            movement.jump();\n        }\n    }\n    handleWeaponSwitching() {\n        const currentTime = Date.now() / 1000;\n        // Prevent rapid weapon switching\n        if (currentTime - this.lastWeaponSwitchTime < this.weaponSwitchCooldown) {\n            return;\n        }\n        // Handle weapon switching with number keys\n        if (this.inputManager.isKeyPressed(\"1\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.DIVINITY; // Default sword subclass\n                this.fireRate = this.swordFireRate; // Use sword-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to sword\n            }\n        } else if (this.inputManager.isKeyPressed(\"2\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL; // Default bow subclass\n                this.fireRate = 0.225; // Bow fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"3\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.CHAOS; // Default scythe subclass\n                this.fireRate = this.scytheFireRate; // Use scythe fire rate (0.5s)\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"4\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.FROST; // Default sabres subclass\n                this.fireRate = this.sabresFireRate; // Use sabres-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"5\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ARCANE; // Default runeblade subclass\n                this.fireRate = this.runebladeFireRate; // Use runeblade fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to runeblade\n            }\n        }\n    }\n    handleCombatInput(playerTransform) {\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            this.handleBowInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            this.handleScytheInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            this.handleSwordInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            this.handleSabresInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            this.handleRunebladeInput(playerTransform);\n        }\n    }\n    handleBowInput(playerTransform) {\n        // Handle Viper Sting ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isViperStingCharging && !this.isCharging) {\n            this.performViperSting(playerTransform);\n        }\n        // Handle Barrage ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\")) {\n            if (!this.isBarrageCharging && !this.isCharging && !this.isViperStingCharging) {\n                this.performBarrage(playerTransform);\n            }\n        }\n        // Handle Cobra Shot ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\")) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.performCobraShot(playerTransform);\n            }\n        }\n        // Handle bow charging and firing\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n            }\n            // Increase charge progress (could be time-based)\n            if (!this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.chargeProgress = Math.min(this.chargeProgress + 0.0125, 1.0); // BOW CHARGE SPEED\n            }\n        } else if (this.isCharging) {\n            // Check if any ability is charging - if so, cancel the regular bow shot\n            if (this.isViperStingCharging || this.isBarrageCharging || this.isCobraShotCharging) {\n                this.isCharging = false;\n                this.chargeProgress = 0;\n                return;\n            }\n            // Store charge progress before resetting for visual effects\n            const finalChargeProgress = this.chargeProgress;\n            // Release the bow\n            this.fireProjectile(playerTransform);\n            this.isCharging = false;\n            this.chargeProgress = 0;\n            // Trigger visual effects callback with the stored charge progress\n            this.triggerBowReleaseEffects(finalChargeProgress);\n        }\n    }\n    handleScytheInput(playerTransform) {\n        // Handle scythe left click for EntropicBolt\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\"⚡ Started charging scythe (spinning)\");\n            }\n            // Increase charge progress continuously for spinning animation (no cap)\n            this.chargeProgress += 0.03; // Continuously increase for spinning\n            // Fire EntropicBolt projectiles continuously while spinning\n            this.fireEntropicBoltProjectile(playerTransform);\n        } else if (this.isCharging) {\n            // Stop spinning when mouse is released\n            this.isCharging = false;\n            this.chargeProgress = 0;\n        }\n        // Handle CrossentropyBolt ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isCharging) {\n            this.fireCrossentropyBoltAbility(playerTransform);\n        }\n        // Handle Reanimate ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isCharging) {\n            this.performReanimateAbility(playerTransform);\n        }\n        // Handle Frost Nova ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isCharging) {\n            this.performFrostNovaAbility(playerTransform);\n        }\n    }\n    fireProjectile(playerTransform) {\n        // Rate limiting - prevent spam clicking\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.fireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction (same as camera direction since dragon faces camera)\n        // This ensures arrows fire outward from where the dragon is facing\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation to account for restricted camera bounds\n        // Since camera can't look down much due to bounds, we add a fixed downward angle\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        // Create a rotation matrix to apply the downward angle around the camera's right axis\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Perfect shot timing constants\n        const perfectShotMinThreshold = 0.7; // 85% charge\n        const perfectShotMaxThreshold = 0.98; // 95% charge\n        const isPerfectShot = this.chargeProgress >= perfectShotMinThreshold && this.chargeProgress <= perfectShotMaxThreshold;\n        // Check if bow is fully charged for special projectile\n        if (this.chargeProgress >= 1.0) {\n            this.createChargedArrowProjectile(playerTransform.position.clone(), direction);\n        } else if (isPerfectShot) {\n            this.createPerfectShotProjectile(playerTransform.position.clone(), direction);\n        } else {\n            // Debug: Log the firing angle to verify it's changing with camera rotation\n            const angle = Math.atan2(direction.x, direction.z);\n            this.createProjectile(playerTransform.position.clone(), direction);\n        }\n    }\n    fireEntropicBoltProjectile(playerTransform) {\n        // Rate limiting - use new scythe rate (0.35 seconds)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.scytheFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        const spinStatus = this.isCharging ? \" (SPINNING)\" : \"\";\n        this.createEntropicBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    fireCrossentropyBoltAbility(playerTransform) {\n        // Rate limiting - use CrossentropyBolt rate (1 per second)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCrossentropyTime < this.crossentropyFireRate) {\n            return;\n        }\n        this.lastCrossentropyTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        this.createCrossentropyBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    createProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create projectile using the ProjectileSystem with current weapon config\n        const projectileConfig = {\n            speed: 25,\n            damage: 10,\n            lifetime: 3,\n            maxDistance: 25,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createProjectile(this.world, spawnPosition, direction, this.playerEntity.id, projectileConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"regular_arrow\", spawnPosition, direction, projectileConfig);\n        }\n    }\n    createEntropicBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Check if player has enough mana (15 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastEntropicBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(10);\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create EntropicBolt projectile using the new method\n        const entropicConfig = {\n            speed: 20,\n            damage: 20,\n            lifetime: 2,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createEntropicBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, entropicConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"entropic_bolt\", spawnPosition, direction, entropicConfig);\n        }\n    }\n    createCrossentropyBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(40);\n            console.log(\"⚔️ Consumed 40 mana for Crossentropy Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create CrossentropyBolt projectile using the existing method\n        const crossentropyConfig = {\n            speed: 15,\n            damage: 90,\n            lifetime: 2.5,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createCrossentropyBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, crossentropyConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"crossentropy_bolt\", spawnPosition, direction, crossentropyConfig);\n        }\n    }\n    performReanimateAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Rate limiting - prevent spam casting (1 second cooldown)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastReanimateTime < 1.0) {\n            return;\n        }\n        this.lastReanimateTime = currentTime;\n        // Check if player has enough mana (20 mana cost - doubled from 10)\n        const gameUI = window.gameUI;\n        const currentMana = gameUI ? gameUI.getCurrentMana() : 0;\n        if (gameUI && !gameUI.canCastReanimate()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(20);\n            const manaAfter = gameUI.getCurrentMana();\n        }\n        // Always trigger the visual effect first, regardless of healing success\n        this.triggerReanimateEffect(playerTransform);\n        // Get player's health component and heal for 30 HP \n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const didHeal = healthComponent.heal(30); // REANIMATE HEAL AMOUNT\n            if (didHeal) {\n            // console.log(`🩸 Reanimate healed player for 30 HP. Current health: ${healthComponent.currentHealth}/${healthComponent.maxHealth}`);\n            } else {\n            // console.log('🩸 Reanimate cast successfully but player already at full health');\n            }\n        }\n    }\n    triggerReanimateEffect(playerTransform) {\n        // Trigger the visual healing effect\n        if (this.onReanimateCallback) {\n            this.onReanimateCallback();\n        }\n        const playerPosition = playerTransform.position;\n    }\n    performFrostNovaAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFrostNovaTime < this.frostNovaFireRate) {\n            return;\n        }\n        // Check if player has enough mana (50 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastFrostNova()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(50);\n        }\n        this.lastFrostNovaTime = currentTime;\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger Frost Nova callback for visual effects\n        if (this.onFrostNovaCallback) {\n            this.onFrostNovaCallback(playerPosition, direction);\n        }\n        // Find all enemies within 5 unit radius and freeze them\n        this.freezeEnemiesInRadius(playerPosition, 6.0, currentTime);\n        // Trigger global frost nova visual effect\n        (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.triggerGlobalFrostNova)(playerPosition);\n    }\n    performCobraShot(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCobraShotTime < this.cobraShotFireRate) {\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCobraShot()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isCobraShotCharging = true;\n        this.cobraShotChargeProgress = 0;\n        this.lastCobraShotTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 750; // 0.75 second charge time (between Viper Sting and Barrage)\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.cobraShotChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.cobraShotChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCobraShot(playerTransform);\n                this.isCobraShotCharging = false;\n                this.cobraShotChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCobraShot(playerTransform) {\n        // Get player position and direction (same as other projectiles)\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level like Viper Sting\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Cobra Shot damage is handled by CobraShotManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage (similar to Viper Sting)\n        // Trigger Cobra Shot callback for visual effects\n        if (this.onCobraShotCallback) {\n            this.onCobraShotCallback(spawnPosition, direction);\n        }\n        // Trigger global cobra shot with proper positioning (handles local visual effects and damage)\n        (0,_components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_13__.triggerGlobalCobraShot)(spawnPosition, direction);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"cobra_shot_projectile\", spawnPosition, direction, {\n                speed: 20,\n                damage: 29,\n                lifetime: 8,\n                venomDuration: 6\n            });\n        }\n    }\n    freezeEnemiesInRadius(centerPosition, radius, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        let frozenCount = 0;\n        let damagedPlayers = 0;\n        // Get local socket ID to prevent self-targeting\n        const localSocketId = window.localSocketId;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            // Skip self (local player entity)\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const entityPosition = entityTransform.position;\n            const distance = centerPosition.distanceTo(entityPosition);\n            // Check if entity is within freeze radius\n            if (distance <= radius) {\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                if (enemy) {\n                    // This is an enemy - freeze it (single player mode)\n                    enemy.freeze(6.0, currentTime);\n                    frozenCount++;\n                    // Add frozen visual effect for this enemy\n                    (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.addGlobalFrozenEnemy)(entity.id.toString(), entityPosition);\n                } else {\n                    // This is likely another player in PVP mode - deal damage and freeze\n                    // CRITICAL FIX: First check if this entity represents the local player\n                    const serverPlayerEntities = window.serverPlayerEntities;\n                    let targetPlayerId = null;\n                    if (serverPlayerEntities && serverPlayerEntities.current) {\n                        serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                            if (localEntityId === entity.id) {\n                                targetPlayerId = playerId;\n                            }\n                        });\n                    }\n                    // NEVER damage or debuff ourselves\n                    if (targetPlayerId && targetPlayerId === localSocketId) {\n                        console.log(\"⚠️ Skipping Frost Nova on local player \".concat(localSocketId));\n                        return; // Skip this entity completely\n                    }\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity && targetPlayerId) {\n                        const frostNovaDamage = 50; // Frost Nova damage\n                        combatSystem.queueDamage(entity, frostNovaDamage, this.playerEntity, \"frost_nova\");\n                        damagedPlayers++;\n                        // Broadcast freeze effect to the target player so they get frozen on their end\n                        if (this.onDebuffCallback) {\n                            console.log(\"\\uD83C\\uDFAF Broadcasting freeze effect to player \".concat(targetPlayerId, \" (NOT local player \").concat(localSocketId, \")\"));\n                            this.onDebuffCallback(entity.id, \"frozen\", 6000, entityPosition);\n                        }\n                    }\n                }\n            }\n        });\n        if (frozenCount > 0) {\n        // console.log(`❄️ Frost Nova froze ${frozenCount} enemies within ${radius} unit radius`);\n        }\n        if (damagedPlayers > 0) {\n        // console.log(`❄️ Frost Nova damaged ${damagedPlayers} players within ${radius} unit radius`);\n        }\n    }\n    createChargedArrowProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create charged arrow projectile - more powerful than regular arrows\n        const chargedArrowConfig = {\n            speed: 35,\n            damage: 50,\n            lifetime: 2,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, chargedArrowConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"charged_arrow\", spawnPosition, direction, chargedArrowConfig);\n        }\n    }\n    createPerfectShotProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create perfect shot projectile - enhanced charged arrow with special effects\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, {\n            speed: 40,\n            damage: 75,\n            lifetime: 6,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        });\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"perfect_shot\", spawnPosition, direction, {\n                speed: 40,\n                damage: 75,\n                lifetime: 6,\n                piercing: true,\n                subclass: this.currentSubclass,\n                level: this.currentLevel,\n                opacity: 1.0\n            });\n        }\n    }\n    // Methods to configure weapon for testing\n    setWeaponSubclass(subclass) {\n        this.currentSubclass = subclass;\n    }\n    // Method to set bow release callback\n    setBowReleaseCallback(callback) {\n        this.onBowReleaseCallback = callback;\n    }\n    setDivineStormCallback(callback) {\n        this.onDivineStormCallback = callback;\n    }\n    setProjectileCreatedCallback(callback) {\n        this.onProjectileCreatedCallback = callback;\n    }\n    setViperStingCallback(callback) {\n        this.onViperStingCallback = callback;\n    }\n    setBarrageCallback(callback) {\n        this.onBarrageCallback = callback;\n    }\n    setReanimateCallback(callback) {\n        this.onReanimateCallback = callback;\n    }\n    setFrostNovaCallback(callback) {\n        this.onFrostNovaCallback = callback;\n    }\n    setCobraShotCallback(callback) {\n        this.onCobraShotCallback = callback;\n    }\n    setChargeCallback(callback) {\n        this.onChargeCallback = callback;\n    }\n    setDeflectCallback(callback) {\n        this.onDeflectCallback = callback;\n    }\n    setSkyfallCallback(callback) {\n        this.onSkyfallCallback = callback;\n    }\n    setBackstabCallback(callback) {\n        this.onBackstabCallback = callback;\n    }\n    setSunderCallback(callback) {\n        this.onSunderCallback = callback;\n    }\n    setSmiteCallback(callback) {\n        this.onSmiteCallback = callback;\n    }\n    setDeathGraspCallback(callback) {\n        this.onDeathGraspCallback = callback;\n    }\n    setConsumeManaCallback(callback) {\n        this.onConsumeManaCallback = callback;\n    }\n    setCheckManaCallback(callback) {\n        this.onCheckManaCallback = callback;\n    }\n    setDebuffCallback(callback) {\n        this.onDebuffCallback = callback;\n    }\n    // Method to trigger bow release effects\n    triggerBowReleaseEffects(finalChargeProgress) {\n        if (this.onBowReleaseCallback) {\n            // Check if this was a perfect shot\n            const perfectShotMinThreshold = 0.75; // 85% charge\n            const perfectShotMaxThreshold = 0.98; // 95% charge\n            const isPerfectShot = finalChargeProgress >= perfectShotMinThreshold && finalChargeProgress <= perfectShotMaxThreshold;\n            this.onBowReleaseCallback(finalChargeProgress, isPerfectShot);\n        }\n    }\n    setWeaponLevel(level) {\n        this.currentLevel = level;\n    }\n    getCurrentWeaponConfig() {\n        return {\n            weapon: this.currentWeapon,\n            subclass: this.currentSubclass,\n            level: this.currentLevel\n        };\n    }\n    // Getters for weapon state (for UI/rendering)\n    getCurrentWeapon() {\n        return this.currentWeapon;\n    }\n    getCurrentSubclass() {\n        return this.currentSubclass;\n    }\n    isWeaponCharging() {\n        return this.isCharging;\n    }\n    getChargeProgress() {\n        return this.chargeProgress;\n    }\n    isViperStingChargingActive() {\n        return this.isViperStingCharging;\n    }\n    getViperStingChargeProgress() {\n        return this.viperStingChargeProgress;\n    }\n    isBarrageChargingActive() {\n        return this.isBarrageCharging;\n    }\n    getBarrageChargeProgress() {\n        return this.barrageChargeProgress;\n    }\n    isCobraShotChargingActive() {\n        return this.isCobraShotCharging;\n    }\n    getCobraShotChargeProgress() {\n        return this.cobraShotChargeProgress;\n    }\n    isWeaponSwinging() {\n        return this.isSwinging;\n    }\n    // Sword-specific getters\n    getSwordComboStep() {\n        return this.swordComboStep;\n    }\n    isDivineStormActive() {\n        return this.isDivineStorming;\n    }\n    isChargeActive() {\n        return this.isSwordCharging;\n    }\n    isDeflectActive() {\n        return this.isDeflecting;\n    }\n    isSkyfallActive() {\n        return this.isSkyfalling;\n    }\n    isBackstabActive() {\n        return this.isBackstabbing;\n    }\n    isSunderActive() {\n        return this.isSundering;\n    }\n    isSmiteActive() {\n        return this.isSmiting;\n    }\n    isDeathGraspActive() {\n        return this.isDeathGrasping;\n    }\n    handleSwordInput(playerTransform) {\n        // Handle sword melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isDivineStorming && !this.isSwordCharging && !this.isDeflecting) {\n            this.performSwordMeleeAttack(playerTransform);\n        }\n        // Handle Divine Storm ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting) {\n            this.performDivineStorm(playerTransform);\n        }\n        // Handle Charge ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwordCharging && !this.isDivineStorming && !this.isSwinging && !this.isDeflecting) {\n            this.performCharge(playerTransform);\n        }\n        // Handle Deflect ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeflecting && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging) {\n            this.performDeflect(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    handleRunebladeInput(playerTransform) {\n        // Handle runeblade melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSmiting && !this.isDeathGrasping) {\n            this.performRunebladeMeleeAttack(playerTransform);\n        }\n        // Handle Smite ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSmiting && !this.isSwinging && !this.isDeathGrasping) {\n            this.performSmite(playerTransform);\n        }\n        // Handle DeathGrasp ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeathGrasping && !this.isSmiting && !this.isSwinging) {\n            this.performDeathGrasp(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    performSwordMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sword-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.swordFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        // Set swinging state - completion will be handled by sword component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    performRunebladeMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use runeblade-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.runebladeFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        // Set swinging state - completion will be handled by runeblade component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (same as sword)\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    performSmite(playerTransform) {\n        // Check if using Runeblade\n        if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSmiteTime < this.smiteCooldown) {\n            return; // Still on cooldown\n        }\n        // Check if already smiting\n        if (this.isSmiting) {\n            return;\n        }\n        // Check if player has enough mana (35 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastSmite()) {\n            console.log(\"⚡ Smite: Not enough mana to cast (need 35)\");\n            return;\n        }\n        this.lastSmiteTime = currentTime;\n        this.isSmiting = true;\n        // Consume mana (35 mana)\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(35);\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\"⚡ Smite: Consumed 35 mana. Mana: \".concat(manaBefore, \" -> \").concat(manaAfter));\n        }\n        // Get player position and direction\n        const position = playerTransform.position.clone();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Offset the smite position slightly forward to look like it's coming from the runeblade swing\n        const smitePosition = position.clone().add(direction.clone().multiplyScalar(2.5));\n        // NOTE: Damage detection is now handled by the Smite visual component\n        // to prevent double damage. The visual component's damage detection is more\n        // accurate and properly timed with the animation.\n        // The healing will be triggered by the visual component's onDamageDealt callback\n        // instead of the ControlSystem's performSmiteDamage method.\n        console.log(\"⚡ Smite: Damage detection delegated to visual component\");\n        // Trigger smite callback with healing callback\n        if (this.onSmiteCallback) {\n            this.onSmiteCallback(smitePosition, direction, (damageDealtFlag)=>{\n                // Handle healing when damage is dealt by the visual component\n                if (damageDealtFlag) {\n                    console.log(\"⚡ Smite: Damage detected by visual component, triggering healing\");\n                    this.performSmiteHealing();\n                }\n            });\n        }\n        // Reset smiting state after animation duration (same as the Smite component)\n        setTimeout(()=>{\n            this.isSmiting = false;\n        }, 900); // 0.9 seconds matches the animation duration\n    }\n    performSmiteDamage(smitePosition) {\n        if (!this.playerEntity) return false;\n        const smiteDamage = 80;\n        const damageRadius = 3.0; // Small radius around impact location\n        let damageDealt = false;\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return; // Don't damage self\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            const distance = smitePosition.distanceTo(entityTransform.position);\n            if (distance <= damageRadius) {\n                // Entity is within damage radius - apply damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem && this.playerEntity) {\n                    combatSystem.queueDamage(entity, smiteDamage, this.playerEntity, \"smite\");\n                    damageDealt = true;\n                    console.log(\"⚡ Smite dealt \".concat(smiteDamage, \" damage to entity \").concat(entity.id, \" at distance \").concat(distance.toFixed(2)));\n                } else {\n                    console.log(\"⚡ Smite: Could not find CombatSystem or playerEntity to deal damage\");\n                }\n            }\n        });\n        // NOTE: PVP player damage detection is now handled by the Smite visual component\n        // to prevent double damage. The visual component properly handles PVP damage\n        // through the broadcastPlayerDamage system.\n        return damageDealt;\n    }\n    performSmiteHealing() {\n        if (!this.playerEntity) {\n            console.log(\"⚡ Smite: No player entity available for healing\");\n            return;\n        }\n        // Get player's health component and heal for 20 HP (like Reanimate ability)\n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const oldHealth = healthComponent.currentHealth;\n            const maxHealth = healthComponent.maxHealth;\n            // Always attempt to heal, even if at full health (heal method handles this)\n            const didHeal = healthComponent.heal(20); // Smite healing amount\n            if (didHeal) {\n                console.log(\"⚡ Smite SUCCESSFULLY healed player for 20 HP! Health: \".concat(oldHealth, \" -> \").concat(healthComponent.currentHealth, \"/\").concat(maxHealth));\n            } else {\n                console.log(\"⚡ Smite: Player already at full health (\".concat(healthComponent.currentHealth, \"/\").concat(maxHealth, \") - no healing needed\"));\n            }\n        } else {\n            console.log(\"⚡ Smite: CRITICAL ERROR - Could not find health component for player entity \".concat(this.playerEntity.id));\n            // Fallback: Try to heal through gameUI if health component is not available\n            try {\n                const gameUI = window.gameUI;\n                if (gameUI && typeof gameUI.gainHealth === \"function\") {\n                    gameUI.gainHealth(20);\n                    console.log(\"⚡ Smite: FALLBACK healing through gameUI - healed for 20 HP\");\n                }\n            } catch (error) {\n                console.log(\"⚡ Smite: Could not heal through fallback method either\");\n            }\n        }\n    }\n    performDeathGrasp(playerTransform) {\n        // Check if using Runeblade\n        if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeathGraspTime < this.deathGraspCooldown) {\n            return; // Still on cooldown\n        }\n        // Check if already death grasping\n        if (this.isDeathGrasping) {\n            return;\n        }\n        // Check if player has enough mana (25 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDeathGrasp()) {\n            console.log(\"\\uD83D\\uDC80 DeathGrasp: Not enough mana to cast (need 25)\");\n            return;\n        }\n        this.lastDeathGraspTime = currentTime;\n        this.isDeathGrasping = true;\n        // Consume mana (25 mana)\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(25);\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\"\\uD83D\\uDC80 DeathGrasp: Consumed 25 mana. Mana: \".concat(manaBefore, \" -> \").concat(manaAfter));\n        }\n        // Get player position and direction\n        const position = playerTransform.position.clone();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger death grasp callback\n        if (this.onDeathGraspCallback) {\n            this.onDeathGraspCallback(position, direction);\n        }\n        // Reset death grasping state after animation duration\n        setTimeout(()=>{\n            this.isDeathGrasping = false;\n        }, 1200); // 1.2 seconds matches the animation duration\n    }\n    // Called by sword component when swing animation completes\n    onSwordSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        // Reset swinging state\n        this.isSwinging = false;\n        // Advance combo step for next attack\n        this.swordComboStep = this.swordComboStep % 3 + 1;\n    }\n    // Called by runeblade component when smite animation completes\n    onSmiteComplete() {\n        if (!this.isSmiting) return; // Prevent multiple calls\n        // Reset smiting state\n        this.isSmiting = false;\n    }\n    // Called by runeblade component when death grasp animation completes\n    onDeathGraspComplete() {\n        if (!this.isDeathGrasping) return; // Prevent multiple calls\n        // Reset death grasping state\n        this.isDeathGrasping = false;\n    }\n    handleSabresInput(playerTransform) {\n        // Handle left click for dual sabre attack\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performSabresMeleeAttack(playerTransform);\n        }\n        // Handle Q key for Backstab ability\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performBackstab(playerTransform);\n        }\n        // Handle E key for Sunder ability\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwinging && !this.isSkyfalling && !this.isSundering) {\n            this.performSunder(playerTransform);\n        }\n        // Handle R key for Skyfall ability (switched from E)\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isSkyfalling && !this.isSundering) {\n            this.performSkyfall(playerTransform);\n        }\n        // Update Skyfall state if active\n        if (this.isSkyfalling) {\n            this.updateSkyfallMovement(playerTransform);\n        }\n        // Update Backstab state if active\n        if (this.isBackstabbing) {\n            this.updateBackstabState(playerTransform);\n        }\n        // Update Sunder state if active\n        if (this.isSundering) {\n            this.updateSunderState(playerTransform);\n        }\n    }\n    performSabresMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sabres-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.sabresFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        console.log(\"⚔️ Sabres dual attack initiated\");\n        // Set swinging state - completion will be handled by sabres component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (dual attack)\n        this.performSabresMeleeDamage(playerTransform);\n    }\n    // Called by sabres component when swing animation completes\n    onSabresSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\"⚔️ Sabres dual swing completed\");\n        // Reset swinging state\n        this.isSwinging = false;\n    }\n    performSabresMeleeDamage(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Get all entities that could be damaged\n        const allEntities = this.world.getAllEntities();\n        const potentialTargets = allEntities.filter((entity)=>entity.hasComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health) && entity.hasComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform) && entity !== this.playerEntity);\n        // SABRES DAMAGE\n        const attackRange = 3.8; // Slightly longer range than sword\n        const attackAngle = Math.PI / 2; // 60 degree cone (wider than sword)\n        const leftSabreDamage = 19;\n        const rightSabreDamage = 23;\n        // Get camera direction for attack direction\n        const attackDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(attackDirection);\n        attackDirection.normalize();\n        let hitCount = 0;\n        for (const target of potentialTargets){\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!targetTransform || !targetHealth || targetHealth.isDead) continue;\n            // Calculate direction to target\n            const directionToTarget = targetTransform.position.clone().sub(playerTransform.position);\n            const distanceToTarget = directionToTarget.length();\n            // Check if target is within range\n            if (distanceToTarget > attackRange) continue;\n            // Check if target is within attack cone\n            directionToTarget.normalize();\n            const dotProduct = attackDirection.dot(directionToTarget);\n            const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dotProduct)));\n            if (angleToTarget > attackAngle / 2) continue;\n            // Target is within range and cone - apply damage from both sabres\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                // Left sabre hit (immediate)\n                combatSystem.queueDamage(target, leftSabreDamage, this.playerEntity || undefined);\n                // Right sabre hit (with small delay)\n                setTimeout(()=>{\n                    if (!targetHealth.isDead) {\n                        combatSystem.queueDamage(target, rightSabreDamage, this.playerEntity || undefined);\n                    }\n                }, 100); // 100ms delay between sabre hits\n                hitCount++;\n            }\n        }\n    }\n    // Skyfall ability implementation\n    performSkyfall(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSkyfallTime < this.skyfallCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSkyfall()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(40);\n        // Start Skyfall\n        this.isSkyfalling = true;\n        this.skyfallPhase = \"ascending\";\n        this.skyfallStartTime = currentTime;\n        this.lastSkyfallTime = currentTime;\n        this.skyfallStartPosition.copy(playerTransform.position);\n        // Set target height (double jump height)\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            this.skyfallOriginalGravity = playerMovement.gravity;\n            this.skyfallTargetHeight = playerTransform.position.y + playerMovement.jumpForce * 1.4; // Reduced height by 30% (was 2x, now 1.4x)\n            // Apply upward velocity\n            playerMovement.velocity.y = playerMovement.jumpForce * 2; // Stronger initial velocity\n            playerMovement.gravity = 0; // Disable gravity during ascent\n        // Don't disable canMove as it prevents all physics updates including gravity\n        // Instead we'll control horizontal movement in the ControlSystem\n        }\n        // Trigger callback for multiplayer/visual effects\n        if (this.onSkyfallCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onSkyfallCallback(playerTransform.position, direction);\n        }\n    }\n    updateSkyfallMovement(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerMovement) return;\n        const elapsedTime = currentTime - this.skyfallStartTime;\n        switch(this.skyfallPhase){\n            case \"ascending\":\n                // Check if we've reached target height or started falling\n                if (playerTransform.position.y >= this.skyfallTargetHeight || playerMovement.velocity.y <= 0) {\n                    this.skyfallPhase = \"descending\";\n                    playerMovement.velocity.y = 0; // Stop at peak\n                    playerMovement.gravity = this.skyfallOriginalGravity * 30; // Faster descent\n                }\n                break;\n            case \"descending\":\n                // Check if we've landed (close to original height or on ground)\n                if (playerTransform.position.y <= this.skyfallStartPosition.y + 0.5) {\n                    this.skyfallPhase = \"landing\";\n                    this.performSkyfallLanding(playerTransform);\n                }\n                break;\n            case \"landing\":\n                // Landing phase complete\n                this.completeSkyfallAbility(playerTransform);\n                break;\n        }\n        // Safety timeout (if something goes wrong, end after 5 seconds)\n        if (elapsedTime > 4.0) {\n            this.completeSkyfallAbility(playerTransform);\n        }\n    }\n    performSkyfallLanding(playerTransform) {\n        // Deal damage to enemies in landing area\n        const allEntities = this.world.getAllEntities();\n        const landingPosition = playerTransform.position;\n        const damageRadius = 4.0; // 4 unit radius\n        const skyfallDamage = 125; // 125 damage as requested\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check distance to landing position\n            const distanceToLanding = landingPosition.distanceTo(targetTransform.position);\n            if (distanceToLanding <= damageRadius) {\n                // Apply Skyfall damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem) {\n                    combatSystem.queueDamage(entity, skyfallDamage, this.playerEntity || undefined);\n                    hitCount++;\n                }\n            }\n        }\n    }\n    completeSkyfallAbility(playerTransform) {\n        var _this_playerEntity;\n        // Reset all Skyfall states\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        // Restore player movement\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            playerMovement.gravity = this.skyfallOriginalGravity;\n            playerMovement.velocity.y = 0; // Stop any remaining vertical movement\n        }\n    }\n    updateBackstabState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.backstabStartTime;\n        // Check if backstab animation duration has elapsed\n        if (elapsedTime >= this.backstabDuration) {\n            this.isBackstabbing = false;\n        }\n    }\n    // Sunder ability implementation\n    performSunder(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSunderTime < this.sunderCooldown) {\n            return;\n        }\n        // Check energy cost (35 energy)\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSunder()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(35);\n        // Set cooldown\n        this.lastSunderTime = currentTime;\n        // Start sunder animation (same as backstab)\n        this.isSundering = true;\n        this.sunderStartTime = currentTime;\n        // Perform sunder damage with stacking logic\n        this.performSunderDamage(playerTransform);\n    }\n    updateSunderState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.sunderStartTime;\n        // Check if sunder animation duration has elapsed\n        if (elapsedTime >= this.sunderDuration) {\n            this.isSundering = false;\n        }\n    }\n    performSunderDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const sunderRange = 3.5; // Same range as backstab\n        let hitCount = 0;\n        const currentTime = Date.now() / 1000;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > sunderRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 4); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Apply Sunder stacks and calculate damage\n            const { damage, stackCount, isStunned } = this.applySunderStack(entity.id, currentTime);\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"sunder\");\n                // Apply stun effect if at 3 stacks\n                if (isStunned) {\n                    const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                    if (enemy) {\n                        enemy.freeze(4.0, currentTime); // 4 second stun (using freeze mechanics for movement)\n                        // Add visual stun effect (different from freeze)\n                        (0,_components_weapons_StunManager__WEBPACK_IMPORTED_MODULE_12__.addGlobalStunnedEnemy)(entity.id.toString(), targetTransform.position);\n                    }\n                    // Broadcast stun effect for PVP (using new 'stunned' type)\n                    // CRITICAL FIX: Check if we're about to target ourselves before broadcasting debuff\n                    if (this.onDebuffCallback) {\n                        const localSocketId = window.localSocketId;\n                        const serverPlayerEntities = window.serverPlayerEntities;\n                        let targetPlayerId = null;\n                        if (serverPlayerEntities && serverPlayerEntities.current) {\n                            serverPlayerEntities.current.forEach((localEntityId, playerId)=>{\n                                if (localEntityId === entity.id) {\n                                    targetPlayerId = playerId;\n                                }\n                            });\n                        }\n                        // NEVER broadcast debuff to ourselves\n                        if (targetPlayerId && targetPlayerId !== localSocketId) {\n                            console.log(\"\\uD83C\\uDFAF Broadcasting stun effect to player \".concat(targetPlayerId, \" (NOT local player \").concat(localSocketId, \")\"));\n                            this.onDebuffCallback(entity.id, \"stunned\", 4000, targetTransform.position);\n                        } else {\n                            console.log(\"⚠️ Skipping stun broadcast - would target local player \".concat(localSocketId, \" or invalid target \").concat(targetPlayerId));\n                        }\n                    }\n                }\n                hitCount++;\n            }\n            // Trigger callback for multiplayer/visual effects\n            if (this.onSunderCallback) {\n                this.onSunderCallback(playerTransform.position, playerDirection, damage, stackCount);\n            }\n        }\n    }\n    applySunderStack(entityId, currentTime) {\n        const stackDuration = 10.0; // 10 seconds\n        let currentStacks = this.sunderStacks.get(entityId);\n        // Clean up expired stacks or initialize new entry\n        if (!currentStacks || currentTime - currentStacks.lastApplied > stackDuration) {\n            currentStacks = {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            };\n        }\n        // Calculate damage based on current stack count (before adding new stack)\n        const baseDamages = [\n            60,\n            70,\n            80,\n            90\n        ]; // 0, 1, 2, 3 stacks\n        const damage = baseDamages[Math.min(currentStacks.stacks, 3)];\n        let isStunned = false;\n        let newStackCount = currentStacks.stacks;\n        // Apply new stack\n        if (currentStacks.stacks < 3) {\n            newStackCount = currentStacks.stacks + 1;\n            this.sunderStacks.set(entityId, {\n                stacks: newStackCount,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        } else {\n            // At 3 stacks, apply stun and reset to 0 stacks\n            isStunned = true;\n            newStackCount = 0;\n            this.sunderStacks.set(entityId, {\n                stacks: 0,\n                lastApplied: currentTime,\n                duration: stackDuration\n            });\n        }\n        return {\n            damage,\n            stackCount: newStackCount,\n            isStunned\n        };\n    }\n    // Clean up expired Sunder stacks periodically\n    cleanupSunderStacks() {\n        const currentTime = Date.now() / 1000;\n        const stackDuration = 10.0;\n        // Convert to array to avoid iteration issues\n        const entries = Array.from(this.sunderStacks.entries());\n        for (const [entityId, stackData] of entries){\n            if (currentTime - stackData.lastApplied > stackDuration) {\n                this.sunderStacks.delete(entityId);\n            }\n        }\n    }\n    resetAllAbilityStates() {\n        // Reset all ability states when switching weapons\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.isBackstabbing = false;\n        this.isSundering = false;\n        this.isDivineStorming = false;\n        this.isSwordCharging = false;\n        this.isDeflecting = false;\n        // Clear Sunder stacks when switching weapons\n        this.sunderStacks.clear();\n    }\n    // Backstab ability implementation\n    performBackstab(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastBackstabTime < this.backstabCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastBackstab()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(60);\n        // Set cooldown\n        this.lastBackstabTime = currentTime;\n        // Start backstab animation\n        this.isBackstabbing = true;\n        this.backstabStartTime = currentTime;\n        // Trigger callback for multiplayer/visual effects\n        if (this.onBackstabCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onBackstabCallback(playerTransform.position, direction, 75, false); // Base damage, not backstab by default\n        }\n        // Perform backstab damage\n        this.performBackstabDamage(playerTransform);\n    }\n    performBackstabDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const backstabRange = 4.25; // Sabre melee range\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > backstabRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 3); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Determine if this is a backstab (attacking from behind the target)\n            let isBackstab = false;\n            let damage = 75; // Base damage\n            // For PVP players, check if we're behind them\n            const pvpPlayers = window.pvpPlayers;\n            const localSocketId = window.localSocketId;\n            if (pvpPlayers && localSocketId) {\n                // Find the target player in PVP players map\n                let targetPlayer = null;\n                for (const [playerId, player] of pvpPlayers){\n                    if (playerId !== localSocketId) {\n                        const playerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(player.position.x, player.position.y, player.position.z);\n                        if (playerPos.distanceTo(targetTransform.position) < 0.5) {\n                            targetPlayer = player;\n                            break;\n                        }\n                    }\n                }\n                if (targetPlayer) {\n                    // Calculate target's facing direction from their rotation\n                    const targetFacingDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(targetPlayer.rotation.y), 0, Math.cos(targetPlayer.rotation.y)).normalize();\n                    // Vector from target to attacker\n                    const attackerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(playerPosition, targetTransform.position).normalize();\n                    // Check if attacker is behind target (dot product < 0 means opposite direction)\n                    const behindDotProduct = targetFacingDirection.dot(attackerDirection);\n                    isBackstab = behindDotProduct < -0.3; // 70 degree cone behind target\n                    if (isBackstab) {\n                        damage = 175; // Backstab damage\n                    }\n                }\n            }\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"backstab\");\n                hitCount++;\n            }\n        }\n    }\n    performMeleeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Melee attack parameters - increased for PVP combat\n        const meleeRange = 4.5; // Increased attack range for PVP\n        const meleeAngle = Math.PI / 2; // 120 degree cone (60 degrees each side)\n        // Base damage values based on combo step and weapon type\n        let baseDamage = 45; // Default base damage\n        // Weapon-specific damage scaling\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            // Sword damage values\n            switch(this.swordComboStep){\n                case 1:\n                    baseDamage = 40;\n                    break;\n                case 2:\n                    baseDamage = 45;\n                    break;\n                case 3:\n                    baseDamage = 55;\n                    break; // Finisher does more damage\n            }\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            // Runeblade damage values\n            switch(this.swordComboStep){\n                case 1:\n                    baseDamage = 30;\n                    break;\n                case 2:\n                    baseDamage = 35;\n                    break;\n                case 3:\n                    baseDamage = 45;\n                    break; // Finisher does more damage\n            }\n        }\n        // Get combat system to apply damage\n        const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n        // Track enemies hit for rage generation\n        let enemiesHit = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            // Check if entity has enemy component and health\n            const enemyTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const enemyHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!enemyTransform || !enemyHealth || entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const enemyPosition = enemyTransform.position;\n            const toEnemy = enemyPosition.clone().sub(playerPosition);\n            const distance = toEnemy.length();\n            // Debug logging for PVP hit detection\n            // Check if enemy is within range\n            if (distance <= meleeRange) {\n                // Check if enemy is within attack cone\n                toEnemy.normalize();\n                const angle = direction.angleTo(toEnemy);\n                const angleDegrees = angle * 180 / Math.PI;\n                const maxAngleDegrees = meleeAngle / 2 * 180 / Math.PI;\n                if (angle <= meleeAngle / 2) {\n                    // Enemy is within attack cone - deal damage through combat system\n                    if (combatSystem && this.playerEntity) {\n                        // Queue damage through combat system (which will route to multiplayer for enemies)\n                        combatSystem.queueDamage(entity, baseDamage, this.playerEntity, \"melee\");\n                        enemiesHit++;\n                    }\n                }\n            }\n        });\n        // Generate rage only if we hit enemies (5 rage per hit, max 5 per swing)\n        if (enemiesHit > 0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const rageToGain = Math.min(enemiesHit * 5, 5); // 5 rage per hit, max 5 per swing\n                gameUI.gainRage(rageToGain);\n            }\n        }\n    }\n    checkForDashInput(movement, transform) {\n        // Check for double-tap on movement keys\n        const dashDirections = [\n            {\n                key: \"w\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)\n            },\n            {\n                key: \"s\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n            },\n            {\n                key: \"a\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0)\n            },\n            {\n                key: \"d\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0)\n            } // Right\n        ];\n        for (const { key, direction } of dashDirections){\n            if (this.inputManager.checkDoubleTap(key)) {\n                // Debug: Log the double tap detection\n                const debugInfo = this.inputManager.getDoubleTapDebugInfo(key);\n                // Convert input direction to world space based on camera orientation\n                const worldDirection = this.getWorldSpaceDirection(direction);\n                // Attempt to start dash\n                const currentTime = Date.now() / 1000; // Convert to seconds\n                const dashStarted = movement.startDash(worldDirection, transform.position, currentTime);\n                if (dashStarted) {\n                    // Reset the double-tap state to prevent multiple dashes\n                    this.inputManager.resetDoubleTap(key);\n                }\n                break; // Only process one dash per frame\n            }\n        }\n    }\n    handleDashMovement(movement, transform) {\n        if (!movement.isDashing) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        const dashResult = movement.updateDash(currentTime);\n        if (dashResult.newPosition) {\n            // Apply bounds checking (similar to old implementation)\n            const MAX_DASH_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = dashResult.newPosition.length();\n            if (distanceFromOrigin <= MAX_DASH_BOUNDS) {\n                transform.position.copy(dashResult.newPosition);\n            } else {\n                // Cancel dash if it would move too far from origin\n                // console.warn(`Dash cancelled: would move too far from origin (${distanceFromOrigin.toFixed(2)} > ${MAX_DASH_BOUNDS})`);\n                movement.cancelDash();\n            }\n        }\n    }\n    handleChargeMovement(movement, transform) {\n        if (!movement.isCharging) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        // Check if charge was stopped by collision\n        if (this.chargeStoppedByCollision) {\n            movement.cancelCharge();\n            return;\n        }\n        const chargeResult = movement.updateCharge(currentTime);\n        if (chargeResult.newPosition) {\n            // Apply bounds checking\n            const MAX_CHARGE_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = chargeResult.newPosition.length();\n            // Check for pillar collision\n            const pillarCollision = this.checkPillarCollision(chargeResult.newPosition);\n            if (distanceFromOrigin > MAX_CHARGE_BOUNDS) {\n                // Cancel charge if it would move too far from origin\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (pillarCollision.hasCollision) {\n                // Cancel charge if it would collide with a pillar\n                console.warn(\"Charge cancelled: would collide with pillar at [\".concat(pillarCollision.pillarCenter.toArray().join(\", \"), \"]\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (!this.chargeStoppedByCollision) {\n                // Only update position if not stopped by collision\n                transform.position.copy(chargeResult.newPosition);\n            }\n        }\n        if (chargeResult.isComplete || this.chargeStoppedByCollision) {\n            console.log(\"⚔️ Charge movement completed\");\n            // Notify sword component that charge is complete\n            this.onChargeComplete();\n        }\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    getWorldSpaceDirection(inputDirection) {\n        // Get camera direction vectors\n        const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(cameraDirection);\n        // Get camera's right vector\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Get camera's forward vector (projected on XZ plane)\n        const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n        // Transform input direction to world space\n        const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldDirection.addScaledVector(cameraRight, inputDirection.x);\n        worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n        worldDirection.normalize();\n        return worldDirection;\n    }\n    performDivineStorm(playerTransform) {\n        // Check if player has enough rage (minimum 20 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDivineStorm()) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDivineStormTime < this.divineStormCooldown) {\n            return;\n        }\n        // Get current rage amount and consume ALL rage\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40; // Fallback to 40 if gameUI not available\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 20\n        }\n        // Calculate extended duration: base 4 seconds + 1 second per 10 rage consumed\n        const baseStormDuration = 1000; // 4 seconds base\n        const bonusDuration = Math.floor(currentRage / 10) * 500; // 1 second per 10 rage\n        const totalDivineStormDuration = baseStormDuration + bonusDuration;\n        this.isDivineStorming = true;\n        this.lastDivineStormTime = currentTime;\n        // Trigger Divine Storm callback for multiplayer\n        if (this.onDivineStormCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDivineStormCallback(playerTransform.position.clone(), direction, totalDivineStormDuration);\n        }\n        // Divine Storm lasts for calculated duration\n        setTimeout(()=>{\n            this.isDivineStorming = false;\n        }, totalDivineStormDuration);\n    }\n    performCharge(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastChargeTime < this.chargeCooldown) {\n            return;\n        }\n        this.isSwordCharging = true;\n        this.lastChargeTime = currentTime;\n        // Reset collision tracking for new charge\n        this.chargeStoppedByCollision = false;\n        // Trigger Charge callback for multiplayer\n        if (this.onChargeCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onChargeCallback(playerTransform.position.clone(), direction);\n        }\n        // Gain rage for using charge ability (+20 rage)\n        const gameUI = window.gameUI;\n        if (gameUI) {\n            gameUI.gainRage(20);\n        }\n        // Start the charge movement using the separate charge system\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                // Get charge direction from camera\n                const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(direction);\n                direction.y = 0; // Keep movement horizontal\n                direction.normalize();\n                // Start charge with 10.5 distance (separate from dash system)\n                const chargeStarted = playerMovement.startCharge(direction, playerTransform.position, currentTime);\n                if (chargeStarted) {\n                    // Schedule charge damage detection during movement\n                    this.scheduleChargeDamage(playerTransform, direction, currentTime);\n                }\n            }\n        }\n    }\n    // Schedule damage detection during charge movement\n    scheduleChargeDamage(playerTransform, chargeDirection, startTime) {\n        const chargeDuration = 0.6;\n        const damageCheckInterval = 50; // Check for damage every 50ms for better collision detection\n        const chargeDamage = 40; // High damage for charge ability\n        const chargeRadius = 2.5; // Damage radius around player during charge\n        // Reset charge hit tracking\n        this.chargeHitEntities.clear();\n        this.chargeStoppedByCollision = false;\n        const damageInterval = setInterval(()=>{\n            const currentTime = Date.now() / 1000;\n            // Stop if charge is complete, cancelled, or stopped by collision\n            if (!this.isSwordCharging || currentTime - startTime > chargeDuration || this.chargeStoppedByCollision) {\n                clearInterval(damageInterval);\n                return;\n            }\n            // Get all entities in the world to check for damage\n            const allEntities = this.world.getAllEntities();\n            const playerPosition = playerTransform.position;\n            let hitSomething = false;\n            // Debug: Log all entities in the world during charge\n            // ENHANCED: Also check against server player positions directly as a fallback\n            // This ensures we don't miss collisions due to entity sync issues\n            const serverPlayers = window.pvpPlayers || new Map();\n            const localSocketId = window.localSocketId;\n            serverPlayers.forEach((serverPlayer, playerId)=>{\n                // Skip self\n                if (playerId === localSocketId) return;\n                // Skip already hit players (use hash of player ID for tracking)\n                const playerIdHash = playerId.length * 1000 + playerId.charCodeAt(0);\n                if (this.chargeHitEntities.has(playerIdHash)) return;\n                const serverPlayerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(serverPlayer.position.x, serverPlayer.position.y, serverPlayer.position.z);\n                const distance = playerPosition.distanceTo(serverPlayerPos);\n                const stopDistance = 0.9 + 1.0; // Player collision radius + buffer\n                if (distance <= stopDistance && serverPlayer.health > 0) {\n                    this.chargeHitEntities.add(playerIdHash);\n                    hitSomething = true;\n                    // Apply damage through PVP system if available\n                    if (this.onProjectileCreatedCallback) {\n                        this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                            damage: chargeDamage,\n                            targetId: playerId,\n                            hitPosition: {\n                                x: serverPlayerPos.x,\n                                y: serverPlayerPos.y,\n                                z: serverPlayerPos.z\n                            }\n                        });\n                    }\n                }\n            });\n            allEntities.forEach((entity)=>{\n                var _this_playerEntity;\n                // Skip self\n                if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n                // Skip already hit entities\n                if (this.chargeHitEntities.has(entity.id)) return;\n                // Check if entity has transform and health (could be enemy or player)\n                const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n                const entityCollider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n                // Debug: Log entity details\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n                const entityPosition = entityTransform.position;\n                const distance = playerPosition.distanceTo(entityPosition);\n                // Check if entity is within charge damage radius\n                // In PVP, we want to stop just before hitting the enemy, not overlap with them\n                const stopDistance = entityCollider ? entityCollider.radius + 1.0 : chargeRadius; // Stop 1 unit away from enemy edge\n                // Debug: Log position and distance information\n                if (distance <= stopDistance) {\n                    // Mark as hit to prevent multiple hits\n                    this.chargeHitEntities.add(entity.id);\n                    hitSomething = true;\n                    // Apply damage through combat system\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        combatSystem.queueDamage(entity, chargeDamage, this.playerEntity, \"charge\");\n                        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                        const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                        // Broadcast charge attack for PVP (includes damage and animation)\n                        if (this.onProjectileCreatedCallback) {\n                            this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                                damage: chargeDamage,\n                                targetId: entity.id,\n                                hitPosition: {\n                                    x: entityPosition.x,\n                                    y: entityPosition.y,\n                                    z: entityPosition.z\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            // In PVP mode, stop charge when hitting something\n            if (hitSomething) {\n                this.chargeStoppedByCollision = true;\n                // Stop the charge movement immediately\n                if (this.playerEntity) {\n                    const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                    if (playerMovement) {\n                        playerMovement.cancelCharge();\n                    }\n                }\n                // Clear the damage interval immediately to prevent further hits\n                clearInterval(damageInterval);\n                // Trigger charge completion\n                this.onChargeComplete();\n            }\n        }, damageCheckInterval);\n    }\n    // Called by sword component when Charge completes\n    onChargeComplete() {\n        this.isSwordCharging = false;\n    }\n    performDeflect(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeflectTime < this.deflectCooldown) {\n            return;\n        }\n        this.isDeflecting = true;\n        this.lastDeflectTime = currentTime;\n        // Trigger Deflect callback for multiplayer\n        if (this.onDeflectCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDeflectCallback(playerTransform.position.clone(), direction);\n        }\n        // Set up deflect barrier that blocks damage and reflects projectiles\n        this.setupDeflectBarrier(playerTransform);\n        // Auto-complete deflect after duration\n        setTimeout(()=>{\n            this.onDeflectComplete();\n        }, this.deflectDuration * 1000);\n    }\n    performViperSting(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastViperStingTime < this.viperStingFireRate) {\n            return;\n        }\n        // Check if player has enough energy (60 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastViperSting()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(60);\n        }\n        this.isViperStingCharging = true;\n        this.viperStingChargeProgress = 0;\n        this.lastViperStingTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.viperStingChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.viperStingChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireViperSting(playerTransform);\n                this.isViperStingCharging = false;\n                this.viperStingChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireViperSting(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Viper Sting damage is handled by ViperStingManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage\n        // Trigger Viper Sting callback for visual effects\n        if (this.onViperStingCallback) {\n            this.onViperStingCallback(playerPosition, direction);\n        }\n        // Trigger the global Viper Sting manager for visual effects\n        const success = (0,_components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_14__.triggerGlobalViperSting)();\n        if (success) {\n        // console.log('🐍 Viper Sting visual effects successfully triggered!');\n        }\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"viper_sting_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 61,\n                lifetime: 5,\n                isReturning: false\n            });\n        }\n    }\n    performBarrage(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastBarrageTime < this.barrageFireRate) {\n            console.log(\"⏰ Barrage on cooldown for \".concat((this.barrageFireRate - (currentTime - this.lastBarrageTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastBarrage()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isBarrageCharging = true;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 500; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.barrageChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.barrageChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireBarrage(playerTransform);\n                this.isBarrageCharging = false;\n                this.barrageChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireBarrage(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        // Apply same downward compensation as projectile system\n        const compensationAngle = Math.PI / 6; // 30 degrees\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Create 5 arrows: center (0°), left (15°, 30°), right (-15°, -30°) using proper ECS projectiles\n        const angles = [\n            0,\n            Math.PI / 12,\n            -Math.PI / 12,\n            Math.PI / 6,\n            -Math.PI / 6\n        ]; // 0°, 15°, -15°, 30°, -30°\n        angles.forEach((angle)=>{\n            // Rotate the base direction by the specified angle around the Y axis\n            const projectileDirection = direction.clone();\n            const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationY(angle);\n            projectileDirection.applyMatrix4(rotationMatrix);\n            projectileDirection.normalize();\n            // Offset spawn position slightly forward to avoid collision with player\n            const spawnPosition = playerPosition.clone();\n            spawnPosition.add(projectileDirection.clone().multiplyScalar(1)); // 1 unit forward\n            // Create proper ECS projectile entity\n            const projectileConfig = {\n                speed: 22,\n                damage: 30,\n                lifetime: 8,\n                maxDistance: 25,\n                piercing: false,\n                subclass: this.currentSubclass,\n                level: 1,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, spawnPosition, projectileDirection, this.playerEntity.id, projectileConfig);\n            // Mark as barrage arrow for visual identification\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__.Renderer);\n            if (renderer === null || renderer === void 0 ? void 0 : renderer.mesh) {\n                renderer.mesh.userData.isBarrageArrow = true;\n                renderer.mesh.userData.isRegularArrow = false; // Override regular arrow marking\n            }\n            // Broadcast projectile creation to other players\n            if (this.onProjectileCreatedCallback) {\n                this.onProjectileCreatedCallback(\"barrage_projectile\", spawnPosition, projectileDirection, projectileConfig);\n            }\n        });\n        // Trigger Barrage callback for additional visual effects if needed\n        if (this.onBarrageCallback) {\n            this.onBarrageCallback(playerPosition, direction);\n        }\n    }\n    setupDeflectBarrier(playerTransform) {\n        // Activate the deflect barrier\n        const playerPosition = playerTransform.getWorldPosition();\n        const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n        if (this.playerEntity) {\n            const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (movement && movement.inputStrength > 0.1) {\n                // Player is actively moving - use movement direction (same as DragonRenderer)\n                const moveDir = movement.moveDirection;\n                if (moveDir.length() > 0.1) {\n                    const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                    playerRotation.y = moveAngle;\n                }\n            } else {\n                // Not moving - use camera direction (same as DragonRenderer fallback)\n                const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(cameraDirection);\n                playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n            }\n        }\n        this.deflectBarrier.activate(playerPosition, playerRotation, this.playerEntity || undefined);\n    }\n    updateDeflectBarrier(playerTransform) {\n        // Update deflect barrier position if it's active\n        if (this.deflectBarrier.isBarrierActive()) {\n            const playerPosition = playerTransform.getWorldPosition();\n            const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n            if (this.playerEntity) {\n                const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                if (movement && movement.inputStrength > 0.1) {\n                    // Player is actively moving - use movement direction (same as DragonRenderer)\n                    const moveDir = movement.moveDirection;\n                    if (moveDir.length() > 0.1) {\n                        const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                        playerRotation.y = moveAngle;\n                    }\n                } else {\n                    // Not moving - use camera direction (same as DragonRenderer fallback)\n                    const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    this.camera.getWorldDirection(cameraDirection);\n                    playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n                }\n            }\n            // Update barrier position to follow player\n            this.deflectBarrier.updatePosition(playerPosition, playerRotation);\n        }\n    }\n    // Called by sword component when Deflect completes\n    onDeflectComplete() {\n        this.isDeflecting = false;\n        this.deflectBarrier.deactivate();\n    }\n    // Public methods to get cooldown information for UI\n    getWeaponSwitchCooldown() {\n        const currentTime = Date.now() / 1000;\n        return {\n            current: Math.max(0, this.weaponSwitchCooldown - (currentTime - this.lastWeaponSwitchTime)),\n            max: this.weaponSwitchCooldown\n        };\n    }\n    getAbilityCooldowns() {\n        const currentTime = Date.now() / 1000;\n        const cooldowns = {};\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deflectCooldown - (currentTime - this.lastDeflectTime)),\n                max: this.deflectCooldown,\n                isActive: this.isDeflecting\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.chargeCooldown - (currentTime - this.lastChargeTime)),\n                max: this.chargeCooldown,\n                isActive: this.isSwordCharging\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.divineStormCooldown - (currentTime - this.lastDivineStormTime)),\n                max: this.divineStormCooldown,\n                isActive: this.isDivineStorming\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.barrageFireRate - (currentTime - this.lastBarrageTime)),\n                max: this.barrageFireRate,\n                isActive: this.isBarrageCharging\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)),\n                max: this.cobraShotFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.viperStingFireRate - (currentTime - this.lastViperStingTime)),\n                max: this.viperStingFireRate,\n                isActive: this.isViperStingCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, 1.0 - (currentTime - this.lastReanimateTime)),\n                max: 1.0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)),\n                max: this.frostNovaFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.crossentropyFireRate - (currentTime - this.lastCrossentropyTime)),\n                max: this.crossentropyFireRate,\n                isActive: false\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.backstabCooldown - (currentTime - this.lastBackstabTime)),\n                max: this.backstabCooldown,\n                isActive: this.isBackstabbing\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.sunderCooldown - (currentTime - this.lastSunderTime)),\n                max: this.sunderCooldown,\n                isActive: this.isSundering\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.skyfallCooldown - (currentTime - this.lastSkyfallTime)),\n                max: this.skyfallCooldown,\n                isActive: this.isSkyfalling\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.RUNEBLADE) {\n            // RUNEBLADE abilities\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deathGraspCooldown - (currentTime - this.lastDeathGraspTime)),\n                max: this.deathGraspCooldown,\n                isActive: this.isDeathGrasping\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.smiteCooldown - (currentTime - this.lastSmiteTime)),\n                max: this.smiteCooldown,\n                isActive: this.isSmiting\n            };\n        // R is unused for RUNEBLADE\n        }\n        return cooldowns;\n    }\n    constructor(camera, inputManager, world, projectileSystem){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        this.playerEntity = null;\n        // Rate limiting for projectile firing\n        this.lastFireTime = 0;\n        this.lastCrossentropyTime = 0 // Separate tracking for CrossentropyBolt\n        ;\n        this.lastReanimateTime = 0 // Separate tracking for Reanimate ability\n        ;\n        this.lastViperStingTime = 0;\n        this.lastFrostNovaTime = 0 // Separate tracking for Frost Nova ability\n        ;\n        this.lastCobraShotTime = 0 // Separate tracking for Cobra Shot ability\n        ;\n        this.fireRate = 0.2 // Default for bow\n        ;\n        this.swordFireRate = 0.9 // Rate for sword attacks\n        ;\n        this.runebladeFireRate = 0.75 // Runeblade attack rate\n        ;\n        this.sabresFireRate = 0.6 // Sabres dual attack rate (600ms between attacks)\n        ;\n        this.scytheFireRate = 0.375 // EntropicBolt rate (0.33s cooldown)\n        ;\n        this.crossentropyFireRate = 2 // CrossentropyBolt rate (1 per second)\n        ;\n        this.viperStingFireRate = 2.5 // Viper Sting rate (2 seconds cooldown)\n        ;\n        this.frostNovaFireRate = 12.0 // Frost Nova rate (12 seconds cooldown)\n        ;\n        this.cobraShotFireRate = 2.5 // Cobra Shot rate (2 seconds cooldown)\n        ;\n        // Current weapon configuration\n        this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW // Default weapon\n        ;\n        this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL // Default for bow\n        ;\n        this.currentLevel = 1;\n        // Weapon-specific states\n        this.isCharging = false;\n        this.chargeProgress = 0;\n        this.isSwinging = false;\n        // Viper Sting charging state\n        this.isViperStingCharging = false;\n        this.viperStingChargeProgress = 0;\n        // Barrage charging state\n        this.isBarrageCharging = false;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = 0;\n        this.barrageFireRate = 5.0 // 5 second cooldown (keeping as requested)\n        ;\n        // Cobra Shot charging state\n        this.isCobraShotCharging = false;\n        this.cobraShotChargeProgress = 0;\n        // Sword-specific states\n        this.swordComboStep = 1;\n        this.lastSwordAttackTime = 0;\n        this.swordComboResetTime = 1 // Reset combo after 1 seconds\n        ;\n        // Divine Storm ability state\n        this.isDivineStorming = false;\n        this.lastDivineStormTime = 0;\n        this.divineStormCooldown = 8.0 // 8 second cooldown\n        ;\n        // Charge ability state\n        this.isSwordCharging = false;\n        this.lastChargeTime = 0;\n        this.chargeCooldown = 8.0 // 8 second cooldown\n        ;\n        // Deflect ability state\n        this.isDeflecting = false;\n        this.lastDeflectTime = 0;\n        this.deflectCooldown = 6.0 // 8 second cooldown\n        ;\n        this.deflectDuration = 3.0 // 3 second duration\n        ;\n        // Skyfall ability state (Sabres)\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.lastSkyfallTime = 0;\n        this.skyfallCooldown = 5.0 // 4 second cooldown\n        ;\n        this.skyfallStartTime = 0;\n        this.skyfallStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.skyfallTargetHeight = 0;\n        this.skyfallOriginalGravity = 0;\n        // Backstab ability state (Sabres)\n        this.lastBackstabTime = 0;\n        this.backstabCooldown = 1.5 // 2 second cooldown\n        ;\n        this.isBackstabbing = false;\n        this.backstabStartTime = 0;\n        this.backstabDuration = 1.0 // Total animation duration (0.3 + 0.4 + 0.3 seconds)\n        ;\n        // Sunder ability state (Sabres)\n        this.lastSunderTime = 0;\n        this.sunderCooldown = 1.125 // 1.5 second cooldown\n        ;\n        this.isSundering = false;\n        this.sunderStartTime = 0;\n        this.sunderDuration = 1.0 // Same animation duration as backstab\n        ;\n        // Sunder stack tracking - Map of entity ID to stack data\n        this.sunderStacks = new Map();\n        // Smite ability state (Runeblade)\n        this.lastSmiteTime = 0;\n        this.smiteCooldown = 2.0 // 2 second cooldown\n        ;\n        this.isSmiting = false;\n        // DeathGrasp ability state (Runeblade)\n        this.lastDeathGraspTime = 0;\n        this.deathGraspCooldown = 5.0 // 5 second cooldown\n        ;\n        this.isDeathGrasping = false;\n        this.lastWeaponSwitchTime = 0;\n        this.weaponSwitchCooldown = 1.5 // 200ms cooldown to prevent rapid switching\n        ;\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Track charge hit entities to prevent multiple hits and enable collision stopping\n        this.chargeHitEntities = new Set();\n        this.chargeStoppedByCollision = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.world = world;\n        this.projectileSystem = projectileSystem;\n        this.deflectBarrier = new _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__.DeflectBarrier(world);\n        this.priority = 5; // Run early for input handling\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUEyQztBQUNjO0FBR25CO0FBRWlCO0FBQ0Y7QUFDSjtBQUNGO0FBQ007QUFDQTtBQUlQO0FBQzJCO0FBQ0o7QUFDZ0M7QUFDNUI7QUFDVTtBQUNFO0FBRTlFLE1BQU1rQixzQkFBc0JoQiwrQ0FBTUE7SUFnTGhDaUIsVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsWUFBWSxHQUFHRDtJQUN0QjtJQUVPRSxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNILFlBQVksRUFBRTtRQUV4QixNQUFNSSxrQkFBa0IsSUFBSSxDQUFDSixZQUFZLENBQUNLLFlBQVksQ0FBQ3ZCLGdFQUFTQTtRQUNoRSxNQUFNd0IsaUJBQWlCLElBQUksQ0FBQ04sWUFBWSxDQUFDSyxZQUFZLENBQUN0Qiw4REFBUUE7UUFFOUQsSUFBSSxDQUFDcUIsbUJBQW1CLENBQUNFLGdCQUFnQjtRQUV6Qyw2QkFBNkI7UUFDN0IsSUFBSSxPQUFPQSxlQUFlQyxhQUFhLEtBQUssWUFBWTtZQUN0REQsZUFBZUMsYUFBYTtRQUM5QjtRQUVBLDhDQUE4QztRQUM5QyxJQUFJLENBQUNDLG1CQUFtQjtRQUV4QiwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDQyxxQkFBcUI7UUFFMUIsMERBQTBEO1FBQzFELElBQUksQ0FBQ0Msa0JBQWtCLENBQUNKLGdCQUFnQkY7UUFFeEMsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ08sb0JBQW9CLENBQUNMLGdCQUFnQkY7UUFFMUMsc0ZBQXNGO1FBQ3RGLElBQUksQ0FBQ0UsZUFBZU0sU0FBUyxJQUFJLENBQUNOLGVBQWVPLFVBQVUsSUFBSSxDQUFDUCxlQUFlUSxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUM3RyxJQUFJLENBQUNDLG1C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LENBQUN3WCxjQUFjLEdBQUcsSUFBSXZnQiwrRUFBY0EsQ0FBQ3VIO1FBQ3pDLElBQUksQ0FBQzRaLFFBQVEsR0FBRyxHQUFHLCtCQUErQjtJQUNwRDtBQXV2RkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ29udHJvbFN5c3RlbS50cz8yYzI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnRyb2wgc3lzdGVtIGZvciBwbGF5ZXIgaW5wdXQgaGFuZGxpbmdcbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDQgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcbmltcG9ydCB7IENvbGxpZGVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBJbnB1dE1hbmFnZXIgfSBmcm9tICdAL2NvcmUvSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5pbXBvcnQgeyBDb21iYXRTeXN0ZW0gfSBmcm9tICcuL0NvbWJhdFN5c3RlbSc7XG5pbXBvcnQgeyBXZWFwb25TdWJjbGFzcywgV2VhcG9uVHlwZSB9IGZyb20gJ0AvY29tcG9uZW50cy9kcmFnb24vd2VhcG9ucyc7XG5pbXBvcnQgeyBEZWZsZWN0QmFycmllciB9IGZyb20gJ0AvY29tcG9uZW50cy93ZWFwb25zL0RlZmxlY3RCYXJyaWVyJztcbmltcG9ydCB7IHRyaWdnZXJHbG9iYWxGcm9zdE5vdmEsIGFkZEdsb2JhbEZyb3plbkVuZW15IH0gZnJvbSAnQC9jb21wb25lbnRzL3dlYXBvbnMvRnJvc3ROb3ZhTWFuYWdlcic7XG5pbXBvcnQgeyBhZGRHbG9iYWxTdHVubmVkRW5lbXkgfSBmcm9tICdAL2NvbXBvbmVudHMvd2VhcG9ucy9TdHVuTWFuYWdlcic7XG5pbXBvcnQgeyB0cmlnZ2VyR2xvYmFsQ29icmFTaG90IH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0NvYnJhU2hvdE1hbmFnZXInO1xuaW1wb3J0IHsgdHJpZ2dlckdsb2JhbFZpcGVyU3RpbmcgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvVmlwZXJTdGluZ01hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgQ29udHJvbFN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBNb3ZlbWVudF07XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FtZXJhOiBQZXJzcGVjdGl2ZUNhbWVyYTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbTtcbiAgcHJpdmF0ZSBwbGF5ZXJFbnRpdHk6IEVudGl0eSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJvdyByZWxlYXNlIGVmZmVjdHNcbiAgcHJpdmF0ZSBvbkJvd1JlbGVhc2VDYWxsYmFjaz86IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIERpdmluZSBTdG9ybSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EaXZpbmVTdG9ybUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgcHJvamVjdGlsZSBjcmVhdGlvblxuICBwcml2YXRlIG9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaz86IChwcm9qZWN0aWxlVHlwZTogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBjb25maWc6IGFueSkgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBWaXBlciBTdGluZyBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25WaXBlclN0aW5nQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBCYXJyYWdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkJhcnJhZ2VDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIFJlYW5pbWF0ZSBoZWFsaW5nIGVmZmVjdFxuICBwcml2YXRlIG9uUmVhbmltYXRlQ2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEZyb3N0IE5vdmEgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uRnJvc3ROb3ZhQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBDb2JyYSBTaG90IGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNvYnJhU2hvdENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgQ2hhcmdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNoYXJnZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgRGVmbGVjdCBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EZWZsZWN0Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgZGVidWZmIGVmZmVjdHMgaW4gUFZQXG4gIHByaXZhdGUgb25EZWJ1ZmZDYWxsYmFjaz86ICh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnIHwgJ3N0dW5uZWQnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBTa3lmYWxsIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblNreWZhbGxDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEJhY2tzdGFiIGFiaWxpdHlcbiAgcHJpdmF0ZSBvbkJhY2tzdGFiQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZGFtYWdlOiBudW1iZXIsIGlzQmFja3N0YWI6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgU3VuZGVyIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblN1bmRlckNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGRhbWFnZTogbnVtYmVyLCBzdGFja0NvdW50OiBudW1iZXIpID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIFNtaXRlIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblNtaXRlQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgb25EYW1hZ2VEZWFsdD86IChkYW1hZ2VEZWFsdDogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAvLyBDYWxsYmFjayBmb3IgRGVhdGhHcmFzcCBhYmlsaXR5XG4gIHByaXZhdGUgb25EZWF0aEdyYXNwQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcblxuICAvLyBDYWxsYmFjayBmb3IgUnVuZWJsYWRlIG1hbmEgY29uc3VtcHRpb25cbiAgcHJpdmF0ZSBvbkNvbnN1bWVNYW5hQ2FsbGJhY2s/OiAoYW1vdW50OiBudW1iZXIpID0+IHZvaWQ7XG5cbiAgLy8gQ2FsbGJhY2sgZm9yIFJ1bmVibGFkZSBtYW5hIGNoZWNraW5nXG4gIHByaXZhdGUgb25DaGVja01hbmFDYWxsYmFjaz86IChhbW91bnQ6IG51bWJlcikgPT4gYm9vbGVhbjtcblxuICAvLyBSYXRlIGxpbWl0aW5nIGZvciBwcm9qZWN0aWxlIGZpcmluZ1xuICBwcml2YXRlIGxhc3RGaXJlVGltZSA9IDA7XG4gIHByaXZhdGUgbGFzdENyb3NzZW50cm9weVRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICBwcml2YXRlIGxhc3RSZWFuaW1hdGVUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIFJlYW5pbWF0ZSBhYmlsaXR5XG4gIHByaXZhdGUgbGFzdFZpcGVyU3RpbmdUaW1lID0gMDtcbiAgcHJpdmF0ZSBsYXN0RnJvc3ROb3ZhVGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBGcm9zdCBOb3ZhIGFiaWxpdHlcbiAgcHJpdmF0ZSBsYXN0Q29icmFTaG90VGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBDb2JyYSBTaG90IGFiaWxpdHlcbiAgcHJpdmF0ZSBmaXJlUmF0ZSA9IDAuMjsgLy8gRGVmYXVsdCBmb3IgYm93XG4gIHByaXZhdGUgc3dvcmRGaXJlUmF0ZSA9IDAuOTsgLy8gUmF0ZSBmb3Igc3dvcmQgYXR0YWNrc1xuICBwcml2YXRlIHJ1bmVibGFkZUZpcmVSYXRlID0gMC43NTsgLy8gUnVuZWJsYWRlIGF0dGFjayByYXRlXG4gIHByaXZhdGUgc2FicmVzRmlyZVJhdGUgPSAwLjY7IC8vIFNhYnJlcyBkdWFsIGF0dGFjayByYXRlICg2MDBtcyBiZXR3ZWVuIGF0dGFja3MpXG4gIHByaXZhdGUgc2N5dGhlRmlyZVJhdGUgPSAwLjM3NTsgLy8gRW50cm9waWNCb2x0IHJhdGUgKDAuMzNzIGNvb2xkb3duKVxuICBwcml2YXRlIGNyb3NzZW50cm9weUZpcmVSYXRlID0gMjsgLy8gQ3Jvc3NlbnRyb3B5Qm9sdCByYXRlICgxIHBlciBzZWNvbmQpXG4gIHByaXZhdGUgdmlwZXJTdGluZ0ZpcmVSYXRlID0gMi41OyAvLyBWaXBlciBTdGluZyByYXRlICgyIHNlY29uZHMgY29vbGRvd24pXG4gIHByaXZhdGUgZnJvc3ROb3ZhRmlyZVJhdGUgPSAxMi4wOyAvLyBGcm9zdCBOb3ZhIHJhdGUgKDEyIHNlY29uZHMgY29vbGRvd24pXG4gIHByaXZhdGUgY29icmFTaG90RmlyZVJhdGUgPSAyLjU7IC8vIENvYnJhIFNob3QgcmF0ZSAoMiBzZWNvbmRzIGNvb2xkb3duKVxuICBcbiAgLy8gQ3VycmVudCB3ZWFwb24gY29uZmlndXJhdGlvblxuICBwcml2YXRlIGN1cnJlbnRXZWFwb246IFdlYXBvblR5cGUgPSBXZWFwb25UeXBlLkJPVzsgLy8gRGVmYXVsdCB3ZWFwb25cbiAgcHJpdmF0ZSBjdXJyZW50U3ViY2xhc3M6IFdlYXBvblN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRUxFTUVOVEFMOyAvLyBEZWZhdWx0IGZvciBib3dcbiAgcHJpdmF0ZSBjdXJyZW50TGV2ZWwgPSAxO1xuICBcbiAgLy8gV2VhcG9uLXNwZWNpZmljIHN0YXRlc1xuICBwcml2YXRlIGlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIHByaXZhdGUgaXNTd2luZ2luZyA9IGZhbHNlO1xuICBcbiAgLy8gVmlwZXIgU3RpbmcgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc1ZpcGVyU3RpbmdDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIHZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIFxuICAvLyBCYXJyYWdlIGNoYXJnaW5nIHN0YXRlXG4gIHByaXZhdGUgaXNCYXJyYWdlQ2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBiYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBwcml2YXRlIGxhc3RCYXJyYWdlVGltZSA9IDA7XG4gIHByaXZhdGUgYmFycmFnZUZpcmVSYXRlID0gNS4wOyAvLyA1IHNlY29uZCBjb29sZG93biAoa2VlcGluZyBhcyByZXF1ZXN0ZWQpXG4gIFxuICAvLyBDb2JyYSBTaG90IGNoYXJnaW5nIHN0YXRlXG4gIHByaXZhdGUgaXNDb2JyYVNob3RDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gMDtcbiAgXG4gIC8vIFN3b3JkLXNwZWNpZmljIHN0YXRlc1xuICBwcml2YXRlIHN3b3JkQ29tYm9TdGVwOiAxIHwgMiB8IDMgPSAxO1xuICBwcml2YXRlIGxhc3RTd29yZEF0dGFja1RpbWUgPSAwO1xuICBwcml2YXRlIHN3b3JkQ29tYm9SZXNldFRpbWUgPSAxOyAvLyBSZXNldCBjb21ibyBhZnRlciAxIHNlY29uZHNcbiAgXG4gIC8vIERpdmluZSBTdG9ybSBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNEaXZpbmVTdG9ybWluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3REaXZpbmVTdG9ybVRpbWUgPSAwO1xuICBwcml2YXRlIGRpdmluZVN0b3JtQ29vbGRvd24gPSA4LjA7IC8vIDggc2Vjb25kIGNvb2xkb3duXG4gIFxuICAvLyBDaGFyZ2UgYWJpbGl0eSBzdGF0ZVxuICBwcml2YXRlIGlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RDaGFyZ2VUaW1lID0gMDtcbiAgcHJpdmF0ZSBjaGFyZ2VDb29sZG93biA9IDguMDsgLy8gOCBzZWNvbmQgY29vbGRvd25cbiAgXG4gIC8vIERlZmxlY3QgYWJpbGl0eSBzdGF0ZVxuICBwcml2YXRlIGlzRGVmbGVjdGluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3REZWZsZWN0VGltZSA9IDA7XG4gIHByaXZhdGUgZGVmbGVjdENvb2xkb3duID0gNi4wOyAvLyA4IHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGRlZmxlY3REdXJhdGlvbiA9IDMuMDsgLy8gMyBzZWNvbmQgZHVyYXRpb25cbiAgcHJpdmF0ZSBkZWZsZWN0QmFycmllcjogRGVmbGVjdEJhcnJpZXI7XG4gIFxuICAvLyBTa3lmYWxsIGFiaWxpdHkgc3RhdGUgKFNhYnJlcylcbiAgcHJpdmF0ZSBpc1NreWZhbGxpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBza3lmYWxsUGhhc2U6ICdub25lJyB8ICdhc2NlbmRpbmcnIHwgJ2Rlc2NlbmRpbmcnIHwgJ2xhbmRpbmcnID0gJ25vbmUnO1xuICBwcml2YXRlIGxhc3RTa3lmYWxsVGltZSA9IDA7XG4gIHByaXZhdGUgc2t5ZmFsbENvb2xkb3duID0gNS4wOyAvLyA0IHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIHNreWZhbGxTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIHNreWZhbGxTdGFydFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBza3lmYWxsVGFyZ2V0SGVpZ2h0ID0gMDtcbiAgcHJpdmF0ZSBza3lmYWxsT3JpZ2luYWxHcmF2aXR5ID0gMDtcbiAgXG4gIC8vIEJhY2tzdGFiIGFiaWxpdHkgc3RhdGUgKFNhYnJlcylcbiAgcHJpdmF0ZSBsYXN0QmFja3N0YWJUaW1lID0gMDtcbiAgcHJpdmF0ZSBiYWNrc3RhYkNvb2xkb3duID0gMS41OyAvLyAyIHNlY29uZCBjb29sZG93blxuICBwcml2YXRlIGlzQmFja3N0YWJiaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgYmFja3N0YWJTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIGJhY2tzdGFiRHVyYXRpb24gPSAxLjA7IC8vIFRvdGFsIGFuaW1hdGlvbiBkdXJhdGlvbiAoMC4zICsgMC40ICsgMC4zIHNlY29uZHMpXG4gIFxuICAvLyBTdW5kZXIgYWJpbGl0eSBzdGF0ZSAoU2FicmVzKVxuICBwcml2YXRlIGxhc3RTdW5kZXJUaW1lID0gMDtcbiAgcHJpdmF0ZSBzdW5kZXJDb29sZG93biA9IDEuMTI1OyAvLyAxLjUgc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgaXNTdW5kZXJpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdW5kZXJTdGFydFRpbWUgPSAwO1xuICBwcml2YXRlIHN1bmRlckR1cmF0aW9uID0gMS4wOyAvLyBTYW1lIGFuaW1hdGlvbiBkdXJhdGlvbiBhcyBiYWNrc3RhYlxuICBcbiAgLy8gU3VuZGVyIHN0YWNrIHRyYWNraW5nIC0gTWFwIG9mIGVudGl0eSBJRCB0byBzdGFjayBkYXRhXG4gIHByaXZhdGUgc3VuZGVyU3RhY2tzID0gbmV3IE1hcDxudW1iZXIsIHsgc3RhY2tzOiBudW1iZXI7IGxhc3RBcHBsaWVkOiBudW1iZXI7IGR1cmF0aW9uOiBudW1iZXIgfT4oKTtcblxuICAvLyBTbWl0ZSBhYmlsaXR5IHN0YXRlIChSdW5lYmxhZGUpXG4gIHByaXZhdGUgbGFzdFNtaXRlVGltZSA9IDA7XG4gIHByaXZhdGUgc21pdGVDb29sZG93biA9IDIuMDsgLy8gMiBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBpc1NtaXRpbmcgPSBmYWxzZTtcblxuICAvLyBEZWF0aEdyYXNwIGFiaWxpdHkgc3RhdGUgKFJ1bmVibGFkZSlcbiAgcHJpdmF0ZSBsYXN0RGVhdGhHcmFzcFRpbWUgPSAwO1xuICBwcml2YXRlIGRlYXRoR3Jhc3BDb29sZG93biA9IDUuMDsgLy8gNSBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBpc0RlYXRoR3Jhc3BpbmcgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoXG4gICAgY2FtZXJhOiBQZXJzcGVjdGl2ZUNhbWVyYSwgXG4gICAgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXIsIFxuICAgIHdvcmxkOiBXb3JsZCxcbiAgICBwcm9qZWN0aWxlU3lzdGVtOiBQcm9qZWN0aWxlU3lzdGVtXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIgPSBpbnB1dE1hbmFnZXI7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbSA9IHByb2plY3RpbGVTeXN0ZW07XG4gICAgdGhpcy5kZWZsZWN0QmFycmllciA9IG5ldyBEZWZsZWN0QmFycmllcih3b3JsZCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDU7IC8vIFJ1biBlYXJseSBmb3IgaW5wdXQgaGFuZGxpbmdcbiAgfVxuXG4gIHB1YmxpYyBzZXRQbGF5ZXIoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICB0aGlzLnBsYXllckVudGl0eSA9IGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcblxuICAgIGNvbnN0IHBsYXllclRyYW5zZm9ybSA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBcbiAgICBpZiAoIXBsYXllclRyYW5zZm9ybSB8fCAhcGxheWVyTW92ZW1lbnQpIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSBkZWJ1ZmYgc3RhdGVzIGZpcnN0XG4gICAgaWYgKHR5cGVvZiBwbGF5ZXJNb3ZlbWVudC51cGRhdGVEZWJ1ZmZzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC51cGRhdGVEZWJ1ZmZzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4cGlyZWQgU3VuZGVyIHN0YWNrcyBwZXJpb2RpY2FsbHlcbiAgICB0aGlzLmNsZWFudXBTdW5kZXJTdGFja3MoKTtcblxuICAgIC8vIEhhbmRsZSB3ZWFwb24gc3dpdGNoaW5nXG4gICAgdGhpcy5oYW5kbGVXZWFwb25Td2l0Y2hpbmcoKTtcblxuICAgIC8vIEhhbmRsZSBkYXNoIG1vdmVtZW50IGZpcnN0IChvdmVycmlkZXMgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmhhbmRsZURhc2hNb3ZlbWVudChwbGF5ZXJNb3ZlbWVudCwgcGxheWVyVHJhbnNmb3JtKTtcblxuICAgIC8vIEhhbmRsZSBjaGFyZ2UgbW92ZW1lbnQgKG92ZXJyaWRlcyByZWd1bGFyIG1vdmVtZW50KVxuICAgIHRoaXMuaGFuZGxlQ2hhcmdlTW92ZW1lbnQocGxheWVyTW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBIYW5kbGUgcGxheWVyIG1vdmVtZW50IGlucHV0IChvbmx5IGlmIG5vdCBkYXNoaW5nLCBjaGFyZ2luZywgZnJvemVuLCBvciBza3lmYWxsaW5nKVxuICAgIGlmICghcGxheWVyTW92ZW1lbnQuaXNEYXNoaW5nICYmICFwbGF5ZXJNb3ZlbWVudC5pc0NoYXJnaW5nICYmICFwbGF5ZXJNb3ZlbWVudC5pc0Zyb3plbiAmJiAhdGhpcy5pc1NreWZhbGxpbmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZW1lbnRJbnB1dChwbGF5ZXJNb3ZlbWVudCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBjb21iYXQgaW5wdXRcbiAgICB0aGlzLmhhbmRsZUNvbWJhdElucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGRlZmxlY3QgYmFycmllciBwb3NpdGlvbiBpZiBhY3RpdmVcbiAgICB0aGlzLnVwZGF0ZURlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1vdmVtZW50SW5wdXQobW92ZW1lbnQ6IE1vdmVtZW50KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcGxheWVyVHJhbnNmb3JtID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCFwbGF5ZXJUcmFuc2Zvcm0pIHJldHVybjtcblxuICAgIC8vIENoZWNrIGZvciBkb3VibGUtdGFwIGRhc2hlcyBmaXJzdCAoYmVmb3JlIHByb2Nlc3NpbmcgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmNoZWNrRm9yRGFzaElucHV0KG1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gR2V0IGlucHV0IGRpcmVjdGlvblxuICAgIGNvbnN0IGlucHV0RGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgbGV0IGhhc0lucHV0ID0gZmFsc2U7XG5cbiAgICAvLyBXQVNEIG1vdmVtZW50XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgndycpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi56IC09IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3MnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueiArPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdhJykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnggLT0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZCcpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi54ICs9IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIGRpYWdvbmFsIG1vdmVtZW50XG4gICAgaWYgKGlucHV0RGlyZWN0aW9uLmxlbmd0aCgpID4gMCkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnB1dCB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBjYW1lcmEgb3JpZW50YXRpb25cbiAgICBpZiAoaGFzSW5wdXQpIHtcbiAgICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FtZXJhJ3MgcmlnaHQgdmVjdG9yXG4gICAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoY2FtZXJhRGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW1lcmEncyBmb3J3YXJkIHZlY3RvciAocHJvamVjdGVkIG9uIFhaIHBsYW5lKVxuICAgICAgY29uc3QgY2FtZXJhRm9yd2FyZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjYW1lcmFGb3J3YXJkLmNyb3NzVmVjdG9ycyhuZXcgVmVjdG9yMygwLCAxLCAwKSwgY2FtZXJhUmlnaHQpLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlXG4gICAgICBjb25zdCB3b3JsZERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB3b3JsZERpcmVjdGlvbi5hZGRTY2FsZWRWZWN0b3IoY2FtZXJhUmlnaHQsIGlucHV0RGlyZWN0aW9uLngpO1xuICAgICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYUZvcndhcmQsIC1pbnB1dERpcmVjdGlvbi56KTtcbiAgICAgIHdvcmxkRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBtb3ZlbWVudC5zZXRNb3ZlRGlyZWN0aW9uKHdvcmxkRGlyZWN0aW9uLCAxLjApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlbWVudC5zZXRNb3ZlRGlyZWN0aW9uKG5ldyBWZWN0b3IzKDAsIDAsIDApLCAwKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUganVtcGluZ1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJyAnKSkgeyAvLyBTcGFjZWJhclxuICAgICAgbW92ZW1lbnQuanVtcCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbGFzdFdlYXBvblN3aXRjaFRpbWUgPSAwO1xuICBwcml2YXRlIHdlYXBvblN3aXRjaENvb2xkb3duID0gMS41OyAvLyAyMDBtcyBjb29sZG93biB0byBwcmV2ZW50IHJhcGlkIHN3aXRjaGluZ1xuXG4gIHByaXZhdGUgaGFuZGxlV2VhcG9uU3dpdGNoaW5nKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gUHJldmVudCByYXBpZCB3ZWFwb24gc3dpdGNoaW5nXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA8IHRoaXMud2VhcG9uU3dpdGNoQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2VhcG9uIHN3aXRjaGluZyB3aXRoIG51bWJlciBrZXlzXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnMScpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlNXT1JEKSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxBYmlsaXR5U3RhdGVzKCk7IC8vIFJlc2V0IGFsbCBhYmlsaXR5IHN0YXRlcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgICAgIHRoaXMuY3VycmVudFdlYXBvbiA9IFdlYXBvblR5cGUuU1dPUkQ7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRElWSU5JVFk7IC8vIERlZmF1bHQgc3dvcmQgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IHRoaXMuc3dvcmRGaXJlUmF0ZTsgLy8gVXNlIHN3b3JkLXNwZWNpZmljIGZpcmUgcmF0ZVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIHRoaXMuc3dvcmRDb21ib1N0ZXAgPSAxOyAvLyBSZXNldCBjb21ibyB3aGVuIHN3aXRjaGluZyB0byBzd29yZFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCcyJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuQk9XKSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxBYmlsaXR5U3RhdGVzKCk7IC8vIFJlc2V0IGFsbCBhYmlsaXR5IHN0YXRlcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgICAgIHRoaXMuY3VycmVudFdlYXBvbiA9IFdlYXBvblR5cGUuQk9XO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkVMRU1FTlRBTDsgLy8gRGVmYXVsdCBib3cgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IDAuMjI1OyAvLyBCb3cgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnMycpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlNDWVRIRSkge1xuICAgICAgICB0aGlzLnJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOyAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNDWVRIRTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5DSEFPUzsgLy8gRGVmYXVsdCBzY3l0aGUgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IHRoaXMuc2N5dGhlRmlyZVJhdGU7IC8vIFVzZSBzY3l0aGUgZmlyZSByYXRlICgwLjVzKVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzQnKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5TQUJSRVMpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5TQUJSRVM7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRlJPU1Q7IC8vIERlZmF1bHQgc2FicmVzIHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSB0aGlzLnNhYnJlc0ZpcmVSYXRlOyAvLyBVc2Ugc2FicmVzLXNwZWNpZmljIGZpcmUgcmF0ZVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzUnKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5SVU5FQkxBREU7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuQVJDQU5FOyAvLyBEZWZhdWx0IHJ1bmVibGFkZSBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5ydW5lYmxhZGVGaXJlUmF0ZTsgLy8gVXNlIHJ1bmVibGFkZSBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gMTsgLy8gUmVzZXQgY29tYm8gd2hlbiBzd2l0Y2hpbmcgdG8gcnVuZWJsYWRlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVDb21iYXRJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuQk9XKSB7XG4gICAgICB0aGlzLmhhbmRsZUJvd0lucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICB0aGlzLmhhbmRsZVNjeXRoZUlucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3dvcmRJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNBQlJFUykge1xuICAgICAgdGhpcy5oYW5kbGVTYWJyZXNJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlJVTkVCTEFERSkge1xuICAgICAgdGhpcy5oYW5kbGVSdW5lYmxhZGVJbnB1dChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQm93SW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgVmlwZXIgU3RpbmcgYWJpbGl0eSB3aXRoICdSJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQmFycmFnZSBhYmlsaXR5IHdpdGggJ1EnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3EnKSkge1xuXG4gICAgICBpZiAoIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDaGFyZ2luZyAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZykge1xuICAgICAgICB0aGlzLnBlcmZvcm1CYXJyYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBDb2JyYSBTaG90IGFiaWxpdHkgd2l0aCAnRScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpKSB7XG5cbiAgICAgIGlmICghdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nICYmICF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQ29icmFTaG90KHBsYXllclRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBib3cgY2hhcmdpbmcgYW5kIGZpcmluZ1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSkgeyAvLyBMZWZ0IG1vdXNlIGJ1dHRvbiBoZWxkXG4gICAgICBpZiAoIXRoaXMuaXNDaGFyZ2luZyAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuXG4gICAgICB9XG4gICAgICAvLyBJbmNyZWFzZSBjaGFyZ2UgcHJvZ3Jlc3MgKGNvdWxkIGJlIHRpbWUtYmFzZWQpXG4gICAgICBpZiAoIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gTWF0aC5taW4odGhpcy5jaGFyZ2VQcm9ncmVzcyArIDAuMDEyNSwgMS4wKTsgLy8gQk9XIENIQVJHRSBTUEVFRFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICAvLyBDaGVjayBpZiBhbnkgYWJpbGl0eSBpcyBjaGFyZ2luZyAtIGlmIHNvLCBjYW5jZWwgdGhlIHJlZ3VsYXIgYm93IHNob3RcbiAgICAgIGlmICh0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nIHx8IHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgfHwgdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdG9yZSBjaGFyZ2UgcHJvZ3Jlc3MgYmVmb3JlIHJlc2V0dGluZyBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICAgIGNvbnN0IGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPSB0aGlzLmNoYXJnZVByb2dyZXNzO1xuICAgICAgXG4gICAgICAvLyBSZWxlYXNlIHRoZSBib3dcbiAgICAgIHRoaXMuZmlyZVByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgdmlzdWFsIGVmZmVjdHMgY2FsbGJhY2sgd2l0aCB0aGUgc3RvcmVkIGNoYXJnZSBwcm9ncmVzc1xuICAgICAgdGhpcy50cmlnZ2VyQm93UmVsZWFzZUVmZmVjdHMoZmluYWxDaGFyZ2VQcm9ncmVzcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTY3l0aGVJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBzY3l0aGUgbGVmdCBjbGljayBmb3IgRW50cm9waWNCb2x0XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uIGhlbGRcbiAgICAgIGlmICghdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgICBjb25zb2xlLmxvZygn4pqhIFN0YXJ0ZWQgY2hhcmdpbmcgc2N5dGhlIChzcGlubmluZyknKTtcbiAgICAgIH1cbiAgICAgIC8vIEluY3JlYXNlIGNoYXJnZSBwcm9ncmVzcyBjb250aW51b3VzbHkgZm9yIHNwaW5uaW5nIGFuaW1hdGlvbiAobm8gY2FwKVxuICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyArPSAwLjAzOyAvLyBDb250aW51b3VzbHkgaW5jcmVhc2UgZm9yIHNwaW5uaW5nXG4gICAgICBcbiAgICAgIC8vIEZpcmUgRW50cm9waWNCb2x0IHByb2plY3RpbGVzIGNvbnRpbnVvdXNseSB3aGlsZSBzcGlubmluZ1xuICAgICAgdGhpcy5maXJlRW50cm9waWNCb2x0UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICAvLyBTdG9wIHNwaW5uaW5nIHdoZW4gbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBDcm9zc2VudHJvcHlCb2x0IGFiaWxpdHkgd2l0aCAnUicga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncicpICYmICF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMuZmlyZUNyb3NzZW50cm9weUJvbHRBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBSZWFuaW1hdGUgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5wZXJmb3JtUmVhbmltYXRlQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRnJvc3QgTm92YSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaXJlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSBwcmV2ZW50IHNwYW0gY2xpY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5maXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIEdldCBkcmFnb24ncyBmYWNpbmcgZGlyZWN0aW9uIChzYW1lIGFzIGNhbWVyYSBkaXJlY3Rpb24gc2luY2UgZHJhZ29uIGZhY2VzIGNhbWVyYSlcbiAgICAvLyBUaGlzIGVuc3VyZXMgYXJyb3dzIGZpcmUgb3V0d2FyZCBmcm9tIHdoZXJlIHRoZSBkcmFnb24gaXMgZmFjaW5nXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gdG8gYWNjb3VudCBmb3IgcmVzdHJpY3RlZCBjYW1lcmEgYm91bmRzXG4gICAgLy8gU2luY2UgY2FtZXJhIGNhbid0IGxvb2sgZG93biBtdWNoIGR1ZSB0byBib3VuZHMsIHdlIGFkZCBhIGZpeGVkIGRvd253YXJkIGFuZ2xlXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBcbiAgICAvLyBDcmVhdGUgYSByb3RhdGlvbiBtYXRyaXggdG8gYXBwbHkgdGhlIGRvd253YXJkIGFuZ2xlIGFyb3VuZCB0aGUgY2FtZXJhJ3MgcmlnaHQgYXhpc1xuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIFBlcmZlY3Qgc2hvdCB0aW1pbmcgY29uc3RhbnRzXG4gICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjc7IC8vIDg1JSBjaGFyZ2VcbiAgICBjb25zdCBwZXJmZWN0U2hvdE1heFRocmVzaG9sZCA9IDAuOTg7IC8vIDk1JSBjaGFyZ2VcbiAgICBjb25zdCBpc1BlcmZlY3RTaG90ID0gdGhpcy5jaGFyZ2VQcm9ncmVzcyA+PSBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCAmJiB0aGlzLmNoYXJnZVByb2dyZXNzIDw9IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGJvdyBpcyBmdWxseSBjaGFyZ2VkIGZvciBzcGVjaWFsIHByb2plY3RpbGVcbiAgICBpZiAodGhpcy5jaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzUGVyZmVjdFNob3QpIHtcbiAgICAgIHRoaXMuY3JlYXRlUGVyZmVjdFNob3RQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWJ1ZzogTG9nIHRoZSBmaXJpbmcgYW5nbGUgdG8gdmVyaWZ5IGl0J3MgY2hhbmdpbmcgd2l0aCBjYW1lcmEgcm90YXRpb25cbiAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnopO1xuICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gdXNlIG5ldyBzY3l0aGUgcmF0ZSAoMC4zNSBzZWNvbmRzKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLnNjeXRoZUZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb25cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiAoc2FtZSBhcyBib3cgcHJvamVjdGlsZXMpXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHNwaW5TdGF0dXMgPSB0aGlzLmlzQ2hhcmdpbmcgPyAnIChTUElOTklORyknIDogJyc7XG4gICAgXG4gICAgdGhpcy5jcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gdXNlIENyb3NzZW50cm9weUJvbHQgcmF0ZSAoMSBwZXIgc2Vjb25kKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q3Jvc3NlbnRyb3B5VGltZSA8IHRoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3Jvc3NlbnRyb3B5VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIEdldCBkcmFnb24ncyBmYWNpbmcgZGlyZWN0aW9uXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSBhbmdsZSBjb21wZW5zYXRpb24gKHNhbWUgYXMgYm93IHByb2plY3RpbGVzKVxuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXMgZG93bndhcmQgY29tcGVuc2F0aW9uXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIFxuICAgIHRoaXMuY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHZhbGlkIHRhcmdldHMgaW4gdGhlIHdvcmxkIGJlZm9yZSBjcmVhdGluZyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuICAgIGNvbnN0IHZhbGlkVGFyZ2V0cyA9IHBvdGVudGlhbFRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiBcbiAgICAgIHRhcmdldC5pZCAhPT0gdGhpcy5wbGF5ZXJFbnRpdHkhLmlkICYmIC8vIE5vdCB0aGUgcGxheWVyIGl0c2VsZlxuICAgICAgIXRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKT8uaXNEZWFkIC8vIE5vdCBkZWFkXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbiBtdWx0aXBsYXllciBtb2RlLCBvbmx5IGNyZWF0ZSBwcm9qZWN0aWxlcyBpZiB0aGVyZSBhcmUgdmFsaWQgdGFyZ2V0cyBvciBpZiB3ZSBuZWVkIHRvIGJyb2FkY2FzdCB0byBvdGhlciBwbGF5ZXJzXG4gICAgY29uc3QgaGFzVmFsaWRUYXJnZXRzID0gdmFsaWRUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc2hvdWxkQnJvYWRjYXN0ID0gdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgIT09IHVuZGVmaW5lZDtcbiAgICBcbiAgICBpZiAoIWhhc1ZhbGlkVGFyZ2V0cyAmJiAhc2hvdWxkQnJvYWRjYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjc1OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZSB1c2luZyB0aGUgUHJvamVjdGlsZVN5c3RlbSB3aXRoIGN1cnJlbnQgd2VhcG9uIGNvbmZpZ1xuICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICBzcGVlZDogMjUsXG4gICAgICBkYW1hZ2U6IDEwLCAvLyBBcnJvdyBkYW1hZ2Ugc2hvdWxkIGJlIDEwXG4gICAgICBsaWZldGltZTogMyxcbiAgICAgIG1heERpc3RhbmNlOiAyNSwgLy8gTGltaXQgYm93IGFycm93cyB0byAyNSB1bml0cyBkaXN0YW5jZVxuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlUHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygncmVndWxhcl9hcnJvdycsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgcHJvamVjdGlsZUNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSB2YWxpZCB0YXJnZXRzIGluIHRoZSB3b3JsZCBiZWZvcmUgY3JlYXRpbmcgcHJvamVjdGlsZXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBjb25zdCB2YWxpZFRhcmdldHMgPSBwb3RlbnRpYWxUYXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gXG4gICAgICB0YXJnZXQuaWQgIT09IHRoaXMucGxheWVyRW50aXR5IS5pZCAmJiAvLyBOb3QgdGhlIHBsYXllciBpdHNlbGZcbiAgICAgICF0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk/LmlzRGVhZCAvLyBOb3QgZGVhZFxuICAgICk7XG4gICAgXG4gICAgLy8gSW4gbXVsdGlwbGF5ZXIgbW9kZSwgb25seSBjcmVhdGUgcHJvamVjdGlsZXMgaWYgdGhlcmUgYXJlIHZhbGlkIHRhcmdldHMgb3IgaWYgd2UgbmVlZCB0byBicm9hZGNhc3QgdG8gb3RoZXIgcGxheWVyc1xuICAgIGNvbnN0IGhhc1ZhbGlkVGFyZ2V0cyA9IHZhbGlkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNob3VsZEJyb2FkY2FzdCA9IHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrICE9PSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKCFoYXNWYWxpZFRhcmdldHMgJiYgIXNob3VsZEJyb2FkY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICgxNSBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdEVudHJvcGljQm9sdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgbWFuYVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lTWFuYSgxMCk7XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAxOyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgRW50cm9waWNCb2x0IHByb2plY3RpbGUgdXNpbmcgdGhlIG5ldyBtZXRob2RcbiAgICBjb25zdCBlbnRyb3BpY0NvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAyMCwgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgICAgZGFtYWdlOiAyMCwgLy8gRW50cm9waWNCb2x0IGRhbWFnZVxuICAgICAgbGlmZXRpbWU6IDIsIC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICAgIHBpZXJjaW5nOiBmYWxzZSwgLy8gTm9uLXBpZXJjaW5nIHNvIHByb2plY3RpbGUgZ2V0cyBkZXN0cm95ZWQgb24gaGl0XG4gICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24gZWZmZWN0XG4gICAgICBleHBsb3Npb25SYWRpdXM6IDAsIC8vIE5vIGV4cGxvc2lvbiByYWRpdXNcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgZW50cm9waWNDb25maWdcbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdlbnRyb3BpY19ib2x0Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBlbnRyb3BpY0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDQwIG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0Q3Jvc3NlbnRyb3B5Qm9sdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgbWFuYVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lTWFuYSg0MCk7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIENvbnN1bWVkIDQwIG1hbmEgZm9yIENyb3NzZW50cm9weSBCb2x0Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAxOyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgQ3Jvc3NlbnRyb3B5Qm9sdCBwcm9qZWN0aWxlIHVzaW5nIHRoZSBleGlzdGluZyBtZXRob2RcbiAgICBjb25zdCBjcm9zc2VudHJvcHlDb25maWcgPSB7XG4gICAgICBzcGVlZDogMTUsIC8vIFNsb3dlciB0aGFuIEVudHJvcGljQm9sdFxuICAgICAgZGFtYWdlOiA5MCwgLy8gSGlnaGVyIGRhbWFnZSBmb3IgUiBhYmlsaXR5XG4gICAgICBsaWZldGltZTogMi41LCAvLyBMb25nZXIgbGlmZXRpbWVcbiAgICAgIHBpZXJjaW5nOiBmYWxzZSwgLy8gXG4gICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBEaXNhYmxlZCBleHBsb3Npb24gZWZmZWN0IGZvciBwZXJmb3JtYW5jZVxuICAgICAgZXhwbG9zaW9uUmFkaXVzOiAwLCAvLyBObyBleHBsb3Npb24gcmFkaXVzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICBjcm9zc2VudHJvcHlDb25maWdcbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdjcm9zc2VudHJvcHlfYm9sdCcsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgY3Jvc3NlbnRyb3B5Q29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1SZWFuaW1hdGVBYmlsaXR5KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJhdGUgbGltaXRpbmcgLSBwcmV2ZW50IHNwYW0gY2FzdGluZyAoMSBzZWNvbmQgY29vbGRvd24pXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZWFuaW1hdGVUaW1lIDwgMS4wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICgyMCBtYW5hIGNvc3QgLSBkb3VibGVkIGZyb20gMTApXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBjb25zdCBjdXJyZW50TWFuYSA9IGdhbWVVSSA/IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpIDogMDtcbiAgICBcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdFJlYW5pbWF0ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgbWFuYVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGNvbnN0IG1hbmFCZWZvcmUgPSBnYW1lVUkuZ2V0Q3VycmVudE1hbmEoKTtcbiAgICAgIGdhbWVVSS5jb25zdW1lTWFuYSgyMCk7XG4gICAgICBjb25zdCBtYW5hQWZ0ZXIgPSBnYW1lVUkuZ2V0Q3VycmVudE1hbmEoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWx3YXlzIHRyaWdnZXIgdGhlIHZpc3VhbCBlZmZlY3QgZmlyc3QsIHJlZ2FyZGxlc3Mgb2YgaGVhbGluZyBzdWNjZXNzXG4gICAgdGhpcy50cmlnZ2VyUmVhbmltYXRlRWZmZWN0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gR2V0IHBsYXllcidzIGhlYWx0aCBjb21wb25lbnQgYW5kIGhlYWwgZm9yIDMwIEhQIFxuICAgIGNvbnN0IGhlYWx0aENvbXBvbmVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIGlmIChoZWFsdGhDb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGRpZEhlYWwgPSBoZWFsdGhDb21wb25lbnQuaGVhbCgzMCk7IC8vIFJFQU5JTUFURSBIRUFMIEFNT1VOVFxuICAgICAgaWYgKGRpZEhlYWwpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYPCfqbggUmVhbmltYXRlIGhlYWxlZCBwbGF5ZXIgZm9yIDMwIEhQLiBDdXJyZW50IGhlYWx0aDogJHtoZWFsdGhDb21wb25lbnQuY3VycmVudEhlYWx0aH0vJHtoZWFsdGhDb21wb25lbnQubWF4SGVhbHRofWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ/CfqbggUmVhbmltYXRlIGNhc3Qgc3VjY2Vzc2Z1bGx5IGJ1dCBwbGF5ZXIgYWxyZWFkeSBhdCBmdWxsIGhlYWx0aCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJpZ2dlclJlYW5pbWF0ZUVmZmVjdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFRyaWdnZXIgdGhlIHZpc3VhbCBoZWFsaW5nIGVmZmVjdFxuICAgIFxuICAgIGlmICh0aGlzLm9uUmVhbmltYXRlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25SZWFuaW1hdGVDYWxsYmFjaygpO1xuICAgIH0gXG4gICAgXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1Gcm9zdE5vdmFBYmlsaXR5KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGcm9zdE5vdmFUaW1lIDwgdGhpcy5mcm9zdE5vdmFGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICg1MCBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdEZyb3N0Tm92YSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgbWFuYVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lTWFuYSg1MCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIEZyb3N0IE5vdmEgY2FsbGJhY2sgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Gcm9zdE5vdmFDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrKHBsYXllclBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaW5kIGFsbCBlbmVtaWVzIHdpdGhpbiA1IHVuaXQgcmFkaXVzIGFuZCBmcmVlemUgdGhlbVxuICAgIHRoaXMuZnJlZXplRW5lbWllc0luUmFkaXVzKHBsYXllclBvc2l0aW9uLCA2LjAsIGN1cnJlbnRUaW1lKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdsb2JhbCBmcm9zdCBub3ZhIHZpc3VhbCBlZmZlY3RcbiAgICB0cmlnZ2VyR2xvYmFsRnJvc3ROb3ZhKHBsYXllclBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q29icmFTaG90VGltZSA8IHRoaXMuY29icmFTaG90RmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBlbmVyZ3kgKDQwIGVuZXJneSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RDb2JyYVNob3QoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNDApO1xuICAgIH1cblxuICAgIHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0Q29icmFTaG90VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSA3NTA7IC8vIDAuNzUgc2Vjb25kIGNoYXJnZSB0aW1lIChiZXR3ZWVuIFZpcGVyIFN0aW5nIGFuZCBCYXJyYWdlKVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBjaGFyZ2VTdGFydFRpbWU7XG4gICAgICB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGFyZ2VJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZmlyZUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlQ29icmFTaG90KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uIChzYW1lIGFzIG90aGVyIHByb2plY3RpbGVzKVxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDAuODI1OyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsIGxpa2UgVmlwZXIgU3RpbmdcbiAgICBcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIGFzIG90aGVyIHByb2plY3RpbGVzXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgXG4gICAgLy8gTm90ZTogQ29icmEgU2hvdCBkYW1hZ2UgaXMgaGFuZGxlZCBieSBDb2JyYVNob3RNYW5hZ2VyLCBub3QgRUNTIHByb2plY3RpbGVzXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgcHJvamVjdGlsZXMgYW5kIGRhbWFnZSAoc2ltaWxhciB0byBWaXBlciBTdGluZylcbiAgICBcbiAgICAvLyBUcmlnZ2VyIENvYnJhIFNob3QgY2FsbGJhY2sgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Db2JyYVNob3RDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkNvYnJhU2hvdENhbGxiYWNrKHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyaWdnZXIgZ2xvYmFsIGNvYnJhIHNob3Qgd2l0aCBwcm9wZXIgcG9zaXRpb25pbmcgKGhhbmRsZXMgbG9jYWwgdmlzdWFsIGVmZmVjdHMgYW5kIGRhbWFnZSlcbiAgICB0cmlnZ2VyR2xvYmFsQ29icmFTaG90KHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2NvYnJhX3Nob3RfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwge1xuICAgICAgICBzcGVlZDogMjAsIC8vIENvbnNpc3RlbnQgc3BlZWQgZm9yIFBWUFxuICAgICAgICBkYW1hZ2U6IDI5LCAvLyBVc2UgY29uc2lzdGVudCBkYW1hZ2UgdmFsdWVcbiAgICAgICAgbGlmZXRpbWU6IDgsXG4gICAgICAgIHZlbm9tRHVyYXRpb246IDZcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZnJlZXplRW5lbWllc0luUmFkaXVzKGNlbnRlclBvc2l0aW9uOiBWZWN0b3IzLCByYWRpdXM6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgbGV0IGZyb3plbkNvdW50ID0gMDtcbiAgICBsZXQgZGFtYWdlZFBsYXllcnMgPSAwO1xuICAgIFxuICAgIC8vIEdldCBsb2NhbCBzb2NrZXQgSUQgdG8gcHJldmVudCBzZWxmLXRhcmdldGluZ1xuICAgIGNvbnN0IGxvY2FsU29ja2V0SWQgPSAod2luZG93IGFzIGFueSkubG9jYWxTb2NrZXRJZDtcbiAgICBcbiAgICBhbGxFbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghZW50aXR5VHJhbnNmb3JtIHx8ICFlbnRpdHlIZWFsdGggfHwgZW50aXR5SGVhbHRoLmlzRGVhZCkgcmV0dXJuO1xuICAgICAgXG4gICAgICAvLyBTa2lwIHNlbGYgKGxvY2FsIHBsYXllciBlbnRpdHkpXG4gICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgZW50aXR5UG9zaXRpb24gPSBlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNlbnRlclBvc2l0aW9uLmRpc3RhbmNlVG8oZW50aXR5UG9zaXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaXMgd2l0aGluIGZyZWV6ZSByYWRpdXNcbiAgICAgIGlmIChkaXN0YW5jZSA8PSByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlbmVteSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZW5lbXkgLSBmcmVlemUgaXQgKHNpbmdsZSBwbGF5ZXIgbW9kZSlcbiAgICAgICAgICBlbmVteS5mcmVlemUoNi4wLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgZnJvemVuQ291bnQrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgZnJvemVuIHZpc3VhbCBlZmZlY3QgZm9yIHRoaXMgZW5lbXlcbiAgICAgICAgICBhZGRHbG9iYWxGcm96ZW5FbmVteShlbnRpdHkuaWQudG9TdHJpbmcoKSwgZW50aXR5UG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGFub3RoZXIgcGxheWVyIGluIFBWUCBtb2RlIC0gZGVhbCBkYW1hZ2UgYW5kIGZyZWV6ZVxuICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogRmlyc3QgY2hlY2sgaWYgdGhpcyBlbnRpdHkgcmVwcmVzZW50cyB0aGUgbG9jYWwgcGxheWVyXG4gICAgICAgICAgY29uc3Qgc2VydmVyUGxheWVyRW50aXRpZXMgPSAod2luZG93IGFzIGFueSkuc2VydmVyUGxheWVyRW50aXRpZXM7XG4gICAgICAgICAgbGV0IHRhcmdldFBsYXllcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc2VydmVyUGxheWVyRW50aXRpZXMgJiYgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudCkge1xuICAgICAgICAgICAgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudC5mb3JFYWNoKChsb2NhbEVudGl0eUlkOiBudW1iZXIsIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsRW50aXR5SWQgPT09IGVudGl0eS5pZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFBsYXllcklkID0gcGxheWVySWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBORVZFUiBkYW1hZ2Ugb3IgZGVidWZmIG91cnNlbHZlc1xuICAgICAgICAgIGlmICh0YXJnZXRQbGF5ZXJJZCAmJiB0YXJnZXRQbGF5ZXJJZCA9PT0gbG9jYWxTb2NrZXRJZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKaoO+4jyBTa2lwcGluZyBGcm9zdCBOb3ZhIG9uIGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9YCk7XG4gICAgICAgICAgICByZXR1cm47IC8vIFNraXAgdGhpcyBlbnRpdHkgY29tcGxldGVseVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkgJiYgdGFyZ2V0UGxheWVySWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb3N0Tm92YURhbWFnZSA9IDUwOyAvLyBGcm9zdCBOb3ZhIGRhbWFnZVxuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgZnJvc3ROb3ZhRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ2Zyb3N0X25vdmEnKTtcbiAgICAgICAgICAgIGRhbWFnZWRQbGF5ZXJzKys7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBmcmVlemUgZWZmZWN0IHRvIHRoZSB0YXJnZXQgcGxheWVyIHNvIHRoZXkgZ2V0IGZyb3plbiBvbiB0aGVpciBlbmRcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGVidWZmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gQnJvYWRjYXN0aW5nIGZyZWV6ZSBlZmZlY3QgdG8gcGxheWVyICR7dGFyZ2V0UGxheWVySWR9IChOT1QgbG9jYWwgcGxheWVyICR7bG9jYWxTb2NrZXRJZH0pYCk7XG4gICAgICAgICAgICAgIHRoaXMub25EZWJ1ZmZDYWxsYmFjayhlbnRpdHkuaWQsICdmcm96ZW4nLCA2MDAwLCBlbnRpdHlQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKGZyb3plbkNvdW50ID4gMCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYOKdhO+4jyBGcm9zdCBOb3ZhIGZyb3plICR7ZnJvemVuQ291bnR9IGVuZW1pZXMgd2l0aGluICR7cmFkaXVzfSB1bml0IHJhZGl1c2ApO1xuICAgIH1cbiAgICBpZiAoZGFtYWdlZFBsYXllcnMgPiAwKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhg4p2E77iPIEZyb3N0IE5vdmEgZGFtYWdlZCAke2RhbWFnZWRQbGF5ZXJzfSBwbGF5ZXJzIHdpdGhpbiAke3JhZGl1c30gdW5pdCByYWRpdXNgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC41OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgY2hhcmdlZCBhcnJvdyBwcm9qZWN0aWxlIC0gbW9yZSBwb3dlcmZ1bCB0aGFuIHJlZ3VsYXIgYXJyb3dzXG4gICAgY29uc3QgY2hhcmdlZEFycm93Q29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDM1LCAvLyBGYXN0ZXIgdGhhbiByZWd1bGFyIGFycm93cyAoMjUpXG4gICAgICBkYW1hZ2U6IDUwLCAvLyBNdWNoIGhpZ2hlciBkYW1hZ2UgdGhhbiByZWd1bGFyIGFycm93cyAoMTApXG4gICAgICBsaWZldGltZTogMiwgLy8gTG9uZ2VyIGxpZmV0aW1lIHRoYW4gcmVndWxhciBhcnJvd3MgKDMpXG4gICAgICBwaWVyY2luZzogdHJ1ZSwgLy8gQ2hhcmdlZCBhcnJvd3MgY2FuIHBpZXJjZSB0aHJvdWdoIGVuZW1pZXNcbiAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIE5vIGV4cGxvc2lvbiwgYnV0IGNvdWxkIGFkZCBzcGVjaWFsIGVmZmVjdHNcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgY2hhcmdlZEFycm93Q29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY2hhcmdlZF9hcnJvdycsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgY2hhcmdlZEFycm93Q29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVBlcmZlY3RTaG90UHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjU7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBwZXJmZWN0IHNob3QgcHJvamVjdGlsZSAtIGVuaGFuY2VkIGNoYXJnZWQgYXJyb3cgd2l0aCBzcGVjaWFsIGVmZmVjdHNcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICB7XG4gICAgICAgIHNwZWVkOiA0MCwgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBjaGFyZ2VkIGFycm93cyAoMzUpXG4gICAgICAgIGRhbWFnZTogNzUsIC8vIEhpZ2hlciBkYW1hZ2UgdGhhbiByZWd1bGFyIGNoYXJnZWQgYXJyb3dzICg1MClcbiAgICAgICAgbGlmZXRpbWU6IDYsIC8vIExvbmdlciBsaWZldGltZSB0aGFuIHJlZ3VsYXIgY2hhcmdlZCBhcnJvd3MgKDUpXG4gICAgICAgIHBpZXJjaW5nOiB0cnVlLCAvLyBQZXJmZWN0IHNob3RzIGNhbiBwaWVyY2UgdGhyb3VnaCBlbmVtaWVzXG4gICAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIE5vIGV4cGxvc2lvbiwgYnV0IGhhcyBzcGVjaWFsIHZpc3VhbCBlZmZlY3RzXG4gICAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH1cbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdwZXJmZWN0X3Nob3QnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIHtcbiAgICAgICAgc3BlZWQ6IDQwLFxuICAgICAgICBkYW1hZ2U6IDc1LFxuICAgICAgICBsaWZldGltZTogNixcbiAgICAgICAgcGllcmNpbmc6IHRydWUsXG4gICAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZHMgdG8gY29uZmlndXJlIHdlYXBvbiBmb3IgdGVzdGluZ1xuICBwdWJsaWMgc2V0V2VhcG9uU3ViY2xhc3Moc3ViY2xhc3M6IFdlYXBvblN1YmNsYXNzKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBzdWJjbGFzcztcbiAgfVxuXG4gIC8vIE1ldGhvZCB0byBzZXQgYm93IHJlbGVhc2UgY2FsbGJhY2tcbiAgcHVibGljIHNldEJvd1JlbGVhc2VDYWxsYmFjayhjYWxsYmFjazogKGZpbmFsUHJvZ3Jlc3M6IG51bWJlciwgaXNQZXJmZWN0U2hvdD86IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREaXZpbmVTdG9ybUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZHVyYXRpb246IG51bWJlcikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrOiAocHJvamVjdGlsZVR5cGU6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgY29uZmlnOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VmlwZXJTdGluZ0NhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25WaXBlclN0aW5nQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRCYXJyYWdlQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkJhcnJhZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgcHVibGljIHNldFJlYW5pbWF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblJlYW5pbWF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRGcm9zdE5vdmFDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRnJvc3ROb3ZhQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldENvYnJhU2hvdENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Db2JyYVNob3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0Q2hhcmdlQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYXJnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREZWZsZWN0Q2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRlZmxlY3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0U2t5ZmFsbENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Ta3lmYWxsQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldEJhY2tzdGFiQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBkYW1hZ2U6IG51bWJlciwgaXNCYWNrc3RhYjogYm9vbGVhbikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25CYWNrc3RhYkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRTdW5kZXJDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGRhbWFnZTogbnVtYmVyLCBzdGFja0NvdW50OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uU3VuZGVyQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRTbWl0ZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgb25EYW1hZ2VEZWFsdD86IChkYW1hZ2VEZWFsdDogYm9vbGVhbikgPT4gdm9pZCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25TbWl0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0RGVhdGhHcmFzcENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EZWF0aEdyYXNwQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRDb25zdW1lTWFuYUNhbGxiYWNrKGNhbGxiYWNrOiAoYW1vdW50OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29uc3VtZU1hbmFDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgcHVibGljIHNldENoZWNrTWFuYUNhbGxiYWNrKGNhbGxiYWNrOiAoYW1vdW50OiBudW1iZXIpID0+IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hlY2tNYW5hQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXREZWJ1ZmZDYWxsYmFjayhjYWxsYmFjazogKHRhcmdldEVudGl0eUlkOiBudW1iZXIsIGRlYnVmZlR5cGU6ICdmcm96ZW4nIHwgJ3Nsb3dlZCcgfCAnc3R1bm5lZCcsIGR1cmF0aW9uOiBudW1iZXIsIHBvc2l0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRlYnVmZkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gdHJpZ2dlciBib3cgcmVsZWFzZSBlZmZlY3RzXG4gIHByaXZhdGUgdHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzKGZpbmFsQ2hhcmdlUHJvZ3Jlc3M6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBhIHBlcmZlY3Qgc2hvdFxuICAgICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjc1OyAvLyA4NSUgY2hhcmdlXG4gICAgICBjb25zdCBwZXJmZWN0U2hvdE1heFRocmVzaG9sZCA9IDAuOTg7IC8vIDk1JSBjaGFyZ2VcbiAgICAgIGNvbnN0IGlzUGVyZmVjdFNob3QgPSBmaW5hbENoYXJnZVByb2dyZXNzID49IHBlcmZlY3RTaG90TWluVGhyZXNob2xkICYmIGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPD0gcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQ7XG4gICAgICBcbiAgICAgIHRoaXMub25Cb3dSZWxlYXNlQ2FsbGJhY2soZmluYWxDaGFyZ2VQcm9ncmVzcywgaXNQZXJmZWN0U2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFdlYXBvbkxldmVsKGxldmVsOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgcHVibGljIGdldEN1cnJlbnRXZWFwb25Db25maWcoKTogeyB3ZWFwb246IFdlYXBvblR5cGU7IHN1YmNsYXNzOiBXZWFwb25TdWJjbGFzczsgbGV2ZWw6IG51bWJlciB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgd2VhcG9uOiB0aGlzLmN1cnJlbnRXZWFwb24sXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWxcbiAgICB9O1xuICB9XG5cbiAgLy8gR2V0dGVycyBmb3Igd2VhcG9uIHN0YXRlIChmb3IgVUkvcmVuZGVyaW5nKVxuICBwdWJsaWMgZ2V0Q3VycmVudFdlYXBvbigpOiBXZWFwb25UeXBlIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50V2VhcG9uO1xuICB9XG5cbiAgcHVibGljIGdldEN1cnJlbnRTdWJjbGFzcygpOiBXZWFwb25TdWJjbGFzcyB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFN1YmNsYXNzO1xuICB9XG5cbiAgcHVibGljIGlzV2VhcG9uQ2hhcmdpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzVmlwZXJTdGluZ0NoYXJnaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldFZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc0JhcnJhZ2VDaGFyZ2luZ0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRCYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNDb2JyYVNob3RDaGFyZ2luZ0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGdldENvYnJhU2hvdENoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNXZWFwb25Td2luZ2luZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1N3aW5naW5nO1xuICB9XG5cbiAgLy8gU3dvcmQtc3BlY2lmaWMgZ2V0dGVyc1xuICBwdWJsaWMgZ2V0U3dvcmRDb21ib1N0ZXAoKTogMSB8IDIgfCAzIHtcbiAgICByZXR1cm4gdGhpcy5zd29yZENvbWJvU3RlcDtcbiAgfVxuXG4gIHB1YmxpYyBpc0RpdmluZVN0b3JtQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRGl2aW5lU3Rvcm1pbmc7XG4gIH1cblxuICBwdWJsaWMgaXNDaGFyZ2VBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTd29yZENoYXJnaW5nO1xuICB9XG5cbiAgcHVibGljIGlzRGVmbGVjdEFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RlZmxlY3Rpbmc7XG4gIH1cbiAgXG4gIHB1YmxpYyBpc1NreWZhbGxBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTa3lmYWxsaW5nO1xuICB9XG4gIFxuICBwdWJsaWMgaXNCYWNrc3RhYkFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0JhY2tzdGFiYmluZztcbiAgfVxuICBcbiAgcHVibGljIGlzU3VuZGVyQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU3VuZGVyaW5nO1xuICB9XG5cbiAgcHVibGljIGlzU21pdGVBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTbWl0aW5nO1xuICB9XG5cbiAgcHVibGljIGlzRGVhdGhHcmFzcEFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RlYXRoR3Jhc3Bpbmc7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVN3b3JkSW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgc3dvcmQgbWVsZWUgYXR0YWNrc1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykgeyAvLyBMZWZ0IG1vdXNlIGJ1dHRvblxuICAgICAgdGhpcy5wZXJmb3JtU3dvcmRNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBEaXZpbmUgU3Rvcm0gYWJpbGl0eSB3aXRoICdSJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNEaXZpbmVTdG9ybWluZyAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzU3dvcmRDaGFyZ2luZyAmJiAhdGhpcy5pc0RlZmxlY3RpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybURpdmluZVN0b3JtKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIENoYXJnZSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEaXZpbmVTdG9ybWluZyAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtQ2hhcmdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIERlZmxlY3QgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNEZWZsZWN0aW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybURlZmxlY3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29tYm8gcmVzZXRcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFN3b3JkQXR0YWNrVGltZSA+IHRoaXMuc3dvcmRDb21ib1Jlc2V0VGltZSkge1xuICAgICAgdGhpcy5zd29yZENvbWJvU3RlcCA9IDE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSdW5lYmxhZGVJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBydW5lYmxhZGUgbWVsZWUgYXR0YWNrc1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzU21pdGluZyAmJiAhdGhpcy5pc0RlYXRoR3Jhc3BpbmcpIHsgLy8gTGVmdCBtb3VzZSBidXR0b25cbiAgICAgIHRoaXMucGVyZm9ybVJ1bmVibGFkZU1lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIFNtaXRlIGFiaWxpdHkgd2l0aCAnRScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU21pdGluZyAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGVhdGhHcmFzcGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtU21pdGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgRGVhdGhHcmFzcCBhYmlsaXR5IHdpdGggJ1EnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3EnKSAmJiAhdGhpcy5pc0RlYXRoR3Jhc3BpbmcgJiYgIXRoaXMuaXNTbWl0aW5nICYmICF0aGlzLmlzU3dpbmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybURlYXRoR3Jhc3AocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29tYm8gcmVzZXRcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFN3b3JkQXR0YWNrVGltZSA+IHRoaXMuc3dvcmRDb21ib1Jlc2V0VGltZSkge1xuICAgICAgdGhpcy5zd29yZENvbWJvU3RlcCA9IDE7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtU3dvcmRNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSBwcmV2ZW50IHNwYW0gY2xpY2tpbmcgKHVzZSBzd29yZC1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc3dvcmRGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMubGFzdFN3b3JkQXR0YWNrVGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgLy8gU2V0IHN3aW5naW5nIHN0YXRlIC0gY29tcGxldGlvbiB3aWxsIGJlIGhhbmRsZWQgYnkgc3dvcmQgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcblxuICAgIC8vIFBlcmZvcm0gbWVsZWUgZGFtYWdlIGluIGEgY29uZSBpbiBmcm9udCBvZiBwbGF5ZXJcbiAgICB0aGlzLnBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gTm90ZTogU3dpbmcgY29tcGxldGlvbiBhbmQgY29tYm8gYWR2YW5jZW1lbnQgaXMgbm93IGhhbmRsZWQgYnkgb25Td29yZFN3aW5nQ29tcGxldGUgY2FsbGJhY2tcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVJ1bmVibGFkZU1lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHJ1bmVibGFkZS1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMucnVuZWJsYWRlRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmxhc3RTd29yZEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcblxuICAgIC8vIFNldCBzd2luZ2luZyBzdGF0ZSAtIGNvbXBsZXRpb24gd2lsbCBiZSBoYW5kbGVkIGJ5IHJ1bmVibGFkZSBjb21wb25lbnQgY2FsbGJhY2tcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSB0cnVlO1xuXG4gICAgLy8gUGVyZm9ybSBtZWxlZSBkYW1hZ2UgaW4gYSBjb25lIGluIGZyb250IG9mIHBsYXllciAoc2FtZSBhcyBzd29yZClcbiAgICB0aGlzLnBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gTm90ZTogU3dpbmcgY29tcGxldGlvbiBhbmQgY29tYm8gYWR2YW5jZW1lbnQgaXMgbm93IGhhbmRsZWQgYnkgb25Td29yZFN3aW5nQ29tcGxldGUgY2FsbGJhY2tcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNtaXRlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdXNpbmcgUnVuZWJsYWRlXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U21pdGVUaW1lIDwgdGhpcy5zbWl0ZUNvb2xkb3duKSB7XG4gICAgICByZXR1cm47IC8vIFN0aWxsIG9uIGNvb2xkb3duXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBzbWl0aW5nXG4gICAgaWYgKHRoaXMuaXNTbWl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMzUgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RTbWl0ZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCAobmVlZCAzNSlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RTbWl0ZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmlzU21pdGluZyA9IHRydWU7XG5cbiAgICAvLyBDb25zdW1lIG1hbmEgKDM1IG1hbmEpXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDM1KTtcbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogQ29uc3VtZWQgMzUgbWFuYS4gTWFuYTogJHttYW5hQmVmb3JlfSAtPiAke21hbmFBZnRlcn1gKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAvLyBPZmZzZXQgdGhlIHNtaXRlIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gbG9vayBsaWtlIGl0J3MgY29taW5nIGZyb20gdGhlIHJ1bmVibGFkZSBzd2luZ1xuICAgIGNvbnN0IHNtaXRlUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigyLjUpKTtcblxuICAgIC8vIE5PVEU6IERhbWFnZSBkZXRlY3Rpb24gaXMgbm93IGhhbmRsZWQgYnkgdGhlIFNtaXRlIHZpc3VhbCBjb21wb25lbnRcbiAgICAvLyB0byBwcmV2ZW50IGRvdWJsZSBkYW1hZ2UuIFRoZSB2aXN1YWwgY29tcG9uZW50J3MgZGFtYWdlIGRldGVjdGlvbiBpcyBtb3JlXG4gICAgLy8gYWNjdXJhdGUgYW5kIHByb3Blcmx5IHRpbWVkIHdpdGggdGhlIGFuaW1hdGlvbi5cblxuICAgIC8vIFRoZSBoZWFsaW5nIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IHRoZSB2aXN1YWwgY29tcG9uZW50J3Mgb25EYW1hZ2VEZWFsdCBjYWxsYmFja1xuICAgIC8vIGluc3RlYWQgb2YgdGhlIENvbnRyb2xTeXN0ZW0ncyBwZXJmb3JtU21pdGVEYW1hZ2UgbWV0aG9kLlxuXG4gICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogRGFtYWdlIGRldGVjdGlvbiBkZWxlZ2F0ZWQgdG8gdmlzdWFsIGNvbXBvbmVudGApO1xuXG4gICAgLy8gVHJpZ2dlciBzbWl0ZSBjYWxsYmFjayB3aXRoIGhlYWxpbmcgY2FsbGJhY2tcbiAgICBpZiAodGhpcy5vblNtaXRlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25TbWl0ZUNhbGxiYWNrKHNtaXRlUG9zaXRpb24sIGRpcmVjdGlvbiwgKGRhbWFnZURlYWx0RmxhZzogYm9vbGVhbikgPT4ge1xuICAgICAgICAvLyBIYW5kbGUgaGVhbGluZyB3aGVuIGRhbWFnZSBpcyBkZWFsdCBieSB0aGUgdmlzdWFsIGNvbXBvbmVudFxuICAgICAgICBpZiAoZGFtYWdlRGVhbHRGbGFnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogRGFtYWdlIGRldGVjdGVkIGJ5IHZpc3VhbCBjb21wb25lbnQsIHRyaWdnZXJpbmcgaGVhbGluZ2ApO1xuICAgICAgICAgIHRoaXMucGVyZm9ybVNtaXRlSGVhbGluZygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBzbWl0aW5nIHN0YXRlIGFmdGVyIGFuaW1hdGlvbiBkdXJhdGlvbiAoc2FtZSBhcyB0aGUgU21pdGUgY29tcG9uZW50KVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5pc1NtaXRpbmcgPSBmYWxzZTtcbiAgICB9LCA5MDApOyAvLyAwLjkgc2Vjb25kcyBtYXRjaGVzIHRoZSBhbmltYXRpb24gZHVyYXRpb25cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNtaXRlRGFtYWdlKHNtaXRlUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBzbWl0ZURhbWFnZSA9IDgwO1xuICAgIGNvbnN0IGRhbWFnZVJhZGl1cyA9IDMuMDsgLy8gU21hbGwgcmFkaXVzIGFyb3VuZCBpbXBhY3QgbG9jYXRpb25cbiAgICBsZXQgZGFtYWdlRGVhbHQgPSBmYWxzZTtcblxuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBlbmVtaWVzL3BsYXllcnNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcblxuICAgIGFsbEVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgIGlmIChlbnRpdHkuaWQgPT09IHRoaXMucGxheWVyRW50aXR5Py5pZCkgcmV0dXJuOyAvLyBEb24ndCBkYW1hZ2Ugc2VsZlxuXG4gICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG5cbiAgICAgIGlmICghZW50aXR5VHJhbnNmb3JtIHx8ICFlbnRpdHlIZWFsdGggfHwgZW50aXR5SGVhbHRoLmlzRGVhZCkgcmV0dXJuO1xuXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHNtaXRlUG9zaXRpb24uZGlzdGFuY2VUbyhlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gZGFtYWdlUmFkaXVzKSB7XG4gICAgICAgIC8vIEVudGl0eSBpcyB3aXRoaW4gZGFtYWdlIHJhZGl1cyAtIGFwcGx5IGRhbWFnZVxuICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICBpZiAoY29tYmF0U3lzdGVtICYmIHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgc21pdGVEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5LCAnc21pdGUnKTtcbiAgICAgICAgICBkYW1hZ2VEZWFsdCA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZSBkZWFsdCAke3NtaXRlRGFtYWdlfSBkYW1hZ2UgdG8gZW50aXR5ICR7ZW50aXR5LmlkfSBhdCBkaXN0YW5jZSAke2Rpc3RhbmNlLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogQ291bGQgbm90IGZpbmQgQ29tYmF0U3lzdGVtIG9yIHBsYXllckVudGl0eSB0byBkZWFsIGRhbWFnZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOT1RFOiBQVlAgcGxheWVyIGRhbWFnZSBkZXRlY3Rpb24gaXMgbm93IGhhbmRsZWQgYnkgdGhlIFNtaXRlIHZpc3VhbCBjb21wb25lbnRcbiAgICAvLyB0byBwcmV2ZW50IGRvdWJsZSBkYW1hZ2UuIFRoZSB2aXN1YWwgY29tcG9uZW50IHByb3Blcmx5IGhhbmRsZXMgUFZQIGRhbWFnZVxuICAgIC8vIHRocm91Z2ggdGhlIGJyb2FkY2FzdFBsYXllckRhbWFnZSBzeXN0ZW0uXG5cbiAgICByZXR1cm4gZGFtYWdlRGVhbHQ7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1TbWl0ZUhlYWxpbmcoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc29sZS5sb2coYOKaoSBTbWl0ZTogTm8gcGxheWVyIGVudGl0eSBhdmFpbGFibGUgZm9yIGhlYWxpbmdgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgcGxheWVyJ3MgaGVhbHRoIGNvbXBvbmVudCBhbmQgaGVhbCBmb3IgMjAgSFAgKGxpa2UgUmVhbmltYXRlIGFiaWxpdHkpXG4gICAgY29uc3QgaGVhbHRoQ29tcG9uZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKGhlYWx0aENvbXBvbmVudCkge1xuICAgICAgY29uc3Qgb2xkSGVhbHRoID0gaGVhbHRoQ29tcG9uZW50LmN1cnJlbnRIZWFsdGg7XG4gICAgICBjb25zdCBtYXhIZWFsdGggPSBoZWFsdGhDb21wb25lbnQubWF4SGVhbHRoO1xuXG4gICAgICAvLyBBbHdheXMgYXR0ZW1wdCB0byBoZWFsLCBldmVuIGlmIGF0IGZ1bGwgaGVhbHRoIChoZWFsIG1ldGhvZCBoYW5kbGVzIHRoaXMpXG4gICAgICBjb25zdCBkaWRIZWFsID0gaGVhbHRoQ29tcG9uZW50LmhlYWwoMjApOyAvLyBTbWl0ZSBoZWFsaW5nIGFtb3VudFxuXG4gICAgICBpZiAoZGlkSGVhbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlIFNVQ0NFU1NGVUxMWSBoZWFsZWQgcGxheWVyIGZvciAyMCBIUCEgSGVhbHRoOiAke29sZEhlYWx0aH0gLT4gJHtoZWFsdGhDb21wb25lbnQuY3VycmVudEhlYWx0aH0vJHttYXhIZWFsdGh9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBQbGF5ZXIgYWxyZWFkeSBhdCBmdWxsIGhlYWx0aCAoJHtoZWFsdGhDb21wb25lbnQuY3VycmVudEhlYWx0aH0vJHttYXhIZWFsdGh9KSAtIG5vIGhlYWxpbmcgbmVlZGVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgU21pdGU6IENSSVRJQ0FMIEVSUk9SIC0gQ291bGQgbm90IGZpbmQgaGVhbHRoIGNvbXBvbmVudCBmb3IgcGxheWVyIGVudGl0eSAke3RoaXMucGxheWVyRW50aXR5LmlkfWApO1xuXG4gICAgICAvLyBGYWxsYmFjazogVHJ5IHRvIGhlYWwgdGhyb3VnaCBnYW1lVUkgaWYgaGVhbHRoIGNvbXBvbmVudCBpcyBub3QgYXZhaWxhYmxlXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgICAgICBpZiAoZ2FtZVVJICYmIHR5cGVvZiBnYW1lVUkuZ2FpbkhlYWx0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdhbWVVSS5nYWluSGVhbHRoKDIwKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBGQUxMQkFDSyBoZWFsaW5nIHRocm91Z2ggZ2FtZVVJIC0gaGVhbGVkIGZvciAyMCBIUGApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqhIFNtaXRlOiBDb3VsZCBub3QgaGVhbCB0aHJvdWdoIGZhbGxiYWNrIG1ldGhvZCBlaXRoZXJgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1EZWF0aEdyYXNwKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdXNpbmcgUnVuZWJsYWRlXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVhdGhHcmFzcFRpbWUgPCB0aGlzLmRlYXRoR3Jhc3BDb29sZG93bikge1xuICAgICAgcmV0dXJuOyAvLyBTdGlsbCBvbiBjb29sZG93blxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgZGVhdGggZ3Jhc3BpbmdcbiAgICBpZiAodGhpcy5pc0RlYXRoR3Jhc3BpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICgyNSBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdERlYXRoR3Jhc3AoKSkge1xuICAgICAgY29uc29sZS5sb2coYPCfkoAgRGVhdGhHcmFzcDogTm90IGVub3VnaCBtYW5hIHRvIGNhc3QgKG5lZWQgMjUpYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0RGVhdGhHcmFzcFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmlzRGVhdGhHcmFzcGluZyA9IHRydWU7XG5cbiAgICAvLyBDb25zdW1lIG1hbmEgKDI1IG1hbmEpXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDI1KTtcbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc29sZS5sb2coYPCfkoAgRGVhdGhHcmFzcDogQ29uc3VtZWQgMjUgbWFuYS4gTWFuYTogJHttYW5hQmVmb3JlfSAtPiAke21hbmFBZnRlcn1gKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAvLyBUcmlnZ2VyIGRlYXRoIGdyYXNwIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMub25EZWF0aEdyYXNwQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25EZWF0aEdyYXNwQ2FsbGJhY2socG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgZGVhdGggZ3Jhc3Bpbmcgc3RhdGUgYWZ0ZXIgYW5pbWF0aW9uIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmlzRGVhdGhHcmFzcGluZyA9IGZhbHNlO1xuICAgIH0sIDEyMDApOyAvLyAxLjIgc2Vjb25kcyBtYXRjaGVzIHRoZSBhbmltYXRpb24gZHVyYXRpb25cbiAgfVxuXG4gIC8vIENhbGxlZCBieSBzd29yZCBjb21wb25lbnQgd2hlbiBzd2luZyBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvblN3b3JkU3dpbmdDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTd2luZ2luZykgcmV0dXJuOyAvLyBQcmV2ZW50IG11bHRpcGxlIGNhbGxzXG5cbiAgICAvLyBSZXNldCBzd2luZ2luZyBzdGF0ZVxuICAgIHRoaXMuaXNTd2luZ2luZyA9IGZhbHNlO1xuXG4gICAgLy8gQWR2YW5jZSBjb21ibyBzdGVwIGZvciBuZXh0IGF0dGFja1xuICAgIHRoaXMuc3dvcmRDb21ib1N0ZXAgPSAodGhpcy5zd29yZENvbWJvU3RlcCAlIDMgKyAxKSBhcyAxIHwgMiB8IDM7XG5cbiAgfVxuXG4gIC8vIENhbGxlZCBieSBydW5lYmxhZGUgY29tcG9uZW50IHdoZW4gc21pdGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuICBwdWJsaWMgb25TbWl0ZUNvbXBsZXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1NtaXRpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuXG4gICAgLy8gUmVzZXQgc21pdGluZyBzdGF0ZVxuICAgIHRoaXMuaXNTbWl0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgcnVuZWJsYWRlIGNvbXBvbmVudCB3aGVuIGRlYXRoIGdyYXNwIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uRGVhdGhHcmFzcENvbXBsZXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc0RlYXRoR3Jhc3BpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuXG4gICAgLy8gUmVzZXQgZGVhdGggZ3Jhc3Bpbmcgc3RhdGVcbiAgICB0aGlzLmlzRGVhdGhHcmFzcGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTYWJyZXNJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBsZWZ0IGNsaWNrIGZvciBkdWFsIHNhYnJlIGF0dGFja1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzU2t5ZmFsbGluZyAmJiAhdGhpcy5pc1N1bmRlcmluZykge1xuICAgICAgdGhpcy5wZXJmb3JtU2FicmVzTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFEga2V5IGZvciBCYWNrc3RhYiBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1CYWNrc3RhYihwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRSBrZXkgZm9yIFN1bmRlciBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1TdW5kZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFIga2V5IGZvciBTa3lmYWxsIGFiaWxpdHkgKHN3aXRjaGVkIGZyb20gRSlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNTa3lmYWxsaW5nICYmICF0aGlzLmlzU3VuZGVyaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1Ta3lmYWxsKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBTa3lmYWxsIHN0YXRlIGlmIGFjdGl2ZVxuICAgIGlmICh0aGlzLmlzU2t5ZmFsbGluZykge1xuICAgICAgdGhpcy51cGRhdGVTa3lmYWxsTW92ZW1lbnQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIEJhY2tzdGFiIHN0YXRlIGlmIGFjdGl2ZVxuICAgIGlmICh0aGlzLmlzQmFja3N0YWJiaW5nKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJhY2tzdGFiU3RhdGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIFN1bmRlciBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc1N1bmRlcmluZykge1xuICAgICAgdGhpcy51cGRhdGVTdW5kZXJTdGF0ZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHNhYnJlcy1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc2FicmVzRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pqU77iPIFNhYnJlcyBkdWFsIGF0dGFjayBpbml0aWF0ZWQnKTtcbiAgICBcbiAgICAvLyBTZXQgc3dpbmdpbmcgc3RhdGUgLSBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieSBzYWJyZXMgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIG1lbGVlIGRhbWFnZSBpbiBhIGNvbmUgaW4gZnJvbnQgb2YgcGxheWVyIChkdWFsIGF0dGFjaylcbiAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHNhYnJlcyBjb21wb25lbnQgd2hlbiBzd2luZyBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvblNhYnJlc1N3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGR1YWwgc3dpbmcgY29tcGxldGVkJyk7XG4gICAgXG4gICAgLy8gUmVzZXQgc3dpbmdpbmcgc3RhdGVcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIHRoYXQgY291bGQgYmUgZGFtYWdlZFxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSBhbGxFbnRpdGllcy5maWx0ZXIoZW50aXR5ID0+IFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChIZWFsdGgpICYmIFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChUcmFuc2Zvcm0pICYmXG4gICAgICBlbnRpdHkgIT09IHRoaXMucGxheWVyRW50aXR5XG4gICAgKTtcbiAgICBcbiAgICAvLyBTQUJSRVMgREFNQUdFXG4gICAgY29uc3QgYXR0YWNrUmFuZ2UgPSAzLjg7IC8vIFNsaWdodGx5IGxvbmdlciByYW5nZSB0aGFuIHN3b3JkXG4gICAgY29uc3QgYXR0YWNrQW5nbGUgPSBNYXRoLlBJIC8gMjsgLy8gNjAgZGVncmVlIGNvbmUgKHdpZGVyIHRoYW4gc3dvcmQpXG4gICAgY29uc3QgbGVmdFNhYnJlRGFtYWdlID0gMTk7XG4gICAgY29uc3QgcmlnaHRTYWJyZURhbWFnZSA9IDIzO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEgZGlyZWN0aW9uIGZvciBhdHRhY2sgZGlyZWN0aW9uXG4gICAgY29uc3QgYXR0YWNrRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihhdHRhY2tEaXJlY3Rpb24pO1xuICAgIGF0dGFja0RpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBvdGVudGlhbFRhcmdldHMpIHtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldEhlYWx0aCB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIGRpcmVjdGlvbiB0byB0YXJnZXRcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBjb25zdCBkaXN0YW5jZVRvVGFyZ2V0ID0gZGlyZWN0aW9uVG9UYXJnZXQubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkaXN0YW5jZVRvVGFyZ2V0ID4gYXR0YWNrUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgd2l0aGluIGF0dGFjayBjb25lXG4gICAgICBkaXJlY3Rpb25Ub1RhcmdldC5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBhdHRhY2tEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVG9UYXJnZXQgPSBNYXRoLmFjb3MoTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIGRvdFByb2R1Y3QpKSk7XG4gICAgICBcbiAgICAgIGlmIChhbmdsZVRvVGFyZ2V0ID4gYXR0YWNrQW5nbGUgLyAyKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gVGFyZ2V0IGlzIHdpdGhpbiByYW5nZSBhbmQgY29uZSAtIGFwcGx5IGRhbWFnZSBmcm9tIGJvdGggc2FicmVzXG4gICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICAvLyBMZWZ0IHNhYnJlIGhpdCAoaW1tZWRpYXRlKVxuICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCBsZWZ0U2FicmVEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSaWdodCBzYWJyZSBoaXQgKHdpdGggc21hbGwgZGVsYXkpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghdGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldCwgcmlnaHRTYWJyZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7IC8vIDEwMG1zIGRlbGF5IGJldHdlZW4gc2FicmUgaGl0c1xuICAgICAgICBcbiAgICAgICAgaGl0Q291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTa3lmYWxsIGFiaWxpdHkgaW1wbGVtZW50YXRpb25cbiAgcHJpdmF0ZSBwZXJmb3JtU2t5ZmFsbChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSA8IHRoaXMuc2t5ZmFsbENvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGVuZXJneSBjb3N0XG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoIWdhbWVVSSB8fCAhZ2FtZVVJLmNhbkNhc3RTa3lmYWxsKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg0MCk7XG4gICAgXG4gICAgLy8gU3RhcnQgU2t5ZmFsbFxuICAgIHRoaXMuaXNTa3lmYWxsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdhc2NlbmRpbmcnO1xuICAgIHRoaXMuc2t5ZmFsbFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMubGFzdFNreWZhbGxUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5za3lmYWxsU3RhcnRQb3NpdGlvbi5jb3B5KHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgXG4gICAgLy8gU2V0IHRhcmdldCBoZWlnaHQgKGRvdWJsZSBqdW1wIGhlaWdodClcbiAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5Py5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgdGhpcy5za3lmYWxsT3JpZ2luYWxHcmF2aXR5ID0gcGxheWVyTW92ZW1lbnQuZ3Jhdml0eTtcbiAgICAgIHRoaXMuc2t5ZmFsbFRhcmdldEhlaWdodCA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55ICsgKHBsYXllck1vdmVtZW50Lmp1bXBGb3JjZSAqIDEuNCk7IC8vIFJlZHVjZWQgaGVpZ2h0IGJ5IDMwJSAod2FzIDJ4LCBub3cgMS40eClcbiAgICAgICAgICAgIFxuICAgICAgLy8gQXBwbHkgdXB3YXJkIHZlbG9jaXR5XG4gICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gcGxheWVyTW92ZW1lbnQuanVtcEZvcmNlICogMjsgLy8gU3Ryb25nZXIgaW5pdGlhbCB2ZWxvY2l0eVxuICAgICAgcGxheWVyTW92ZW1lbnQuZ3Jhdml0eSA9IDA7IC8vIERpc2FibGUgZ3Jhdml0eSBkdXJpbmcgYXNjZW50XG4gICAgICAvLyBEb24ndCBkaXNhYmxlIGNhbk1vdmUgYXMgaXQgcHJldmVudHMgYWxsIHBoeXNpY3MgdXBkYXRlcyBpbmNsdWRpbmcgZ3Jhdml0eVxuICAgICAgLy8gSW5zdGVhZCB3ZSdsbCBjb250cm9sIGhvcml6b250YWwgbW92ZW1lbnQgaW4gdGhlIENvbnRyb2xTeXN0ZW1cbiAgICB9XG5cbiAgICBcbiAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllci92aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uU2t5ZmFsbENhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIHRoaXMub25Ta3lmYWxsQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVTa3lmYWxsTW92ZW1lbnQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHk/LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKCFwbGF5ZXJNb3ZlbWVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSB0aGlzLnNreWZhbGxTdGFydFRpbWU7XG4gICAgXG5cbiAgICBcbiAgICBzd2l0Y2ggKHRoaXMuc2t5ZmFsbFBoYXNlKSB7XG4gICAgICBjYXNlICdhc2NlbmRpbmcnOlxuICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRhcmdldCBoZWlnaHQgb3Igc3RhcnRlZCBmYWxsaW5nXG4gICAgICAgIGlmIChwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24ueSA+PSB0aGlzLnNreWZhbGxUYXJnZXRIZWlnaHQgfHwgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnZGVzY2VuZGluZyc7XG4gICAgICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueSA9IDA7IC8vIFN0b3AgYXQgcGVha1xuICAgICAgICAgIHBsYXllck1vdmVtZW50LmdyYXZpdHkgPSB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHkgKiAzMDsgLy8gRmFzdGVyIGRlc2NlbnRcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdkZXNjZW5kaW5nJzpcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgbGFuZGVkIChjbG9zZSB0byBvcmlnaW5hbCBoZWlnaHQgb3Igb24gZ3JvdW5kKVxuICAgICAgICBpZiAocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLnkgPD0gdGhpcy5za3lmYWxsU3RhcnRQb3NpdGlvbi55ICsgMC41KSB7XG4gICAgICAgICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnbGFuZGluZyc7XG4gICAgICAgICAgdGhpcy5wZXJmb3JtU2t5ZmFsbExhbmRpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdsYW5kaW5nJzpcbiAgICAgICAgLy8gTGFuZGluZyBwaGFzZSBjb21wbGV0ZVxuICAgICAgICB0aGlzLmNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIC8vIFNhZmV0eSB0aW1lb3V0IChpZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgZW5kIGFmdGVyIDUgc2Vjb25kcylcbiAgICBpZiAoZWxhcHNlZFRpbWUgPiA0LjApIHtcbiAgICAgIHRoaXMuY29tcGxldGVTa3lmYWxsQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBwZXJmb3JtU2t5ZmFsbExhbmRpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBEZWFsIGRhbWFnZSB0byBlbmVtaWVzIGluIGxhbmRpbmcgYXJlYVxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IGxhbmRpbmdQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCBkYW1hZ2VSYWRpdXMgPSA0LjA7IC8vIDQgdW5pdCByYWRpdXNcbiAgICBjb25zdCBza3lmYWxsRGFtYWdlID0gMTI1OyAvLyAxMjUgZGFtYWdlIGFzIHJlcXVlc3RlZFxuICAgIFxuICAgIGxldCBoaXRDb3VudCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgYWxsRW50aXRpZXMpIHtcbiAgICAgIGlmIChlbnRpdHkgPT09IHRoaXMucGxheWVyRW50aXR5KSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBkaXN0YW5jZSB0byBsYW5kaW5nIHBvc2l0aW9uXG4gICAgICBjb25zdCBkaXN0YW5jZVRvTGFuZGluZyA9IGxhbmRpbmdQb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZVRvTGFuZGluZyA8PSBkYW1hZ2VSYWRpdXMpIHtcbiAgICAgICAgLy8gQXBwbHkgU2t5ZmFsbCBkYW1hZ2VcbiAgICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIHNreWZhbGxEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gICAgICAgICAgaGl0Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBjb21wbGV0ZVNreWZhbGxBYmlsaXR5KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmVzZXQgYWxsIFNreWZhbGwgc3RhdGVzXG4gICAgdGhpcy5pc1NreWZhbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdub25lJztcbiAgICBcbiAgICAvLyBSZXN0b3JlIHBsYXllciBtb3ZlbWVudFxuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHk/LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC5ncmF2aXR5ID0gdGhpcy5za3lmYWxsT3JpZ2luYWxHcmF2aXR5O1xuICAgICAgcGxheWVyTW92ZW1lbnQudmVsb2NpdHkueSA9IDA7IC8vIFN0b3AgYW55IHJlbWFpbmluZyB2ZXJ0aWNhbCBtb3ZlbWVudFxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVCYWNrc3RhYlN0YXRlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBjb25zdCBlbGFwc2VkVGltZSA9IGN1cnJlbnRUaW1lIC0gdGhpcy5iYWNrc3RhYlN0YXJ0VGltZTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBiYWNrc3RhYiBhbmltYXRpb24gZHVyYXRpb24gaGFzIGVsYXBzZWRcbiAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGhpcy5iYWNrc3RhYkR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmlzQmFja3N0YWJiaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvLyBTdW5kZXIgYWJpbGl0eSBpbXBsZW1lbnRhdGlvblxuICBwcml2YXRlIHBlcmZvcm1TdW5kZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U3VuZGVyVGltZSA8IHRoaXMuc3VuZGVyQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZW5lcmd5IGNvc3QgKDM1IGVuZXJneSlcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmICghZ2FtZVVJIHx8ICFnYW1lVUkuY2FuQ2FzdFN1bmRlcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koMzUpO1xuICAgIFxuICAgIC8vIFNldCBjb29sZG93blxuICAgIHRoaXMubGFzdFN1bmRlclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBzdW5kZXIgYW5pbWF0aW9uIChzYW1lIGFzIGJhY2tzdGFiKVxuICAgIHRoaXMuaXNTdW5kZXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VuZGVyU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBzdW5kZXIgZGFtYWdlIHdpdGggc3RhY2tpbmcgbG9naWNcbiAgICB0aGlzLnBlcmZvcm1TdW5kZXJEYW1hZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVTdW5kZXJTdGF0ZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuc3VuZGVyU3RhcnRUaW1lO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHN1bmRlciBhbmltYXRpb24gZHVyYXRpb24gaGFzIGVsYXBzZWRcbiAgICBpZiAoZWxhcHNlZFRpbWUgPj0gdGhpcy5zdW5kZXJEdXJhdGlvbikge1xuICAgICAgdGhpcy5pc1N1bmRlcmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBwZXJmb3JtU3VuZGVyRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGVuZW1pZXMvcGxheWVyc1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgZmFjaW5nIGRpcmVjdGlvbiAoY2FtZXJhIGRpcmVjdGlvbilcbiAgICBjb25zdCBwbGF5ZXJEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKHBsYXllckRpcmVjdGlvbik7XG4gICAgcGxheWVyRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHN1bmRlclJhbmdlID0gMy41OyAvLyBTYW1lIHJhbmdlIGFzIGJhY2tzdGFiXG4gICAgbGV0IGhpdENvdW50ID0gMDtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBpZiAoZW50aXR5ID09PSB0aGlzLnBsYXllckVudGl0eSkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRIZWFsdGggfHwgIXRhcmdldFRyYW5zZm9ybSB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIHJhbmdlXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZSA+IHN1bmRlclJhbmdlKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIGZyb250IG9mIHBsYXllciAoY29uZSBhdHRhY2spXG4gICAgICBjb25zdCBkaXJlY3Rpb25Ub1RhcmdldCA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgLnN1YlZlY3RvcnModGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLCBwbGF5ZXJQb3NpdGlvbilcbiAgICAgICAgLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICBjb25zdCBkb3RQcm9kdWN0ID0gcGxheWVyRGlyZWN0aW9uLmRvdChkaXJlY3Rpb25Ub1RhcmdldCk7XG4gICAgICBjb25zdCBhbmdsZVRocmVzaG9sZCA9IE1hdGguY29zKE1hdGguUEkgLyA0KTsgLy8gNjAgZGVncmVlIGNvbmVcbiAgICAgIFxuICAgICAgaWYgKGRvdFByb2R1Y3QgPCBhbmdsZVRocmVzaG9sZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IFN1bmRlciBzdGFja3MgYW5kIGNhbGN1bGF0ZSBkYW1hZ2VcbiAgICAgIGNvbnN0IHsgZGFtYWdlLCBzdGFja0NvdW50LCBpc1N0dW5uZWQgfSA9IHRoaXMuYXBwbHlTdW5kZXJTdGFjayhlbnRpdHkuaWQsIGN1cnJlbnRUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgZGFtYWdlXG4gICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgaWYgKGNvbWJhdFN5c3RlbSkge1xuICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoXG4gICAgICAgICAgZW50aXR5LFxuICAgICAgICAgIGRhbWFnZSxcbiAgICAgICAgICB0aGlzLnBsYXllckVudGl0eSEsXG4gICAgICAgICAgJ3N1bmRlcidcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IHN0dW4gZWZmZWN0IGlmIGF0IDMgc3RhY2tzXG4gICAgICAgIGlmIChpc1N0dW5uZWQpIHtcbiAgICAgICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgICAgIGlmIChlbmVteSkge1xuICAgICAgICAgICAgZW5lbXkuZnJlZXplKDQuMCwgY3VycmVudFRpbWUpOyAvLyA0IHNlY29uZCBzdHVuICh1c2luZyBmcmVlemUgbWVjaGFuaWNzIGZvciBtb3ZlbWVudClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIHZpc3VhbCBzdHVuIGVmZmVjdCAoZGlmZmVyZW50IGZyb20gZnJlZXplKVxuICAgICAgICAgICAgYWRkR2xvYmFsU3R1bm5lZEVuZW15KGVudGl0eS5pZC50b1N0cmluZygpLCB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBCcm9hZGNhc3Qgc3R1biBlZmZlY3QgZm9yIFBWUCAodXNpbmcgbmV3ICdzdHVubmVkJyB0eXBlKVxuICAgICAgICAgIC8vIENSSVRJQ0FMIEZJWDogQ2hlY2sgaWYgd2UncmUgYWJvdXQgdG8gdGFyZ2V0IG91cnNlbHZlcyBiZWZvcmUgYnJvYWRjYXN0aW5nIGRlYnVmZlxuICAgICAgICAgIGlmICh0aGlzLm9uRGVidWZmQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU29ja2V0SWQgPSAod2luZG93IGFzIGFueSkubG9jYWxTb2NrZXRJZDtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclBsYXllckVudGl0aWVzID0gKHdpbmRvdyBhcyBhbnkpLnNlcnZlclBsYXllckVudGl0aWVzO1xuICAgICAgICAgICAgbGV0IHRhcmdldFBsYXllcklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlcnZlclBsYXllckVudGl0aWVzICYmIHNlcnZlclBsYXllckVudGl0aWVzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgc2VydmVyUGxheWVyRW50aXRpZXMuY3VycmVudC5mb3JFYWNoKChsb2NhbEVudGl0eUlkOiBudW1iZXIsIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxFbnRpdHlJZCA9PT0gZW50aXR5LmlkKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRQbGF5ZXJJZCA9IHBsYXllcklkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE5FVkVSIGJyb2FkY2FzdCBkZWJ1ZmYgdG8gb3Vyc2VsdmVzXG4gICAgICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQgJiYgdGFyZ2V0UGxheWVySWQgIT09IGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gQnJvYWRjYXN0aW5nIHN0dW4gZWZmZWN0IHRvIHBsYXllciAke3RhcmdldFBsYXllcklkfSAoTk9UIGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9KWApO1xuICAgICAgICAgICAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2soZW50aXR5LmlkLCAnc3R1bm5lZCcsIDQwMDAsIHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFNraXBwaW5nIHN0dW4gYnJvYWRjYXN0IC0gd291bGQgdGFyZ2V0IGxvY2FsIHBsYXllciAke2xvY2FsU29ja2V0SWR9IG9yIGludmFsaWQgdGFyZ2V0ICR7dGFyZ2V0UGxheWVySWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBoaXRDb3VudCsrO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllci92aXN1YWwgZWZmZWN0c1xuICAgICAgaWYgKHRoaXMub25TdW5kZXJDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uU3VuZGVyQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBwbGF5ZXJEaXJlY3Rpb24sIGRhbWFnZSwgc3RhY2tDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGFwcGx5U3VuZGVyU3RhY2soZW50aXR5SWQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHsgZGFtYWdlOiBudW1iZXI7IHN0YWNrQ291bnQ6IG51bWJlcjsgaXNTdHVubmVkOiBib29sZWFuIH0ge1xuICAgIGNvbnN0IHN0YWNrRHVyYXRpb24gPSAxMC4wOyAvLyAxMCBzZWNvbmRzXG4gICAgbGV0IGN1cnJlbnRTdGFja3MgPSB0aGlzLnN1bmRlclN0YWNrcy5nZXQoZW50aXR5SWQpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGV4cGlyZWQgc3RhY2tzIG9yIGluaXRpYWxpemUgbmV3IGVudHJ5XG4gICAgaWYgKCFjdXJyZW50U3RhY2tzIHx8IChjdXJyZW50VGltZSAtIGN1cnJlbnRTdGFja3MubGFzdEFwcGxpZWQpID4gc3RhY2tEdXJhdGlvbikge1xuICAgICAgY3VycmVudFN0YWNrcyA9IHsgc3RhY2tzOiAwLCBsYXN0QXBwbGllZDogY3VycmVudFRpbWUsIGR1cmF0aW9uOiBzdGFja0R1cmF0aW9uIH07XG4gICAgfVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBkYW1hZ2UgYmFzZWQgb24gY3VycmVudCBzdGFjayBjb3VudCAoYmVmb3JlIGFkZGluZyBuZXcgc3RhY2spXG4gICAgY29uc3QgYmFzZURhbWFnZXMgPSBbNjAsIDcwLCA4MCwgOTBdOyAvLyAwLCAxLCAyLCAzIHN0YWNrc1xuICAgIGNvbnN0IGRhbWFnZSA9IGJhc2VEYW1hZ2VzW01hdGgubWluKGN1cnJlbnRTdGFja3Muc3RhY2tzLCAzKV07XG4gICAgXG4gICAgbGV0IGlzU3R1bm5lZCA9IGZhbHNlO1xuICAgIGxldCBuZXdTdGFja0NvdW50ID0gY3VycmVudFN0YWNrcy5zdGFja3M7XG4gICAgXG4gICAgLy8gQXBwbHkgbmV3IHN0YWNrXG4gICAgaWYgKGN1cnJlbnRTdGFja3Muc3RhY2tzIDwgMykge1xuICAgICAgbmV3U3RhY2tDb3VudCA9IGN1cnJlbnRTdGFja3Muc3RhY2tzICsgMTtcbiAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLnNldChlbnRpdHlJZCwge1xuICAgICAgICBzdGFja3M6IG5ld1N0YWNrQ291bnQsXG4gICAgICAgIGxhc3RBcHBsaWVkOiBjdXJyZW50VGltZSxcbiAgICAgICAgZHVyYXRpb246IHN0YWNrRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCAzIHN0YWNrcywgYXBwbHkgc3R1biBhbmQgcmVzZXQgdG8gMCBzdGFja3NcbiAgICAgIGlzU3R1bm5lZCA9IHRydWU7XG4gICAgICBuZXdTdGFja0NvdW50ID0gMDtcbiAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLnNldChlbnRpdHlJZCwge1xuICAgICAgICBzdGFja3M6IDAsXG4gICAgICAgIGxhc3RBcHBsaWVkOiBjdXJyZW50VGltZSxcbiAgICAgICAgZHVyYXRpb246IHN0YWNrRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBkYW1hZ2UsIHN0YWNrQ291bnQ6IG5ld1N0YWNrQ291bnQsIGlzU3R1bm5lZCB9O1xuICB9XG4gIFxuICAvLyBDbGVhbiB1cCBleHBpcmVkIFN1bmRlciBzdGFja3MgcGVyaW9kaWNhbGx5XG4gIHByaXZhdGUgY2xlYW51cFN1bmRlclN0YWNrcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IHN0YWNrRHVyYXRpb24gPSAxMC4wO1xuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgdG8gYXZvaWQgaXRlcmF0aW9uIGlzc3Vlc1xuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHRoaXMuc3VuZGVyU3RhY2tzLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIHN0YWNrRGF0YV0gb2YgZW50cmllcykge1xuICAgICAgaWYgKChjdXJyZW50VGltZSAtIHN0YWNrRGF0YS5sYXN0QXBwbGllZCkgPiBzdGFja0R1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3VuZGVyU3RhY2tzLmRlbGV0ZShlbnRpdHlJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOiB2b2lkIHtcbiAgICAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgIHRoaXMuaXNTa3lmYWxsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5za3lmYWxsUGhhc2UgPSAnbm9uZSc7XG4gICAgdGhpcy5pc0JhY2tzdGFiYmluZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTdW5kZXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gICAgXG4gICAgLy8gQ2xlYXIgU3VuZGVyIHN0YWNrcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgdGhpcy5zdW5kZXJTdGFja3MuY2xlYXIoKTtcbiAgfVxuXG4gIC8vIEJhY2tzdGFiIGFiaWxpdHkgaW1wbGVtZW50YXRpb25cbiAgcHJpdmF0ZSBwZXJmb3JtQmFja3N0YWIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFja3N0YWJUaW1lIDwgdGhpcy5iYWNrc3RhYkNvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGVuZXJneSBjb3N0XG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoIWdhbWVVSSB8fCAhZ2FtZVVJLmNhbkNhc3RCYWNrc3RhYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNjApO1xuICAgIFxuICAgIC8vIFNldCBjb29sZG93blxuICAgIHRoaXMubGFzdEJhY2tzdGFiVGltZSA9IGN1cnJlbnRUaW1lO1xuICBcbiAgICBcbiAgICAvLyBTdGFydCBiYWNrc3RhYiBhbmltYXRpb25cbiAgICB0aGlzLmlzQmFja3N0YWJiaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmJhY2tzdGFiU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXIvdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkJhY2tzdGFiQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgdGhpcy5vbkJhY2tzdGFiQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBkaXJlY3Rpb24sIDc1LCBmYWxzZSk7IC8vIEJhc2UgZGFtYWdlLCBub3QgYmFja3N0YWIgYnkgZGVmYXVsdFxuICAgIH1cbiAgICBcbiAgICAvLyBQZXJmb3JtIGJhY2tzdGFiIGRhbWFnZVxuICAgIHRoaXMucGVyZm9ybUJhY2tzdGFiRGFtYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1CYWNrc3RhYkRhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBlbmVtaWVzL3BsYXllcnNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIGZhY2luZyBkaXJlY3Rpb24gKGNhbWVyYSBkaXJlY3Rpb24pXG4gICAgY29uc3QgcGxheWVyRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihwbGF5ZXJEaXJlY3Rpb24pO1xuICAgIHBsYXllckRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICBjb25zdCBiYWNrc3RhYlJhbmdlID0gNC4yNTsgLy8gU2FicmUgbWVsZWUgcmFuZ2VcbiAgICBsZXQgaGl0Q291bnQgPSAwO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBpZiAoZW50aXR5ID09PSB0aGlzLnBsYXllckVudGl0eSkgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIFxuICAgICAgaWYgKCF0YXJnZXRIZWFsdGggfHwgIXRhcmdldFRyYW5zZm9ybSB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIHJhbmdlXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0YW5jZSA+IGJhY2tzdGFiUmFuZ2UpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgaW4gZnJvbnQgb2YgcGxheWVyIChjb25lIGF0dGFjaylcbiAgICAgIGNvbnN0IGRpcmVjdGlvblRvVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKVxuICAgICAgICAuc3ViVmVjdG9ycyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24sIHBsYXllclBvc2l0aW9uKVxuICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBwbGF5ZXJEaXJlY3Rpb24uZG90KGRpcmVjdGlvblRvVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGFuZ2xlVGhyZXNob2xkID0gTWF0aC5jb3MoTWF0aC5QSSAvIDMpOyAvLyA2MCBkZWdyZWUgY29uZVxuICAgICAgXG4gICAgICBpZiAoZG90UHJvZHVjdCA8IGFuZ2xlVGhyZXNob2xkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBiYWNrc3RhYiAoYXR0YWNraW5nIGZyb20gYmVoaW5kIHRoZSB0YXJnZXQpXG4gICAgICBsZXQgaXNCYWNrc3RhYiA9IGZhbHNlO1xuICAgICAgbGV0IGRhbWFnZSA9IDc1OyAvLyBCYXNlIGRhbWFnZVxuICAgICAgXG4gICAgICAvLyBGb3IgUFZQIHBsYXllcnMsIGNoZWNrIGlmIHdlJ3JlIGJlaGluZCB0aGVtXG4gICAgICBjb25zdCBwdnBQbGF5ZXJzID0gKHdpbmRvdyBhcyBhbnkpLnB2cFBsYXllcnM7XG4gICAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgICBcbiAgICAgIGlmIChwdnBQbGF5ZXJzICYmIGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgdGFyZ2V0IHBsYXllciBpbiBQVlAgcGxheWVycyBtYXBcbiAgICAgICAgbGV0IHRhcmdldFBsYXllciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgW3BsYXllcklkLCBwbGF5ZXJdIG9mIHB2cFBsYXllcnMpIHtcbiAgICAgICAgICBpZiAocGxheWVySWQgIT09IGxvY2FsU29ja2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXllclBvcyA9IG5ldyBWZWN0b3IzKHBsYXllci5wb3NpdGlvbi54LCBwbGF5ZXIucG9zaXRpb24ueSwgcGxheWVyLnBvc2l0aW9uLnopO1xuICAgICAgICAgICAgaWYgKHBsYXllclBvcy5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgPCAwLjUpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0UGxheWVyID0gcGxheWVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0YXJnZXRQbGF5ZXIpIHtcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGFyZ2V0J3MgZmFjaW5nIGRpcmVjdGlvbiBmcm9tIHRoZWlyIHJvdGF0aW9uXG4gICAgICAgICAgY29uc3QgdGFyZ2V0RmFjaW5nRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoXG4gICAgICAgICAgICBNYXRoLnNpbih0YXJnZXRQbGF5ZXIucm90YXRpb24ueSksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC5jb3ModGFyZ2V0UGxheWVyLnJvdGF0aW9uLnkpXG4gICAgICAgICAgKS5ub3JtYWxpemUoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZWN0b3IgZnJvbSB0YXJnZXQgdG8gYXR0YWNrZXJcbiAgICAgICAgICBjb25zdCBhdHRhY2tlckRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgICAgIC5zdWJWZWN0b3JzKHBsYXllclBvc2l0aW9uLCB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pXG4gICAgICAgICAgICAubm9ybWFsaXplKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYXR0YWNrZXIgaXMgYmVoaW5kIHRhcmdldCAoZG90IHByb2R1Y3QgPCAwIG1lYW5zIG9wcG9zaXRlIGRpcmVjdGlvbilcbiAgICAgICAgICBjb25zdCBiZWhpbmREb3RQcm9kdWN0ID0gdGFyZ2V0RmFjaW5nRGlyZWN0aW9uLmRvdChhdHRhY2tlckRpcmVjdGlvbik7XG4gICAgICAgICAgaXNCYWNrc3RhYiA9IGJlaGluZERvdFByb2R1Y3QgPCAtMC4zOyAvLyA3MCBkZWdyZWUgY29uZSBiZWhpbmQgdGFyZ2V0XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGlzQmFja3N0YWIpIHtcbiAgICAgICAgICAgIGRhbWFnZSA9IDE3NTsgLy8gQmFja3N0YWIgZGFtYWdlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IGRhbWFnZVxuICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgIGlmIChjb21iYXRTeXN0ZW0pIHtcbiAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKFxuICAgICAgICAgIGVudGl0eSxcbiAgICAgICAgICBkYW1hZ2UsXG4gICAgICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkhLFxuICAgICAgICAgICdiYWNrc3RhYidcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGhpdENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtTWVsZWVEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIGluIHRoZSB3b3JsZCB0byBjaGVjayBmb3IgZW5lbWllc1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgZmFjaW5nIGRpcmVjdGlvbiAoY2FtZXJhIGRpcmVjdGlvbilcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIE1lbGVlIGF0dGFjayBwYXJhbWV0ZXJzIC0gaW5jcmVhc2VkIGZvciBQVlAgY29tYmF0XG4gICAgY29uc3QgbWVsZWVSYW5nZSA9IDQuNTsgLy8gSW5jcmVhc2VkIGF0dGFjayByYW5nZSBmb3IgUFZQXG4gICAgY29uc3QgbWVsZWVBbmdsZSA9IE1hdGguUEkgLyAyOyAvLyAxMjAgZGVncmVlIGNvbmUgKDYwIGRlZ3JlZXMgZWFjaCBzaWRlKVxuICAgIFxuICAgIC8vIEJhc2UgZGFtYWdlIHZhbHVlcyBiYXNlZCBvbiBjb21ibyBzdGVwIGFuZCB3ZWFwb24gdHlwZVxuICAgIGxldCBiYXNlRGFtYWdlID0gNDU7IC8vIERlZmF1bHQgYmFzZSBkYW1hZ2VcblxuICAgIC8vIFdlYXBvbi1zcGVjaWZpYyBkYW1hZ2Ugc2NhbGluZ1xuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgIC8vIFN3b3JkIGRhbWFnZSB2YWx1ZXNcbiAgICAgIHN3aXRjaCAodGhpcy5zd29yZENvbWJvU3RlcCkge1xuICAgICAgICBjYXNlIDE6IGJhc2VEYW1hZ2UgPSA0MDsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogYmFzZURhbWFnZSA9IDQ1OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBiYXNlRGFtYWdlID0gNTU7IGJyZWFrOyAvLyBGaW5pc2hlciBkb2VzIG1vcmUgZGFtYWdlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuUlVORUJMQURFKSB7XG4gICAgICAvLyBSdW5lYmxhZGUgZGFtYWdlIHZhbHVlc1xuICAgICAgc3dpdGNoICh0aGlzLnN3b3JkQ29tYm9TdGVwKSB7XG4gICAgICAgIGNhc2UgMTogYmFzZURhbWFnZSA9IDMwOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBiYXNlRGFtYWdlID0gMzU7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGJhc2VEYW1hZ2UgPSA0NTsgYnJlYWs7IC8vIEZpbmlzaGVyIGRvZXMgbW9yZSBkYW1hZ2VcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IGNvbWJhdCBzeXN0ZW0gdG8gYXBwbHkgZGFtYWdlXG4gICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICBcbiAgICAvLyBUcmFjayBlbmVtaWVzIGhpdCBmb3IgcmFnZSBnZW5lcmF0aW9uXG4gICAgbGV0IGVuZW1pZXNIaXQgPSAwO1xuICAgIFxuICAgIGFsbEVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgZW5lbXkgY29tcG9uZW50IGFuZCBoZWFsdGhcbiAgICAgIGNvbnN0IGVuZW15VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgZW5lbXlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBpZiAoIWVuZW15VHJhbnNmb3JtIHx8ICFlbmVteUhlYWx0aCB8fCBlbnRpdHkuaWQgPT09IHRoaXMucGxheWVyRW50aXR5Py5pZCkgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zdCBlbmVteVBvc2l0aW9uID0gZW5lbXlUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBjb25zdCB0b0VuZW15ID0gZW5lbXlQb3NpdGlvbi5jbG9uZSgpLnN1YihwbGF5ZXJQb3NpdGlvbik7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRvRW5lbXkubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIFBWUCBoaXQgZGV0ZWN0aW9uXG4gICAgICBcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZW5lbXkgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gbWVsZWVSYW5nZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBlbmVteSBpcyB3aXRoaW4gYXR0YWNrIGNvbmVcbiAgICAgICAgdG9FbmVteS5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBkaXJlY3Rpb24uYW5nbGVUbyh0b0VuZW15KTtcbiAgICAgICAgY29uc3QgYW5nbGVEZWdyZWVzID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBjb25zdCBtYXhBbmdsZURlZ3JlZXMgPSAobWVsZWVBbmdsZSAvIDIpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoYW5nbGUgPD0gbWVsZWVBbmdsZSAvIDIpIHtcbiAgICAgICAgICAvLyBFbmVteSBpcyB3aXRoaW4gYXR0YWNrIGNvbmUgLSBkZWFsIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY29tYmF0U3lzdGVtICYmIHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgICAgICAvLyBRdWV1ZSBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtICh3aGljaCB3aWxsIHJvdXRlIHRvIG11bHRpcGxheWVyIGZvciBlbmVtaWVzKVxuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgYmFzZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHksICdtZWxlZScpO1xuICAgICAgICAgICAgZW5lbWllc0hpdCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHJhZ2Ugb25seSBpZiB3ZSBoaXQgZW5lbWllcyAoNSByYWdlIHBlciBoaXQsIG1heCA1IHBlciBzd2luZylcbiAgICBpZiAoZW5lbWllc0hpdCA+IDApIHtcbiAgICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICAgIGNvbnN0IHJhZ2VUb0dhaW4gPSBNYXRoLm1pbihlbmVtaWVzSGl0ICogNSwgNSk7IC8vIDUgcmFnZSBwZXIgaGl0LCBtYXggNSBwZXIgc3dpbmdcbiAgICAgICAgZ2FtZVVJLmdhaW5SYWdlKHJhZ2VUb0dhaW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGb3JEYXNoSW5wdXQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGZvciBkb3VibGUtdGFwIG9uIG1vdmVtZW50IGtleXNcbiAgICBjb25zdCBkYXNoRGlyZWN0aW9ucyA9IFtcbiAgICAgIHsga2V5OiAndycsIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgLTEpIH0sIC8vIEZvcndhcmRcbiAgICAgIHsga2V5OiAncycsIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoMCwgMCwgMSkgfSwgIC8vIEJhY2t3YXJkXG4gICAgICB7IGtleTogJ2EnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKC0xLCAwLCAwKSB9LCAvLyBMZWZ0XG4gICAgICB7IGtleTogJ2QnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDEsIDAsIDApIH0gICAvLyBSaWdodFxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkaXJlY3Rpb24gfSBvZiBkYXNoRGlyZWN0aW9ucykge1xuICAgICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmNoZWNrRG91YmxlVGFwKGtleSkpIHtcbiAgICAgICAgLy8gRGVidWc6IExvZyB0aGUgZG91YmxlIHRhcCBkZXRlY3Rpb25cbiAgICAgICAgY29uc3QgZGVidWdJbmZvID0gdGhpcy5pbnB1dE1hbmFnZXIuZ2V0RG91YmxlVGFwRGVidWdJbmZvKGtleSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IGlucHV0IGRpcmVjdGlvbiB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBjYW1lcmEgb3JpZW50YXRpb25cbiAgICAgICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSB0aGlzLmdldFdvcmxkU3BhY2VEaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3RhcnQgZGFzaFxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcbiAgICAgICAgY29uc3QgZGFzaFN0YXJ0ZWQgPSBtb3ZlbWVudC5zdGFydERhc2god29ybGREaXJlY3Rpb24sIHRyYW5zZm9ybS5wb3NpdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRhc2hTdGFydGVkKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIGRvdWJsZS10YXAgc3RhdGUgdG8gcHJldmVudCBtdWx0aXBsZSBkYXNoZXNcbiAgICAgICAgICB0aGlzLmlucHV0TWFuYWdlci5yZXNldERvdWJsZVRhcChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBicmVhazsgLy8gT25seSBwcm9jZXNzIG9uZSBkYXNoIHBlciBmcmFtZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRGFzaE1vdmVtZW50KG1vdmVtZW50OiBNb3ZlbWVudCwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIW1vdmVtZW50LmlzRGFzaGluZykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgY29uc3QgZGFzaFJlc3VsdCA9IG1vdmVtZW50LnVwZGF0ZURhc2goY3VycmVudFRpbWUpO1xuXG4gICAgaWYgKGRhc2hSZXN1bHQubmV3UG9zaXRpb24pIHtcbiAgICAgIC8vIEFwcGx5IGJvdW5kcyBjaGVja2luZyAoc2ltaWxhciB0byBvbGQgaW1wbGVtZW50YXRpb24pXG4gICAgICBjb25zdCBNQVhfREFTSF9CT1VORFMgPSAyOTsgLy8gTWF4aW11bSBkaXN0YW5jZSBmcm9tIG9yaWdpbiAobWF0Y2hlcyBtYXAgYm91bmRhcnkpXG4gICAgICBjb25zdCBkaXN0YW5jZUZyb21PcmlnaW4gPSBkYXNoUmVzdWx0Lm5ld1Bvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2VGcm9tT3JpZ2luIDw9IE1BWF9EQVNIX0JPVU5EUykge1xuICAgICAgICB0cmFuc2Zvcm0ucG9zaXRpb24uY29weShkYXNoUmVzdWx0Lm5ld1Bvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENhbmNlbCBkYXNoIGlmIGl0IHdvdWxkIG1vdmUgdG9vIGZhciBmcm9tIG9yaWdpblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oYERhc2ggY2FuY2VsbGVkOiB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW4gKCR7ZGlzdGFuY2VGcm9tT3JpZ2luLnRvRml4ZWQoMil9ID4gJHtNQVhfREFTSF9CT1VORFN9KWApO1xuICAgICAgICBtb3ZlbWVudC5jYW5jZWxEYXNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVDaGFyZ2VNb3ZlbWVudChtb3ZlbWVudDogTW92ZW1lbnQsIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKCFtb3ZlbWVudC5pc0NoYXJnaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcbiAgICBcbiAgICAvLyBDaGVjayBpZiBjaGFyZ2Ugd2FzIHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgaWYgKHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICBtb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2hhcmdlUmVzdWx0ID0gbW92ZW1lbnQudXBkYXRlQ2hhcmdlKGN1cnJlbnRUaW1lKTtcblxuICAgIGlmIChjaGFyZ2VSZXN1bHQubmV3UG9zaXRpb24pIHtcbiAgICAgIC8vIEFwcGx5IGJvdW5kcyBjaGVja2luZ1xuICAgICAgY29uc3QgTUFYX0NIQVJHRV9CT1VORFMgPSAyOTsgLy8gTWF4aW11bSBkaXN0YW5jZSBmcm9tIG9yaWdpbiAobWF0Y2hlcyBtYXAgYm91bmRhcnkpXG4gICAgICBjb25zdCBkaXN0YW5jZUZyb21PcmlnaW4gPSBjaGFyZ2VSZXN1bHQubmV3UG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBwaWxsYXIgY29sbGlzaW9uXG4gICAgICBjb25zdCBwaWxsYXJDb2xsaXNpb24gPSB0aGlzLmNoZWNrUGlsbGFyQ29sbGlzaW9uKGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZUZyb21PcmlnaW4gPiBNQVhfQ0hBUkdFX0JPVU5EUykge1xuICAgICAgICAvLyBDYW5jZWwgY2hhcmdlIGlmIGl0IHdvdWxkIG1vdmUgdG9vIGZhciBmcm9tIG9yaWdpblxuICAgICAgICBtb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgLy8gTm90aWZ5IHN3b3JkIGNvbXBvbmVudCB0aGF0IGNoYXJnZSB3YXMgY2FuY2VsbGVkXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChwaWxsYXJDb2xsaXNpb24uaGFzQ29sbGlzaW9uKSB7XG4gICAgICAgIC8vIENhbmNlbCBjaGFyZ2UgaWYgaXQgd291bGQgY29sbGlkZSB3aXRoIGEgcGlsbGFyXG4gICAgICAgIGNvbnNvbGUud2FybihgQ2hhcmdlIGNhbmNlbGxlZDogd291bGQgY29sbGlkZSB3aXRoIHBpbGxhciBhdCBbJHtwaWxsYXJDb2xsaXNpb24ucGlsbGFyQ2VudGVyLnRvQXJyYXkoKS5qb2luKCcsICcpfV1gKTtcbiAgICAgICAgbW92ZW1lbnQuY2FuY2VsQ2hhcmdlKCk7XG4gICAgICAgIC8vIE5vdGlmeSBzd29yZCBjb21wb25lbnQgdGhhdCBjaGFyZ2Ugd2FzIGNhbmNlbGxlZFxuICAgICAgICB0aGlzLm9uQ2hhcmdlQ29tcGxldGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHBvc2l0aW9uIGlmIG5vdCBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgICAgICB0cmFuc2Zvcm0ucG9zaXRpb24uY29weShjaGFyZ2VSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGFyZ2VSZXN1bHQuaXNDb21wbGV0ZSB8fCB0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbikge1xuICAgICAgY29uc29sZS5sb2coJ+KalO+4jyBDaGFyZ2UgbW92ZW1lbnQgY29tcGxldGVkJyk7XG4gICAgICAvLyBOb3RpZnkgc3dvcmQgY29tcG9uZW50IHRoYXQgY2hhcmdlIGlzIGNvbXBsZXRlXG4gICAgICB0aGlzLm9uQ2hhcmdlQ29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBEZWZpbmUgcGlsbGFyIHBvc2l0aW9ucyAoc2FtZSBhcyBpbiBFbnZpcm9ubWVudC50c3gpXG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1BPU0lUSU9OUyA9IFtcbiAgICBuZXcgVmVjdG9yMygwLCAwLCAtNSksICAgICAgICAvLyBGcm9udCBwaWxsYXJcbiAgICBuZXcgVmVjdG9yMygtNC4yNSwgMCwgMi41KSwgICAvLyBMZWZ0IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKDQuMjUsIDAsIDIuNSkgICAgIC8vIFJpZ2h0IHBpbGxhclxuICBdO1xuICBwcml2YXRlIHJlYWRvbmx5IFBJTExBUl9SQURJVVMgPSAwLjc7IC8vIFNhbWUgYXMgUGlsbGFyQ29sbGlzaW9uLnRzeFxuXG4gIHByaXZhdGUgY2hlY2tQaWxsYXJDb2xsaXNpb24ocG9zaXRpb246IFZlY3RvcjMpOiB7IGhhc0NvbGxpc2lvbjogYm9vbGVhbjsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSB7XG4gICAgZm9yIChjb25zdCBwaWxsYXJQb3Mgb2YgdGhpcy5QSUxMQVJfUE9TSVRJT05TKSB7XG4gICAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKHBvc2l0aW9uLngsIDAsIHBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKHBpbGxhclBvcy54LCAwLCBwaWxsYXJQb3Mueik7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGhvcml6b250YWxQb3MuZGlzdGFuY2VUbyhwaWxsYXJIb3Jpem9udGFsKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5QSUxMQVJfUkFESVVTKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBub3JtYWwgdmVjdG9yIHBvaW50aW5nIGF3YXkgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGhvcml6b250YWxQb3MuY2xvbmUoKS5zdWIocGlsbGFySG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHBsYXllciBpcyBleGFjdGx5IGF0IHBpbGxhciBjZW50ZXJcbiAgICAgICAgaWYgKG5vcm1hbC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgIG5vcm1hbC5zZXQoMSwgMCwgMCk7IC8vIERlZmF1bHQgZGlyZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNDb2xsaXNpb246IHRydWUsXG4gICAgICAgICAgbm9ybWFsOiBub3JtYWwsXG4gICAgICAgICAgcGlsbGFyQ2VudGVyOiBwaWxsYXJQb3MuY2xvbmUoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBoYXNDb2xsaXNpb246IGZhbHNlLCBub3JtYWw6IG5ldyBWZWN0b3IzKCksIHBpbGxhckNlbnRlcjogbmV3IFZlY3RvcjMoKSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRXb3JsZFNwYWNlRGlyZWN0aW9uKGlucHV0RGlyZWN0aW9uOiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgLy8gR2V0IGNhbWVyYSBkaXJlY3Rpb24gdmVjdG9yc1xuICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBHZXQgY2FtZXJhJ3MgcmlnaHQgdmVjdG9yXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhjYW1lcmFEaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBHZXQgY2FtZXJhJ3MgZm9yd2FyZCB2ZWN0b3IgKHByb2plY3RlZCBvbiBYWiBwbGFuZSlcbiAgICBjb25zdCBjYW1lcmFGb3J3YXJkID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFGb3J3YXJkLmNyb3NzVmVjdG9ycyhuZXcgVmVjdG9yMygwLCAxLCAwKSwgY2FtZXJhUmlnaHQpLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIGlucHV0IGRpcmVjdGlvbiB0byB3b3JsZCBzcGFjZVxuICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB3b3JsZERpcmVjdGlvbi5hZGRTY2FsZWRWZWN0b3IoY2FtZXJhUmlnaHQsIGlucHV0RGlyZWN0aW9uLngpO1xuICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFGb3J3YXJkLCAtaW5wdXREaXJlY3Rpb24ueik7XG4gICAgd29ybGREaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gd29ybGREaXJlY3Rpb247XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1EaXZpbmVTdG9ybShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIHJhZ2UgKG1pbmltdW0gMjAgcmFnZSByZXF1aXJlZClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0RGl2aW5lU3Rvcm0oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUgPCB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCByYWdlIGFtb3VudCBhbmQgY29uc3VtZSBBTEwgcmFnZVxuICAgIGNvbnN0IGN1cnJlbnRSYWdlID0gZ2FtZVVJID8gZ2FtZVVJLmdldEN1cnJlbnRSYWdlKCkgOiA0MDsgLy8gRmFsbGJhY2sgdG8gNDAgaWYgZ2FtZVVJIG5vdCBhdmFpbGFibGVcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUFsbFJhZ2UoKTsgLy8gQ29uc3VtZSBhbGwgcmFnZSBpbnN0ZWFkIG9mIGp1c3QgMjBcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgZXh0ZW5kZWQgZHVyYXRpb246IGJhc2UgNCBzZWNvbmRzICsgMSBzZWNvbmQgcGVyIDEwIHJhZ2UgY29uc3VtZWRcbiAgICBjb25zdCBiYXNlU3Rvcm1EdXJhdGlvbiA9IDEwMDA7IC8vIDQgc2Vjb25kcyBiYXNlXG4gICAgY29uc3QgYm9udXNEdXJhdGlvbiA9IE1hdGguZmxvb3IoY3VycmVudFJhZ2UgLyAxMCkgKiA1MDA7IC8vIDEgc2Vjb25kIHBlciAxMCByYWdlXG4gICAgY29uc3QgdG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uID0gYmFzZVN0b3JtRHVyYXRpb24gKyBib251c0R1cmF0aW9uO1xuXG4gICAgdGhpcy5pc0RpdmluZVN0b3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIERpdmluZSBTdG9ybSBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXJcbiAgICBpZiAodGhpcy5vbkRpdmluZVN0b3JtQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5vbkRpdmluZVN0b3JtQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbiwgdG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBEaXZpbmUgU3Rvcm0gbGFzdHMgZm9yIGNhbGN1bGF0ZWQgZHVyYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaXNEaXZpbmVTdG9ybWluZyA9IGZhbHNlO1xuICAgIH0sIHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbik7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1DaGFyZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSA8IHRoaXMuY2hhcmdlQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0Q2hhcmdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFJlc2V0IGNvbGxpc2lvbiB0cmFja2luZyBmb3IgbmV3IGNoYXJnZVxuICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBDaGFyZ2UgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25DaGFyZ2VDYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uQ2hhcmdlQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIEdhaW4gcmFnZSBmb3IgdXNpbmcgY2hhcmdlIGFiaWxpdHkgKCsyMCByYWdlKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmdhaW5SYWdlKDIwKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RhcnQgdGhlIGNoYXJnZSBtb3ZlbWVudCB1c2luZyB0aGUgc2VwYXJhdGUgY2hhcmdlIHN5c3RlbVxuICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICAgIC8vIEdldCBjaGFyZ2UgZGlyZWN0aW9uIGZyb20gY2FtZXJhXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIGRpcmVjdGlvbi55ID0gMDsgLy8gS2VlcCBtb3ZlbWVudCBob3Jpem9udGFsXG4gICAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IGNoYXJnZSB3aXRoIDEwLjUgZGlzdGFuY2UgKHNlcGFyYXRlIGZyb20gZGFzaCBzeXN0ZW0pXG4gICAgICAgIGNvbnN0IGNoYXJnZVN0YXJ0ZWQgPSBwbGF5ZXJNb3ZlbWVudC5zdGFydENoYXJnZShkaXJlY3Rpb24sIHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoYXJnZVN0YXJ0ZWQpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBjaGFyZ2UgZGFtYWdlIGRldGVjdGlvbiBkdXJpbmcgbW92ZW1lbnRcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlQ2hhcmdlRGFtYWdlKHBsYXllclRyYW5zZm9ybSwgZGlyZWN0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUcmFjayBjaGFyZ2UgaGl0IGVudGl0aWVzIHRvIHByZXZlbnQgbXVsdGlwbGUgaGl0cyBhbmQgZW5hYmxlIGNvbGxpc2lvbiBzdG9wcGluZ1xuICBwcml2YXRlIGNoYXJnZUhpdEVudGl0aWVzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gIHByaXZhdGUgY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG5cbiAgLy8gU2NoZWR1bGUgZGFtYWdlIGRldGVjdGlvbiBkdXJpbmcgY2hhcmdlIG1vdmVtZW50XG4gIHByaXZhdGUgc2NoZWR1bGVDaGFyZ2VEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIGNoYXJnZURpcmVjdGlvbjogVmVjdG9yMywgc3RhcnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjaGFyZ2VEdXJhdGlvbiA9IDAuNjsgXG4gICAgY29uc3QgZGFtYWdlQ2hlY2tJbnRlcnZhbCA9IDUwOyAvLyBDaGVjayBmb3IgZGFtYWdlIGV2ZXJ5IDUwbXMgZm9yIGJldHRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgY29uc3QgY2hhcmdlRGFtYWdlID0gNDA7IC8vIEhpZ2ggZGFtYWdlIGZvciBjaGFyZ2UgYWJpbGl0eVxuICAgIGNvbnN0IGNoYXJnZVJhZGl1cyA9IDIuNTsgLy8gRGFtYWdlIHJhZGl1cyBhcm91bmQgcGxheWVyIGR1cmluZyBjaGFyZ2VcbiAgICBcbiAgICAvLyBSZXNldCBjaGFyZ2UgaGl0IHRyYWNraW5nXG4gICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5jbGVhcigpO1xuICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgZGFtYWdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgXG4gICAgICAvLyBTdG9wIGlmIGNoYXJnZSBpcyBjb21wbGV0ZSwgY2FuY2VsbGVkLCBvciBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgICAgaWYgKCF0aGlzLmlzU3dvcmRDaGFyZ2luZyB8fCBjdXJyZW50VGltZSAtIHN0YXJ0VGltZSA+IGNoYXJnZUR1cmF0aW9uIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZGFtYWdlSW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBkYW1hZ2VcbiAgICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBcbiAgICAgIGxldCBoaXRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gRGVidWc6IExvZyBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIGR1cmluZyBjaGFyZ2VcbiAgICAgIFxuICAgICAgLy8gRU5IQU5DRUQ6IEFsc28gY2hlY2sgYWdhaW5zdCBzZXJ2ZXIgcGxheWVyIHBvc2l0aW9ucyBkaXJlY3RseSBhcyBhIGZhbGxiYWNrXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZG9uJ3QgbWlzcyBjb2xsaXNpb25zIGR1ZSB0byBlbnRpdHkgc3luYyBpc3N1ZXNcbiAgICAgIGNvbnN0IHNlcnZlclBsYXllcnMgPSAod2luZG93IGFzIGFueSkucHZwUGxheWVycyB8fCBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBsb2NhbFNvY2tldElkID0gKHdpbmRvdyBhcyBhbnkpLmxvY2FsU29ja2V0SWQ7XG4gICAgICAgICAgICBcbiAgICAgIHNlcnZlclBsYXllcnMuZm9yRWFjaCgoc2VydmVyUGxheWVyOiBhbnksIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChwbGF5ZXJJZCA9PT0gbG9jYWxTb2NrZXRJZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBhbHJlYWR5IGhpdCBwbGF5ZXJzICh1c2UgaGFzaCBvZiBwbGF5ZXIgSUQgZm9yIHRyYWNraW5nKVxuICAgICAgICBjb25zdCBwbGF5ZXJJZEhhc2ggPSBwbGF5ZXJJZC5sZW5ndGggKiAxMDAwICsgcGxheWVySWQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuaGFzKHBsYXllcklkSGFzaCkpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNlcnZlclBsYXllclBvcyA9IG5ldyBWZWN0b3IzKHNlcnZlclBsYXllci5wb3NpdGlvbi54LCBzZXJ2ZXJQbGF5ZXIucG9zaXRpb24ueSwgc2VydmVyUGxheWVyLnBvc2l0aW9uLnopO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8oc2VydmVyUGxheWVyUG9zKTtcbiAgICAgICAgY29uc3Qgc3RvcERpc3RhbmNlID0gMC45ICsgMS4wOyAvLyBQbGF5ZXIgY29sbGlzaW9uIHJhZGl1cyArIGJ1ZmZlclxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSBzdG9wRGlzdGFuY2UgJiYgc2VydmVyUGxheWVyLmhlYWx0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmFkZChwbGF5ZXJJZEhhc2gpO1xuICAgICAgICAgIGhpdFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwbHkgZGFtYWdlIHRocm91Z2ggUFZQIHN5c3RlbSBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdzd29yZF9jaGFyZ2VfaGl0JywgcGxheWVyUG9zaXRpb24uY2xvbmUoKSwgY2hhcmdlRGlyZWN0aW9uLmNsb25lKCksIHtcbiAgICAgICAgICAgICAgZGFtYWdlOiBjaGFyZ2VEYW1hZ2UsXG4gICAgICAgICAgICAgIHRhcmdldElkOiBwbGF5ZXJJZCxcbiAgICAgICAgICAgICAgaGl0UG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBzZXJ2ZXJQbGF5ZXJQb3MueCxcbiAgICAgICAgICAgICAgICB5OiBzZXJ2ZXJQbGF5ZXJQb3MueSxcbiAgICAgICAgICAgICAgICB6OiBzZXJ2ZXJQbGF5ZXJQb3MuelxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhbGxFbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiB7XG4gICAgICAgIC8vIFNraXAgc2VsZlxuICAgICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIFNraXAgYWxyZWFkeSBoaXQgZW50aXRpZXNcbiAgICAgICAgaWYgKHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuaGFzKGVudGl0eS5pZCkpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgdHJhbnNmb3JtIGFuZCBoZWFsdGggKGNvdWxkIGJlIGVuZW15IG9yIHBsYXllcilcbiAgICAgICAgY29uc3QgZW50aXR5VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICAgIGNvbnN0IGVudGl0eUNvbGxpZGVyID0gZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBEZWJ1ZzogTG9nIGVudGl0eSBkZXRhaWxzXG4gICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7ZW50aXR5LmlkfSlgO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFlbnRpdHlUcmFuc2Zvcm0gfHwgIWVudGl0eUhlYWx0aCB8fCBlbnRpdHlIZWFsdGguaXNEZWFkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBlbnRpdHlQb3NpdGlvbiA9IGVudGl0eVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKGVudGl0eVBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBpcyB3aXRoaW4gY2hhcmdlIGRhbWFnZSByYWRpdXNcbiAgICAgICAgLy8gSW4gUFZQLCB3ZSB3YW50IHRvIHN0b3AganVzdCBiZWZvcmUgaGl0dGluZyB0aGUgZW5lbXksIG5vdCBvdmVybGFwIHdpdGggdGhlbVxuICAgICAgICBjb25zdCBzdG9wRGlzdGFuY2UgPSBlbnRpdHlDb2xsaWRlciA/IGVudGl0eUNvbGxpZGVyLnJhZGl1cyArIDEuMCA6IGNoYXJnZVJhZGl1czsgLy8gU3RvcCAxIHVuaXQgYXdheSBmcm9tIGVuZW15IGVkZ2VcbiAgICAgICAgXG4gICAgICAgIC8vIERlYnVnOiBMb2cgcG9zaXRpb24gYW5kIGRpc3RhbmNlIGluZm9ybWF0aW9uXG4gICAgICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gc3RvcERpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gTWFyayBhcyBoaXQgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzXG4gICAgICAgICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5hZGQoZW50aXR5LmlkKTtcbiAgICAgICAgICBoaXRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW1cbiAgICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIGNoYXJnZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHksICdjaGFyZ2UnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7ZW50aXR5LmlkfSlgO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBCcm9hZGNhc3QgY2hhcmdlIGF0dGFjayBmb3IgUFZQIChpbmNsdWRlcyBkYW1hZ2UgYW5kIGFuaW1hdGlvbilcbiAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnc3dvcmRfY2hhcmdlX2hpdCcsIHBsYXllclBvc2l0aW9uLmNsb25lKCksIGNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLCB7XG4gICAgICAgICAgICAgICAgZGFtYWdlOiBjaGFyZ2VEYW1hZ2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IGVudGl0eS5pZCxcbiAgICAgICAgICAgICAgICBoaXRQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogZW50aXR5UG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgIHk6IGVudGl0eVBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICB6OiBlbnRpdHlQb3NpdGlvbi56XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJbiBQVlAgbW9kZSwgc3RvcCBjaGFyZ2Ugd2hlbiBoaXR0aW5nIHNvbWV0aGluZ1xuICAgICAgaWYgKGhpdFNvbWV0aGluZykge1xuICAgICAgICB0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbiA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9wIHRoZSBjaGFyZ2UgbW92ZW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgICAgIGlmIChwbGF5ZXJNb3ZlbWVudCkge1xuICAgICAgICAgICAgcGxheWVyTW92ZW1lbnQuY2FuY2VsQ2hhcmdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciB0aGUgZGFtYWdlIGludGVydmFsIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgZnVydGhlciBoaXRzXG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZGFtYWdlSW50ZXJ2YWwpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciBjaGFyZ2UgY29tcGxldGlvblxuICAgICAgICB0aGlzLm9uQ2hhcmdlQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9LCBkYW1hZ2VDaGVja0ludGVydmFsKTtcbiAgfVxuXG4gIC8vIENhbGxlZCBieSBzd29yZCBjb21wb25lbnQgd2hlbiBDaGFyZ2UgY29tcGxldGVzXG4gIHB1YmxpYyBvbkNoYXJnZUNvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuaXNTd29yZENoYXJnaW5nID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1EZWZsZWN0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERlZmxlY3RUaW1lIDwgdGhpcy5kZWZsZWN0Q29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzRGVmbGVjdGluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0RGVmbGVjdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIERlZmxlY3QgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25EZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5vbkRlZmxlY3RDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHVwIGRlZmxlY3QgYmFycmllciB0aGF0IGJsb2NrcyBkYW1hZ2UgYW5kIHJlZmxlY3RzIHByb2plY3RpbGVzXG4gICAgdGhpcy5zZXR1cERlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gQXV0by1jb21wbGV0ZSBkZWZsZWN0IGFmdGVyIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm9uRGVmbGVjdENvbXBsZXRlKCk7XG4gICAgfSwgdGhpcy5kZWZsZWN0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUgPCB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIGVuZXJneSAoNjAgZW5lcmd5IGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdFZpcGVyU3RpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNjApO1xuICAgIH1cblxuICAgIHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RWaXBlclN0aW5nVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSAxMDAwOyAvLyAxIHNlY29uZCBjaGFyZ2UgdGltZVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBjaGFyZ2VTdGFydFRpbWU7XG4gICAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyBjaGFyZ2VEdXJhdGlvbiwgMS4wKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGNoYXJnZUludGVydmFsKTtcbiAgICAgICAgdGhpcy5maXJlVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9LCAxNik7IC8vIH42MGZwcyB1cGRhdGVzXG4gIH1cblxuICBwcml2YXRlIGZpcmVWaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIHBsYXllclBvc2l0aW9uLnkgKz0gMC44MjU7IC8vIFNob290IGZyb20gY2hlc3QgbGV2ZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIGFzIG90aGVyIHByb2plY3RpbGVzXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgXG4gICAgLy8gTm90ZTogVmlwZXIgU3RpbmcgZGFtYWdlIGlzIGhhbmRsZWQgYnkgVmlwZXJTdGluZ01hbmFnZXIsIG5vdCBFQ1MgcHJvamVjdGlsZXNcbiAgICAvLyBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZSBwcm9qZWN0aWxlcyBhbmQgZGFtYWdlXG4gICAgXG4gICAgLy8gVHJpZ2dlciBWaXBlciBTdGluZyBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjayhwbGF5ZXJQb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJpZ2dlciB0aGUgZ2xvYmFsIFZpcGVyIFN0aW5nIG1hbmFnZXIgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgY29uc3Qgc3VjY2VzcyA9IHRyaWdnZXJHbG9iYWxWaXBlclN0aW5nKCk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCfwn5CNIFZpcGVyIFN0aW5nIHZpc3VhbCBlZmZlY3RzIHN1Y2Nlc3NmdWxseSB0cmlnZ2VyZWQhJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCd2aXBlcl9zdGluZ19wcm9qZWN0aWxlJywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiAxNixcbiAgICAgICAgZGFtYWdlOiA2MSxcbiAgICAgICAgbGlmZXRpbWU6IDUsXG4gICAgICAgIGlzUmV0dXJuaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYXJyYWdlVGltZSA8IHRoaXMuYmFycmFnZUZpcmVSYXRlKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4o+wIEJhcnJhZ2Ugb24gY29vbGRvd24gZm9yICR7KHRoaXMuYmFycmFnZUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFycmFnZVRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBlbmVyZ3kgKDQwIGVuZXJneSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RCYXJyYWdlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDQwKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQmFycmFnZUNoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0QmFycmFnZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBjaGFyZ2luZyBhbmltYXRpb25cbiAgICBjb25zdCBjaGFyZ2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gNTAwOyAvLyAxIHNlY29uZCBjaGFyZ2UgdGltZVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSBjaGFyZ2VTdGFydFRpbWU7XG4gICAgICB0aGlzLmJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyBjaGFyZ2VEdXJhdGlvbiwgMS4wKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGNoYXJnZUludGVydmFsKTtcbiAgICAgICAgdGhpcy5maXJlQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLmlzQmFycmFnZUNoYXJnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9LCAxNik7IC8vIH42MGZwcyB1cGRhdGVzXG4gIH1cblxuICBwcml2YXRlIGZpcmVCYXJyYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIHBsYXllclBvc2l0aW9uLnkgKz0gMC44MjU7IC8vIFNob290IGZyb20gY2hlc3QgbGV2ZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgXG4gICAgLy8gQXBwbHkgc2FtZSBkb3dud2FyZCBjb21wZW5zYXRpb24gYXMgcHJvamVjdGlsZSBzeXN0ZW1cbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgNSBhcnJvd3M6IGNlbnRlciAoMMKwKSwgbGVmdCAoMTXCsCwgMzDCsCksIHJpZ2h0ICgtMTXCsCwgLTMwwrApIHVzaW5nIHByb3BlciBFQ1MgcHJvamVjdGlsZXNcbiAgICBjb25zdCBhbmdsZXMgPSBbMCwgTWF0aC5QSSAvIDEyLCAtTWF0aC5QSSAvIDEyLCBNYXRoLlBJIC8gNiwgLU1hdGguUEkgLyA2XTsgLy8gMMKwLCAxNcKwLCAtMTXCsCwgMzDCsCwgLTMwwrBcbiAgICBcbiAgICBhbmdsZXMuZm9yRWFjaChhbmdsZSA9PiB7XG4gICAgICAvLyBSb3RhdGUgdGhlIGJhc2UgZGlyZWN0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAgICAgIGNvbnN0IHByb2plY3RpbGVEaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKS5tYWtlUm90YXRpb25ZKGFuZ2xlKTtcbiAgICAgIHByb2plY3RpbGVEaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICAgIHByb2plY3RpbGVEaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIE9mZnNldCBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBsYXllclBvc2l0aW9uLmNsb25lKCk7XG4gICAgICBzcGF3blBvc2l0aW9uLmFkZChwcm9qZWN0aWxlRGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgcHJvcGVyIEVDUyBwcm9qZWN0aWxlIGVudGl0eVxuICAgICAgY29uc3QgcHJvamVjdGlsZUNvbmZpZyA9IHtcbiAgICAgICAgc3BlZWQ6IDIyLCAvLyBTbGlnaHRseSBmYXN0ZXIgdGhhbiByZWd1bGFyIGFycm93cyAoMjApXG4gICAgICAgIGRhbWFnZTogMzAsIC8vIEhpZ2ggZGFtYWdlIGZvciBiYXJyYWdlIGFycm93c1xuICAgICAgICBsaWZldGltZTogOCxcbiAgICAgICAgbWF4RGlzdGFuY2U6IDI1LCAvLyBMaW1pdCBiYXJyYWdlIGFycm93cyB0byAyNSB1bml0cyBkaXN0YW5jZSAoc2FtZSBhcyByZWd1bGFyIGFycm93cylcbiAgICAgICAgcGllcmNpbmc6IGZhbHNlLFxuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiAxLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlUHJvamVjdGlsZShcbiAgICAgICAgdGhpcy53b3JsZCxcbiAgICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgICAgcHJvamVjdGlsZURpcmVjdGlvbixcbiAgICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkhLmlkLFxuICAgICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIGFzIGJhcnJhZ2UgYXJyb3cgZm9yIHZpc3VhbCBpZGVudGlmaWNhdGlvblxuICAgICAgY29uc3QgcmVuZGVyZXIgPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChSZW5kZXJlcikgYXMgUmVuZGVyZXI7XG4gICAgICBpZiAocmVuZGVyZXI/Lm1lc2gpIHtcbiAgICAgICAgcmVuZGVyZXIubWVzaC51c2VyRGF0YS5pc0JhcnJhZ2VBcnJvdyA9IHRydWU7XG4gICAgICAgIHJlbmRlcmVyLm1lc2gudXNlckRhdGEuaXNSZWd1bGFyQXJyb3cgPSBmYWxzZTsgLy8gT3ZlcnJpZGUgcmVndWxhciBhcnJvdyBtYXJraW5nXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnYmFycmFnZV9wcm9qZWN0aWxlJywgc3Bhd25Qb3NpdGlvbiwgcHJvamVjdGlsZURpcmVjdGlvbiwgcHJvamVjdGlsZUNvbmZpZyk7XG4gICAgICB9XG4gICAgICBcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIEJhcnJhZ2UgY2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgdmlzdWFsIGVmZmVjdHMgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMub25CYXJyYWdlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25CYXJyYWdlQ2FsbGJhY2socGxheWVyUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cERlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQWN0aXZhdGUgdGhlIGRlZmxlY3QgYmFycmllclxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBjb25zdCBwbGF5ZXJSb3RhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIFxuICAgIC8vIFVzZSBTQU1FIHJvdGF0aW9uIGxvZ2ljIGFzIERyYWdvblJlbmRlcmVyIGZvciBjb25zaXN0ZW5jeSB3aXRoIHZpc3VhbCBzaGllbGRcbiAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGlmIChtb3ZlbWVudCAmJiBtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoID4gMC4xKSB7XG4gICAgICAgIC8vIFBsYXllciBpcyBhY3RpdmVseSBtb3ZpbmcgLSB1c2UgbW92ZW1lbnQgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyKVxuICAgICAgICBjb25zdCBtb3ZlRGlyID0gbW92ZW1lbnQubW92ZURpcmVjdGlvbjtcbiAgICAgICAgaWYgKG1vdmVEaXIubGVuZ3RoKCkgPiAwLjEpIHtcbiAgICAgICAgICBjb25zdCBtb3ZlQW5nbGUgPSBNYXRoLmF0YW4yKG1vdmVEaXIueCwgbW92ZURpci56KTtcbiAgICAgICAgICBwbGF5ZXJSb3RhdGlvbi55ID0gbW92ZUFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgbW92aW5nIC0gdXNlIGNhbWVyYSBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIgZmFsbGJhY2spXG4gICAgICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBNYXRoLmF0YW4yKGNhbWVyYURpcmVjdGlvbi54LCBjYW1lcmFEaXJlY3Rpb24ueik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZGVmbGVjdEJhcnJpZXIuYWN0aXZhdGUocGxheWVyUG9zaXRpb24sIHBsYXllclJvdGF0aW9uLCB0aGlzLnBsYXllckVudGl0eSB8fCB1bmRlZmluZWQpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVEZWZsZWN0QmFycmllcihwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBkZWZsZWN0IGJhcnJpZXIgcG9zaXRpb24gaWYgaXQncyBhY3RpdmVcbiAgICBpZiAodGhpcy5kZWZsZWN0QmFycmllci5pc0JhcnJpZXJBY3RpdmUoKSkge1xuICAgICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgICAgY29uc3QgcGxheWVyUm90YXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIFNBTUUgcm90YXRpb24gbG9naWMgYXMgRHJhZ29uUmVuZGVyZXIgZm9yIGNvbnNpc3RlbmN5IHdpdGggdmlzdWFsIHNoaWVsZFxuICAgICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgIGNvbnN0IG1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgaWYgKG1vdmVtZW50ICYmIG1vdmVtZW50LmlucHV0U3RyZW5ndGggPiAwLjEpIHtcbiAgICAgICAgICAvLyBQbGF5ZXIgaXMgYWN0aXZlbHkgbW92aW5nIC0gdXNlIG1vdmVtZW50IGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlcilcbiAgICAgICAgICBjb25zdCBtb3ZlRGlyID0gbW92ZW1lbnQubW92ZURpcmVjdGlvbjtcbiAgICAgICAgICBpZiAobW92ZURpci5sZW5ndGgoKSA+IDAuMSkge1xuICAgICAgICAgICAgY29uc3QgbW92ZUFuZ2xlID0gTWF0aC5hdGFuMihtb3ZlRGlyLngsIG1vdmVEaXIueik7XG4gICAgICAgICAgICBwbGF5ZXJSb3RhdGlvbi55ID0gbW92ZUFuZ2xlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3QgbW92aW5nIC0gdXNlIGNhbWVyYSBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIgZmFsbGJhY2spXG4gICAgICAgICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBNYXRoLmF0YW4yKGNhbWVyYURpcmVjdGlvbi54LCBjYW1lcmFEaXJlY3Rpb24ueik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGJhcnJpZXIgcG9zaXRpb24gdG8gZm9sbG93IHBsYXllclxuICAgICAgdGhpcy5kZWZsZWN0QmFycmllci51cGRhdGVQb3NpdGlvbihwbGF5ZXJQb3NpdGlvbiwgcGxheWVyUm90YXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBieSBzd29yZCBjb21wb25lbnQgd2hlbiBEZWZsZWN0IGNvbXBsZXRlc1xuICBwdWJsaWMgb25EZWZsZWN0Q29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5pc0RlZmxlY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRlZmxlY3RCYXJyaWVyLmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBtZXRob2RzIHRvIGdldCBjb29sZG93biBpbmZvcm1hdGlvbiBmb3IgVUlcbiAgcHVibGljIGdldFdlYXBvblN3aXRjaENvb2xkb3duKCk6IHsgY3VycmVudDogbnVtYmVyOyBtYXg6IG51bWJlciB9IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLndlYXBvblN3aXRjaENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSkpLFxuICAgICAgbWF4OiB0aGlzLndlYXBvblN3aXRjaENvb2xkb3duXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBYmlsaXR5Q29vbGRvd25zKCk6IFJlY29yZDxzdHJpbmcsIHsgY3VycmVudDogbnVtYmVyOyBtYXg6IG51bWJlcjsgaXNBY3RpdmU6IGJvb2xlYW4gfT4ge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgY29uc3QgY29vbGRvd25zOiBSZWNvcmQ8c3RyaW5nLCB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXI7IGlzQWN0aXZlOiBib29sZWFuIH0+ID0ge307XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuZGVmbGVjdENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVmbGVjdFRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmRlZmxlY3RDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNEZWZsZWN0aW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuY2hhcmdlQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDaGFyZ2VUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5jaGFyZ2VDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNTd29yZENoYXJnaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuZGl2aW5lU3Rvcm1Db29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERpdmluZVN0b3JtVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZGl2aW5lU3Rvcm1Db29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNEaXZpbmVTdG9ybWluZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmJhcnJhZ2VGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5iYXJyYWdlRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQmFycmFnZUNoYXJnaW5nXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuY29icmFTaG90RmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2JyYVNob3RUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5jb2JyYVNob3RGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMudmlwZXJTdGluZ0ZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgMS4wIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVhbmltYXRlVGltZSkpLFxuICAgICAgICBtYXg6IDEuMCxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydFJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGcm9zdE5vdmFUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5mcm9zdE5vdmFGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29vbGRvd25zWydSJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5jcm9zc2VudHJvcHlGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNBQlJFUykge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuYmFja3N0YWJDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhY2tzdGFiVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuYmFja3N0YWJDb29sZG93bixcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNCYWNrc3RhYmJpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0UnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5zdW5kZXJDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFN1bmRlclRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLnN1bmRlckNvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1N1bmRlcmluZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLnNreWZhbGxDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFNreWZhbGxUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5za3lmYWxsQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzU2t5ZmFsbGluZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5SVU5FQkxBREUpIHtcbiAgICAgIC8vIFJVTkVCTEFERSBhYmlsaXRpZXNcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRlYXRoR3Jhc3BDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERlYXRoR3Jhc3BUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5kZWF0aEdyYXNwQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGVhdGhHcmFzcGluZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLnNtaXRlQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTbWl0ZVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLnNtaXRlQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzU21pdGluZ1xuICAgICAgfTtcbiAgICAgIC8vIFIgaXMgdW51c2VkIGZvciBSVU5FQkxBREVcbiAgICB9XG5cbiAgICByZXR1cm4gY29vbGRvd25zO1xuICB9XG59Il0sIm5hbWVzIjpbIlZlY3RvcjMiLCJNYXRyaXg0IiwiU3lzdGVtIiwiVHJhbnNmb3JtIiwiTW92ZW1lbnQiLCJIZWFsdGgiLCJFbmVteSIsIlJlbmRlcmVyIiwiQ29sbGlkZXIiLCJDb21iYXRTeXN0ZW0iLCJXZWFwb25TdWJjbGFzcyIsIldlYXBvblR5cGUiLCJEZWZsZWN0QmFycmllciIsInRyaWdnZXJHbG9iYWxGcm9zdE5vdmEiLCJhZGRHbG9iYWxGcm96ZW5FbmVteSIsImFkZEdsb2JhbFN0dW5uZWRFbmVteSIsInRyaWdnZXJHbG9iYWxDb2JyYVNob3QiLCJ0cmlnZ2VyR2xvYmFsVmlwZXJTdGluZyIsIkNvbnRyb2xTeXN0ZW0iLCJzZXRQbGF5ZXIiLCJlbnRpdHkiLCJwbGF5ZXJFbnRpdHkiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsInBsYXllclRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInBsYXllck1vdmVtZW50IiwidXBkYXRlRGVidWZmcyIsImNsZWFudXBTdW5kZXJTdGFja3MiLCJoYW5kbGVXZWFwb25Td2l0Y2hpbmciLCJoYW5kbGVEYXNoTW92ZW1lbnQiLCJoYW5kbGVDaGFyZ2VNb3ZlbWVudCIsImlzRGFzaGluZyIsImlzQ2hhcmdpbmciLCJpc0Zyb3plbiIsImlzU2t5ZmFsbGluZyIsImhhbmRsZU1vdmVtZW50SW5wdXQiLCJoYW5kbGVDb21iYXRJbnB1dCIsInVwZGF0ZURlZmxlY3RCYXJyaWVyIiwibW92ZW1lbnQiLCJjaGVja0ZvckRhc2hJbnB1dCIsImlucHV0RGlyZWN0aW9uIiwiaGFzSW5wdXQiLCJpbnB1dE1hbmFnZXIiLCJpc0tleVByZXNzZWQiLCJ6IiwieCIsImxlbmd0aCIsIm5vcm1hbGl6ZSIsImNhbWVyYURpcmVjdGlvbiIsImNhbWVyYSIsImdldFdvcmxkRGlyZWN0aW9uIiwiY2FtZXJhUmlnaHQiLCJjcm9zc1ZlY3RvcnMiLCJjYW1lcmFGb3J3YXJkIiwid29ybGREaXJlY3Rpb24iLCJhZGRTY2FsZWRWZWN0b3IiLCJzZXRNb3ZlRGlyZWN0aW9uIiwianVtcCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImxhc3RXZWFwb25Td2l0Y2hUaW1lIiwid2VhcG9uU3dpdGNoQ29vbGRvd24iLCJjdXJyZW50V2VhcG9uIiwiU1dPUkQiLCJyZXNldEFsbEFiaWxpdHlTdGF0ZXMiLCJjdXJyZW50U3ViY2xhc3MiLCJESVZJTklUWSIsImZpcmVSYXRlIiwic3dvcmRGaXJlUmF0ZSIsInN3b3JkQ29tYm9TdGVwIiwiQk9XIiwiRUxFTUVOVEFMIiwiU0NZVEhFIiwiQ0hBT1MiLCJzY3l0aGVGaXJlUmF0ZSIsIlNBQlJFUyIsIkZST1NUIiwic2FicmVzRmlyZVJhdGUiLCJSVU5FQkxBREUiLCJBUkNBTkUiLCJydW5lYmxhZGVGaXJlUmF0ZSIsImhhbmRsZUJvd0lucHV0IiwiaGFuZGxlU2N5dGhlSW5wdXQiLCJoYW5kbGVTd29yZElucHV0IiwiaGFuZGxlU2FicmVzSW5wdXQiLCJoYW5kbGVSdW5lYmxhZGVJbnB1dCIsImlzVmlwZXJTdGluZ0NoYXJnaW5nIiwicGVyZm9ybVZpcGVyU3RpbmciLCJpc0JhcnJhZ2VDaGFyZ2luZyIsInBlcmZvcm1CYXJyYWdlIiwiaXNDb2JyYVNob3RDaGFyZ2luZyIsInBlcmZvcm1Db2JyYVNob3QiLCJpc01vdXNlQnV0dG9uUHJlc3NlZCIsImNoYXJnZVByb2dyZXNzIiwiTWF0aCIsIm1pbiIsImZpbmFsQ2hhcmdlUHJvZ3Jlc3MiLCJmaXJlUHJvamVjdGlsZSIsInRyaWdnZXJCb3dSZWxlYXNlRWZmZWN0cyIsImNvbnNvbGUiLCJsb2ciLCJmaXJlRW50cm9waWNCb2x0UHJvamVjdGlsZSIsImZpcmVDcm9zc2VudHJvcHlCb2x0QWJpbGl0eSIsInBlcmZvcm1SZWFuaW1hdGVBYmlsaXR5IiwicGVyZm9ybUZyb3N0Tm92YUFiaWxpdHkiLCJsYXN0RmlyZVRpbWUiLCJkaXJlY3Rpb24iLCJjb21wZW5zYXRpb25BbmdsZSIsIlBJIiwicm90YXRpb25NYXRyaXgiLCJtYWtlUm90YXRpb25BeGlzIiwiYXBwbHlNYXRyaXg0IiwicGVyZmVjdFNob3RNaW5UaHJlc2hvbGQiLCJwZXJmZWN0U2hvdE1heFRocmVzaG9sZCIsImlzUGVyZmVjdFNob3QiLCJjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlIiwicG9zaXRpb24iLCJjbG9uZSIsImNyZWF0ZVBlcmZlY3RTaG90UHJvamVjdGlsZSIsImFuZ2xlIiwiYXRhbjIiLCJjcmVhdGVQcm9qZWN0aWxlIiwic3BpblN0YXR1cyIsImNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJsYXN0Q3Jvc3NlbnRyb3B5VGltZSIsImNyb3NzZW50cm9weUZpcmVSYXRlIiwiY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUiLCJwb3RlbnRpYWxUYXJnZXRzIiwid29ybGQiLCJxdWVyeUVudGl0aWVzIiwidmFsaWRUYXJnZXRzIiwiZmlsdGVyIiwidGFyZ2V0IiwiaWQiLCJpc0RlYWQiLCJoYXNWYWxpZFRhcmdldHMiLCJzaG91bGRCcm9hZGNhc3QiLCJvblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2siLCJ1bmRlZmluZWQiLCJzcGF3blBvc2l0aW9uIiwiYWRkIiwibXVsdGlwbHlTY2FsYXIiLCJ5IiwicHJvamVjdGlsZUNvbmZpZyIsInNwZWVkIiwiZGFtYWdlIiwibGlmZXRpbWUiLCJtYXhEaXN0YW5jZSIsInN1YmNsYXNzIiwibGV2ZWwiLCJjdXJyZW50TGV2ZWwiLCJvcGFjaXR5IiwicHJvamVjdGlsZVN5c3RlbSIsImdhbWVVSSIsIndpbmRvdyIsImNhbkNhc3RFbnRyb3BpY0JvbHQiLCJjb25zdW1lTWFuYSIsImVudHJvcGljQ29uZmlnIiwicGllcmNpbmciLCJleHBsb3NpdmUiLCJleHBsb3Npb25SYWRpdXMiLCJjYW5DYXN0Q3Jvc3NlbnRyb3B5Qm9sdCIsImNyb3NzZW50cm9weUNvbmZpZyIsImxhc3RSZWFuaW1hdGVUaW1lIiwiY3VycmVudE1hbmEiLCJnZXRDdXJyZW50TWFuYSIsImNhbkNhc3RSZWFuaW1hdGUiLCJtYW5hQmVmb3JlIiwibWFuYUFmdGVyIiwidHJpZ2dlclJlYW5pbWF0ZUVmZmVjdCIsImhlYWx0aENvbXBvbmVudCIsImRpZEhlYWwiLCJoZWFsIiwib25SZWFuaW1hdGVDYWxsYmFjayIsInBsYXllclBvc2l0aW9uIiwibGFzdEZyb3N0Tm92YVRpbWUiLCJmcm9zdE5vdmFGaXJlUmF0ZSIsImNhbkNhc3RGcm9zdE5vdmEiLCJnZXRXb3JsZFBvc2l0aW9uIiwib25Gcm9zdE5vdmFDYWxsYmFjayIsImZyZWV6ZUVuZW1pZXNJblJhZGl1cyIsImxhc3RDb2JyYVNob3RUaW1lIiwiY29icmFTaG90RmlyZVJhdGUiLCJjYW5DYXN0Q29icmFTaG90IiwiY29uc3VtZUVuZXJneSIsImNvYnJhU2hvdENoYXJnZVByb2dyZXNzIiwiY2hhcmdlU3RhcnRUaW1lIiwiY2hhcmdlRHVyYXRpb24iLCJjaGFyZ2VJbnRlcnZhbCIsInNldEludGVydmFsIiwiZWxhcHNlZCIsImNsZWFySW50ZXJ2YWwiLCJmaXJlQ29icmFTaG90Iiwib25Db2JyYVNob3RDYWxsYmFjayIsInZlbm9tRHVyYXRpb24iLCJjZW50ZXJQb3NpdGlvbiIsInJhZGl1cyIsImFsbEVudGl0aWVzIiwiZ2V0QWxsRW50aXRpZXMiLCJmcm96ZW5Db3VudCIsImRhbWFnZWRQbGF5ZXJzIiwibG9jYWxTb2NrZXRJZCIsImZvckVhY2giLCJlbnRpdHlUcmFuc2Zvcm0iLCJlbnRpdHlIZWFsdGgiLCJlbnRpdHlQb3NpdGlvbiIsImRpc3RhbmNlIiwiZGlzdGFuY2VUbyIsImVuZW15IiwiZnJlZXplIiwidG9TdHJpbmciLCJzZXJ2ZXJQbGF5ZXJFbnRpdGllcyIsInRhcmdldFBsYXllcklkIiwiY3VycmVudCIsImxvY2FsRW50aXR5SWQiLCJwbGF5ZXJJZCIsImNvbWJhdFN5c3RlbSIsImdldFN5c3RlbSIsImZyb3N0Tm92YURhbWFnZSIsInF1ZXVlRGFtYWdlIiwib25EZWJ1ZmZDYWxsYmFjayIsImNoYXJnZWRBcnJvd0NvbmZpZyIsInNldFdlYXBvblN1YmNsYXNzIiwic2V0Qm93UmVsZWFzZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvbkJvd1JlbGVhc2VDYWxsYmFjayIsInNldERpdmluZVN0b3JtQ2FsbGJhY2siLCJvbkRpdmluZVN0b3JtQ2FsbGJhY2siLCJzZXRQcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrIiwic2V0VmlwZXJTdGluZ0NhbGxiYWNrIiwib25WaXBlclN0aW5nQ2FsbGJhY2siLCJzZXRCYXJyYWdlQ2FsbGJhY2siLCJvbkJhcnJhZ2VDYWxsYmFjayIsInNldFJlYW5pbWF0ZUNhbGxiYWNrIiwic2V0RnJvc3ROb3ZhQ2FsbGJhY2siLCJzZXRDb2JyYVNob3RDYWxsYmFjayIsInNldENoYXJnZUNhbGxiYWNrIiwib25DaGFyZ2VDYWxsYmFjayIsInNldERlZmxlY3RDYWxsYmFjayIsIm9uRGVmbGVjdENhbGxiYWNrIiwic2V0U2t5ZmFsbENhbGxiYWNrIiwib25Ta3lmYWxsQ2FsbGJhY2siLCJzZXRCYWNrc3RhYkNhbGxiYWNrIiwib25CYWNrc3RhYkNhbGxiYWNrIiwic2V0U3VuZGVyQ2FsbGJhY2siLCJvblN1bmRlckNhbGxiYWNrIiwic2V0U21pdGVDYWxsYmFjayIsIm9uU21pdGVDYWxsYmFjayIsInNldERlYXRoR3Jhc3BDYWxsYmFjayIsIm9uRGVhdGhHcmFzcENhbGxiYWNrIiwic2V0Q29uc3VtZU1hbmFDYWxsYmFjayIsIm9uQ29uc3VtZU1hbmFDYWxsYmFjayIsInNldENoZWNrTWFuYUNhbGxiYWNrIiwib25DaGVja01hbmFDYWxsYmFjayIsInNldERlYnVmZkNhbGxiYWNrIiwic2V0V2VhcG9uTGV2ZWwiLCJnZXRDdXJyZW50V2VhcG9uQ29uZmlnIiwid2VhcG9uIiwiZ2V0Q3VycmVudFdlYXBvbiIsImdldEN1cnJlbnRTdWJjbGFzcyIsImlzV2VhcG9uQ2hhcmdpbmciLCJnZXRDaGFyZ2VQcm9ncmVzcyIsImlzVmlwZXJTdGluZ0NoYXJnaW5nQWN0aXZlIiwiZ2V0VmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzIiwidmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzIiwiaXNCYXJyYWdlQ2hhcmdpbmdBY3RpdmUiLCJnZXRCYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MiLCJiYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MiLCJpc0NvYnJhU2hvdENoYXJnaW5nQWN0aXZlIiwiZ2V0Q29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MiLCJpc1dlYXBvblN3aW5naW5nIiwiaXNTd2luZ2luZyIsImdldFN3b3JkQ29tYm9TdGVwIiwiaXNEaXZpbmVTdG9ybUFjdGl2ZSIsImlzRGl2aW5lU3Rvcm1pbmciLCJpc0NoYXJnZUFjdGl2ZSIsImlzU3dvcmRDaGFyZ2luZyIsImlzRGVmbGVjdEFjdGl2ZSIsImlzRGVmbGVjdGluZyIsImlzU2t5ZmFsbEFjdGl2ZSIsImlzQmFja3N0YWJBY3RpdmUiLCJpc0JhY2tzdGFiYmluZyIsImlzU3VuZGVyQWN0aXZlIiwiaXNTdW5kZXJpbmciLCJpc1NtaXRlQWN0aXZlIiwiaXNTbWl0aW5nIiwiaXNEZWF0aEdyYXNwQWN0aXZlIiwiaXNEZWF0aEdyYXNwaW5nIiwicGVyZm9ybVN3b3JkTWVsZWVBdHRhY2siLCJwZXJmb3JtRGl2aW5lU3Rvcm0iLCJwZXJmb3JtQ2hhcmdlIiwicGVyZm9ybURlZmxlY3QiLCJsYXN0U3dvcmRBdHRhY2tUaW1lIiwic3dvcmRDb21ib1Jlc2V0VGltZSIsInBlcmZvcm1SdW5lYmxhZGVNZWxlZUF0dGFjayIsInBlcmZvcm1TbWl0ZSIsInBlcmZvcm1EZWF0aEdyYXNwIiwicGVyZm9ybU1lbGVlRGFtYWdlIiwibGFzdFNtaXRlVGltZSIsInNtaXRlQ29vbGRvd24iLCJjYW5DYXN0U21pdGUiLCJzbWl0ZVBvc2l0aW9uIiwiZGFtYWdlRGVhbHRGbGFnIiwicGVyZm9ybVNtaXRlSGVhbGluZyIsInNldFRpbWVvdXQiLCJwZXJmb3JtU21pdGVEYW1hZ2UiLCJzbWl0ZURhbWFnZSIsImRhbWFnZVJhZGl1cyIsImRhbWFnZURlYWx0IiwidG9GaXhlZCIsIm9sZEhlYWx0aCIsImN1cnJlbnRIZWFsdGgiLCJtYXhIZWFsdGgiLCJnYWluSGVhbHRoIiwiZXJyb3IiLCJsYXN0RGVhdGhHcmFzcFRpbWUiLCJkZWF0aEdyYXNwQ29vbGRvd24iLCJjYW5DYXN0RGVhdGhHcmFzcCIsIm9uU3dvcmRTd2luZ0NvbXBsZXRlIiwib25TbWl0ZUNvbXBsZXRlIiwib25EZWF0aEdyYXNwQ29tcGxldGUiLCJwZXJmb3JtU2FicmVzTWVsZWVBdHRhY2siLCJwZXJmb3JtQmFja3N0YWIiLCJwZXJmb3JtU3VuZGVyIiwicGVyZm9ybVNreWZhbGwiLCJ1cGRhdGVTa3lmYWxsTW92ZW1lbnQiLCJ1cGRhdGVCYWNrc3RhYlN0YXRlIiwidXBkYXRlU3VuZGVyU3RhdGUiLCJwZXJmb3JtU2FicmVzTWVsZWVEYW1hZ2UiLCJvblNhYnJlc1N3aW5nQ29tcGxldGUiLCJoYXNDb21wb25lbnQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0FuZ2xlIiwibGVmdFNhYnJlRGFtYWdlIiwicmlnaHRTYWJyZURhbWFnZSIsImF0dGFja0RpcmVjdGlvbiIsImhpdENvdW50IiwidGFyZ2V0VHJhbnNmb3JtIiwidGFyZ2V0SGVhbHRoIiwiZGlyZWN0aW9uVG9UYXJnZXQiLCJzdWIiLCJkaXN0YW5jZVRvVGFyZ2V0IiwiZG90UHJvZHVjdCIsImRvdCIsImFuZ2xlVG9UYXJnZXQiLCJhY29zIiwibWF4IiwibGFzdFNreWZhbGxUaW1lIiwic2t5ZmFsbENvb2xkb3duIiwiY2FuQ2FzdFNreWZhbGwiLCJza3lmYWxsUGhhc2UiLCJza3lmYWxsU3RhcnRUaW1lIiwic2t5ZmFsbFN0YXJ0UG9zaXRpb24iLCJjb3B5Iiwic2t5ZmFsbE9yaWdpbmFsR3Jhdml0eSIsImdyYXZpdHkiLCJza3lmYWxsVGFyZ2V0SGVpZ2h0IiwianVtcEZvcmNlIiwidmVsb2NpdHkiLCJlbGFwc2VkVGltZSIsInBlcmZvcm1Ta3lmYWxsTGFuZGluZyIsImNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkiLCJsYW5kaW5nUG9zaXRpb24iLCJza3lmYWxsRGFtYWdlIiwiZGlzdGFuY2VUb0xhbmRpbmciLCJiYWNrc3RhYlN0YXJ0VGltZSIsImJhY2tzdGFiRHVyYXRpb24iLCJsYXN0U3VuZGVyVGltZSIsInN1bmRlckNvb2xkb3duIiwiY2FuQ2FzdFN1bmRlciIsInN1bmRlclN0YXJ0VGltZSIsInBlcmZvcm1TdW5kZXJEYW1hZ2UiLCJzdW5kZXJEdXJhdGlvbiIsInBsYXllckRpcmVjdGlvbiIsInN1bmRlclJhbmdlIiwic3ViVmVjdG9ycyIsImFuZ2xlVGhyZXNob2xkIiwiY29zIiwic3RhY2tDb3VudCIsImlzU3R1bm5lZCIsImFwcGx5U3VuZGVyU3RhY2siLCJlbnRpdHlJZCIsInN0YWNrRHVyYXRpb24iLCJjdXJyZW50U3RhY2tzIiwic3VuZGVyU3RhY2tzIiwiZ2V0IiwibGFzdEFwcGxpZWQiLCJzdGFja3MiLCJkdXJhdGlvbiIsImJhc2VEYW1hZ2VzIiwibmV3U3RhY2tDb3VudCIsInNldCIsImVudHJpZXMiLCJBcnJheSIsImZyb20iLCJzdGFja0RhdGEiLCJkZWxldGUiLCJjbGVhciIsImxhc3RCYWNrc3RhYlRpbWUiLCJiYWNrc3RhYkNvb2xkb3duIiwiY2FuQ2FzdEJhY2tzdGFiIiwicGVyZm9ybUJhY2tzdGFiRGFtYWdlIiwiYmFja3N0YWJSYW5nZSIsImlzQmFja3N0YWIiLCJwdnBQbGF5ZXJzIiwidGFyZ2V0UGxheWVyIiwicGxheWVyIiwicGxheWVyUG9zIiwidGFyZ2V0RmFjaW5nRGlyZWN0aW9uIiwic2luIiwicm90YXRpb24iLCJhdHRhY2tlckRpcmVjdGlvbiIsImJlaGluZERvdFByb2R1Y3QiLCJtZWxlZVJhbmdlIiwibWVsZWVBbmdsZSIsImJhc2VEYW1hZ2UiLCJlbmVtaWVzSGl0IiwiZW5lbXlUcmFuc2Zvcm0iLCJlbmVteUhlYWx0aCIsImVuZW15UG9zaXRpb24iLCJ0b0VuZW15IiwiYW5nbGVUbyIsImFuZ2xlRGVncmVlcyIsIm1heEFuZ2xlRGVncmVlcyIsInJhZ2VUb0dhaW4iLCJnYWluUmFnZSIsInRyYW5zZm9ybSIsImRhc2hEaXJlY3Rpb25zIiwia2V5IiwiY2hlY2tEb3VibGVUYXAiLCJkZWJ1Z0luZm8iLCJnZXREb3VibGVUYXBEZWJ1Z0luZm8iLCJnZXRXb3JsZFNwYWNlRGlyZWN0aW9uIiwiZGFzaFN0YXJ0ZWQiLCJzdGFydERhc2giLCJyZXNldERvdWJsZVRhcCIsImRhc2hSZXN1bHQiLCJ1cGRhdGVEYXNoIiwibmV3UG9zaXRpb24iLCJNQVhfREFTSF9CT1VORFMiLCJkaXN0YW5jZUZyb21PcmlnaW4iLCJjYW5jZWxEYXNoIiwiY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uIiwiY2FuY2VsQ2hhcmdlIiwiY2hhcmdlUmVzdWx0IiwidXBkYXRlQ2hhcmdlIiwiTUFYX0NIQVJHRV9CT1VORFMiLCJwaWxsYXJDb2xsaXNpb24iLCJjaGVja1BpbGxhckNvbGxpc2lvbiIsIm9uQ2hhcmdlQ29tcGxldGUiLCJoYXNDb2xsaXNpb24iLCJ3YXJuIiwicGlsbGFyQ2VudGVyIiwidG9BcnJheSIsImpvaW4iLCJpc0NvbXBsZXRlIiwicGlsbGFyUG9zIiwiUElMTEFSX1BPU0lUSU9OUyIsImhvcml6b250YWxQb3MiLCJwaWxsYXJIb3Jpem9udGFsIiwiUElMTEFSX1JBRElVUyIsIm5vcm1hbCIsImNhbkNhc3REaXZpbmVTdG9ybSIsImxhc3REaXZpbmVTdG9ybVRpbWUiLCJkaXZpbmVTdG9ybUNvb2xkb3duIiwiY3VycmVudFJhZ2UiLCJnZXRDdXJyZW50UmFnZSIsImNvbnN1bWVBbGxSYWdlIiwiYmFzZVN0b3JtRHVyYXRpb24iLCJib251c0R1cmF0aW9uIiwiZmxvb3IiLCJ0b3RhbERpdmluZVN0b3JtRHVyYXRpb24iLCJsYXN0Q2hhcmdlVGltZSIsImNoYXJnZUNvb2xkb3duIiwiY2hhcmdlU3RhcnRlZCIsInN0YXJ0Q2hhcmdlIiwic2NoZWR1bGVDaGFyZ2VEYW1hZ2UiLCJjaGFyZ2VEaXJlY3Rpb24iLCJzdGFydFRpbWUiLCJkYW1hZ2VDaGVja0ludGVydmFsIiwiY2hhcmdlRGFtYWdlIiwiY2hhcmdlUmFkaXVzIiwiY2hhcmdlSGl0RW50aXRpZXMiLCJkYW1hZ2VJbnRlcnZhbCIsImhpdFNvbWV0aGluZyIsInNlcnZlclBsYXllcnMiLCJNYXAiLCJzZXJ2ZXJQbGF5ZXIiLCJwbGF5ZXJJZEhhc2giLCJjaGFyQ29kZUF0IiwiaGFzIiwic2VydmVyUGxheWVyUG9zIiwic3RvcERpc3RhbmNlIiwiaGVhbHRoIiwidGFyZ2V0SWQiLCJoaXRQb3NpdGlvbiIsImVudGl0eUNvbGxpZGVyIiwiZW50aXR5VHlwZSIsImdldERpc3BsYXlOYW1lIiwibGFzdERlZmxlY3RUaW1lIiwiZGVmbGVjdENvb2xkb3duIiwic2V0dXBEZWZsZWN0QmFycmllciIsIm9uRGVmbGVjdENvbXBsZXRlIiwiZGVmbGVjdER1cmF0aW9uIiwibGFzdFZpcGVyU3RpbmdUaW1lIiwidmlwZXJTdGluZ0ZpcmVSYXRlIiwiY2FuQ2FzdFZpcGVyU3RpbmciLCJmaXJlVmlwZXJTdGluZyIsInN1Y2Nlc3MiLCJpc1JldHVybmluZyIsImxhc3RCYXJyYWdlVGltZSIsImJhcnJhZ2VGaXJlUmF0ZSIsImNhbkNhc3RCYXJyYWdlIiwiZmlyZUJhcnJhZ2UiLCJhbmdsZXMiLCJwcm9qZWN0aWxlRGlyZWN0aW9uIiwibWFrZVJvdGF0aW9uWSIsInByb2plY3RpbGVFbnRpdHkiLCJyZW5kZXJlciIsIm1lc2giLCJ1c2VyRGF0YSIsImlzQmFycmFnZUFycm93IiwiaXNSZWd1bGFyQXJyb3ciLCJwbGF5ZXJSb3RhdGlvbiIsImlucHV0U3RyZW5ndGgiLCJtb3ZlRGlyIiwibW92ZURpcmVjdGlvbiIsIm1vdmVBbmdsZSIsImRlZmxlY3RCYXJyaWVyIiwiYWN0aXZhdGUiLCJpc0JhcnJpZXJBY3RpdmUiLCJ1cGRhdGVQb3NpdGlvbiIsImRlYWN0aXZhdGUiLCJnZXRXZWFwb25Td2l0Y2hDb29sZG93biIsImdldEFiaWxpdHlDb29sZG93bnMiLCJjb29sZG93bnMiLCJpc0FjdGl2ZSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwiU2V0IiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ControlSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/HealthBarSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/HealthBarSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBarSystem: function() { return /* binding */ HealthBarSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/HealthBar */ \"(app-pages-browser)/./src/ecs/components/HealthBar.ts\");\n// Health bar system for rendering health bars above entities\n\n\n\n\n\nclass HealthBarSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update health bar logic\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n            if (!transform.enabled || !health.enabled || !healthBar.enabled) {\n                continue;\n            }\n            // Update health bar with current health ratio\n            const worldPosition = transform.getWorldPosition();\n            const cameraPosition = this.camera.position;\n            healthBar.updateHealthBar(health.getHealthRatio(), cameraPosition, worldPosition, deltaTime);\n        }\n    }\n    render(entities, deltaTime) {\n    // Health bars are automatically rendered as part of the scene\n    // This method can be used for any additional rendering logic\n    }\n    onEntityAdded(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Add health bar group to scene\n            this.scene.add(healthBar.getGroup());\n        }\n    }\n    onEntityRemoved(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Remove health bar group from scene and dispose resources\n            this.scene.remove(healthBar.getGroup());\n            healthBar.dispose();\n        }\n    }\n    onDisable() {\n        // Clean up all health bars from scene\n        const healthBarGroups = [];\n        this.scene.traverse((object)=>{\n            if (object instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group && object.userData.isHealthBar) {\n                healthBarGroups.push(object);\n            }\n        });\n        for (const group of healthBarGroups){\n            this.scene.remove(group);\n        }\n    }\n    constructor(scene, camera){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar\n        ];\n        this.scene = scene;\n        this.camera = camera;\n        this.priority = 100; // Render after main objects\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0hlYWx0aEJhclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDQTtBQUNqQjtBQUVXO0FBQ047QUFDTTtBQUVoRCxNQUFNSyx3QkFBd0JKLHFEQUFZQTtJQVl4Q0ssT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQkFBMEI7UUFDMUIsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1QsZ0VBQVNBO1lBQy9DLE1BQU1VLFNBQVNILE9BQU9FLFlBQVksQ0FBQ1IsMERBQU1BO1lBQ3pDLE1BQU1VLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBRS9DLElBQUksQ0FBQ00sVUFBVUksT0FBTyxJQUFJLENBQUNGLE9BQU9FLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCTCxVQUFVTSxnQkFBZ0I7WUFDaEQsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1lBRTNDTixVQUFVTyxlQUFlLENBQ3ZCUixPQUFPUyxjQUFjLElBQ3JCSixnQkFDQUYsZUFDQVA7UUFFSjtJQUNGO0lBRU9jLE9BQU9mLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7SUFDekQsOERBQThEO0lBQzlELDZEQUE2RDtJQUMvRDtJQUVPZSxjQUFjZCxNQUFjLEVBQVE7UUFDekMsTUFBTUksWUFBWUosT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7UUFDL0MsSUFBSVMsV0FBVztZQUNiLGdDQUFnQztZQUNoQyxJQUFJLENBQUNXLEtBQUssQ0FBQ0MsR0FBRyxDQUFDWixVQUFVYSxRQUFRO1FBQ25DO0lBQ0Y7SUFFT0MsZ0JBQWdCbEIsTUFBYyxFQUFRO1FBQzNDLE1BQU1JLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1FBQy9DLElBQUlTLFdBQVc7WUFDYiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDVyxLQUFLLENBQUNJLE1BQU0sQ0FBQ2YsVUFBVWEsUUFBUTtZQUNwQ2IsVUFBVWdCLE9BQU87UUFDbkI7SUFDRjtJQUVPQyxZQUFrQjtRQUN2QixzQ0FBc0M7UUFDdEMsTUFBTUMsa0JBQTJCLEVBQUU7UUFFbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDQztZQUNuQixJQUFJQSxrQkFBa0JqQyx1REFBS0EsSUFBSWlDLE9BQU9DLFFBQVEsQ0FBQ0MsV0FBVyxFQUFFO2dCQUMxREosZ0JBQWdCSyxJQUFJLENBQUNIO1lBQ3ZCO1FBQ0Y7UUFFQSxLQUFLLE1BQU1JLFNBQVNOLGdCQUFpQjtZQUNuQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUztRQUNwQjtJQUNGO0lBbEVBQyxZQUFZZCxLQUFZLEVBQUVOLE1BQWMsQ0FBRTtRQUN4QyxLQUFLO2FBTFNxQixxQkFBcUI7WUFBQ3JDLGdFQUFTQTtZQUFFQywwREFBTUE7WUFBRUMsZ0VBQVNBO1NBQUM7UUFNakUsSUFBSSxDQUFDb0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRyxLQUFLLDRCQUE0QjtJQUNuRDtBQThERiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9IZWFsdGhCYXJTeXN0ZW0udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIHN5c3RlbSBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBHcm91cCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEhlYWx0aEJhciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoQmFyJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhclN5c3RlbSBleHRlbmRzIFJlbmRlclN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBIZWFsdGgsIEhlYWx0aEJhcl07XG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwOyAvLyBSZW5kZXIgYWZ0ZXIgbWFpbiBvYmplY3RzXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBsb2dpY1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWhlYWx0aC5lbmFibGVkIHx8ICFoZWFsdGhCYXIuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2l0aCBjdXJyZW50IGhlYWx0aCByYXRpb1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBoZWFsdGhCYXIudXBkYXRlSGVhbHRoQmFyKFxuICAgICAgICBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSxcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgIGRlbHRhVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBIZWFsdGggYmFycyBhcmUgYXV0b21hdGljYWxseSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzY2VuZVxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBhbnkgYWRkaXRpb25hbCByZW5kZXJpbmcgbG9naWNcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgaGVhbHRoQmFyID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGhCYXIpO1xuICAgIGlmIChoZWFsdGhCYXIpIHtcbiAgICAgIC8vIEFkZCBoZWFsdGggYmFyIGdyb3VwIHRvIHNjZW5lXG4gICAgICB0aGlzLnNjZW5lLmFkZChoZWFsdGhCYXIuZ2V0R3JvdXAoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKTtcbiAgICBpZiAoaGVhbHRoQmFyKSB7XG4gICAgICAvLyBSZW1vdmUgaGVhbHRoIGJhciBncm91cCBmcm9tIHNjZW5lIGFuZCBkaXNwb3NlIHJlc291cmNlc1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoaGVhbHRoQmFyLmdldEdyb3VwKCkpO1xuICAgICAgaGVhbHRoQmFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBoZWFsdGggYmFycyBmcm9tIHNjZW5lXG4gICAgY29uc3QgaGVhbHRoQmFyR3JvdXBzOiBHcm91cFtdID0gW107XG4gICAgXG4gICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgR3JvdXAgJiYgb2JqZWN0LnVzZXJEYXRhLmlzSGVhbHRoQmFyKSB7XG4gICAgICAgIGhlYWx0aEJhckdyb3Vwcy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGhlYWx0aEJhckdyb3Vwcykge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoZ3JvdXApO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdyb3VwIiwiUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiSGVhbHRoQmFyIiwiSGVhbHRoQmFyU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoZWFsdGgiLCJoZWFsdGhCYXIiLCJlbmFibGVkIiwid29ybGRQb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYSIsInBvc2l0aW9uIiwidXBkYXRlSGVhbHRoQmFyIiwiZ2V0SGVhbHRoUmF0aW8iLCJyZW5kZXIiLCJvbkVudGl0eUFkZGVkIiwic2NlbmUiLCJhZGQiLCJnZXRHcm91cCIsIm9uRW50aXR5UmVtb3ZlZCIsInJlbW92ZSIsImRpc3Bvc2UiLCJvbkRpc2FibGUiLCJoZWFsdGhCYXJHcm91cHMiLCJ0cmF2ZXJzZSIsIm9iamVjdCIsInVzZXJEYXRhIiwiaXNIZWFsdGhCYXIiLCJwdXNoIiwiZ3JvdXAiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/HealthBarSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/InterpolationSystem.ts":
/*!********************************************!*\
  !*** ./src/systems/InterpolationSystem.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InterpolationSystem: function() { return /* binding */ InterpolationSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Interpolation */ \"(app-pages-browser)/./src/ecs/components/Interpolation.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Interpolation system for smooth entity movement and rotation\n\n\n\n\n\nclass InterpolationSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    /**\n   * Update interpolation for all entities with interpolation buffers\n   */ update(entities, deltaTime) {\n        this.currentTime = performance.now();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_4__.Movement);\n            if (!(transform === null || transform === void 0 ? void 0 : transform.enabled) || !(interpolationBuffer === null || interpolationBuffer === void 0 ? void 0 : interpolationBuffer.enabled)) {\n                continue;\n            }\n            // Skip local players (entities that can move) - they should not be interpolated\n            // Only remote players (canMove = false) should use interpolation\n            if (movement && movement.canMove) {\n                continue;\n            }\n            this.interpolateEntity(transform, interpolationBuffer);\n        }\n    }\n    /**\n   * Render interpolation (called during render phase for smooth visuals)\n   */ render(entities, deltaTime) {\n        // For now, render and update phases are the same for interpolation\n        // In the future, we could separate concerns if needed\n        this.update(entities, deltaTime);\n    }\n    /**\n   * Interpolate a single entity's transform\n   */ interpolateEntity(transform, interpolationBuffer) {\n        const interpolatedTransform = interpolationBuffer.getInterpolatedTransform(this.currentTime);\n        // Apply interpolated position\n        transform.position.copy(interpolatedTransform.position);\n        // Apply interpolated rotation\n        transform.quaternion.copy(interpolatedTransform.rotation);\n        // Update the transform's Euler rotation to match the quaternion\n        transform.rotation.setFromQuaternion(transform.quaternion);\n        // Mark matrices as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    /**\n   * Add server state to an entity's interpolation buffer\n   */ addServerState(entity, position, rotation, timestamp) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            interpolationBuffer.addServerState(position, rotation, timestamp);\n        }\n    }\n    /**\n   * Get interpolation statistics for debugging\n   */ getInterpolationStats(entity) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            return interpolationBuffer.getBufferStats();\n        }\n        return null;\n    }\n    /**\n   * Clear interpolation buffer for an entity\n   */ clearInterpolationBuffer(entity) {\n        const interpolationBuffer = entity.getComponent(_ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer);\n        if (interpolationBuffer) {\n            interpolationBuffer.clearBuffer();\n        }\n    }\n    /**\n   * Set interpolation delay for all entities (in milliseconds)\n   */ setInterpolationDelay(entity, delayMs) {\n        // Note: This would require modifying the InterpolationBuffer component\n        // For now, the delay is fixed in the component itself\n        console.warn(\"Interpolation delay is currently fixed in InterpolationBuffer component\");\n    }\n    /**\n   * Get the current render time used for interpolation\n   */ getCurrentRenderTime() {\n        return this.currentTime;\n    }\n    /**\n   * Advanced interpolation methods for smoother movement\n   */ /**\n   * Hermite spline interpolation for smoother curves\n   * This provides better interpolation between keyframes by considering velocity\n   */ static hermiteInterpolate(p0, p1, v0, v1, t // Interpolation factor [0,1]\n    ) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        // Hermite basis functions\n        const h00 = 2 * t3 - 3 * t2 + 1; // (1 + 2t)(1 - t)^2\n        const h10 = t3 - 2 * t2 + t; // t(1 - t)^2\n        const h01 = -2 * t3 + 3 * t2; // t^2(3 - 2t)\n        const h11 = t3 - t2; // t^2(t - 1)\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, h00);\n        result.addScaledVector(v0, h10);\n        result.addScaledVector(p1, h01);\n        result.addScaledVector(v1, h11);\n        return result;\n    }\n    /**\n   * Catmull-Rom spline interpolation for smooth curves through waypoints\n   */ static catmullRomInterpolate(p0, p1, p2, p3, t // Interpolation factor [0,1]\n    ) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        // Catmull-Rom basis functions\n        const c00 = -0.5 * t3 + t2 - 0.5 * t;\n        const c10 = 1.5 * t3 - 2.5 * t2 + 1;\n        const c20 = -1.5 * t3 + 2 * t2 + 0.5 * t;\n        const c30 = 0.5 * t3 - 0.5 * t2;\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, c00);\n        result.addScaledVector(p1, c10);\n        result.addScaledVector(p2, c20);\n        result.addScaledVector(p3, c30);\n        return result;\n    }\n    /**\n   * Cubic Bezier interpolation for smooth curves with control points\n   */ static bezierInterpolate(p0, p1, p2, p3, t // Interpolation factor [0,1]\n    ) {\n        const u = 1 - t;\n        const tt = t * t;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ttt = tt * t;\n        const result = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        result.addScaledVector(p0, uuu); // (1-t)^3 * p0\n        result.addScaledVector(p1, 3 * uu * t); // 3*(1-t)^2*t * p1\n        result.addScaledVector(p2, 3 * u * tt); // 3*(1-t)*t^2 * p2\n        result.addScaledVector(p3, ttt); // t^3 * p3\n        return result;\n    }\n    /**\n   * Smooth step interpolation for easing\n   */ static smoothStepInterpolate(start, end, t) {\n        // Smoothstep function: 3t^2 - 2t^3\n        const smoothT = t * t * (3 - 2 * t);\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(start, end, smoothT);\n    }\n    /**\n   * Smoother step interpolation for even smoother easing\n   */ static smootherStepInterpolate(start, end, t) {\n        // Smootherstep function: 6t^5 - 15t^4 + 10t^3\n        const smoothT = t * t * t * (t * (6 * t - 15) + 10);\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(start, end, smoothT);\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Interpolation__WEBPACK_IMPORTED_MODULE_3__.InterpolationBuffer\n        ];\n        this.currentTime = 0;\n        this.priority = 20; // Run after physics but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0ludGVycG9sYXRpb25TeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsK0RBQStEO0FBQ0g7QUFDdEI7QUFFaUI7QUFDYztBQUNoQjtBQUU5QyxNQUFNSyw0QkFBNEJKLCtDQUFNQTtJQVM3Qzs7R0FFQyxHQUNELE9BQWNNLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsSUFBSSxDQUFDQyxXQUFXLEdBQUdDLFlBQVlDLEdBQUc7UUFFbEMsS0FBSyxNQUFNQyxVQUFVTCxTQUFVO1lBQzdCLE1BQU1NLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1osZ0VBQVNBO1lBQy9DLE1BQU1hLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1lBQ25FLE1BQU1hLFdBQVdKLE9BQU9FLFlBQVksQ0FBQ1YsOERBQVFBO1lBRTdDLElBQUksRUFBQ1Msc0JBQUFBLGdDQUFBQSxVQUFXSSxPQUFPLEtBQUksRUFBQ0YsZ0NBQUFBLDBDQUFBQSxvQkFBcUJFLE9BQU8sR0FBRTtnQkFDeEQ7WUFDRjtZQUVBLGdGQUFnRjtZQUNoRixpRUFBaUU7WUFDakUsSUFBSUQsWUFBWUEsU0FBU0UsT0FBTyxFQUFFO2dCQUNoQztZQUNGO1lBRUEsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ04sV0FBV0U7UUFDcEM7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBY1IsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxtRUFBbUU7UUFDbkUsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ0YsTUFBTSxDQUFDQyxVQUFVQztJQUN4QjtJQUVBOztHQUVDLEdBQ0Qsa0JBQTBCSyxTQUFvQixFQUFFRSxtQkFBd0MsRUFBUTtRQUM5RixNQUFNTSx3QkFBd0JOLG9CQUFvQk8sd0JBQXdCLENBQUMsSUFBSSxDQUFDYixXQUFXO1FBRTNGLDhCQUE4QjtRQUM5QkksVUFBVVUsUUFBUSxDQUFDQyxJQUFJLENBQUNILHNCQUFzQkUsUUFBUTtRQUV0RCw4QkFBOEI7UUFDOUJWLFVBQVVZLFVBQVUsQ0FBQ0QsSUFBSSxDQUFDSCxzQkFBc0JLLFFBQVE7UUFFeEQsZ0VBQWdFO1FBQ2hFYixVQUFVYSxRQUFRLENBQUNDLGlCQUFpQixDQUFDZCxVQUFVWSxVQUFVO1FBRXpELGtDQUFrQztRQUNsQ1osVUFBVWUsaUJBQWlCLEdBQUc7SUFDaEM7SUFFQTs7R0FFQyxHQUNELGVBQXNCaEIsTUFBYyxFQUFFVyxRQUFpQixFQUFFRyxRQUFvQixFQUFFSSxTQUFrQixFQUFRO1FBQ3ZHLE1BQU1mLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1FBQ25FLElBQUlZLHFCQUFxQjtZQUN2QkEsb0JBQW9CYyxjQUFjLENBQUNOLFVBQVVHLFVBQVVJO1FBQ3pEO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUE2QmxCLE1BQWMsRUFBTztRQUNoRCxNQUFNRyxzQkFBc0JILE9BQU9FLFlBQVksQ0FBQ1gsOEVBQW1CQTtRQUNuRSxJQUFJWSxxQkFBcUI7WUFDdkIsT0FBT0Esb0JBQW9CaUIsY0FBYztRQUMzQztRQUNBLE9BQU87SUFDVDtJQUVBOztHQUVDLEdBQ0QseUJBQWdDcEIsTUFBYyxFQUFRO1FBQ3BELE1BQU1HLHNCQUFzQkgsT0FBT0UsWUFBWSxDQUFDWCw4RUFBbUJBO1FBQ25FLElBQUlZLHFCQUFxQjtZQUN2QkEsb0JBQW9CbUIsV0FBVztRQUNqQztJQUNGO0lBRUE7O0dBRUMsR0FDRCxzQkFBNkJ0QixNQUFjLEVBQUV3QixPQUFlLEVBQVE7UUFDbEUsdUVBQXVFO1FBQ3ZFLHNEQUFzRDtRQUN0REMsUUFBUUMsSUFBSSxDQUFDO0lBQ2Y7SUFFQTs7R0FFQyxHQUNELHVCQUFzQztRQUNwQyxPQUFPLElBQUksQ0FBQzdCLFdBQVc7SUFDekI7SUFFQTs7R0FFQyxHQUVEOzs7R0FHQyxHQUNELE9BQWMrQixtQkFDWkMsRUFBVyxFQUNYQyxFQUFXLEVBQ1hDLEVBQVcsRUFDWEMsRUFBVyxFQUNYQyxFQUFZLDZCQUE2QjtJQUFoQyxFQUNBO1FBQ1QsTUFBTUMsS0FBS0QsSUFBSUE7UUFDZixNQUFNRSxLQUFLRCxLQUFLRDtRQUVoQiwwQkFBMEI7UUFDMUIsTUFBTUcsTUFBTSxJQUFJRCxLQUFLLElBQUlELEtBQUssR0FBTSxvQkFBb0I7UUFDeEQsTUFBTUcsTUFBTUYsS0FBSyxJQUFJRCxLQUFLRCxHQUFVLGFBQWE7UUFDakQsTUFBTUssTUFBTSxDQUFDLElBQUlILEtBQUssSUFBSUQsSUFBVSxjQUFjO1FBQ2xELE1BQU1LLE1BQU1KLEtBQUtELElBQW1CLGFBQWE7UUFFakQsTUFBTU0sU0FBUyxJQUFJcEQseURBQU9BO1FBQzFCb0QsT0FBT0MsZUFBZSxDQUFDWixJQUFJTztRQUMzQkksT0FBT0MsZUFBZSxDQUFDVixJQUFJTTtRQUMzQkcsT0FBT0MsZUFBZSxDQUFDWCxJQUFJUTtRQUMzQkUsT0FBT0MsZUFBZSxDQUFDVCxJQUFJTztRQUUzQixPQUFPQztJQUNUO0lBRUE7O0dBRUMsR0FDRCxPQUFjRSxzQkFDWmIsRUFBVyxFQUNYQyxFQUFXLEVBQ1hhLEVBQVcsRUFDWEMsRUFBVyxFQUNYWCxFQUFhLDZCQUE2QjtJQUFqQyxFQUNBO1FBQ1QsTUFBTUMsS0FBS0QsSUFBSUE7UUFDZixNQUFNRSxLQUFLRCxLQUFLRDtRQUVoQiw4QkFBOEI7UUFDOUIsTUFBTVksTUFBTSxDQUFDLE1BQU1WLEtBQUtELEtBQUssTUFBTUQ7UUFDbkMsTUFBTWEsTUFBTSxNQUFNWCxLQUFLLE1BQU1ELEtBQUs7UUFDbEMsTUFBTWEsTUFBTSxDQUFDLE1BQU1aLEtBQUssSUFBSUQsS0FBSyxNQUFNRDtRQUN2QyxNQUFNZSxNQUFNLE1BQU1iLEtBQUssTUFBTUQ7UUFFN0IsTUFBTU0sU0FBUyxJQUFJcEQseURBQU9BO1FBQzFCb0QsT0FBT0MsZUFBZSxDQUFDWixJQUFJZ0I7UUFDM0JMLE9BQU9DLGVBQWUsQ0FBQ1gsSUFBSWdCO1FBQzNCTixPQUFPQyxlQUFlLENBQUNFLElBQUlJO1FBQzNCUCxPQUFPQyxlQUFlLENBQUNHLElBQUlJO1FBRTNCLE9BQU9SO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQWNTLGtCQUNacEIsRUFBVyxFQUNYQyxFQUFXLEVBQ1hhLEVBQVcsRUFDWEMsRUFBVyxFQUNYWCxFQUFhLDZCQUE2QjtJQUFqQyxFQUNBO1FBQ1QsTUFBTWlCLElBQUksSUFBSWpCO1FBQ2QsTUFBTWtCLEtBQUtsQixJQUFJQTtRQUNmLE1BQU1tQixLQUFLRixJQUFJQTtRQUNmLE1BQU1HLE1BQU1ELEtBQUtGO1FBQ2pCLE1BQU1JLE1BQU1ILEtBQUtsQjtRQUVqQixNQUFNTyxTQUFTLElBQUlwRCx5REFBT0E7UUFDMUJvRCxPQUFPQyxlQUFlLENBQUNaLElBQUl3QixNQUFXLGVBQWU7UUFDckRiLE9BQU9DLGVBQWUsQ0FBQ1gsSUFBSSxJQUFJc0IsS0FBS25CLElBQUksbUJBQW1CO1FBQzNETyxPQUFPQyxlQUFlLENBQUNFLElBQUksSUFBSU8sSUFBSUMsS0FBTSxtQkFBbUI7UUFDNURYLE9BQU9DLGVBQWUsQ0FBQ0csSUFBSVUsTUFBWSxXQUFXO1FBRWxELE9BQU9kO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQWNlLHNCQUFzQkMsS0FBYyxFQUFFQyxHQUFZLEVBQUV4QixDQUFTLEVBQVc7UUFDcEYsbUNBQW1DO1FBQ25DLE1BQU15QixVQUFVekIsSUFBSUEsSUFBSyxLQUFJLElBQUlBLENBQUFBO1FBQ2pDLE9BQU8sSUFBSTdDLHlEQUFPQSxHQUFHdUUsV0FBVyxDQUFDSCxPQUFPQyxLQUFLQztJQUMvQztJQUVBOztHQUVDLEdBQ0QsT0FBY0Usd0JBQXdCSixLQUFjLEVBQUVDLEdBQVksRUFBRXhCLENBQVMsRUFBVztRQUN0Riw4Q0FBOEM7UUFDOUMsTUFBTXlCLFVBQVV6QixJQUFJQSxJQUFJQSxJQUFLQSxDQUFBQSxJQUFLLEtBQUlBLElBQUksRUFBQyxJQUFLLEVBQUM7UUFDakQsT0FBTyxJQUFJN0MseURBQU9BLEdBQUd1RSxXQUFXLENBQUNILE9BQU9DLEtBQUtDO0lBQy9DO0lBL01BRyxhQUFjO1FBQ1osS0FBSzthQUpTQyxxQkFBcUI7WUFBQ3hFLGdFQUFTQTtZQUFFQyw4RUFBbUJBO1NBQUM7YUFDN0RNLGNBQWM7UUFJcEIsSUFBSSxDQUFDa0UsUUFBUSxHQUFHLElBQUkseUNBQXlDO0lBQy9EO0FBNk1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0ludGVycG9sYXRpb25TeXN0ZW0udHM/NjNlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbnRlcnBvbGF0aW9uIHN5c3RlbSBmb3Igc21vb3RoIGVudGl0eSBtb3ZlbWVudCBhbmQgcm90YXRpb25cbmltcG9ydCB7IFZlY3RvcjMsIFF1YXRlcm5pb24gfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBJbnRlcnBvbGF0aW9uQnVmZmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9JbnRlcnBvbGF0aW9uJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5cbmV4cG9ydCBjbGFzcyBJbnRlcnBvbGF0aW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIEludGVycG9sYXRpb25CdWZmZXJdO1xuICBwcml2YXRlIGN1cnJlbnRUaW1lID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyMDsgLy8gUnVuIGFmdGVyIHBoeXNpY3MgYnV0IGJlZm9yZSByZW5kZXJpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgaW50ZXJwb2xhdGlvbiBmb3IgYWxsIGVudGl0aWVzIHdpdGggaW50ZXJwb2xhdGlvbiBidWZmZXJzXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbkJ1ZmZlciA9IGVudGl0eS5nZXRDb21wb25lbnQoSW50ZXJwb2xhdGlvbkJ1ZmZlcik7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuXG4gICAgICBpZiAoIXRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhaW50ZXJwb2xhdGlvbkJ1ZmZlcj8uZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBsb2NhbCBwbGF5ZXJzIChlbnRpdGllcyB0aGF0IGNhbiBtb3ZlKSAtIHRoZXkgc2hvdWxkIG5vdCBiZSBpbnRlcnBvbGF0ZWRcbiAgICAgIC8vIE9ubHkgcmVtb3RlIHBsYXllcnMgKGNhbk1vdmUgPSBmYWxzZSkgc2hvdWxkIHVzZSBpbnRlcnBvbGF0aW9uXG4gICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuY2FuTW92ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnRlcnBvbGF0ZUVudGl0eSh0cmFuc2Zvcm0sIGludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgaW50ZXJwb2xhdGlvbiAoY2FsbGVkIGR1cmluZyByZW5kZXIgcGhhc2UgZm9yIHNtb290aCB2aXN1YWxzKVxuICAgKi9cbiAgcHVibGljIHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRm9yIG5vdywgcmVuZGVyIGFuZCB1cGRhdGUgcGhhc2VzIGFyZSB0aGUgc2FtZSBmb3IgaW50ZXJwb2xhdGlvblxuICAgIC8vIEluIHRoZSBmdXR1cmUsIHdlIGNvdWxkIHNlcGFyYXRlIGNvbmNlcm5zIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlKGVudGl0aWVzLCBkZWx0YVRpbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVycG9sYXRlIGEgc2luZ2xlIGVudGl0eSdzIHRyYW5zZm9ybVxuICAgKi9cbiAgcHJpdmF0ZSBpbnRlcnBvbGF0ZUVudGl0eSh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgaW50ZXJwb2xhdGlvbkJ1ZmZlcjogSW50ZXJwb2xhdGlvbkJ1ZmZlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRlZFRyYW5zZm9ybSA9IGludGVycG9sYXRpb25CdWZmZXIuZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtKHRoaXMuY3VycmVudFRpbWUpO1xuXG4gICAgLy8gQXBwbHkgaW50ZXJwb2xhdGVkIHBvc2l0aW9uXG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkoaW50ZXJwb2xhdGVkVHJhbnNmb3JtLnBvc2l0aW9uKTtcblxuICAgIC8vIEFwcGx5IGludGVycG9sYXRlZCByb3RhdGlvblxuICAgIHRyYW5zZm9ybS5xdWF0ZXJuaW9uLmNvcHkoaW50ZXJwb2xhdGVkVHJhbnNmb3JtLnJvdGF0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNmb3JtJ3MgRXVsZXIgcm90YXRpb24gdG8gbWF0Y2ggdGhlIHF1YXRlcm5pb25cbiAgICB0cmFuc2Zvcm0ucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odHJhbnNmb3JtLnF1YXRlcm5pb24pO1xuXG4gICAgLy8gTWFyayBtYXRyaWNlcyBhcyBuZWVkaW5nIHVwZGF0ZVxuICAgIHRyYW5zZm9ybS5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHNlcnZlciBzdGF0ZSB0byBhbiBlbnRpdHkncyBpbnRlcnBvbGF0aW9uIGJ1ZmZlclxuICAgKi9cbiAgcHVibGljIGFkZFNlcnZlclN0YXRlKGVudGl0eTogRW50aXR5LCBwb3NpdGlvbjogVmVjdG9yMywgcm90YXRpb246IFF1YXRlcm5pb24sIHRpbWVzdGFtcD86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25CdWZmZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uQnVmZmVyKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uQnVmZmVyLmFkZFNlcnZlclN0YXRlKHBvc2l0aW9uLCByb3RhdGlvbiwgdGltZXN0YW1wKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGludGVycG9sYXRpb24gc3RhdGlzdGljcyBmb3IgZGVidWdnaW5nXG4gICAqL1xuICBwdWJsaWMgZ2V0SW50ZXJwb2xhdGlvblN0YXRzKGVudGl0eTogRW50aXR5KTogYW55IHtcbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uQnVmZmVyID0gZW50aXR5LmdldENvbXBvbmVudChJbnRlcnBvbGF0aW9uQnVmZmVyKTtcbiAgICBpZiAoaW50ZXJwb2xhdGlvbkJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGludGVycG9sYXRpb25CdWZmZXIuZ2V0QnVmZmVyU3RhdHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgaW50ZXJwb2xhdGlvbiBidWZmZXIgZm9yIGFuIGVudGl0eVxuICAgKi9cbiAgcHVibGljIGNsZWFySW50ZXJwb2xhdGlvbkJ1ZmZlcihlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25CdWZmZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEludGVycG9sYXRpb25CdWZmZXIpO1xuICAgIGlmIChpbnRlcnBvbGF0aW9uQnVmZmVyKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uQnVmZmVyLmNsZWFyQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcnBvbGF0aW9uIGRlbGF5IGZvciBhbGwgZW50aXRpZXMgKGluIG1pbGxpc2Vjb25kcylcbiAgICovXG4gIHB1YmxpYyBzZXRJbnRlcnBvbGF0aW9uRGVsYXkoZW50aXR5OiBFbnRpdHksIGRlbGF5TXM6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIE5vdGU6IFRoaXMgd291bGQgcmVxdWlyZSBtb2RpZnlpbmcgdGhlIEludGVycG9sYXRpb25CdWZmZXIgY29tcG9uZW50XG4gICAgLy8gRm9yIG5vdywgdGhlIGRlbGF5IGlzIGZpeGVkIGluIHRoZSBjb21wb25lbnQgaXRzZWxmXG4gICAgY29uc29sZS53YXJuKCdJbnRlcnBvbGF0aW9uIGRlbGF5IGlzIGN1cnJlbnRseSBmaXhlZCBpbiBJbnRlcnBvbGF0aW9uQnVmZmVyIGNvbXBvbmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCByZW5kZXIgdGltZSB1c2VkIGZvciBpbnRlcnBvbGF0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0Q3VycmVudFJlbmRlclRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZHZhbmNlZCBpbnRlcnBvbGF0aW9uIG1ldGhvZHMgZm9yIHNtb290aGVyIG1vdmVtZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBIZXJtaXRlIHNwbGluZSBpbnRlcnBvbGF0aW9uIGZvciBzbW9vdGhlciBjdXJ2ZXNcbiAgICogVGhpcyBwcm92aWRlcyBiZXR0ZXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGtleWZyYW1lcyBieSBjb25zaWRlcmluZyB2ZWxvY2l0eVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBoZXJtaXRlSW50ZXJwb2xhdGUoXG4gICAgcDA6IFZlY3RvcjMsIC8vIFN0YXJ0IHBvc2l0aW9uXG4gICAgcDE6IFZlY3RvcjMsIC8vIEVuZCBwb3NpdGlvblxuICAgIHYwOiBWZWN0b3IzLCAvLyBTdGFydCB2ZWxvY2l0eSAodGFuZ2VudClcbiAgICB2MTogVmVjdG9yMywgLy8gRW5kIHZlbG9jaXR5ICh0YW5nZW50KVxuICAgIHQ6IG51bWJlciAgIC8vIEludGVycG9sYXRpb24gZmFjdG9yIFswLDFdXG4gICk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgY29uc3QgdDMgPSB0MiAqIHQ7XG5cbiAgICAvLyBIZXJtaXRlIGJhc2lzIGZ1bmN0aW9uc1xuICAgIGNvbnN0IGgwMCA9IDIgKiB0MyAtIDMgKiB0MiArIDE7ICAgIC8vICgxICsgMnQpKDEgLSB0KV4yXG4gICAgY29uc3QgaDEwID0gdDMgLSAyICogdDIgKyB0OyAgICAgICAgLy8gdCgxIC0gdCleMlxuICAgIGNvbnN0IGgwMSA9IC0yICogdDMgKyAzICogdDI7ICAgICAgIC8vIHReMigzIC0gMnQpXG4gICAgY29uc3QgaDExID0gdDMgLSB0MjsgICAgICAgICAgICAgICAgLy8gdF4yKHQgLSAxKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAwLCBoMDApO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IodjAsIGgxMCk7XG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMSwgaDAxKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHYxLCBoMTEpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXRtdWxsLVJvbSBzcGxpbmUgaW50ZXJwb2xhdGlvbiBmb3Igc21vb3RoIGN1cnZlcyB0aHJvdWdoIHdheXBvaW50c1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgcDA6IFZlY3RvcjMsIC8vIFByZXZpb3VzIHBvaW50XG4gICAgcDE6IFZlY3RvcjMsIC8vIFN0YXJ0IHBvaW50XG4gICAgcDI6IFZlY3RvcjMsIC8vIEVuZCBwb2ludFxuICAgIHAzOiBWZWN0b3IzLCAvLyBOZXh0IHBvaW50XG4gICAgdDogbnVtYmVyICAgIC8vIEludGVycG9sYXRpb24gZmFjdG9yIFswLDFdXG4gICk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgY29uc3QgdDMgPSB0MiAqIHQ7XG5cbiAgICAvLyBDYXRtdWxsLVJvbSBiYXNpcyBmdW5jdGlvbnNcbiAgICBjb25zdCBjMDAgPSAtMC41ICogdDMgKyB0MiAtIDAuNSAqIHQ7XG4gICAgY29uc3QgYzEwID0gMS41ICogdDMgLSAyLjUgKiB0MiArIDE7XG4gICAgY29uc3QgYzIwID0gLTEuNSAqIHQzICsgMiAqIHQyICsgMC41ICogdDtcbiAgICBjb25zdCBjMzAgPSAwLjUgKiB0MyAtIDAuNSAqIHQyO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAwLCBjMDApO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IocDEsIGMxMCk7XG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMiwgYzIwKTtcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAzLCBjMzApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBCZXppZXIgaW50ZXJwb2xhdGlvbiBmb3Igc21vb3RoIGN1cnZlcyB3aXRoIGNvbnRyb2wgcG9pbnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGJlemllckludGVycG9sYXRlKFxuICAgIHAwOiBWZWN0b3IzLCAvLyBTdGFydCBwb2ludFxuICAgIHAxOiBWZWN0b3IzLCAvLyBDb250cm9sIHBvaW50IDFcbiAgICBwMjogVmVjdG9yMywgLy8gQ29udHJvbCBwb2ludCAyXG4gICAgcDM6IFZlY3RvcjMsIC8vIEVuZCBwb2ludFxuICAgIHQ6IG51bWJlciAgICAvLyBJbnRlcnBvbGF0aW9uIGZhY3RvciBbMCwxXVxuICApOiBWZWN0b3IzIHtcbiAgICBjb25zdCB1ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB1dSA9IHUgKiB1O1xuICAgIGNvbnN0IHV1dSA9IHV1ICogdTtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIHJlc3VsdC5hZGRTY2FsZWRWZWN0b3IocDAsIHV1dSk7ICAgICAgLy8gKDEtdCleMyAqIHAwXG4gICAgcmVzdWx0LmFkZFNjYWxlZFZlY3RvcihwMSwgMyAqIHV1ICogdCk7IC8vIDMqKDEtdCleMip0ICogcDFcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAyLCAzICogdSAqIHR0KTsgIC8vIDMqKDEtdCkqdF4yICogcDJcbiAgICByZXN1bHQuYWRkU2NhbGVkVmVjdG9yKHAzLCB0dHQpOyAgICAgICAvLyB0XjMgKiBwM1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTbW9vdGggc3RlcCBpbnRlcnBvbGF0aW9uIGZvciBlYXNpbmdcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc21vb3RoU3RlcEludGVycG9sYXRlKHN0YXJ0OiBWZWN0b3IzLCBlbmQ6IFZlY3RvcjMsIHQ6IG51bWJlcik6IFZlY3RvcjMge1xuICAgIC8vIFNtb290aHN0ZXAgZnVuY3Rpb246IDN0XjIgLSAydF4zXG4gICAgY29uc3Qgc21vb3RoVCA9IHQgKiB0ICogKDMgLSAyICogdCk7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCkubGVycFZlY3RvcnMoc3RhcnQsIGVuZCwgc21vb3RoVCk7XG4gIH1cblxuICAvKipcbiAgICogU21vb3RoZXIgc3RlcCBpbnRlcnBvbGF0aW9uIGZvciBldmVuIHNtb290aGVyIGVhc2luZ1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzbW9vdGhlclN0ZXBJbnRlcnBvbGF0ZShzdGFydDogVmVjdG9yMywgZW5kOiBWZWN0b3IzLCB0OiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICAvLyBTbW9vdGhlcnN0ZXAgZnVuY3Rpb246IDZ0XjUgLSAxNXReNCArIDEwdF4zXG4gICAgY29uc3Qgc21vb3RoVCA9IHQgKiB0ICogdCAqICh0ICogKDYgKiB0IC0gMTUpICsgMTApO1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygpLmxlcnBWZWN0b3JzKHN0YXJ0LCBlbmQsIHNtb290aFQpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkludGVycG9sYXRpb25CdWZmZXIiLCJNb3ZlbWVudCIsIkludGVycG9sYXRpb25TeXN0ZW0iLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImN1cnJlbnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJpbnRlcnBvbGF0aW9uQnVmZmVyIiwibW92ZW1lbnQiLCJlbmFibGVkIiwiY2FuTW92ZSIsImludGVycG9sYXRlRW50aXR5IiwicmVuZGVyIiwiaW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwiZ2V0SW50ZXJwb2xhdGVkVHJhbnNmb3JtIiwicG9zaXRpb24iLCJjb3B5IiwicXVhdGVybmlvbiIsInJvdGF0aW9uIiwic2V0RnJvbVF1YXRlcm5pb24iLCJtYXRyaXhOZWVkc1VwZGF0ZSIsImFkZFNlcnZlclN0YXRlIiwidGltZXN0YW1wIiwiZ2V0SW50ZXJwb2xhdGlvblN0YXRzIiwiZ2V0QnVmZmVyU3RhdHMiLCJjbGVhckludGVycG9sYXRpb25CdWZmZXIiLCJjbGVhckJ1ZmZlciIsInNldEludGVycG9sYXRpb25EZWxheSIsImRlbGF5TXMiLCJjb25zb2xlIiwid2FybiIsImdldEN1cnJlbnRSZW5kZXJUaW1lIiwiaGVybWl0ZUludGVycG9sYXRlIiwicDAiLCJwMSIsInYwIiwidjEiLCJ0IiwidDIiLCJ0MyIsImgwMCIsImgxMCIsImgwMSIsImgxMSIsInJlc3VsdCIsImFkZFNjYWxlZFZlY3RvciIsImNhdG11bGxSb21JbnRlcnBvbGF0ZSIsInAyIiwicDMiLCJjMDAiLCJjMTAiLCJjMjAiLCJjMzAiLCJiZXppZXJJbnRlcnBvbGF0ZSIsInUiLCJ0dCIsInV1IiwidXV1IiwidHR0Iiwic21vb3RoU3RlcEludGVycG9sYXRlIiwic3RhcnQiLCJlbmQiLCJzbW9vdGhUIiwibGVycFZlY3RvcnMiLCJzbW9vdGhlclN0ZXBJbnRlcnBvbGF0ZSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/InterpolationSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/PhysicsSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/PhysicsSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Physics system for handling movement physics\n\n\n\n\nclass PhysicsSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for variable timestep updates\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            // Update debuff states (frozen, slowed, etc.)\n            if (typeof movement.updateDebuffs === \"function\") {\n                movement.updateDebuffs();\n            } else {\n            // console.warn('⚠️ Movement component missing updateDebuffs method:', movement);\n            }\n            this.updateMovement(transform, movement, deltaTime);\n        }\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            this.applyPhysics(transform, movement, fixedDeltaTime);\n        }\n    }\n    updateMovement(transform, movement, deltaTime) {\n        // Update position based on velocity\n        const deltaPosition = movement.velocity.clone().multiplyScalar(deltaTime);\n        // Calculate potential new position\n        const currentPosition = transform.position.clone();\n        const potentialPosition = currentPosition.clone().add(deltaPosition);\n        // Apply map boundary constraints with smooth sliding (radius of 29 units from origin)\n        const MAP_RADIUS = 29;\n        // Only check horizontal distance (ignore Y for boundary)\n        const horizontalPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(potentialPosition.x, 0, potentialPosition.z);\n        const distanceFromCenter = horizontalPosition.length();\n        // Check for pillar collisions first\n        const pillarCollision = this.checkPillarCollision(potentialPosition);\n        if (distanceFromCenter >= MAP_RADIUS) {\n            // If we hit the boundary, calculate tangent movement for smooth sliding\n            const currentHorizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(currentPosition.x, 0, currentPosition.z);\n            const toCenter = currentHorizontalPos.clone().normalize();\n            // Create tangent vector (perpendicular to radius)\n            const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-toCenter.z, 0, toCenter.x);\n            // Project our horizontal movement onto the tangent\n            const horizontalMovement = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(deltaPosition.x, 0, deltaPosition.z);\n            const tangentMovement = tangent.multiplyScalar(horizontalMovement.dot(tangent));\n            // Apply the tangential movement while keeping distance to center constant\n            const newHorizontalPosition = currentHorizontalPos.add(tangentMovement);\n            newHorizontalPosition.normalize().multiplyScalar(MAP_RADIUS);\n            // Update position with tangent movement and preserve Y movement\n            transform.setPosition(newHorizontalPosition.x, currentPosition.y + deltaPosition.y, newHorizontalPosition.z);\n        } else if (pillarCollision.hasCollision) {\n            // Handle pillar collision with smooth sliding\n            const slidePosition = this.calculatePillarSliding(currentPosition, deltaPosition, pillarCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the pillar to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(pillarCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else {\n            // If within bounds and no pillar collision, move normally\n            transform.translate(deltaPosition.x, deltaPosition.y, deltaPosition.z);\n        }\n        // Mark transform matrix as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    calculatePillarSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from pillar center\n        const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.pillarCenter.x, 0, collision.pillarCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(pillarHorizontal);\n        if (distanceAfterSlide < this.PILLAR_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(pillarHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = pillarHorizontal.clone().add(pushDirection.multiplyScalar(this.PILLAR_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    applyPhysics(transform, movement, deltaTime) {\n        // Apply gravity (only affects Y velocity)\n        movement.applyGravity(deltaTime);\n        // Handle horizontal movement directly for immediate response\n        if (movement.inputStrength > 0) {\n            // Use effective max speed which accounts for frozen/slowed states\n            const effectiveMaxSpeed = movement.getEffectiveMaxSpeed();\n            // Direct velocity setting for responsive movement\n            const targetVelocity = movement.moveDirection.clone();\n            targetVelocity.multiplyScalar(effectiveMaxSpeed * movement.inputStrength);\n            // Set horizontal velocity directly (preserve Y velocity for gravity/jumping)\n            movement.velocity.x = targetVelocity.x;\n            movement.velocity.z = targetVelocity.z;\n        } else {\n            // No input - stop horizontal movement immediately for responsive controls\n            movement.velocity.x = 0;\n            movement.velocity.z = 0;\n        }\n        // Apply any additional forces (like knockback, wind, etc.)\n        movement.velocity.add(movement.acceleration.clone().multiplyScalar(deltaTime));\n        // Reset acceleration for next frame\n        movement.acceleration.set(0, 0, 0);\n        // Simple ground check (Y = 0 is ground level, account for sphere radius)\n        const sphereRadius = 0.5; // Player sphere radius\n        const groundLevel = sphereRadius; // Sphere center should be at radius height above ground\n        if (transform.position.y <= groundLevel && movement.velocity.y <= 0) {\n            transform.position.y = groundLevel;\n            movement.velocity.y = 0;\n            movement.isGrounded = true;\n        } else {\n            movement.isGrounded = false;\n        }\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        this.priority = 15; // Run after control system but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrQ0FBK0M7QUFDQztBQUNrQjtBQUVYO0FBQ0Y7QUFFOUMsTUFBTUMsc0JBQXNCQyxzREFBaUJBO0lBUTNDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELHNEQUFzRDtRQUN0RCxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsV0FBV0gsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ0ssYUFBYSxDQUFDRSxVQUFVO2dCQUMzQjtZQUNGO1lBRUEsSUFBSSxDQUFDRixVQUFVRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxJQUFJLENBQUNELFNBQVNFLE9BQU8sRUFBRTtnQkFDaEU7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLE9BQU9GLFNBQVNHLGFBQWEsS0FBSyxZQUFZO2dCQUNoREgsU0FBU0csYUFBYTtZQUN4QixPQUFPO1lBQ0wsaUZBQWlGO1lBQ25GO1lBRUEsSUFBSSxDQUFDQyxjQUFjLENBQUNOLFdBQVdFLFVBQVVKO1FBQzNDO0lBQ0Y7SUFFT1MsWUFBWVYsUUFBa0IsRUFBRVcsY0FBc0IsRUFBUTtRQUNuRSwwQ0FBMEM7UUFDMUMsS0FBSyxNQUFNVCxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBQy9DLE1BQU1RLFdBQVdILE9BQU9FLFlBQVksQ0FBQ04sOERBQVFBO1lBRTdDLDBDQUEwQztZQUMxQyxJQUFJLENBQUNLLGFBQWEsQ0FBQ0UsVUFBVTtnQkFDM0I7WUFDRjtZQUVBLElBQUksQ0FBQ0YsVUFBVUcsT0FBTyxJQUFJLENBQUNELFNBQVNDLE9BQU8sSUFBSSxDQUFDRCxTQUFTRSxPQUFPLEVB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QixTQUFTUyxRQUFRLENBQUNVLENBQUMsR0FBRztRQUN4QjtRQUVBLDJEQUEyRDtRQUMzRG5CLFNBQVNTLFFBQVEsQ0FBQ00sR0FBRyxDQUFDZixTQUFTK0QsWUFBWSxDQUFDckQsS0FBSyxHQUFHQyxjQUFjLENBQUNmO1FBRW5FLG9DQUFvQztRQUNwQ0ksU0FBUytELFlBQVksQ0FBQ2IsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUVoQyx5RUFBeUU7UUFDekUsTUFBTWMsZUFBZSxLQUFLLHVCQUF1QjtRQUNqRCxNQUFNQyxjQUFjRCxjQUFjLHdEQUF3RDtRQUUxRixJQUFJbEUsVUFBVWUsUUFBUSxDQUFDb0IsQ0FBQyxJQUFJZ0MsZUFBZWpFLFNBQVNTLFFBQVEsQ0FBQ3dCLENBQUMsSUFBSSxHQUFHO1lBQ25FbkMsVUFBVWUsUUFBUSxDQUFDb0IsQ0FBQyxHQUFHZ0M7WUFDdkJqRSxTQUFTUyxRQUFRLENBQUN3QixDQUFDLEdBQUc7WUFDdEJqQyxTQUFTa0UsVUFBVSxHQUFHO1FBQ3hCLE9BQU87WUFDTGxFLFNBQVNrRSxVQUFVLEdBQUc7UUFDeEI7SUFDRjtJQWhOQUMsYUFBYztRQUNaLEtBQUs7YUFIU0MscUJBQXFCO1lBQUM1RSxnRUFBU0E7WUFBRUMsOERBQVFBO1NBQUM7UUE2RzFELHVEQUF1RDthQUN0Q21ELG1CQUFtQjtZQUNsQyxJQUFJdkQseURBQU9BLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDbkIsSUFBSUEseURBQU9BLENBQUMsQ0FBQyxNQUFNLEdBQUc7WUFDdEIsSUFBSUEseURBQU9BLENBQUMsTUFBTSxHQUFHLEtBQVMsZUFBZTtTQUM5QzthQUNnQjRELGdCQUFnQixJQUFLLDhCQUE4Qjs7UUEvR2xFLElBQUksQ0FBQ29CLFFBQVEsR0FBRyxJQUFJLGdEQUFnRDtJQUN0RTtBQThNRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9QaHlzaWNzU3lzdGVtLnRzPzBjZDYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGh5c2ljcyBzeXN0ZW0gZm9yIGhhbmRsaW5nIG1vdmVtZW50IHBoeXNpY3NcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUGh5c2ljc1N5c3RlbSBhcyBCYXNlUGh5c2ljc1N5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgTW92ZW1lbnQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL01vdmVtZW50JztcblxuZXhwb3J0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBCYXNlUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBNb3ZlbWVudF07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTU7IC8vIFJ1biBhZnRlciBjb250cm9sIHN5c3RlbSBidXQgYmVmb3JlIHJlbmRlcmluZ1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB2YXJpYWJsZSB0aW1lc3RlcCB1cGRhdGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG5cbiAgICAgIC8vIFNraXAgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbWlzc2luZ1xuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIW1vdmVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFtb3ZlbWVudC5lbmFibGVkIHx8ICFtb3ZlbWVudC5jYW5Nb3ZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgZGVidWZmIHN0YXRlcyAoZnJvemVuLCBzbG93ZWQsIGV0Yy4pXG4gICAgICBpZiAodHlwZW9mIG1vdmVtZW50LnVwZGF0ZURlYnVmZnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbW92ZW1lbnQudXBkYXRlRGVidWZmcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gTW92ZW1lbnQgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlRGVidWZmcyBtZXRob2Q6JywgbW92ZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZU1vdmVtZW50KHRyYW5zZm9ybSwgbW92ZW1lbnQsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGZpeGVkVXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZml4ZWREZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRoaXMgcnVucyBhdCBmaXhlZCB0aW1lc3RlcCBmb3IgcGh5c2ljc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBtb3ZlbWVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHJlcXVpcmVkIGNvbXBvbmVudHMgYXJlIG1pc3NpbmdcbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICFtb3ZlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhbW92ZW1lbnQuZW5hYmxlZCB8fCAhbW92ZW1lbnQuY2FuTW92ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBseVBoeXNpY3ModHJhbnNmb3JtLCBtb3ZlbWVudCwgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTW92ZW1lbnQodHJhbnNmb3JtOiBUcmFuc2Zvcm0sIG1vdmVtZW50OiBNb3ZlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgcG9zaXRpb24gYmFzZWQgb24gdmVsb2NpdHlcbiAgICBjb25zdCBkZWx0YVBvc2l0aW9uID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwb3RlbnRpYWwgbmV3IHBvc2l0aW9uXG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgY29uc3QgcG90ZW50aWFsUG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb24uY2xvbmUoKS5hZGQoZGVsdGFQb3NpdGlvbik7XG4gICAgXG4gICAgLy8gQXBwbHkgbWFwIGJvdW5kYXJ5IGNvbnN0cmFpbnRzIHdpdGggc21vb3RoIHNsaWRpbmcgKHJhZGl1cyBvZiAyOSB1bml0cyBmcm9tIG9yaWdpbilcbiAgICBjb25zdCBNQVBfUkFESVVTID0gMjk7XG4gICAgXG4gICAgLy8gT25seSBjaGVjayBob3Jpem9udGFsIGRpc3RhbmNlIChpZ25vcmUgWSBmb3IgYm91bmRhcnkpXG4gICAgY29uc3QgaG9yaXpvbnRhbFBvc2l0aW9uID0gbmV3IFZlY3RvcjMocG90ZW50aWFsUG9zaXRpb24ueCwgMCwgcG90ZW50aWFsUG9zaXRpb24ueik7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tQ2VudGVyID0gaG9yaXpvbnRhbFBvc2l0aW9uLmxlbmd0aCgpO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBwaWxsYXIgY29sbGlzaW9ucyBmaXJzdFxuICAgIGNvbnN0IHBpbGxhckNvbGxpc2lvbiA9IHRoaXMuY2hlY2tQaWxsYXJDb2xsaXNpb24ocG90ZW50aWFsUG9zaXRpb24pO1xuICAgIFxuICAgIGlmIChkaXN0YW5jZUZyb21DZW50ZXIgPj0gTUFQX1JBRElVUykge1xuICAgICAgLy8gSWYgd2UgaGl0IHRoZSBib3VuZGFyeSwgY2FsY3VsYXRlIHRhbmdlbnQgbW92ZW1lbnQgZm9yIHNtb290aCBzbGlkaW5nXG4gICAgICBjb25zdCBjdXJyZW50SG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKGN1cnJlbnRQb3NpdGlvbi54LCAwLCBjdXJyZW50UG9zaXRpb24ueik7XG4gICAgICBjb25zdCB0b0NlbnRlciA9IGN1cnJlbnRIb3Jpem9udGFsUG9zLmNsb25lKCkubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0YW5nZW50IHZlY3RvciAocGVycGVuZGljdWxhciB0byByYWRpdXMpXG4gICAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLXRvQ2VudGVyLnosIDAsIHRvQ2VudGVyLngpO1xuICAgICAgXG4gICAgICAvLyBQcm9qZWN0IG91ciBob3Jpem9udGFsIG1vdmVtZW50IG9udG8gdGhlIHRhbmdlbnRcbiAgICAgIGNvbnN0IGhvcml6b250YWxNb3ZlbWVudCA9IG5ldyBWZWN0b3IzKGRlbHRhUG9zaXRpb24ueCwgMCwgZGVsdGFQb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHRhbmdlbnRNb3ZlbWVudCA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIoaG9yaXpvbnRhbE1vdmVtZW50LmRvdCh0YW5nZW50KSk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHRoZSB0YW5nZW50aWFsIG1vdmVtZW50IHdoaWxlIGtlZXBpbmcgZGlzdGFuY2UgdG8gY2VudGVyIGNvbnN0YW50XG4gICAgICBjb25zdCBuZXdIb3Jpem9udGFsUG9zaXRpb24gPSBjdXJyZW50SG9yaXpvbnRhbFBvcy5hZGQodGFuZ2VudE1vdmVtZW50KTtcbiAgICAgIG5ld0hvcml6b250YWxQb3NpdGlvbi5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihNQVBfUkFESVVTKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIHdpdGggdGFuZ2VudCBtb3ZlbWVudCBhbmQgcHJlc2VydmUgWSBtb3ZlbWVudFxuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKFxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24ueCwgXG4gICAgICAgIGN1cnJlbnRQb3NpdGlvbi55ICsgZGVsdGFQb3NpdGlvbi55LCAvLyBBbGxvdyB2ZXJ0aWNhbCBtb3ZlbWVudCAoanVtcGluZywgZmFsbGluZylcbiAgICAgICAgbmV3SG9yaXpvbnRhbFBvc2l0aW9uLnpcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwaWxsYXJDb2xsaXNpb24uaGFzQ29sbGlzaW9uKSB7XG4gICAgICAvLyBIYW5kbGUgcGlsbGFyIGNvbGxpc2lvbiB3aXRoIHNtb290aCBzbGlkaW5nXG4gICAgICBjb25zdCBzbGlkZVBvc2l0aW9uID0gdGhpcy5jYWxjdWxhdGVQaWxsYXJTbGlkaW5nKGN1cnJlbnRQb3NpdGlvbiwgZGVsdGFQb3NpdGlvbiwgcGlsbGFyQ29sbGlzaW9uKTtcbiAgICAgIHRyYW5zZm9ybS5zZXRQb3NpdGlvbihzbGlkZVBvc2l0aW9uLngsIHNsaWRlUG9zaXRpb24ueSwgc2xpZGVQb3NpdGlvbi56KTtcbiAgICAgIFxuICAgICAgLy8gUmVkdWNlIHZlbG9jaXR5IGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHBpbGxhciB0byBwcmV2ZW50IGJvdW5jaW5nXG4gICAgICBjb25zdCB2ZWxvY2l0eU5vcm1hbENvbXBvbmVudCA9IG1vdmVtZW50LnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHBpbGxhckNvbGxpc2lvbi5ub3JtYWwpO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkuc3ViKHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50Lm11bHRpcGx5U2NhbGFyKDAuNSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3aXRoaW4gYm91bmRzIGFuZCBubyBwaWxsYXIgY29sbGlzaW9uLCBtb3ZlIG5vcm1hbGx5XG4gICAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKGRlbHRhUG9zaXRpb24ueCwgZGVsdGFQb3NpdGlvbi55LCBkZWx0YVBvc2l0aW9uLnopO1xuICAgIH1cblxuICAgIC8vIE1hcmsgdHJhbnNmb3JtIG1hdHJpeCBhcyBuZWVkaW5nIHVwZGF0ZVxuICAgIHRyYW5zZm9ybS5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICAvLyBEZWZpbmUgcGlsbGFyIHBvc2l0aW9ucyAoc2FtZSBhcyBpbiBFbnZpcm9ubWVudC50c3gpXG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1BPU0lUSU9OUyA9IFtcbiAgICBuZXcgVmVjdG9yMygwLCAwLCAtNSksICAgICAgICAvLyBGcm9udCBwaWxsYXJcbiAgICBuZXcgVmVjdG9yMygtNC4yNSwgMCwgMi41KSwgICAvLyBMZWZ0IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKDQuMjUsIDAsIDIuNSkgICAgIC8vIFJpZ2h0IHBpbGxhclxuICBdO1xuICBwcml2YXRlIHJlYWRvbmx5IFBJTExBUl9SQURJVVMgPSAwLjc7IC8vIFNhbWUgYXMgUGlsbGFyQ29sbGlzaW9uLnRzeFxuXG4gIHByaXZhdGUgY2hlY2tQaWxsYXJDb2xsaXNpb24ocG9zaXRpb246IFZlY3RvcjMpOiB7IGhhc0NvbGxpc2lvbjogYm9vbGVhbjsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSB7XG4gICAgZm9yIChjb25zdCBwaWxsYXJQb3Mgb2YgdGhpcy5QSUxMQVJfUE9TSVRJT05TKSB7XG4gICAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbFBvcyA9IG5ldyBWZWN0b3IzKHBvc2l0aW9uLngsIDAsIHBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKHBpbGxhclBvcy54LCAwLCBwaWxsYXJQb3Mueik7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGhvcml6b250YWxQb3MuZGlzdGFuY2VUbyhwaWxsYXJIb3Jpem9udGFsKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDwgdGhpcy5QSUxMQVJfUkFESVVTKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBub3JtYWwgdmVjdG9yIHBvaW50aW5nIGF3YXkgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGhvcml6b250YWxQb3MuY2xvbmUoKS5zdWIocGlsbGFySG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZXJlIHBsYXllciBpcyBleGFjdGx5IGF0IHBpbGxhciBjZW50ZXJcbiAgICAgICAgaWYgKG5vcm1hbC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICAgIG5vcm1hbC5zZXQoMSwgMCwgMCk7IC8vIERlZmF1bHQgZGlyZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNDb2xsaXNpb246IHRydWUsXG4gICAgICAgICAgbm9ybWFsOiBub3JtYWwsXG4gICAgICAgICAgcGlsbGFyQ2VudGVyOiBwaWxsYXJQb3MuY2xvbmUoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBoYXNDb2xsaXNpb246IGZhbHNlLCBub3JtYWw6IG5ldyBWZWN0b3IzKCksIHBpbGxhckNlbnRlcjogbmV3IFZlY3RvcjMoKSB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVQaWxsYXJTbGlkaW5nKGN1cnJlbnRQb3NpdGlvbjogVmVjdG9yMywgZGVsdGFQb3NpdGlvbjogVmVjdG9yMywgY29sbGlzaW9uOiB7IG5vcm1hbDogVmVjdG9yMzsgcGlsbGFyQ2VudGVyOiBWZWN0b3IzIH0pOiBWZWN0b3IzIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIG5vcm1hbCBpbiBYWiBwbGFuZSlcbiAgICBjb25zdCB0YW5nZW50ID0gbmV3IFZlY3RvcjMoLWNvbGxpc2lvbi5ub3JtYWwueiwgMCwgY29sbGlzaW9uLm5vcm1hbC54KTtcbiAgICBcbiAgICAvLyBQcm9qZWN0IHRoZSBtb3ZlbWVudCB2ZWN0b3Igb250byB0aGUgdGFuZ2VudCBmb3Igc2xpZGluZ1xuICAgIGNvbnN0IHRhbmdlbnRNb3ZlbWVudCA9IGRlbHRhUG9zaXRpb24uY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IodGFuZ2VudCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgcG9zaXRpb24gd2l0aCBzbGlkaW5nIG1vdmVtZW50XG4gICAgY29uc3Qgc2xpZGVQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0YW5nZW50TW92ZW1lbnQpO1xuICAgIFxuICAgIC8vIEVuc3VyZSB3ZSBtYWludGFpbiBtaW5pbXVtIGRpc3RhbmNlIGZyb20gcGlsbGFyIGNlbnRlclxuICAgIGNvbnN0IHBpbGxhckhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhjb2xsaXNpb24ucGlsbGFyQ2VudGVyLngsIDAsIGNvbGxpc2lvbi5waWxsYXJDZW50ZXIueik7XG4gICAgY29uc3Qgc2xpZGVIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMoc2xpZGVQb3NpdGlvbi54LCAwLCBzbGlkZVBvc2l0aW9uLnopO1xuICAgIGNvbnN0IGRpc3RhbmNlQWZ0ZXJTbGlkZSA9IHNsaWRlSG9yaXpvbnRhbC5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgIFxuICAgIGlmIChkaXN0YW5jZUFmdGVyU2xpZGUgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgIC8vIFB1c2ggdGhlIHBvc2l0aW9uIHRvIG1haW50YWluIG1pbmltdW0gZGlzdGFuY2VcbiAgICAgIGNvbnN0IHB1c2hEaXJlY3Rpb24gPSBzbGlkZUhvcml6b250YWwuY2xvbmUoKS5zdWIocGlsbGFySG9yaXpvbnRhbCkubm9ybWFsaXplKCk7XG4gICAgICBpZiAocHVzaERpcmVjdGlvbi5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICBwdXNoRGlyZWN0aW9uLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvcnJlY3RlZEhvcml6b250YWwgPSBwaWxsYXJIb3Jpem9udGFsLmNsb25lKCkuYWRkKHB1c2hEaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIodGhpcy5QSUxMQVJfUkFESVVTKSk7XG4gICAgICBzbGlkZVBvc2l0aW9uLnggPSBjb3JyZWN0ZWRIb3Jpem9udGFsLng7XG4gICAgICBzbGlkZVBvc2l0aW9uLnogPSBjb3JyZWN0ZWRIb3Jpem9udGFsLno7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzbGlkZVBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBhcHBseVBoeXNpY3ModHJhbnNmb3JtOiBUcmFuc2Zvcm0sIG1vdmVtZW50OiBNb3ZlbWVudCwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBBcHBseSBncmF2aXR5IChvbmx5IGFmZmVjdHMgWSB2ZWxvY2l0eSlcbiAgICBtb3ZlbWVudC5hcHBseUdyYXZpdHkoZGVsdGFUaW1lKTtcblxuICAgIC8vIEhhbmRsZSBob3Jpem9udGFsIG1vdmVtZW50IGRpcmVjdGx5IGZvciBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICBpZiAobW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDApIHtcbiAgICAgIC8vIFVzZSBlZmZlY3RpdmUgbWF4IHNwZWVkIHdoaWNoIGFjY291bnRzIGZvciBmcm96ZW4vc2xvd2VkIHN0YXRlc1xuICAgICAgY29uc3QgZWZmZWN0aXZlTWF4U3BlZWQgPSBtb3ZlbWVudC5nZXRFZmZlY3RpdmVNYXhTcGVlZCgpO1xuICAgICAgXG4gICAgICAvLyBEaXJlY3QgdmVsb2NpdHkgc2V0dGluZyBmb3IgcmVzcG9uc2l2ZSBtb3ZlbWVudFxuICAgICAgY29uc3QgdGFyZ2V0VmVsb2NpdHkgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uLmNsb25lKCk7XG4gICAgICB0YXJnZXRWZWxvY2l0eS5tdWx0aXBseVNjYWxhcihlZmZlY3RpdmVNYXhTcGVlZCAqIG1vdmVtZW50LmlucHV0U3RyZW5ndGgpO1xuICAgICAgXG4gICAgICAvLyBTZXQgaG9yaXpvbnRhbCB2ZWxvY2l0eSBkaXJlY3RseSAocHJlc2VydmUgWSB2ZWxvY2l0eSBmb3IgZ3Jhdml0eS9qdW1waW5nKVxuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueCA9IHRhcmdldFZlbG9jaXR5Lng7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS56ID0gdGFyZ2V0VmVsb2NpdHkuejtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gaW5wdXQgLSBzdG9wIGhvcml6b250YWwgbW92ZW1lbnQgaW1tZWRpYXRlbHkgZm9yIHJlc3BvbnNpdmUgY29udHJvbHNcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnggPSAwO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueiA9IDA7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgYW55IGFkZGl0aW9uYWwgZm9yY2VzIChsaWtlIGtub2NrYmFjaywgd2luZCwgZXRjLilcbiAgICBtb3ZlbWVudC52ZWxvY2l0eS5hZGQobW92ZW1lbnQuYWNjZWxlcmF0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGVsdGFUaW1lKSk7XG5cbiAgICAvLyBSZXNldCBhY2NlbGVyYXRpb24gZm9yIG5leHQgZnJhbWVcbiAgICBtb3ZlbWVudC5hY2NlbGVyYXRpb24uc2V0KDAsIDAsIDApO1xuXG4gICAgLy8gU2ltcGxlIGdyb3VuZCBjaGVjayAoWSA9IDAgaXMgZ3JvdW5kIGxldmVsLCBhY2NvdW50IGZvciBzcGhlcmUgcmFkaXVzKVxuICAgIGNvbnN0IHNwaGVyZVJhZGl1cyA9IDAuNTsgLy8gUGxheWVyIHNwaGVyZSByYWRpdXNcbiAgICBjb25zdCBncm91bmRMZXZlbCA9IHNwaGVyZVJhZGl1czsgLy8gU3BoZXJlIGNlbnRlciBzaG91bGQgYmUgYXQgcmFkaXVzIGhlaWdodCBhYm92ZSBncm91bmRcbiAgICBcbiAgICBpZiAodHJhbnNmb3JtLnBvc2l0aW9uLnkgPD0gZ3JvdW5kTGV2ZWwgJiYgbW92ZW1lbnQudmVsb2NpdHkueSA8PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueSA9IGdyb3VuZExldmVsO1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueSA9IDA7XG4gICAgICBtb3ZlbWVudC5pc0dyb3VuZGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZW1lbnQuaXNHcm91bmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJQaHlzaWNzU3lzdGVtIiwiQmFzZVBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwiZW50aXR5IiwidHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwibW92ZW1lbnQiLCJlbmFibGVkIiwiY2FuTW92ZSIsInVwZGF0ZURlYnVmZnMiLCJ1cGRhdGVNb3ZlbWVudCIsImZpeGVkVXBkYXRlIiwiZml4ZWREZWx0YVRpbWUiLCJhcHBseVBoeXNpY3MiLCJkZWx0YVBvc2l0aW9uIiwidmVsb2NpdHkiLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwiY3VycmVudFBvc2l0aW9uIiwicG9zaXRpb24iLCJwb3RlbnRpYWxQb3NpdGlvbiIsImFkZCIsIk1BUF9SQURJVVMiLCJob3Jpem9udGFsUG9zaXRpb24iLCJ4IiwieiIsImRpc3RhbmNlRnJvbUNlbnRlciIsImxlbmd0aCIsInBpbGxhckNvbGxpc2lvbiIsImNoZWNrUGlsbGFyQ29sbGlzaW9uIiwiY3VycmVudEhvcml6b250YWxQb3MiLCJ0b0NlbnRlciIsIm5vcm1hbGl6ZSIsInRhbmdlbnQiLCJob3Jpem9udGFsTW92ZW1lbnQiLCJ0YW5nZW50TW92ZW1lbnQiLCJkb3QiLCJuZXdIb3Jpem9udGFsUG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsInkiLCJoYXNDb2xsaXNpb24iLCJzbGlkZVBvc2l0aW9uIiwiY2FsY3VsYXRlUGlsbGFyU2xpZGluZyIsInZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50IiwicHJvamVjdE9uVmVjdG9yIiwibm9ybWFsIiwic3ViIiwidHJhbnNsYXRlIiwibWF0cml4TmVlZHNVcGRhdGUiLCJwaWxsYXJQb3MiLCJQSUxMQVJfUE9TSVRJT05TIiwiaG9yaXpvbnRhbFBvcyIsInBpbGxhckhvcml6b250YWwiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJQSUxMQVJfUkFESVVTIiwic2V0IiwicGlsbGFyQ2VudGVyIiwiY29sbGlzaW9uIiwic2xpZGVIb3Jpem9udGFsIiwiZGlzdGFuY2VBZnRlclNsaWRlIiwicHVzaERpcmVjdGlvbiIsImNvcnJlY3RlZEhvcml6b250YWwiLCJhcHBseUdyYXZpdHkiLCJpbnB1dFN0cmVuZ3RoIiwiZWZmZWN0aXZlTWF4U3BlZWQiLCJnZXRFZmZlY3RpdmVNYXhTcGVlZCIsInRhcmdldFZlbG9jaXR5IiwibW92ZURpcmVjdGlvbiIsImFjY2VsZXJhdGlvbiIsInNwaGVyZVJhZGl1cyIsImdyb3VuZExldmVsIiwiaXNHcm91bmRlZCIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/PhysicsSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ProjectileSystem.ts":
/*!*****************************************!*\
  !*** ./src/systems/ProjectileSystem.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectileSystem: function() { return /* binding */ ProjectileSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Projectile system for handling projectile movement and collisions\n\n\n\n\n\n\n\n\nclass ProjectileSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    update(entities, deltaTime) {\n        this.projectilesToDestroy.length = 0;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n            if (!transform.enabled || !projectile.enabled) {\n                continue;\n            }\n            // Update projectile\n            projectile.update(deltaTime);\n            // Check if projectile has expired\n            if (projectile.isExpired()) {\n                this.projectilesToDestroy.push(entity.id);\n                continue;\n            }\n            // Move projectile\n            this.moveProjectile(transform, projectile, deltaTime);\n            // Update homing direction if projectile is homing\n            this.updateHomingDirection(entity, projectile, deltaTime);\n            // Arrow orientation is set once at creation - no need to update every frame\n            // this.updateArrowOrientation(entity, projectile);\n            // Check collisions\n            this.checkCollisions(entity, transform, projectile);\n            // Check world boundaries\n            this.checkWorldBounds(entity, transform);\n        }\n        // Destroy expired projectiles\n        for (const entityId of this.projectilesToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    moveProjectile(transform, projectile, deltaTime) {\n        // Use temp vector to avoid allocations\n        this.tempVector.copy(projectile.velocity).multiplyScalar(deltaTime);\n        // Update position\n        transform.translate(this.tempVector.x, this.tempVector.y, this.tempVector.z);\n        transform.matrixNeedsUpdate = true;\n    }\n    updateHomingDirection(projectileEntity, projectile, deltaTime) {\n        // Skip if not homing\n        if (!projectile.targetEntityId || projectile.homingStrength <= 0) {\n            return;\n        }\n        // Get target entity\n        const targetEntity = this.world.getEntity(projectile.targetEntityId);\n        if (!targetEntity) {\n            // Target no longer exists, disable homing\n            projectile.disableHoming();\n            return;\n        }\n        // Get target position\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            projectile.disableHoming();\n            return;\n        }\n        // Get projectile position\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!projectileTransform) {\n            return;\n        }\n        // Check if this is a tower projectile for special handling\n        const isTowerProjectile = projectileEntity.isTowerProjectile === true;\n        // Calculate direction to target\n        const currentPosition = projectileTransform.position;\n        const targetPosition = targetTransform.position;\n        this.tempVector.copy(targetPosition).sub(currentPosition);\n        const distanceToTarget = this.tempVector.length();\n        // For tower projectiles, use more aggressive homing even at close range\n        const minDistanceThreshold = isTowerProjectile ? 0.05 : 0.1; // Closer threshold for towers\n        // If very close to target and not a tower projectile, maintain current direction\n        if (distanceToTarget < minDistanceThreshold && !isTowerProjectile) {\n            return;\n        }\n        // Normalize target direction\n        this.tempVector.normalize();\n        // Get current velocity direction\n        const currentDirection = projectile.velocity.clone().normalize();\n        // For tower projectiles, use more direct approach when very close\n        if (isTowerProjectile && distanceToTarget < 0.3) {\n            // Direct approach: immediately adjust towards target\n            const desiredDirection = this.tempVector.clone();\n            const angle = currentDirection.angleTo(desiredDirection);\n            // For tower projectiles, allow much more aggressive turning when close\n            const maxTurnThisFrame = projectile.maxTurnRate * deltaTime * 2; // Double the turn rate when close\n            const turnAngle = Math.min(angle, maxTurnThisFrame);\n            if (turnAngle > 0.001) {\n                const rotationAxis = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                rotationAxis.crossVectors(currentDirection, desiredDirection).normalize();\n                const newDirection = currentDirection.clone();\n                newDirection.applyAxisAngle(rotationAxis, turnAngle);\n                projectile.velocity.copy(newDirection).multiplyScalar(projectile.speed);\n            }\n        } else {\n            // Standard homing logic with enhanced strength for tower projectiles\n            const homingStrength = isTowerProjectile ? Math.min(projectile.homingStrength + 0.1, 1.0) : projectile.homingStrength;\n            // Calculate desired direction (interpolate between current and target direction)\n            const desiredDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            desiredDirection.lerpVectors(currentDirection, this.tempVector, homingStrength);\n            // Calculate angle between current and desired direction\n            const angle = currentDirection.angleTo(desiredDirection);\n            // Limit turn rate (more aggressive for tower projectiles)\n            const maxTurnThisFrame = projectile.maxTurnRate * deltaTime;\n            const turnAngle = Math.min(angle, maxTurnThisFrame);\n            // If we need to turn\n            if (turnAngle > 0.001) {\n                // Calculate rotation axis\n                const rotationAxis = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                rotationAxis.crossVectors(currentDirection, desiredDirection).normalize();\n                // Create rotation quaternion\n                const cosHalfAngle = Math.cos(turnAngle / 2);\n                const sinHalfAngle = Math.sin(turnAngle / 2);\n                // Apply rotation to current direction\n                const newDirection = currentDirection.clone();\n                newDirection.applyAxisAngle(rotationAxis, turnAngle);\n                // Update velocity while maintaining speed\n                projectile.velocity.copy(newDirection).multiplyScalar(projectile.speed);\n            }\n        }\n    }\n    checkCollisions(projectileEntity, transform, projectile) {\n        var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n        const projectilePos = transform.position;\n        // Skip barrage and viper sting projectiles in PVP mode - they should only be handled by specialized PVP managers\n        const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        if ((renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isBarrageArrow) || (renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.projectileType) === \"viper_sting\") {\n            // In PVP mode, these projectiles are handled by the specialized PVP managers\n            // Skip ECS collision detection to prevent duplicate damage and self-targeting\n            return;\n        }\n        // Get all entities that could be hit - specifically look for enemies with colliders\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        // Early exit if no targets\n        if (potentialTargets.length === 0) return;\n        for (const target of potentialTargets){\n            // Skip self and owner\n            if (target.id === projectileEntity.id || target.id === projectile.owner) {\n                // Debug logging for owner collision prevention\n                if (target.id === projectile.owner) {\n                // console.log(`🚫 Projectile ${projectileEntity.id} skipping owner ${projectile.owner} (target ${target.id})`);\n                }\n                continue;\n            }\n            // Skip if already hit and not piercing\n            if (!projectile.canHitTarget(target.id)) {\n                continue;\n            }\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            // Skip if target is dead\n            if (targetHealth.isDead) {\n                continue;\n            }\n            // Check if projectile can hit this target (layer-based collision)\n            // In PVP mode, projectiles can hit both ENEMY (remote players) and PLAYER (local player) layers\n            if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER) {\n                continue;\n            }\n            // Additional safety check: prevent projectiles from hitting their owner in PVP mode\n            // This is a backup check in case the owner comparison above fails\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && target.id === projectile.owner) {\n                continue;\n            }\n            const targetPos = targetTransform.getWorldPosition();\n            // Use collider radius for more accurate collision detection\n            const projectileRadius = 0.2; // Increased from 0.1 for more forgiving collision detection\n            const targetRadius = targetCollider.radius;\n            // Use squared distance for performance (avoid sqrt)\n            const distanceSquared = projectilePos.distanceToSquared(targetPos);\n            const collisionRadiusSquared = (projectileRadius + targetRadius) ** 2;\n            if (distanceSquared <= collisionRadiusSquared) {\n                this.handleHit(projectileEntity, target, projectile, targetHealth);\n                // If not piercing, destroy projectile\n                if (!projectile.piercing) {\n                    this.projectilesToDestroy.push(projectileEntity.id);\n                    break;\n                }\n            }\n        }\n    }\n    handleHit(projectileEntity, target, projectile, targetHealth) {\n        // Mark target as hit\n        projectile.addHitTarget(target.id);\n        // Deal damage through combat system if available, otherwise directly\n        if (this.combatSystem) {\n            var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n            // Check projectile type for special damage handling\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            const isCrossentropyBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isCrossentropyBolt;\n            const isEntropicBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.isEntropicBolt;\n            let damageType = \"projectile\";\n            if (isCrossentropyBolt) {\n                damageType = \"crossentropy\";\n            } else if (isEntropicBolt) {\n                damageType = \"entropic\";\n            }\n            this.combatSystem.queueDamage(target, projectile.damage, projectileEntity, damageType);\n        } else {\n            // Fallback to direct damage (pass entity for shield absorption)\n            const currentTime = Date.now() / 1000;\n            const damageDealt = targetHealth.takeDamage(projectile.damage, currentTime, target);\n        }\n        // Handle explosion if explosive\n        if (projectile.explosionRadius > 0) {\n            this.handleExplosion(projectileEntity, projectile);\n        }\n    }\n    handleExplosion(projectileEntity, projectile) {\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const explosionCenter = projectileTransform.position;\n        // Emit explosion event for visual effects\n        this.world.emitEvent(\"explosion\", {\n            position: explosionCenter.clone(),\n            color: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(\"#00ff44\"),\n            size: projectile.explosionRadius,\n            duration: 0.5\n        });\n        // Find all entities within explosion radius\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const target of potentialTargets){\n            if (target.id === projectile.owner) continue; // Don't damage owner\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const distance = explosionCenter.distanceTo(targetTransform.position);\n            if (distance <= projectile.explosionRadius) {\n                // Calculate damage falloff based on distance\n                const damageFalloff = 1 - distance / projectile.explosionRadius;\n                const explosionDamage = Math.floor(projectile.damage * damageFalloff);\n                if (explosionDamage > 0) {\n                    const currentTime = Date.now() / 1000;\n                    targetHealth.takeDamage(explosionDamage, currentTime, target);\n                }\n            }\n        }\n    }\n    checkWorldBounds(entity, transform) {\n        const pos = transform.position;\n        const maxDistance = 40; // Maximum distance from origin\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Check if projectile is too far from origin (using squared distance)\n        if (pos.lengthSq() > maxDistanceSquared) {\n            this.projectilesToDestroy.push(entity.id);\n            return; // Early exit\n        }\n        // Check if projectile is below ground (simple ground check)\n        if (pos.y < -10) {\n            this.projectilesToDestroy.push(entity.id);\n        }\n    }\n    // Utility method to create a ChargedArrow projectile for fully charged bow\n    createChargedArrowProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with charged arrow-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 35; // Faster than regular arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 25; // Higher damage than regular arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for ChargedArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a ChargedArrow for special handling\n        placeholderMesh.userData.isChargedArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        return projectileEntity;\n    }\n    // Utility method to create a CrossentropyBolt projectile for scythe\n    createCrossentropyBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with scythe-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Slower than arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 30; // Higher damage than arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for CrossentropyBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.28, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a CrossentropyBolt for special handling\n        placeholderMesh.userData.isCrossentropyBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n        // console.warn('⚠️ Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create an EntropicBolt projectile for scythe left click\n    createEntropicBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with EntropicBolt-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Faster than CrossentropyBolt\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 20; // EntropicBolt damage\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Shorter lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for EntropicBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 6, 6);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as an EntropicBolt for special handling\n        placeholderMesh.userData.isEntropicBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n        // console.warn('⚠️ Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create a projectile\n    createProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20;\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 5; // Set default damage to 5 as requested\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 2;\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        projectile.setStartPosition(position);\n        // Set max distance if specified (for bow arrows)\n        if ((config === null || config === void 0 ? void 0 : config.maxDistance) !== undefined) {\n            projectile.setMaxDistance(config.maxDistance);\n        }\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for RegularArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a RegularArrow for special handling\n        placeholderMesh.userData.isRegularArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        placeholderMesh.userData.projectileType = config === null || config === void 0 ? void 0 : config.projectileType;\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false); // Projectiles don't need to cast shadows\n        } else {\n        // console.warn('⚠️ Renderer component missing setCastShadow method:', renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        // Notify systems that the entity is ready (this will trigger RenderSystem.onEntityAdded)\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Get pool statistics for debugging\n    getPoolStats() {\n        return {\n            vector3: this.vector3Pool.getPoolSize()\n        };\n    }\n    // Dispose of all pools when system is destroyed\n    onDisable() {\n        this.vector3Pool.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ];\n        this.combatSystem = null;\n        this.projectilesToDestroy = [];\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 20; // Run after movement\n        // Initialize vector pool for calculations\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 100);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FO0FBQytCO0FBQzdEO0FBRWlCO0FBQ0U7QUFDUjtBQUNJO0FBQ2dCO0FBR3JCO0FBTXpDLE1BQU1hLHlCQUF5QlIsK0NBQU1BO0lBOEJuQ1MsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQ0Msb0JBQW9CLENBQUNDLE1BQU0sR0FBRztRQUVuQyxLQUFLLE1BQU1DLFVBQVVKLFNBQVU7WUFDN0IsTUFBTUssWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixhQUFhSCxPQUFPRSxZQUFZLENBQUNoQixrRUFBVUE7WUFFakQsSUFBSSxDQUFDZSxVQUFVRyxPQUFPLElBQUksQ0FBQ0QsV0FBV0MsT0FBTyxFQUFFO2dCQUM3QztZQUNGO1lBRUEsb0JBQW9CO1lBQ3BCRCxXQUFXUixNQUFNLENBQUNFO1lBRWxCLGtDQUFrQztZQUNsQyxJQUFJTSxXQUFXRSxTQUFTLElBQUk7Z0JBQzFCLElBQUksQ0FBQ1Asb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtnQkFDeEM7WUFDRjtZQUVBLGtCQUFrQjtZQUNsQixJQUFJLENBQUNDLGNBQWMsQ0FBQ1AsV0FBV0UsWUFBWU47WUFFM0Msa0RBQWtEO1lBQ2xELElBQUksQ0FBQ1kscUJBQXFCLENBQUNULFFBQVFHLFlBQVlOO1lBRS9DLDRFQUE0RTtZQUM1RSxtREFBbUQ7WUFFbkQsbUJBQW1CO1lBQ25CLElBQUksQ0FBQ2EsZUFBZSxDQUFDVixRQUFRQyxXQUFXRTtZQUV4Qyx5QkFBeUI7WUFDekIsSUFBSSxDQUFDUSxnQkFBZ0IsQ0FBQ1gsUUFBUUM7UUFDaEM7UUFFQSw4QkFBOEI7UUFD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SUFDakIsQ0FBQ21MLFNBQVdBLE9BQU9DLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFDN0I7SUFFSjtBQTBwQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvUHJvamVjdGlsZVN5c3RlbS50cz8wMGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2plY3RpbGUgc3lzdGVtIGZvciBoYW5kbGluZyBwcm9qZWN0aWxlIG1vdmVtZW50IGFuZCBjb2xsaXNpb25zXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgU3BoZXJlR2VvbWV0cnksIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUHJvamVjdGlsZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tICdAL2Vjcy9Xb3JsZCc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuaW1wb3J0IHsgV2VhcG9uU3ViY2xhc3MgfSBmcm9tICdAL2NvbXBvbmVudHMvZHJhZ29uL3dlYXBvbnMnO1xuaW1wb3J0IHsgQ29tYmF0U3lzdGVtIH0gZnJvbSAnLi9Db21iYXRTeXN0ZW0nO1xuaW1wb3J0IENyb3NzZW50cm9weUJvbHQgZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0Nyb3NzZW50cm9weUJvbHQnO1xuXG5leHBvcnQgY2xhc3MgUHJvamVjdGlsZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBQcm9qZWN0aWxlXTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgY29tYmF0U3lzdGVtOiBDb21iYXRTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwcm9qZWN0aWxlc1RvRGVzdHJveTogbnVtYmVyW10gPSBbXTtcbiAgXG5cbiAgXG4gIC8vIE9iamVjdCBwb29scyBmb3IgcGVyZm9ybWFuY2UgKGtlZXBpbmcgdmVjdG9yIHBvb2wgZm9yIGNhbGN1bGF0aW9ucylcbiAgcHJpdmF0ZSB2ZWN0b3IzUG9vbDogT2JqZWN0UG9vbDxWZWN0b3IzPjtcbiAgXG4gIC8vIFJldXNhYmxlIG9iamVjdHMgdG8gcmVkdWNlIGFsbG9jYXRpb25zXG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyMDsgLy8gUnVuIGFmdGVyIG1vdmVtZW50XG4gICAgXG5cbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHZlY3RvciBwb29sIGZvciBjYWxjdWxhdGlvbnNcbiAgICB0aGlzLnZlY3RvcjNQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiBuZXcgVmVjdG9yMygpLFxuICAgICAgKHZlY3RvcikgPT4gdmVjdG9yLnNldCgwLCAwLCAwKSxcbiAgICAgIDEwMFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29tYmF0U3lzdGVtKGNvbWJhdFN5c3RlbTogQ29tYmF0U3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5jb21iYXRTeXN0ZW0gPSBjb21iYXRTeXN0ZW07XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95Lmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICAgIGNvbnN0IHByb2plY3RpbGUgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcHJvamVjdGlsZS5lbmFibGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcHJvamVjdGlsZVxuICAgICAgcHJvamVjdGlsZS51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBoYXMgZXhwaXJlZFxuICAgICAgaWYgKHByb2plY3RpbGUuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIHByb2plY3RpbGVcbiAgICAgIHRoaXMubW92ZVByb2plY3RpbGUodHJhbnNmb3JtLCBwcm9qZWN0aWxlLCBkZWx0YVRpbWUpO1xuXG4gICAgICAvLyBVcGRhdGUgaG9taW5nIGRpcmVjdGlvbiBpZiBwcm9qZWN0aWxlIGlzIGhvbWluZ1xuICAgICAgdGhpcy51cGRhdGVIb21pbmdEaXJlY3Rpb24oZW50aXR5LCBwcm9qZWN0aWxlLCBkZWx0YVRpbWUpO1xuXG4gICAgICAvLyBBcnJvdyBvcmllbnRhdGlvbiBpcyBzZXQgb25jZSBhdCBjcmVhdGlvbiAtIG5vIG5lZWQgdG8gdXBkYXRlIGV2ZXJ5IGZyYW1lXG4gICAgICAvLyB0aGlzLnVwZGF0ZUFycm93T3JpZW50YXRpb24oZW50aXR5LCBwcm9qZWN0aWxlKTtcblxuICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xuICAgICAgdGhpcy5jaGVja0NvbGxpc2lvbnMoZW50aXR5LCB0cmFuc2Zvcm0sIHByb2plY3RpbGUpO1xuXG4gICAgICAvLyBDaGVjayB3b3JsZCBib3VuZGFyaWVzXG4gICAgICB0aGlzLmNoZWNrV29ybGRCb3VuZHMoZW50aXR5LCB0cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIERlc3Ryb3kgZXhwaXJlZCBwcm9qZWN0aWxlc1xuICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveSkge1xuICAgICAgdGhpcy53b3JsZC5kZXN0cm95RW50aXR5KGVudGl0eUlkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1vdmVQcm9qZWN0aWxlKHRyYW5zZm9ybTogVHJhbnNmb3JtLCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVzZSB0ZW1wIHZlY3RvciB0byBhdm9pZCBhbGxvY2F0aW9uc1xuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHByb2plY3RpbGUudmVsb2NpdHkpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG5cbiAgICAvLyBVcGRhdGUgcG9zaXRpb25cbiAgICB0cmFuc2Zvcm0udHJhbnNsYXRlKHRoaXMudGVtcFZlY3Rvci54LCB0aGlzLnRlbXBWZWN0b3IueSwgdGhpcy50ZW1wVmVjdG9yLnopO1xuICAgIHRyYW5zZm9ybS5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhvbWluZ0RpcmVjdGlvbihwcm9qZWN0aWxlRW50aXR5OiBFbnRpdHksIHByb2plY3RpbGU6IFByb2plY3RpbGUsIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gU2tpcCBpZiBub3QgaG9taW5nXG4gICAgaWYgKCFwcm9qZWN0aWxlLnRhcmdldEVudGl0eUlkIHx8IHByb2plY3RpbGUuaG9taW5nU3RyZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB0YXJnZXQgZW50aXR5XG4gICAgY29uc3QgdGFyZ2V0RW50aXR5ID0gdGhpcy53b3JsZC5nZXRFbnRpdHkocHJvamVjdGlsZS50YXJnZXRFbnRpdHlJZCk7XG4gICAgaWYgKCF0YXJnZXRFbnRpdHkpIHtcbiAgICAgIC8vIFRhcmdldCBubyBsb25nZXIgZXhpc3RzLCBkaXNhYmxlIGhvbWluZ1xuICAgICAgcHJvamVjdGlsZS5kaXNhYmxlSG9taW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHRhcmdldCBwb3NpdGlvblxuICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldEVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXRhcmdldFRyYW5zZm9ybSkge1xuICAgICAgcHJvamVjdGlsZS5kaXNhYmxlSG9taW5nKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHByb2plY3RpbGUgcG9zaXRpb25cbiAgICBjb25zdCBwcm9qZWN0aWxlVHJhbnNmb3JtID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXByb2plY3RpbGVUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdG93ZXIgcHJvamVjdGlsZSBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIGNvbnN0IGlzVG93ZXJQcm9qZWN0aWxlID0gKHByb2plY3RpbGVFbnRpdHkgYXMgYW55KS5pc1Rvd2VyUHJvamVjdGlsZSA9PT0gdHJ1ZTtcblxuICAgIC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gdG8gdGFyZ2V0XG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gcHJvamVjdGlsZVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbjtcblxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFBvc2l0aW9uKS5zdWIoY3VycmVudFBvc2l0aW9uKTtcbiAgICBjb25zdCBkaXN0YW5jZVRvVGFyZ2V0ID0gdGhpcy50ZW1wVmVjdG9yLmxlbmd0aCgpO1xuXG4gICAgLy8gRm9yIHRvd2VyIHByb2plY3RpbGVzLCB1c2UgbW9yZSBhZ2dyZXNzaXZlIGhvbWluZyBldmVuIGF0IGNsb3NlIHJhbmdlXG4gICAgY29uc3QgbWluRGlzdGFuY2VUaHJlc2hvbGQgPSBpc1Rvd2VyUHJvamVjdGlsZSA/IDAuMDUgOiAwLjE7IC8vIENsb3NlciB0aHJlc2hvbGQgZm9yIHRvd2Vyc1xuXG4gICAgLy8gSWYgdmVyeSBjbG9zZSB0byB0YXJnZXQgYW5kIG5vdCBhIHRvd2VyIHByb2plY3RpbGUsIG1haW50YWluIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgaWYgKGRpc3RhbmNlVG9UYXJnZXQgPCBtaW5EaXN0YW5jZVRocmVzaG9sZCAmJiAhaXNUb3dlclByb2plY3RpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgdGFyZ2V0IGRpcmVjdGlvblxuICAgIHRoaXMudGVtcFZlY3Rvci5ub3JtYWxpemUoKTtcblxuICAgIC8vIEdldCBjdXJyZW50IHZlbG9jaXR5IGRpcmVjdGlvblxuICAgIGNvbnN0IGN1cnJlbnREaXJlY3Rpb24gPSBwcm9qZWN0aWxlLnZlbG9jaXR5LmNsb25lKCkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBGb3IgdG93ZXIgcHJvamVjdGlsZXMsIHVzZSBtb3JlIGRpcmVjdCBhcHByb2FjaCB3aGVuIHZlcnkgY2xvc2VcbiAgICBpZiAoaXNUb3dlclByb2plY3RpbGUgJiYgZGlzdGFuY2VUb1RhcmdldCA8IDAuMykge1xuICAgICAgLy8gRGlyZWN0IGFwcHJvYWNoOiBpbW1lZGlhdGVseSBhZGp1c3QgdG93YXJkcyB0YXJnZXRcbiAgICAgIGNvbnN0IGRlc2lyZWREaXJlY3Rpb24gPSB0aGlzLnRlbXBWZWN0b3IuY2xvbmUoKTtcbiAgICAgIGNvbnN0IGFuZ2xlID0gY3VycmVudERpcmVjdGlvbi5hbmdsZVRvKGRlc2lyZWREaXJlY3Rpb24pO1xuXG4gICAgICAvLyBGb3IgdG93ZXIgcHJvamVjdGlsZXMsIGFsbG93IG11Y2ggbW9yZSBhZ2dyZXNzaXZlIHR1cm5pbmcgd2hlbiBjbG9zZVxuICAgICAgY29uc3QgbWF4VHVyblRoaXNGcmFtZSA9IHByb2plY3RpbGUubWF4VHVyblJhdGUgKiBkZWx0YVRpbWUgKiAyOyAvLyBEb3VibGUgdGhlIHR1cm4gcmF0ZSB3aGVuIGNsb3NlXG4gICAgICBjb25zdCB0dXJuQW5nbGUgPSBNYXRoLm1pbihhbmdsZSwgbWF4VHVyblRoaXNGcmFtZSk7XG5cbiAgICAgIGlmICh0dXJuQW5nbGUgPiAwLjAwMSkge1xuICAgICAgICBjb25zdCByb3RhdGlvbkF4aXMgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICByb3RhdGlvbkF4aXMuY3Jvc3NWZWN0b3JzKGN1cnJlbnREaXJlY3Rpb24sIGRlc2lyZWREaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIGNvbnN0IG5ld0RpcmVjdGlvbiA9IGN1cnJlbnREaXJlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgbmV3RGlyZWN0aW9uLmFwcGx5QXhpc0FuZ2xlKHJvdGF0aW9uQXhpcywgdHVybkFuZ2xlKTtcblxuICAgICAgICBwcm9qZWN0aWxlLnZlbG9jaXR5LmNvcHkobmV3RGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihwcm9qZWN0aWxlLnNwZWVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RhbmRhcmQgaG9taW5nIGxvZ2ljIHdpdGggZW5oYW5jZWQgc3RyZW5ndGggZm9yIHRvd2VyIHByb2plY3RpbGVzXG4gICAgICBjb25zdCBob21pbmdTdHJlbmd0aCA9IGlzVG93ZXJQcm9qZWN0aWxlID8gTWF0aC5taW4ocHJvamVjdGlsZS5ob21pbmdTdHJlbmd0aCArIDAuMSwgMS4wKSA6IHByb2plY3RpbGUuaG9taW5nU3RyZW5ndGg7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkZXNpcmVkIGRpcmVjdGlvbiAoaW50ZXJwb2xhdGUgYmV0d2VlbiBjdXJyZW50IGFuZCB0YXJnZXQgZGlyZWN0aW9uKVxuICAgICAgY29uc3QgZGVzaXJlZERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBkZXNpcmVkRGlyZWN0aW9uLmxlcnBWZWN0b3JzKGN1cnJlbnREaXJlY3Rpb24sIHRoaXMudGVtcFZlY3RvciwgaG9taW5nU3RyZW5ndGgpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYW5nbGUgYmV0d2VlbiBjdXJyZW50IGFuZCBkZXNpcmVkIGRpcmVjdGlvblxuICAgICAgY29uc3QgYW5nbGUgPSBjdXJyZW50RGlyZWN0aW9uLmFuZ2xlVG8oZGVzaXJlZERpcmVjdGlvbik7XG5cbiAgICAgIC8vIExpbWl0IHR1cm4gcmF0ZSAobW9yZSBhZ2dyZXNzaXZlIGZvciB0b3dlciBwcm9qZWN0aWxlcylcbiAgICAgIGNvbnN0IG1heFR1cm5UaGlzRnJhbWUgPSBwcm9qZWN0aWxlLm1heFR1cm5SYXRlICogZGVsdGFUaW1lO1xuICAgICAgY29uc3QgdHVybkFuZ2xlID0gTWF0aC5taW4oYW5nbGUsIG1heFR1cm5UaGlzRnJhbWUpO1xuXG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIHR1cm5cbiAgICAgIGlmICh0dXJuQW5nbGUgPiAwLjAwMSkgeyAvLyBTbWFsbCB0aHJlc2hvbGQgdG8gYXZvaWQgaml0dGVyXG4gICAgICAgIC8vIENhbGN1bGF0ZSByb3RhdGlvbiBheGlzXG4gICAgICAgIGNvbnN0IHJvdGF0aW9uQXhpcyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHJvdGF0aW9uQXhpcy5jcm9zc1ZlY3RvcnMoY3VycmVudERpcmVjdGlvbiwgZGVzaXJlZERpcmVjdGlvbikubm9ybWFsaXplKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHJvdGF0aW9uIHF1YXRlcm5pb25cbiAgICAgICAgY29uc3QgY29zSGFsZkFuZ2xlID0gTWF0aC5jb3ModHVybkFuZ2xlIC8gMik7XG4gICAgICAgIGNvbnN0IHNpbkhhbGZBbmdsZSA9IE1hdGguc2luKHR1cm5BbmdsZSAvIDIpO1xuXG4gICAgICAgIC8vIEFwcGx5IHJvdGF0aW9uIHRvIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgICAgIGNvbnN0IG5ld0RpcmVjdGlvbiA9IGN1cnJlbnREaXJlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgbmV3RGlyZWN0aW9uLmFwcGx5QXhpc0FuZ2xlKHJvdGF0aW9uQXhpcywgdHVybkFuZ2xlKTtcblxuICAgICAgICAvLyBVcGRhdGUgdmVsb2NpdHkgd2hpbGUgbWFpbnRhaW5pbmcgc3BlZWRcbiAgICAgICAgcHJvamVjdGlsZS52ZWxvY2l0eS5jb3B5KG5ld0RpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIocHJvamVjdGlsZS5zcGVlZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIHByaXZhdGUgY2hlY2tDb2xsaXNpb25zKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHByb2plY3RpbGU6IFByb2plY3RpbGUpOiB2b2lkIHtcbiAgICBjb25zdCBwcm9qZWN0aWxlUG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuXG4gICAgLy8gU2tpcCBiYXJyYWdlIGFuZCB2aXBlciBzdGluZyBwcm9qZWN0aWxlcyBpbiBQVlAgbW9kZSAtIHRoZXkgc2hvdWxkIG9ubHkgYmUgaGFuZGxlZCBieSBzcGVjaWFsaXplZCBQVlAgbWFuYWdlcnNcbiAgICBjb25zdCByZW5kZXJlciA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXI/Lm1lc2g/LnVzZXJEYXRhPy5pc0JhcnJhZ2VBcnJvdyB8fCByZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LnByb2plY3RpbGVUeXBlID09PSAndmlwZXJfc3RpbmcnKSB7XG4gICAgICAvLyBJbiBQVlAgbW9kZSwgdGhlc2UgcHJvamVjdGlsZXMgYXJlIGhhbmRsZWQgYnkgdGhlIHNwZWNpYWxpemVkIFBWUCBtYW5hZ2Vyc1xuICAgICAgLy8gU2tpcCBFQ1MgY29sbGlzaW9uIGRldGVjdGlvbiB0byBwcmV2ZW50IGR1cGxpY2F0ZSBkYW1hZ2UgYW5kIHNlbGYtdGFyZ2V0aW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyB0aGF0IGNvdWxkIGJlIGhpdCAtIHNwZWNpZmljYWxseSBsb29rIGZvciBlbmVtaWVzIHdpdGggY29sbGlkZXJzXG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBIZWFsdGgsIENvbGxpZGVyXSk7XG5cbiAgICAvLyBFYXJseSBleGl0IGlmIG5vIHRhcmdldHNcbiAgICBpZiAocG90ZW50aWFsVGFyZ2V0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBvdGVudGlhbFRhcmdldHMpIHtcbiAgICAgIC8vIFNraXAgc2VsZiBhbmQgb3duZXJcbiAgICAgIGlmICh0YXJnZXQuaWQgPT09IHByb2plY3RpbGVFbnRpdHkuaWQgfHwgdGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIG93bmVyIGNvbGxpc2lvbiBwcmV2ZW50aW9uXG4gICAgICAgIGlmICh0YXJnZXQuaWQgPT09IHByb2plY3RpbGUub3duZXIpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+aqyBQcm9qZWN0aWxlICR7cHJvamVjdGlsZUVudGl0eS5pZH0gc2tpcHBpbmcgb3duZXIgJHtwcm9qZWN0aWxlLm93bmVyfSAodGFyZ2V0ICR7dGFyZ2V0LmlkfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGhpdCBhbmQgbm90IHBpZXJjaW5nXG4gICAgICBpZiAoIXByb2plY3RpbGUuY2FuSGl0VGFyZ2V0KHRhcmdldC5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG4gICAgICBcbiAgICAgIC8vIFNraXAgaWYgdGFyZ2V0IGlzIGRlYWRcbiAgICAgIGlmICh0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGNhbiBoaXQgdGhpcyB0YXJnZXQgKGxheWVyLWJhc2VkIGNvbGxpc2lvbilcbiAgICAgIC8vIEluIFBWUCBtb2RlLCBwcm9qZWN0aWxlcyBjYW4gaGl0IGJvdGggRU5FTVkgKHJlbW90ZSBwbGF5ZXJzKSBhbmQgUExBWUVSIChsb2NhbCBwbGF5ZXIpIGxheWVyc1xuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyICE9PSBDb2xsaXNpb25MYXllci5FTkVNWSAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRpdGlvbmFsIHNhZmV0eSBjaGVjazogcHJldmVudCBwcm9qZWN0aWxlcyBmcm9tIGhpdHRpbmcgdGhlaXIgb3duZXIgaW4gUFZQIG1vZGVcbiAgICAgIC8vIFRoaXMgaXMgYSBiYWNrdXAgY2hlY2sgaW4gY2FzZSB0aGUgb3duZXIgY29tcGFyaXNvbiBhYm92ZSBmYWlsc1xuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVIgJiYgdGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYPCfmqsgRXh0cmEgc2FmZXR5OiBQcm9qZWN0aWxlICR7cHJvamVjdGlsZUVudGl0eS5pZH0gcHJldmVudGVkIGZyb20gaGl0dGluZyBvd25lciAke3Byb2plY3RpbGUub3duZXJ9IChQVlAgbW9kZSlgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRhcmdldFRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG5cbiAgICAgIC8vIFVzZSBjb2xsaWRlciByYWRpdXMgZm9yIG1vcmUgYWNjdXJhdGUgY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgY29uc3QgcHJvamVjdGlsZVJhZGl1cyA9IDAuMjsgLy8gSW5jcmVhc2VkIGZyb20gMC4xIGZvciBtb3JlIGZvcmdpdmluZyBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICBjb25zdCB0YXJnZXRSYWRpdXMgPSB0YXJnZXRDb2xsaWRlci5yYWRpdXM7XG5cbiAgICAgIC8vIFVzZSBzcXVhcmVkIGRpc3RhbmNlIGZvciBwZXJmb3JtYW5jZSAoYXZvaWQgc3FydClcbiAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IHByb2plY3RpbGVQb3MuZGlzdGFuY2VUb1NxdWFyZWQodGFyZ2V0UG9zKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblJhZGl1c1NxdWFyZWQgPSAocHJvamVjdGlsZVJhZGl1cyArIHRhcmdldFJhZGl1cykgKiogMjtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA8PSBjb2xsaXNpb25SYWRpdXNTcXVhcmVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSGl0KHByb2plY3RpbGVFbnRpdHksIHRhcmdldCwgcHJvamVjdGlsZSwgdGFyZ2V0SGVhbHRoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vdCBwaWVyY2luZywgZGVzdHJveSBwcm9qZWN0aWxlXG4gICAgICAgIGlmICghcHJvamVjdGlsZS5waWVyY2luZykge1xuICAgICAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChwcm9qZWN0aWxlRW50aXR5LmlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlSGl0KFxuICAgIHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIHByb2plY3RpbGU6IFByb2plY3RpbGUsIFxuICAgIHRhcmdldEhlYWx0aDogSGVhbHRoXG4gICk6IHZvaWQge1xuICAgIC8vIE1hcmsgdGFyZ2V0IGFzIGhpdFxuICAgIHByb2plY3RpbGUuYWRkSGl0VGFyZ2V0KHRhcmdldC5pZCk7XG5cbiAgICAvLyBEZWFsIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZGlyZWN0bHlcbiAgICBpZiAodGhpcy5jb21iYXRTeXN0ZW0pIHtcbiAgICAgIC8vIENoZWNrIHByb2plY3RpbGUgdHlwZSBmb3Igc3BlY2lhbCBkYW1hZ2UgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgY29uc3QgaXNDcm9zc2VudHJvcHlCb2x0ID0gcmVuZGVyZXI/Lm1lc2g/LnVzZXJEYXRhPy5pc0Nyb3NzZW50cm9weUJvbHQ7XG4gICAgICBjb25zdCBpc0VudHJvcGljQm9sdCA9IHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNFbnRyb3BpY0JvbHQ7XG4gICAgICBcbiAgICAgIGxldCBkYW1hZ2VUeXBlID0gJ3Byb2plY3RpbGUnO1xuICAgICAgaWYgKGlzQ3Jvc3NlbnRyb3B5Qm9sdCkge1xuICAgICAgICBkYW1hZ2VUeXBlID0gJ2Nyb3NzZW50cm9weSc7XG4gICAgICB9IGVsc2UgaWYgKGlzRW50cm9waWNCb2x0KSB7XG4gICAgICAgIGRhbWFnZVR5cGUgPSAnZW50cm9waWMnO1xuICAgICAgfVxuICAgICAgXG5cbiAgICAgIFxuICAgICAgdGhpcy5jb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCBwcm9qZWN0aWxlLmRhbWFnZSwgcHJvamVjdGlsZUVudGl0eSwgZGFtYWdlVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCBkYW1hZ2UgKHBhc3MgZW50aXR5IGZvciBzaGllbGQgYWJzb3JwdGlvbilcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBjb25zdCBkYW1hZ2VEZWFsdCA9IHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKHByb2plY3RpbGUuZGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICAgIFxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBleHBsb3Npb24gaWYgZXhwbG9zaXZlXG4gICAgaWYgKHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzID4gMCkge1xuICAgICAgdGhpcy5oYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eSwgcHJvamVjdGlsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eTogRW50aXR5LCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKTogdm9pZCB7XG4gICAgY29uc3QgcHJvamVjdGlsZVRyYW5zZm9ybSA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IGV4cGxvc2lvbkNlbnRlciA9IHByb2plY3RpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG5cbiAgICAvLyBFbWl0IGV4cGxvc2lvbiBldmVudCBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICB0aGlzLndvcmxkLmVtaXRFdmVudCgnZXhwbG9zaW9uJywge1xuICAgICAgcG9zaXRpb246IGV4cGxvc2lvbkNlbnRlci5jbG9uZSgpLFxuICAgICAgY29sb3I6IG5ldyBDb2xvcignIzAwZmY0NCcpLFxuICAgICAgc2l6ZTogcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMsXG4gICAgICBkdXJhdGlvbjogMC41XG4gICAgfSk7XG5cbiAgICAvLyBGaW5kIGFsbCBlbnRpdGllcyB3aXRoaW4gZXhwbG9zaW9uIHJhZGl1c1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoXSk7XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSBjb250aW51ZTsgLy8gRG9uJ3QgZGFtYWdlIG93bmVyXG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBleHBsb3Npb25DZW50ZXIuZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRhbWFnZSBmYWxsb2ZmIGJhc2VkIG9uIGRpc3RhbmNlXG4gICAgICAgIGNvbnN0IGRhbWFnZUZhbGxvZmYgPSAxIC0gKGRpc3RhbmNlIC8gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpO1xuICAgICAgICBjb25zdCBleHBsb3Npb25EYW1hZ2UgPSBNYXRoLmZsb29yKHByb2plY3RpbGUuZGFtYWdlICogZGFtYWdlRmFsbG9mZik7XG5cbiAgICAgICAgaWYgKGV4cGxvc2lvbkRhbWFnZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgIHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKGV4cGxvc2lvbkRhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrV29ybGRCb3VuZHMoZW50aXR5OiBFbnRpdHksIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgcG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IG1heERpc3RhbmNlID0gNDA7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW5cbiAgICBjb25zdCBtYXhEaXN0YW5jZVNxdWFyZWQgPSBtYXhEaXN0YW5jZSAqIG1heERpc3RhbmNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBpcyB0b28gZmFyIGZyb20gb3JpZ2luICh1c2luZyBzcXVhcmVkIGRpc3RhbmNlKVxuICAgIGlmIChwb3MubGVuZ3RoU3EoKSA+IG1heERpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICByZXR1cm47IC8vIEVhcmx5IGV4aXRcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGlzIGJlbG93IGdyb3VuZCAoc2ltcGxlIGdyb3VuZCBjaGVjaylcbiAgICBpZiAocG9zLnkgPCAtMTApIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENoYXJnZWRBcnJvdyBwcm9qZWN0aWxlIGZvciBmdWxseSBjaGFyZ2VkIGJvd1xuICBwdWJsaWMgY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBjaGFyZ2VkIGFycm93LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAzNTsgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDI1OyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCA1OyAvLyBMb25nZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBDaGFyZ2VkQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDaGFyZ2VkQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNDaGFyZ2VkQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIFxuICAgIHJlbmRlcmVyLm1lc2ggPSBwbGFjZWhvbGRlck1lc2g7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG5cbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlXG4gIHB1YmxpYyBjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBzY3l0aGUtc3BlY2lmaWMgc2V0dGluZ3NcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDIwOyAvLyBTbG93ZXIgdGhhbiBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDMwOyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gYXJyb3dzXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgMS43NTsgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIGNvbnN0IHJlbmRlcmVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgcGxhY2Vob2xkZXIgbWVzaCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIFJlYWN0IGNvbXBvbmVudFxuICAgIGNvbnN0IHBsYWNlaG9sZGVyR2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoMC4yOCwgOCwgOCk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNYXRlcmlhbCA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogJyMwMGZmNDQnLFxuICAgICAgZW1pc3NpdmU6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAwLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDcm9zc2VudHJvcHlCb2x0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzQ3Jvc3NlbnRyb3B5Qm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlIGxlZnQgY2xpY2tcbiAgcHVibGljIGNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggRW50cm9waWNCb2x0LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDsgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIHByb2plY3RpbGUuZGFtYWdlID0gY29uZmlnPy5kYW1hZ2UgfHwgMjA7IC8vIEVudHJvcGljQm9sdCBkYW1hZ2VcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fDEuNzU7IC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBFbnRyb3BpY0JvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDYsIDYpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMCxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMCAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGFuIEVudHJvcGljQm9sdCBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5pc0VudHJvcGljQm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG5cbiAgICAvLyBOb3RpZnkgc3lzdGVtcyB0aGF0IHRoZSBlbnRpdHkgaXMgcmVhZHlcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGEgcHJvamVjdGlsZVxuICBwdWJsaWMgY3JlYXRlUHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgICBtYXhEaXN0YW5jZT86IG51bWJlcjtcbiAgICAgIHByb2plY3RpbGVUeXBlPzogc3RyaW5nOyAvLyBBZGQgcHJvamVjdGlsZSB0eXBlIGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnRcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDIwO1xuICAgIHByb2plY3RpbGUuZGFtYWdlID0gY29uZmlnPy5kYW1hZ2UgfHwgNTsgLy8gU2V0IGRlZmF1bHQgZGFtYWdlIHRvIDUgYXMgcmVxdWVzdGVkXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgMjtcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHByb2plY3RpbGUuc2V0U3RhcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgXG4gICAgLy8gU2V0IG1heCBkaXN0YW5jZSBpZiBzcGVjaWZpZWQgKGZvciBib3cgYXJyb3dzKVxuICAgIGlmIChjb25maWc/Lm1heERpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0TWF4RGlzdGFuY2UoY29uZmlnLm1heERpc3RhbmNlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbmZpZz8ucGllcmNpbmcpIHByb2plY3RpbGUuc2V0UGllcmNpbmcodHJ1ZSk7XG4gICAgaWYgKGNvbmZpZz8uZXhwbG9zaXZlICYmIGNvbmZpZz8uZXhwbG9zaW9uUmFkaXVzKSB7XG4gICAgICBwcm9qZWN0aWxlLnNldEV4cGxvc2l2ZShjb25maWcuZXhwbG9zaW9uUmFkaXVzKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocHJvamVjdGlsZSk7XG5cbiAgICAvLyBBZGQgUmVuZGVyZXIgY29tcG9uZW50IC0gd2UnbGwgdXNlIGEgc3BlY2lhbCBtYXJrZXIgZm9yIFJlZ3VsYXJBcnJvd1xuICAgIGNvbnN0IHJlbmRlcmVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgcGxhY2Vob2xkZXIgbWVzaCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIFJlYWN0IGNvbXBvbmVudFxuICAgIGNvbnN0IHBsYWNlaG9sZGVyR2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoMC4xNSwgOCwgOCk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNYXRlcmlhbCA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogJyNmZmFhMDAnLFxuICAgICAgZW1pc3NpdmU6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAzLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjEgLy8gVmVyeSBsb3cgb3BhY2l0eSBzaW5jZSBSZWFjdCBjb21wb25lbnQgd2lsbCBoYW5kbGUgdmlzdWFsc1xuICAgIH0pO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWVzaCA9IG5ldyBNZXNoKHBsYWNlaG9sZGVyR2VvbWV0cnksIHBsYWNlaG9sZGVyTWF0ZXJpYWwpO1xuICAgIFxuICAgIC8vIE1hcmsgdGhpcyBhcyBhIFJlZ3VsYXJBcnJvdyBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5pc1JlZ3VsYXJBcnJvdyA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmRpcmVjdGlvbiA9IGRpcmVjdGlvbi5jbG9uZSgpO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5zdWJjbGFzcyA9IGNvbmZpZz8uc3ViY2xhc3M7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmxldmVsID0gY29uZmlnPy5sZXZlbDtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEub3BhY2l0eSA9IGNvbmZpZz8ub3BhY2l0eSB8fCAxLjA7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVUeXBlID0gY29uZmlnPy5wcm9qZWN0aWxlVHlwZTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7IC8vIFByb2plY3RpbGVzIGRvbid0IG5lZWQgdG8gY2FzdCBzaGFkb3dzXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG4gICAgXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5ICh0aGlzIHdpbGwgdHJpZ2dlciBSZW5kZXJTeXN0ZW0ub25FbnRpdHlBZGRlZClcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cblxuXG4gIC8vIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UG9vbFN0YXRzKCk6IHsgXG4gICAgdmVjdG9yMzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVjdG9yMzogdGhpcy52ZWN0b3IzUG9vbC5nZXRQb29sU2l6ZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8vIERpc3Bvc2Ugb2YgYWxsIHBvb2xzIHdoZW4gc3lzdGVtIGlzIGRlc3Ryb3llZFxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMudmVjdG9yM1Bvb2wuY2xlYXIoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb2xvciIsIlNwaGVyZUdlb21ldHJ5IiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJNZXNoIiwiU3lzdGVtIiwiVHJhbnNmb3JtIiwiUHJvamVjdGlsZSIsIkhlYWx0aCIsIlJlbmRlcmVyIiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIk9iamVjdFBvb2wiLCJQcm9qZWN0aWxlU3lzdGVtIiwic2V0Q29tYmF0U3lzdGVtIiwiY29tYmF0U3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJwcm9qZWN0aWxlc1RvRGVzdHJveSIsImxlbmd0aCIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInByb2plY3RpbGUiLCJlbmFibGVkIiwiaXNFeHBpcmVkIiwicHVzaCIsImlkIiwibW92ZVByb2plY3RpbGUiLCJ1cGRhdGVIb21pbmdEaXJlY3Rpb24iLCJjaGVja0NvbGxpc2lvbnMiLCJjaGVja1dvcmxkQm91bmRzIiwiZW50aXR5SWQiLCJ3b3JsZCIsImRlc3Ryb3lFbnRpdHkiLCJ0ZW1wVmVjdG9yIiwiY29weSIsInZlbG9jaXR5IiwibXVsdGlwbHlTY2FsYXIiLCJ0cmFuc2xhdGUiLCJ4IiwieSIsInoiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInByb2plY3RpbGVFbnRpdHkiLCJ0YXJnZXRFbnRpdHlJZCIsImhvbWluZ1N0cmVuZ3RoIiwidGFyZ2V0RW50aXR5IiwiZ2V0RW50aXR5IiwiZGlzYWJsZUhvbWluZyIsInRhcmdldFRyYW5zZm9ybSIsInByb2plY3RpbGVUcmFuc2Zvcm0iLCJpc1Rvd2VyUHJvamVjdGlsZSIsImN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJzdWIiLCJkaXN0YW5jZVRvVGFyZ2V0IiwibWluRGlzdGFuY2VUaHJlc2hvbGQiLCJub3JtYWxpemUiLCJjdXJyZW50RGlyZWN0aW9uIiwiY2xvbmUiLCJkZXNpcmVkRGlyZWN0aW9uIiwiYW5nbGUiLCJhbmdsZVRvIiwibWF4VHVyblRoaXNGcmFtZSIsIm1heFR1cm5SYXRlIiwidHVybkFuZ2xlIiwiTWF0aCIsIm1pbiIsInJvdGF0aW9uQXhpcyIsImNyb3NzVmVjdG9ycyIsIm5ld0RpcmVjdGlvbiIsImFwcGx5QXhpc0FuZ2xlIiwic3BlZWQiLCJsZXJwVmVjdG9ycyIsImNvc0hhbGZBbmdsZSIsImNvcyIsInNpbkhhbGZBbmdsZSIsInNpbiIsInJlbmRlcmVyIiwicHJvamVjdGlsZVBvcyIsIm1lc2giLCJ1c2VyRGF0YSIsImlzQmFycmFnZUFycm93IiwicHJvamVjdGlsZVR5cGUiLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsInRhcmdldCIsIm93bmVyIiwiY2FuSGl0VGFyZ2V0IiwidGFyZ2V0SGVhbHRoIiwidGFyZ2V0Q29sbGlkZXIiLCJpc0RlYWQiLCJsYXllciIsIkVORU1ZIiwiUExBWUVSIiwidGFyZ2V0UG9zIiwiZ2V0V29ybGRQb3NpdGlvbiIsInByb2plY3RpbGVSYWRpdXMiLCJ0YXJnZXRSYWRpdXMiLCJyYWRpdXMiLCJkaXN0YW5jZVNxdWFyZWQiLCJkaXN0YW5jZVRvU3F1YXJlZCIsImNvbGxpc2lvblJhZGl1c1NxdWFyZWQiLCJoYW5kbGVIaXQiLCJwaWVyY2luZyIsImFkZEhpdFRhcmdldCIsImlzQ3Jvc3NlbnRyb3B5Qm9sdCIsImlzRW50cm9waWNCb2x0IiwiZGFtYWdlVHlwZSIsInF1ZXVlRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwiZGFtYWdlRGVhbHQiLCJ0YWtlRGFtYWdlIiwiZXhwbG9zaW9uUmFkaXVzIiwiaGFuZGxlRXhwbG9zaW9uIiwiZXhwbG9zaW9uQ2VudGVyIiwiZW1pdEV2ZW50IiwiY29sb3IiLCJzaXplIiwiZHVyYXRpb24iLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJkYW1hZ2VGYWxsb2ZmIiwiZXhwbG9zaW9uRGFtYWdlIiwiZmxvb3IiLCJwb3MiLCJtYXhEaXN0YW5jZSIsIm1heERpc3RhbmNlU3F1YXJlZCIsImxlbmd0aFNxIiwiY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZSIsImRpcmVjdGlvbiIsIm93bmVySWQiLCJjb25maWciLCJjcmVhdGVFbnRpdHkiLCJjcmVhdGVDb21wb25lbnQiLCJhZGRDb21wb25lbnQiLCJtYXhMaWZldGltZSIsImxpZmV0aW1lIiwic2V0RGlyZWN0aW9uIiwic2V0UGllcmNpbmciLCJleHBsb3NpdmUiLCJzZXRFeHBsb3NpdmUiLCJwbGFjZWhvbGRlckdlb21ldHJ5IiwicGxhY2Vob2xkZXJNYXRlcmlhbCIsImVtaXNzaXZlIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJwbGFjZWhvbGRlck1lc2giLCJpc0NoYXJnZWRBcnJvdyIsInN1YmNsYXNzIiwibGV2ZWwiLCJjb2xsaWRlciIsIlBST0pFQ1RJTEUiLCJjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZSIsInNldENhc3RTaGFkb3ciLCJub3RpZnlFbnRpdHlBZGRlZCIsImNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJjcmVhdGVQcm9qZWN0aWxlIiwic2V0U3RhcnRQb3NpdGlvbiIsInVuZGVmaW5lZCIsInNldE1heERpc3RhbmNlIiwiaXNSZWd1bGFyQXJyb3ciLCJnZXRQb29sU3RhdHMiLCJ2ZWN0b3IzIiwidmVjdG9yM1Bvb2wiLCJnZXRQb29sU2l6ZSIsIm9uRGlzYWJsZSIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5IiwidmVjdG9yIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ProjectileSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/RenderSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/RenderSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n// Render system for 3D rendering with Three.js\n\n\n\n\nclass RenderSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update animations and renderer components\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            // Update animations with safety check\n            if (typeof rendererComponent.updateAnimations === \"function\") {\n                rendererComponent.updateAnimations(deltaTime);\n            } else {\n            // console.warn('⚠️ Renderer component missing updateAnimations method:', rendererComponent);\n            }\n            // Update mesh if needed\n            this.updateEntityMesh(entity, transform, rendererComponent);\n        }\n    }\n    render(entities, deltaTime) {\n        // Update all entity transforms and meshes\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            this.updateEntityTransform(entity, transform, rendererComponent);\n        }\n        // Render the scene\n        this.renderer.render(this.scene, this.camera);\n    }\n    updateEntityMesh(entity, transform, rendererComponent) {\n        const existingMesh = this.meshMap.get(entity.id);\n        // Handle pre-built mesh/group (like arrows)\n        if (!existingMesh && rendererComponent.mesh) {\n            this.meshMap.set(entity.id, rendererComponent.mesh);\n            this.scene.add(rendererComponent.mesh);\n            return;\n        }\n        // Create mesh if it doesn't exist or needs update (traditional geometry + material)\n        if (!existingMesh && rendererComponent.geometry && rendererComponent.material) {\n            const mesh = rendererComponent.createMesh();\n            if (mesh) {\n                this.meshMap.set(entity.id, mesh);\n                this.scene.add(mesh);\n            }\n        } else if (existingMesh) {\n            // Update existing mesh with safety check\n            if (typeof rendererComponent.updateMesh === \"function\") {\n                rendererComponent.updateMesh();\n            } else {\n            // console.warn('⚠️ Renderer component missing updateMesh method:', rendererComponent);\n            }\n        }\n    }\n    updateEntityTransform(entity, transform, rendererComponent) {\n        const meshOrGroup = this.meshMap.get(entity.id);\n        if (!meshOrGroup) return;\n        // Update transform matrix\n        transform.updateMatrix();\n        // Apply transform to mesh or group\n        meshOrGroup.position.copy(transform.position);\n        meshOrGroup.quaternion.copy(transform.quaternion);\n        meshOrGroup.scale.copy(transform.scale);\n        // Handle instanced rendering (only for meshes)\n        if (rendererComponent.isInstanced && meshOrGroup instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            rendererComponent.updateInstanceMatrix(transform.matrix);\n        }\n    }\n    onEntityAdded(entity) {\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent) {\n            // console.log(`🎨 RenderSystem: Adding entity ${entity.id} to scene`);\n            // Handle pre-built mesh/group (like arrows and elite enemies)\n            if (rendererComponent.mesh) {\n                // console.log(`🏹 Adding pre-built mesh/group for entity ${entity.id}`);\n                this.meshMap.set(entity.id, rendererComponent.mesh);\n                this.scene.add(rendererComponent.mesh);\n                return;\n            }\n            // Handle traditional geometry + material\n            if (rendererComponent.geometry && rendererComponent.material) {\n                // console.log(`🔷 Creating mesh from geometry + material for entity ${entity.id}`);\n                const mesh = rendererComponent.createMesh();\n                if (mesh) {\n                    this.meshMap.set(entity.id, mesh);\n                    this.scene.add(mesh);\n                }\n            } else {\n            // console.log(`⚪ Entity ${entity.id} has Renderer but no geometry/material - skipping mesh creation`);\n            }\n        } else {\n        // console.log(`⚠️ RenderSystem: Entity ${entity.id} has no Renderer component`);\n        }\n    }\n    onEntityRemoved(entity) {\n        const mesh = this.meshMap.get(entity.id);\n        if (mesh) {\n            this.scene.remove(mesh);\n            this.meshMap.delete(entity.id);\n        }\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent && typeof rendererComponent.dispose === \"function\") {\n            rendererComponent.dispose();\n        }\n    }\n    getMesh(entityId) {\n        return this.meshMap.get(entityId);\n    }\n    getScene() {\n        return this.scene;\n    }\n    getCamera() {\n        return this.camera;\n    }\n    getRenderer() {\n        return this.renderer;\n    }\n    // Utility methods for managing the scene\n    addLight(light) {\n        this.scene.add(light);\n    }\n    removeLight(light) {\n        this.scene.remove(light);\n    }\n    addObject(object) {\n        this.scene.add(object);\n    }\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    setFog(fog) {\n        this.scene.fog = fog;\n    }\n    setBackground(background) {\n        this.scene.background = background;\n    }\n    enableShadows() {\n        let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.renderer.shadowMap.enabled = enable;\n        this.renderer.shadowMap.type = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;\n    }\n    setPixelRatio(ratio) {\n        this.renderer.setPixelRatio(ratio || window.devicePixelRatio);\n    }\n    setSize(width, height) {\n        this.renderer.setSize(width, height);\n        if (this.camera instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    dispose() {\n        // Clean up all meshes\n        for (const [entityId, mesh] of Array.from(this.meshMap.entries())){\n            this.scene.remove(mesh);\n        }\n        this.meshMap.clear();\n        // Dispose renderer\n        this.renderer.dispose();\n    }\n    constructor(scene, camera, renderer){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer\n        ];\n        this.meshMap = new Map() // Entity ID -> Mesh/Group mapping\n        ;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.priority = 1000; // Render systems should run last\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLCtDQUErQztBQUNvSTtBQUNuSDtBQUVUO0FBQ0Y7QUFFOUMsTUFBTUcscUJBQXFCQyxxREFBZ0JBO0lBZXpDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDRDQUE0QztRQUM1QyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9ELGtCQUFrQkUsZ0JBQWdCLEtBQUssWUFBWTtnQkFDNURGLGtCQUFrQkUsZ0JBQWdCLENBQUNOO1lBQ3JDLE9BQU87WUFDTCw2RkFBNkY7WUFDL0Y7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBQ04sUUFBUUMsV0FBV0U7UUFDM0M7SUFDRjtJQUVPSSxPQUFPVCxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDBDQUEwQztRQUMxQyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLElBQUksQ0FBQ0kscUJBQXFCLENBQUNSLFFBQVFDLFdBQVdFO1FBQ2hEO1FBRUEsbUJBQW1CO1FBQ25CLElBQUksQ0FBQ00sUUFBUSxDQUFDRixNQUFNLENBQUMsSUFBSSxDQUFDRyxLQUFLLEVBQUUsSUFBSSxDQUFDQyxNQUFNO0lBQzlDO0lBRVFMLGlCQUFpQk4sTUFBYyxFQUFFQyxTQUFvQixFQUFFRSxpQkFBMkIsRUFBUTtRQUNoRyxNQUFNUyxlQUFlLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUNkLE9BQU9lLEVBQUU7UUFFL0MsNENBQTRDO1FBQzVDLElBQUksQ0FBQ0gsZ0JBQWdCVCxrQkFBa0JhLElBQUksRUFBRTtZQUMzQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksR0FBRyxDQUFDakIsT0FBT2UsRUFBRSxFQUFFWixrQkFBa0JhLElBQUk7WUFDbEQsSUFBSSxDQUFDTixLQUFLLENBQUNRLEdBQUcsQ0FBQ2Ysa0JBQWtCYSxJQUFJO1lBQ3JDO1FBQ0Y7UUFFQSxvRkFBb0Y7UUFDcEYsSUFBSSxDQUFDSixnQkFBZ0JULGtCQUFrQmdCLFFBQVEsSUFBSWhCLGtCQUFrQmlCLFFBQVEsRUFBRTtZQUM3RSxNQUFNSixPQUFPYixrQkFBa0JrQixVQUFVO1lBQ3pDLElBQUlMLE1BQU07Z0JBQ1IsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEdBQUcsQ0FBQ2pCLE9BQU9lLEVBQUUsRUFBRUM7Z0JBQzVCLElBQUksQ0FBQ04sS0FBSyxDQUFDUSxHQUFHLENBQUNGO1lBQ2pCO1FBQ0YsT0FBTyxJQUFJSixjQUFjO1lBQ3ZCLHlDQUF5QztZQUN6QyxJQUFJLE9BQU9ULGtCQUFrQm1CLFVBQVUsS0FBSyxZQUFZO2dCQUN0RG5CLGtCQUFrQm1CLFVBQVU7WUFDOUIsT0FBTztZQUNMLHVGQUF1RjtZQUN6RjtRQUNGO0lBQ0Y7SUFFUWQsc0JBQXNCUixNQUFjLEVBQUVDLFNBQW9CLEVBQUVFLGlCQUEyQixFQUFRO1FBQ3JHLE1BQU1vQixjQUFjLElBQUksQ0FBQ1YsT0FBTyxDQUFDQyxHQUFHLENBQUNkLE9BQU9lLEVBQUU7UUFDOUMsSUFBSSxDQUFDUSxhQUFhO1FBRWxCLDBCQUEwQjtRQUMxQnRCLFVBQVV1QixZQUFZO1FBRXRCLG1DQUFtQztRQUNuQ0QsWUFBWUUsUUFBUSxDQUFDQyxJQUFJLENBQUN6QixVQUFVd0IsUUFBUTtRQUM1Q0YsWUFBWUksVUFBVSxDQUFDRCxJQUFJLENBQUN6QixVQUFVMEIsVUFBVTtRQUNoREosWUFBWUssS0FBSyxDQUFDRixJQUFJLENBQUN6QixVQUFVMkIsS0FBSztRQUV0QywrQ0FBK0M7UUFDL0MsSUFBSXpCLGtCQUFrQjBCLFdBQVcsSUFBSU4sdUJBQXVCakMsc0RBQUlBLEVBQUU7WUFDaEVhLGtCQUFrQjJCLG9CQUFvQixDQUFDN0IsVUFBVThCLE1BQU07UUFDekQ7SUFDRjtJQUVPQyxjQUFjaEMsTUFBYyxFQUFRO1FBQ3pDLE1BQU1HLG9CQUFvQkgsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7UUFDdEQsSUFBSU8sbUJBQW1CO1lBQ3JCLHVFQUF1RTtZQUV2RSw4REFBOEQ7WUFDOUQsSUFBSUEsa0JBQWtCYSxJQUFJLEVBQUU7Z0JBQzFCLHlFQUF5RTtnQkFDekUsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEdBQUcsQ0FBQ2pCLE9BQU9lLEVBQUUsRUFBRVosa0JBQWtCYSxJQUFJO2dCQUNsRCxJQUFJLENBQUNOLEtBQUssQ0FBQ1EsR0FBRyxDQUFDZixrQkFBa0JhLElBQUk7Z0JBQ3JDO1lBQ0Y7WUFFQSx5Q0FBeUM7WUFDekMsSUFBSWIsa0JBQWtCZ0IsUUFBUSxJQUFJaEIsa0JBQWtCaUIsUUFBUSxFQUFFO2dCQUM1RCxvRkFBb0Y7Z0JBQ3BGLE1BQU1KLE9BQU9iLGtCQUFrQmtCLFVBQVU7Z0JBQ3pDLElBQUlMLE1BQU07b0JBQ1IsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEdBQUcsQ0FBQ2pCLE9BQU9lLEVBQUUsRUFBRUM7b0JBQzVCLElBQUksQ0FBQ04sS0FBSyxDQUFDUSxHQUFHLENBQUNGO2dCQUNqQjtZQUNGLE9BQU87WUFDTCx1R0FBdUc7WUFDekc7UUFDRixPQUFPO1FBQ0wsaUZBQWlGO1FBQ25GO0lBQ0Y7SUFFT2lCLGdCQUFnQmpDLE1BQWMsRUFBUTtRQUMzQyxNQUFNZ0IsT0FBTyxJQUFJLENBQUNILE9BQU8sQ0FBQ0MsR0FBRyxDQUFDZCxPQUFPZSxFQUFFO1FBQ3ZDLElBQUlDLE1BQU07WUFDUixJQUFJLENBQUNOLEtBQUssQ0FBQ3dCLE1BQU0sQ0FBQ2xCO1lBQ2xCLElBQUksQ0FBQ0gsT0FBTyxDQUFDc0IsTUFBTSxDQUFDbkMsT0FBT2UsRUFBRTtRQUMvQjtRQUVBLE1BQU1aLG9CQUFvQkgsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7UUFDdEQsSUFBSU8scUJBQXFCLE9BQU9BLGtCQUFrQmlDLE9BQU8sS0FBSyxZQUFZO1lBQ3hFakMsa0JBQWtCaUMsT0FBTztRQUMzQjtJQUNGO0lBRU9DLFFBQVFDLFFBQWdCLEVBQTRCO1FBQ3pELE9BQU8sSUFBSSxDQUFDekIsT0FBTyxDQUFDQyxHQUFHLENBQUN3QjtJQUMxQjtJQUVPQyxXQUFrQjtRQUN2QixPQUFPLElBQUksQ0FBQzdCLEtBQUs7SUFDbkI7SUFFTzhCLFlBQW9CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDN0IsTUFBTTtJQUNwQjtJQUVPOEIsY0FBNkI7UUFDbEMsT0FBTyxJQUFJLENBQUNoQyxRQUFRO0lBQ3RCO0lBRUEseUNBQXlDO0lBQ2xDaUMsU0FBU0MsS0FBWSxFQUFRO1FBQ2xDLElBQUksQ0FBQ2pDLEtBQUssQ0FBQ1EsR0FBRyxDQUFDeUI7SUFDakI7SUFFT0MsWUFBWUQsS0FBWSxFQUFRO1FBQ3JDLElBQUksQ0FBQ2pDLEtBQUssQ0FBQ3dCLE1BQU0sQ0FBQ1M7SUFDcEI7SUFFT0UsVUFBVUMsTUFBZ0IsRUFBUTtRQUN2QyxJQUFJLENBQUNwQyxLQUFLLENBQUNRLEdBQUcsQ0FBQzRCO0lBQ2pCO0lBRU9DLGFBQWFELE1BQWdCLEVBQVE7UUFDMUMsSUFBSSxDQUFDcEMsS0FBSyxDQUFDd0IsTUFBTSxDQUFDWTtJQUNwQjtJQUVPRSxPQUFPQyxHQUF5QixFQUFRO1FBQzdDLElBQUksQ0FBQ3ZDLEtBQUssQ0FBQ3VDLEdBQUcsR0FBR0E7SUFDbkI7SUFFT0MsY0FBY0MsVUFBZ0QsRUFBUTtRQUMzRSxJQUFJLENBQUN6QyxLQUFLLENBQUN5QyxVQUFVLEdBQUdBO0lBQzFCO0lBRU9DLGdCQUE0QztZQUE5QkMsU0FBQUEsaUVBQWtCO1FBQ3JDLElBQUksQ0FBQzVDLFFBQVEsQ0FBQzZDLFNBQVMsQ0FBQ2xELE9BQU8sR0FBR2lEO1FBQ2xDLElBQUksQ0FBQzVDLFFBQVEsQ0FBQzZDLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHaEUsa0VBQWdCQTtJQUNqRDtJQUVPaUUsY0FBY0MsS0FBYyxFQUFRO1FBQ3pDLElBQUksQ0FBQ2hELFFBQVEsQ0FBQytDLGFBQWEsQ0FBQ0MsU0FBU0MsT0FBT0MsZ0JBQWdCO0lBQzlEO0lBRU9DLFFBQVFDLEtBQWEsRUFBRUMsTUFBYyxFQUFRO1FBQ2xELElBQUksQ0FBQ3JELFFBQVEsQ0FBQ21ELE9BQU8sQ0FBQ0MsT0FBT0M7UUFFN0IsSUFBSSxJQUFJLENBQUNuRCxNQUFNLFlBQVluQixtRUFBaUJBLEVBQUU7WUFDNUMsSUFBSSxDQUFDbUIsTUFBTSxDQUFDb0QsTUFBTSxHQUFHRixRQUFRQztZQUM3QixJQUFJLENBQUNuRCxNQUFNLENBQUNxRCxzQkFBc0I7UUFDcEM7SUFDRjtJQUVPNUIsVUFBZ0I7UUFDckIsc0JBQXNCO1FBQ3RCLEtBQUssTUFBTSxDQUFDRSxVQUFVdEIsS0FBSyxJQUFJaUQsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ3JELE9BQU8sQ0FBQ3NELE9BQU8sSUFBSztZQUNqRSxJQUFJLENBQUN6RCxLQUFLLENBQUN3QixNQUFNLENBQUNsQjtRQUNwQjtRQUNBLElBQUksQ0FBQ0gsT0FBTyxDQUFDdUQsS0FBSztRQUVsQixtQkFBbUI7UUFDbkIsSUFBSSxDQUFDM0QsUUFBUSxDQUFDMkIsT0FBTztJQUN2QjtJQTFNQWlDLFlBQVkzRCxLQUFZLEVBQUVDLE1BQWMsRUFBRUYsUUFBdUIsQ0FBRTtRQUNqRSxLQUFLO2FBUFM2RCxxQkFBcUI7WUFBQzNFLGdFQUFTQTtZQUFFQyw4REFBUUE7U0FBQzthQUlsRGlCLFVBQVUsSUFBSTBELE1BQTZCLGtDQUFrQzs7UUFJbkYsSUFBSSxDQUFDN0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUMrRCxRQUFRLEdBQUcsTUFBTSxpQ0FBaUM7SUFDekQ7QUFxTUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvUmVuZGVyU3lzdGVtLnRzP2IzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVuZGVyIHN5c3RlbSBmb3IgM0QgcmVuZGVyaW5nIHdpdGggVGhyZWUuanNcbmltcG9ydCB7IFNjZW5lLCBDYW1lcmEsIFdlYkdMUmVuZGVyZXIsIE1lc2gsIEdyb3VwLCBMaWdodCwgT2JqZWN0M0QsIENvbG9yLCBUZXh0dXJlLCBQQ0ZTb2Z0U2hhZG93TWFwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgRm9nLCBGb2dFeHAyLCBDdWJlVGV4dHVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gYXMgQmFzZVJlbmRlclN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcblxuZXhwb3J0IGNsYXNzIFJlbmRlclN5c3RlbSBleHRlbmRzIEJhc2VSZW5kZXJTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgUmVuZGVyZXJdO1xuICBwcml2YXRlIHNjZW5lOiBTY2VuZTtcbiAgcHJpdmF0ZSBjYW1lcmE6IENhbWVyYTtcbiAgcHJpdmF0ZSByZW5kZXJlcjogV2ViR0xSZW5kZXJlcjtcbiAgcHJpdmF0ZSBtZXNoTWFwID0gbmV3IE1hcDxudW1iZXIsIE1lc2ggfCBHcm91cD4oKTsgLy8gRW50aXR5IElEIC0+IE1lc2gvR3JvdXAgbWFwcGluZ1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEsIHJlbmRlcmVyOiBXZWJHTFJlbmRlcmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxMDAwOyAvLyBSZW5kZXIgc3lzdGVtcyBzaG91bGQgcnVuIGxhc3RcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBhbmltYXRpb25zIGFuZCByZW5kZXJlciBjb21wb25lbnRzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcmVuZGVyZXJDb21wb25lbnQuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGFuaW1hdGlvbnMgd2l0aCBzYWZldHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlQW5pbWF0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZW5kZXJlckNvbXBvbmVudC51cGRhdGVBbmltYXRpb25zKGRlbHRhVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVBbmltYXRpb25zIG1ldGhvZDonLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBtZXNoIGlmIG5lZWRlZFxuICAgICAgdGhpcy51cGRhdGVFbnRpdHlNZXNoKGVudGl0eSwgdHJhbnNmb3JtLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGFsbCBlbnRpdHkgdHJhbnNmb3JtcyBhbmQgbWVzaGVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcmVuZGVyZXJDb21wb25lbnQuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbnRpdHlUcmFuc2Zvcm0oZW50aXR5LCB0cmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICAvLyBSZW5kZXIgdGhlIHNjZW5lXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVFbnRpdHlNZXNoKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQ6IFJlbmRlcmVyKTogdm9pZCB7XG4gICAgY29uc3QgZXhpc3RpbmdNZXNoID0gdGhpcy5tZXNoTWFwLmdldChlbnRpdHkuaWQpO1xuXG4gICAgLy8gSGFuZGxlIHByZS1idWlsdCBtZXNoL2dyb3VwIChsaWtlIGFycm93cylcbiAgICBpZiAoIWV4aXN0aW5nTWVzaCAmJiByZW5kZXJlckNvbXBvbmVudC5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgcmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChyZW5kZXJlckNvbXBvbmVudC5tZXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbWVzaCBpZiBpdCBkb2Vzbid0IGV4aXN0IG9yIG5lZWRzIHVwZGF0ZSAodHJhZGl0aW9uYWwgZ2VvbWV0cnkgKyBtYXRlcmlhbClcbiAgICBpZiAoIWV4aXN0aW5nTWVzaCAmJiByZW5kZXJlckNvbXBvbmVudC5nZW9tZXRyeSAmJiByZW5kZXJlckNvbXBvbmVudC5tYXRlcmlhbCkge1xuICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVyQ29tcG9uZW50LmNyZWF0ZU1lc2goKTtcbiAgICAgIGlmIChtZXNoKSB7XG4gICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCBtZXNoKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleGlzdGluZ01lc2gpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBtZXNoIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZU1lc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlTWVzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlTWVzaCBtZXRob2Q6JywgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRW50aXR5VHJhbnNmb3JtKGVudGl0eTogRW50aXR5LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQ6IFJlbmRlcmVyKTogdm9pZCB7XG4gICAgY29uc3QgbWVzaE9yR3JvdXAgPSB0aGlzLm1lc2hNYXAuZ2V0KGVudGl0eS5pZCk7XG4gICAgaWYgKCFtZXNoT3JHcm91cCkgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICB0cmFuc2Zvcm0udXBkYXRlTWF0cml4KCk7XG5cbiAgICAvLyBBcHBseSB0cmFuc2Zvcm0gdG8gbWVzaCBvciBncm91cFxuICAgIG1lc2hPckdyb3VwLnBvc2l0aW9uLmNvcHkodHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICBtZXNoT3JHcm91cC5xdWF0ZXJuaW9uLmNvcHkodHJhbnNmb3JtLnF1YXRlcm5pb24pO1xuICAgIG1lc2hPckdyb3VwLnNjYWxlLmNvcHkodHJhbnNmb3JtLnNjYWxlKTtcblxuICAgIC8vIEhhbmRsZSBpbnN0YW5jZWQgcmVuZGVyaW5nIChvbmx5IGZvciBtZXNoZXMpXG4gICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50LmlzSW5zdGFuY2VkICYmIG1lc2hPckdyb3VwIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlSW5zdGFuY2VNYXRyaXgodHJhbnNmb3JtLm1hdHJpeCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5QWRkZWQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICBjb25zdCByZW5kZXJlckNvbXBvbmVudCA9IGVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIGlmIChyZW5kZXJlckNvbXBvbmVudCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYPCfjqggUmVuZGVyU3lzdGVtOiBBZGRpbmcgZW50aXR5ICR7ZW50aXR5LmlkfSB0byBzY2VuZWApO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgcHJlLWJ1aWx0IG1lc2gvZ3JvdXAgKGxpa2UgYXJyb3dzIGFuZCBlbGl0ZSBlbmVtaWVzKVxuICAgICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYPCfj7kgQWRkaW5nIHByZS1idWlsdCBtZXNoL2dyb3VwIGZvciBlbnRpdHkgJHtlbnRpdHkuaWR9YCk7XG4gICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCByZW5kZXJlckNvbXBvbmVudC5tZXNoKTtcbiAgICAgICAgdGhpcy5zY2VuZS5hZGQocmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHRyYWRpdGlvbmFsIGdlb21ldHJ5ICsgbWF0ZXJpYWxcbiAgICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5nZW9tZXRyeSAmJiByZW5kZXJlckNvbXBvbmVudC5tYXRlcmlhbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+UtyBDcmVhdGluZyBtZXNoIGZyb20gZ2VvbWV0cnkgKyBtYXRlcmlhbCBmb3IgZW50aXR5ICR7ZW50aXR5LmlkfWApO1xuICAgICAgICBjb25zdCBtZXNoID0gcmVuZGVyZXJDb21wb25lbnQuY3JlYXRlTWVzaCgpO1xuICAgICAgICBpZiAobWVzaCkge1xuICAgICAgICAgIHRoaXMubWVzaE1hcC5zZXQoZW50aXR5LmlkLCBtZXNoKTtcbiAgICAgICAgICB0aGlzLnNjZW5lLmFkZChtZXNoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coYOKaqiBFbnRpdHkgJHtlbnRpdHkuaWR9IGhhcyBSZW5kZXJlciBidXQgbm8gZ2VvbWV0cnkvbWF0ZXJpYWwgLSBza2lwcGluZyBtZXNoIGNyZWF0aW9uYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDimqDvuI8gUmVuZGVyU3lzdGVtOiBFbnRpdHkgJHtlbnRpdHkuaWR9IGhhcyBubyBSZW5kZXJlciBjb21wb25lbnRgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25FbnRpdHlSZW1vdmVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgbWVzaCA9IHRoaXMubWVzaE1hcC5nZXQoZW50aXR5LmlkKTtcbiAgICBpZiAobWVzaCkge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUobWVzaCk7XG4gICAgICB0aGlzLm1lc2hNYXAuZGVsZXRlKGVudGl0eS5pZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXJDb21wb25lbnQgJiYgdHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyQ29tcG9uZW50LmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0TWVzaChlbnRpdHlJZDogbnVtYmVyKTogTWVzaCB8IEdyb3VwIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5tZXNoTWFwLmdldChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U2NlbmUoKTogU2NlbmUge1xuICAgIHJldHVybiB0aGlzLnNjZW5lO1xuICB9XG5cbiAgcHVibGljIGdldENhbWVyYSgpOiBDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRSZW5kZXJlcigpOiBXZWJHTFJlbmRlcmVyIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgbWFuYWdpbmcgdGhlIHNjZW5lXG4gIHB1YmxpYyBhZGRMaWdodChsaWdodDogTGlnaHQpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlTGlnaHQobGlnaHQ6IExpZ2h0KTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5yZW1vdmUobGlnaHQpO1xuICB9XG5cbiAgcHVibGljIGFkZE9iamVjdChvYmplY3Q6IE9iamVjdDNEKTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5hZGQob2JqZWN0KTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVPYmplY3Qob2JqZWN0OiBPYmplY3QzRCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUucmVtb3ZlKG9iamVjdCk7XG4gIH1cblxuICBwdWJsaWMgc2V0Rm9nKGZvZzogRm9nIHwgRm9nRXhwMiB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmZvZyA9IGZvZztcbiAgfVxuXG4gIHB1YmxpYyBzZXRCYWNrZ3JvdW5kKGJhY2tncm91bmQ6IENvbG9yIHwgVGV4dHVyZSB8IEN1YmVUZXh0dXJlIHwgbnVsbCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gIH1cblxuICBwdWJsaWMgZW5hYmxlU2hhZG93cyhlbmFibGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IGVuYWJsZTtcbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gUENGU29mdFNoYWRvd01hcDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQaXhlbFJhdGlvKHJhdGlvPzogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHJhdGlvIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIGlmICh0aGlzLmNhbWVyYSBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBhbGwgbWVzaGVzXG4gICAgZm9yIChjb25zdCBbZW50aXR5SWQsIG1lc2hdIG9mIEFycmF5LmZyb20odGhpcy5tZXNoTWFwLmVudHJpZXMoKSkpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgIH1cbiAgICB0aGlzLm1lc2hNYXAuY2xlYXIoKTtcblxuICAgIC8vIERpc3Bvc2UgcmVuZGVyZXJcbiAgICB0aGlzLnJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJQQ0ZTb2Z0U2hhZG93TWFwIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJSZW5kZXJTeXN0ZW0iLCJCYXNlUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiUmVuZGVyZXIiLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInJlbmRlcmVyQ29tcG9uZW50IiwiZW5hYmxlZCIsInVwZGF0ZUFuaW1hdGlvbnMiLCJ1cGRhdGVFbnRpdHlNZXNoIiwicmVuZGVyIiwidXBkYXRlRW50aXR5VHJhbnNmb3JtIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImV4aXN0aW5nTWVzaCIsIm1lc2hNYXAiLCJnZXQiLCJpZCIsIm1lc2giLCJzZXQiLCJhZGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiY3JlYXRlTWVzaCIsInVwZGF0ZU1lc2giLCJtZXNoT3JHcm91cCIsInVwZGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwiY29weSIsInF1YXRlcm5pb24iLCJzY2FsZSIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJvbkVudGl0eUFkZGVkIiwib25FbnRpdHlSZW1vdmVkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZGlzcG9zZSIsImdldE1lc2giLCJlbnRpdHlJZCIsImdldFNjZW5lIiwiZ2V0Q2FtZXJhIiwiZ2V0UmVuZGVyZXIiLCJhZGRMaWdodCIsImxpZ2h0IiwicmVtb3ZlTGlnaHQiLCJhZGRPYmplY3QiLCJvYmplY3QiLCJyZW1vdmVPYmplY3QiLCJzZXRGb2ciLCJmb2ciLCJzZXRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsImVuYWJsZVNoYWRvd3MiLCJlbmFibGUiLCJzaGFkb3dNYXAiLCJ0eXBlIiwic2V0UGl4ZWxSYXRpbyIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/RenderSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/SummonedUnitSystem.ts":
/*!*******************************************!*\
  !*** ./src/systems/SummonedUnitSystem.ts ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SummonedUnitSystem: function() { return /* binding */ SummonedUnitSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n// SummonedUnit system for managing PVP tower minions\n\n\n\n\n\n\n\n\nclass SummonedUnitSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    setWaveCompleteCallback(callback) {\n        this.onWaveComplete = callback;\n    }\n    updatePlayerPosition(playerId, position) {\n        this.playerPositions.set(playerId, position.clone());\n    }\n    updateTowerPosition(towerId, position) {\n        this.towerPositions.set(towerId, position.clone());\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        this.unitsToDestroy.length = 0;\n        // Process existing units\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const unit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!transform || !unit || !health) continue;\n            // Check if unit is expired\n            if (unit.isExpired(currentTime)) {\n                // Remove unit from wave tracking\n                this.waveUnits.delete(entity.id);\n                this.unitsToDestroy.push(entity.id);\n                continue;\n            }\n            // Check if unit is dead\n            if (health.isDead && !unit.isDead) {\n                unit.die(currentTime);\n                // Remove unit from wave tracking\n                this.waveUnits.delete(entity.id);\n                this.unitsToDestroy.push(entity.id);\n                continue;\n            }\n            // Skip inactive or dead units\n            if (!unit.isActive || unit.isDead) continue;\n            // Update unit behavior\n            this.updateUnitBehavior(entity, transform, unit, currentTime, deltaTime);\n        }\n        // Check for wave completion\n        this.checkWaveCompletion(currentTime);\n        // Handle spawning new units\n        this.handleUnitSpawning(currentTime);\n        // Destroy expired units\n        for (const entityId of this.unitsToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    updateUnitBehavior(entity, transform, unit, currentTime, deltaTime) {\n        // Search for targets periodically\n        if (unit.canSearchForTargets(currentTime)) {\n            this.findTargetForUnit(unit, transform.position);\n            unit.updateTargetSearch(currentTime);\n        }\n        // Move towards target position if no specific target\n        if (!unit.currentTarget && unit.targetPosition) {\n            this.moveTowardsPosition(entity, transform, unit, deltaTime);\n        }\n        // Handle combat with current target\n        if (unit.currentTarget && unit.canAttack(currentTime)) {\n            this.handleUnitAttack(entity, unit, currentTime);\n        }\n    }\n    findTargetForUnit(unit, unitPosition) {\n        // Priority 1: Find enemy units to attack\n        const enemyUnits = this.findEnemyUnits(unit.ownerId, unitPosition);\n        if (enemyUnits.length > 0) {\n            // Target the closest enemy unit\n            const closestUnit = this.findClosestEntity(enemyUnits, unitPosition);\n            if (closestUnit) {\n                unit.setTarget(closestUnit.id);\n                return;\n            }\n        }\n        // Priority 2: If no enemy units, target enemy tower\n        const enemyTower = this.findEnemyTower(unit.ownerId, unitPosition);\n        if (enemyTower) {\n            unit.setTarget(enemyTower.id);\n            return;\n        }\n        // No targets found, clear target\n        unit.clearTarget();\n    }\n    findEnemyUnits(ownerId, unitPosition) {\n        const enemyUnits = [];\n        const allEntities = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        for (const entity of allEntities){\n            const summonedUnit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            if (!summonedUnit || !health || !collider) continue;\n            if (health.isDead || !summonedUnit.isActive) continue;\n            // Check if this is an enemy unit (different owner)\n            if (summonedUnit.ownerId !== ownerId && collider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY) {\n                enemyUnits.push(entity);\n            }\n        }\n        return enemyUnits;\n    }\n    findEnemyTower(ownerId, unitPosition) {\n        const allEntities = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        for (const entity of allEntities){\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            if (!tower || !health || !collider) continue;\n            if (health.isDead || !tower.isActive) continue;\n            // Check if this is an enemy tower\n            if (tower.ownerId !== ownerId && collider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY) {\n                return entity;\n            }\n        }\n        return null;\n    }\n    findClosestEntity(entities, fromPosition) {\n        let closestEntity = null;\n        let closestDistance = Infinity;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!transform) continue;\n            const distance = fromPosition.distanceTo(transform.position);\n            if (distance < closestDistance) {\n                closestDistance = distance;\n                closestEntity = entity;\n            }\n        }\n        return closestEntity;\n    }\n    moveTowardsPosition(entity, transform, unit, deltaTime) {\n        if (!unit.targetPosition) return;\n        const currentPos = transform.position;\n        const targetPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(unit.targetPosition.x, unit.targetPosition.y, unit.targetPosition.z);\n        // Calculate direction to target\n        this.tempVector.copy(targetPos).sub(currentPos);\n        const distance = this.tempVector.length();\n        // If close enough to target position, stop moving\n        if (distance < 0.5) {\n            unit.targetPosition = null;\n            return;\n        }\n        // Normalize and move\n        this.tempVector.normalize();\n        const moveDistance = unit.moveSpeed * deltaTime;\n        if (moveDistance < distance) {\n            // Move towards target\n            const newPosition = currentPos.clone().add(this.tempVector.multiplyScalar(moveDistance));\n            transform.setPosition(newPosition.x, newPosition.y, newPosition.z);\n        } else {\n            // Arrived at target\n            transform.setPosition(targetPos.x, targetPos.y, targetPos.z);\n            unit.targetPosition = null;\n        }\n        // Update movement component if it exists\n        const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (movement) {\n            movement.velocity.copy(this.tempVector).multiplyScalar(unit.moveSpeed);\n        }\n    }\n    handleUnitAttack(entity, unit, currentTime) {\n        if (!unit.currentTarget) return;\n        const targetEntity = this.world.getEntity(unit.currentTarget);\n        if (!targetEntity) {\n            unit.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetHealth = targetEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (!targetTransform || !targetHealth) {\n            unit.clearTarget();\n            return;\n        }\n        // Check if target is still in range\n        const unitTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!unitTransform) return;\n        const distance = unitTransform.position.distanceTo(targetTransform.position);\n        if (distance > unit.attackRange) {\n            unit.clearTarget();\n            return;\n        }\n        // Check if target is still alive\n        if (targetHealth.isDead) {\n            unit.clearTarget();\n            return;\n        }\n        // Perform attack\n        if (this.combatSystem) {\n            // Use combat system to handle damage\n            this.combatSystem.queueDamage(targetEntity, unit.attackDamage, entity, \"melee\");\n        } else {\n            // Fallback direct damage\n            targetHealth.takeDamage(unit.attackDamage, currentTime, targetEntity);\n        }\n        unit.performAttack(currentTime);\n    }\n    checkWaveCompletion(currentTime) {\n        // Check if current wave is complete (all units dead or expired)\n        if (this.currentWaveId && this.waveUnits.size === 0) {\n            // Ensure we don't spam the callback (minimum 30 seconds between wave completions)\n            if (currentTime - this.lastWaveCompletionTime >= 30) {\n                console.log(\"\\uD83C\\uDFAF Wave \".concat(this.currentWaveId, \" completed! Awarding experience to all players.\"));\n                // Award experience to all players\n                if (this.onWaveComplete) {\n                    this.onWaveComplete();\n                }\n                this.lastWaveCompletionTime = currentTime;\n                this.currentWaveId = null;\n            }\n        }\n    }\n    handleUnitSpawning(currentTime) {\n        // Get all towers to check for spawning\n        const towers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const towerEntity of towers){\n            const tower = towerEntity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower);\n            const towerTransform = towerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!tower || !towerTransform) continue;\n            if (!tower.isActive || tower.isDead) continue;\n            // Check if it's time to spawn units for this tower\n            const lastSpawn = this.lastSpawnTime.get(tower.ownerId) || 0;\n            if (currentTime - lastSpawn >= this.spawnInterval) {\n                this.spawnUnitsForTower(tower, towerTransform.position, currentTime);\n                this.lastSpawnTime.set(tower.ownerId, currentTime);\n            }\n        }\n    }\n    spawnUnitsForTower(tower, towerPosition, currentTime) {\n        // Start a new wave if this is the first tower spawning in this cycle\n        if (!this.currentWaveId) {\n            this.currentWaveId = \"wave_\".concat(currentTime);\n            this.waveStartTime = currentTime;\n            this.waveUnits.clear();\n            console.log(\"\\uD83C\\uDF0A Starting new wave: \".concat(this.currentWaveId));\n        }\n        // Find the opposing tower position for targeting\n        let opposingTowerPosition = this.findOpposingTowerPosition(tower.ownerId);\n        // If no opposing tower found, use a default position in front of current tower\n        if (!opposingTowerPosition) {\n            opposingTowerPosition = towerPosition.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 20));\n        }\n        // Spawn 3 units and track them in the wave\n        for(let i = 0; i < 3; i++){\n            const unitEntity = this.spawnUnit(tower.ownerId, towerPosition, opposingTowerPosition, i, currentTime);\n            if (unitEntity) {\n                this.waveUnits.add(unitEntity.id);\n            }\n        }\n    }\n    findOpposingTowerPosition(ownerId) {\n        const towers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const towerEntity of towers){\n            const tower = towerEntity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_7__.Tower);\n            const towerTransform = towerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!tower || !towerTransform) continue;\n            if (tower.ownerId !== ownerId) {\n                return towerTransform.position.clone();\n            }\n        }\n        return null;\n    }\n    spawnUnit(ownerId, spawnPosition, targetPosition, unitIndex, currentTime) {\n        const unitEntity = this.world.createEntity();\n        const unitId = \"\".concat(ownerId, \"_unit_\").concat(currentTime, \"_\").concat(unitIndex);\n        // Add offset to spawn position to avoid stacking\n        const offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3((unitIndex - 0.5) * 2, 0, 0);\n        const actualSpawnPosition = spawnPosition.clone().add(offset);\n        // Add Transform component\n        const transform = this.world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.setPosition(actualSpawnPosition.x, actualSpawnPosition.y, actualSpawnPosition.z);\n        unitEntity.addComponent(transform);\n        // Add SummonedUnit component\n        const summonedUnit = this.world.createComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n        summonedUnit.ownerId = ownerId;\n        summonedUnit.unitId = unitId;\n        summonedUnit.targetPosition = {\n            x: targetPosition.x,\n            y: targetPosition.y,\n            z: targetPosition.z\n        };\n        summonedUnit.summonTime = currentTime;\n        unitEntity.addComponent(summonedUnit);\n        // Add Health component\n        const health = new _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health(summonedUnit.maxHealth);\n        unitEntity.addComponent(health);\n        // Add Movement component\n        const movement = this.world.createComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        movement.maxSpeed = summonedUnit.moveSpeed;\n        movement.friction = 0.9;\n        unitEntity.addComponent(movement);\n        // Add Collider component\n        const collider = this.world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.type = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.ColliderType.SPHERE; // Use sphere collider for units\n        collider.radius = 0.5;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY; // Use enemy layer for PVP\n        collider.setOffset(0, 0.6, 0); // Center on unit\n        unitEntity.addComponent(collider);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(unitEntity);\n        return unitEntity;\n    }\n    // Utility methods for external access\n    getUnitCount(ownerId) {\n        const units = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        return units.filter((entity)=>{\n            const unit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            return unit && health && unit.ownerId === ownerId && unit.isActive && !unit.isDead && !health.isDead;\n        }).length;\n    }\n    getAllUnits() {\n        return this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n    }\n    getUnitsByOwner(ownerId) {\n        const allUnits = this.getAllUnits();\n        return allUnits.filter((entity)=>{\n            const unit = entity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n            return unit && unit.ownerId === ownerId;\n        });\n    }\n    onDisable() {\n        // Clean up when system is disabled\n        this.lastSpawnTime.clear();\n        this.playerPositions.clear();\n        this.towerPositions.clear();\n        this.waveUnits.clear();\n        this.currentWaveId = null;\n        this.onWaveComplete = undefined;\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ];\n        this.combatSystem = null;\n        // Unit spawning tracking\n        this.lastSpawnTime = new Map() // ownerId -> last spawn time\n        ;\n        this.spawnInterval = 45 // 45 seconds between spawns\n        ;\n        // Wave tracking\n        this.currentWaveId = null;\n        this.waveUnits = new Set() // Entity IDs of units in current wave\n        ;\n        this.waveStartTime = 0;\n        this.lastWaveCompletionTime = 0;\n        // Unit tracking\n        this.unitsToDestroy = [];\n        // Player and tower positions for targeting\n        this.playerPositions = new Map();\n        this.towerPositions = new Map();\n        // Reusable objects\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 15; // Run before combat system\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1N1bW1vbmVkVW5pdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxxREFBcUQ7QUFDTDtBQUNWO0FBRWlCO0FBQ0Y7QUFDSjtBQUNZO0FBQ3NCO0FBQ3BDO0FBSXhDLE1BQU1VLDJCQUEyQlQsK0NBQU1BO0lBb0NyQ1UsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyx3QkFBd0JDLFFBQW9CLEVBQVE7UUFDekQsSUFBSSxDQUFDQyxjQUFjLEdBQUdEO0lBQ3hCO0lBRU9FLHFCQUFxQkMsUUFBZ0IsRUFBRUMsUUFBaUIsRUFBUTtRQUNyRSxJQUFJLENBQUNDLGVBQWUsQ0FBQ0MsR0FBRyxDQUFDSCxVQUFVQyxTQUFTRyxLQUFLO0lBQ25EO0lBRU9DLG9CQUFvQkMsT0FBZSxFQUFFTCxRQUFpQixFQUFRO1FBQ25FLElBQUksQ0FBQ00sY0FBYyxDQUFDSixHQUFHLENBQUNHLFNBQVNMLFNBQVNHLEtBQUs7SUFDakQ7SUFFT0ksT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHLEtBQUssTUFBTSxxQkFBcUI7UUFFNUQsSUFBSSxDQUFDQyxjQUFjLENBQUNDLE1BQU0sR0FBRztRQUU3Qix5QkFBeUI7UUFDekIsS0FBSyxNQUFNQyxVQUFVUCxTQUFVO1lBQzdCLE1BQU1RLFlBQVlELE9BQU9FLFlBQVksQ0FBQ2pDLGdFQUFTQTtZQUMvQyxNQUFNa0MsT0FBT0gsT0FBT0UsWUFBWSxDQUFDOUIsc0VBQVlBO1lBQzdDLE1BQU1nQyxTQUFTSixPQUFPRSxZQUFZLENBQUMvQiwwREFBTUE7WUFFekMsSUFBSSxDQUFDOEIsYUFBYSxDQUFDRSxRQUFRLENBQUNDLFFBQVE7WUFFcEMsMkJBQTJCO1lBQzNCLElBQUlELEtBQUtFLFNBQVMsQ0FBQ1YsY0FBYztnQkFDL0IsaUNBQWlDO2dC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S0FBS0E7UUFDbEM7SUFDRjtJQUVPMkYsWUFBa0I7UUFDdkIsbUNBQW1DO1FBQ25DLElBQUksQ0FBQ25DLGFBQWEsQ0FBQ00sS0FBSztRQUN4QixJQUFJLENBQUMxRyxlQUFlLENBQUMwRyxLQUFLO1FBQzFCLElBQUksQ0FBQ3JHLGNBQWMsQ0FBQ3FHLEtBQUs7UUFDekIsSUFBSSxDQUFDdEYsU0FBUyxDQUFDc0YsS0FBSztRQUNwQixJQUFJLENBQUNmLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUMvRixjQUFjLEdBQUc0STtJQUN4QjtJQXBiQUMsWUFBWTFHLEtBQVksQ0FBRTtRQUN4QixLQUFLO2FBOUJTMkcscUJBQXFCO1lBQUMzSixnRUFBU0E7WUFBRUcsc0VBQVlBO1lBQUVELDBEQUFNQTtTQUFDO2FBRzlEUSxlQUFvQztRQUU1Qyx5QkFBeUI7YUFDakIyRyxnQkFBcUMsSUFBSXVDLE1BQU8sNkJBQTZCOzthQUM3RXJDLGdCQUF3QixHQUFJLDRCQUE0Qjs7UUFFaEUsZ0JBQWdCO2FBQ1JYLGdCQUErQjthQUMvQnZFLFlBQXlCLElBQUl3SCxNQUFPLHNDQUFzQzs7YUFDMUVuQyxnQkFBd0I7YUFDeEJaLHlCQUFpQztRQUV6QyxnQkFBZ0I7YUFDUmpGLGlCQUEyQixFQUFFO1FBRXJDLDJDQUEyQzthQUNuQ1osa0JBQXdDLElBQUkySTthQUM1Q3RJLGlCQUF1QyxJQUFJc0k7UUFLbkQsbUJBQW1CO2FBQ1h0RSxhQUFhLElBQUl4Rix5REFBT0E7YUFDeEJnSyxjQUFjLElBQUloSyx5REFBT0E7UUFJL0IsSUFBSSxDQUFDa0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQytHLFFBQVEsR0FBRyxJQUFJLDJCQUEyQjtJQUNqRDtBQWliRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9TdW1tb25lZFVuaXRTeXN0ZW0udHM/OGMxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTdW1tb25lZFVuaXQgc3lzdGVtIGZvciBtYW5hZ2luZyBQVlAgdG93ZXIgbWluaW9uc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBTdW1tb25lZFVuaXQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1N1bW1vbmVkVW5pdCc7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIsIENvbGxpZGVyVHlwZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXInO1xuaW1wb3J0IHsgVG93ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1Rvd2VyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgQ29tYmF0U3lzdGVtIH0gZnJvbSAnLi9Db21iYXRTeXN0ZW0nO1xuXG5leHBvcnQgY2xhc3MgU3VtbW9uZWRVbml0U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFN1bW1vbmVkVW5pdCwgSGVhbHRoXTtcblxuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBjb21iYXRTeXN0ZW06IENvbWJhdFN5c3RlbSB8IG51bGwgPSBudWxsO1xuXG4gIC8vIFVuaXQgc3Bhd25pbmcgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0U3Bhd25UaW1lOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpOyAvLyBvd25lcklkIC0+IGxhc3Qgc3Bhd24gdGltZVxuICBwcml2YXRlIHNwYXduSW50ZXJ2YWw6IG51bWJlciA9IDQ1OyAvLyA0NSBzZWNvbmRzIGJldHdlZW4gc3Bhd25zXG5cbiAgLy8gV2F2ZSB0cmFja2luZ1xuICBwcml2YXRlIGN1cnJlbnRXYXZlSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHdhdmVVbml0czogU2V0PG51bWJlcj4gPSBuZXcgU2V0KCk7IC8vIEVudGl0eSBJRHMgb2YgdW5pdHMgaW4gY3VycmVudCB3YXZlXG4gIHByaXZhdGUgd2F2ZVN0YXJ0VGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBsYXN0V2F2ZUNvbXBsZXRpb25UaW1lOiBudW1iZXIgPSAwO1xuXG4gIC8vIFVuaXQgdHJhY2tpbmdcbiAgcHJpdmF0ZSB1bml0c1RvRGVzdHJveTogbnVtYmVyW10gPSBbXTtcblxuICAvLyBQbGF5ZXIgYW5kIHRvd2VyIHBvc2l0aW9ucyBmb3IgdGFyZ2V0aW5nXG4gIHByaXZhdGUgcGxheWVyUG9zaXRpb25zOiBNYXA8c3RyaW5nLCBWZWN0b3IzPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSB0b3dlclBvc2l0aW9uczogTWFwPHN0cmluZywgVmVjdG9yMz4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gV2F2ZSBjb21wbGV0aW9uIGNhbGxiYWNrXG4gIHByaXZhdGUgb25XYXZlQ29tcGxldGU/OiAoKSA9PiB2b2lkO1xuXG4gIC8vIFJldXNhYmxlIG9iamVjdHNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDE1OyAvLyBSdW4gYmVmb3JlIGNvbWJhdCBzeXN0ZW1cbiAgfVxuXG4gIHB1YmxpYyBzZXRDb21iYXRTeXN0ZW0oY29tYmF0U3lzdGVtOiBDb21iYXRTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLmNvbWJhdFN5c3RlbSA9IGNvbWJhdFN5c3RlbTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRXYXZlQ29tcGxldGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25XYXZlQ29tcGxldGUgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVQbGF5ZXJQb3NpdGlvbihwbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIHRoaXMucGxheWVyUG9zaXRpb25zLnNldChwbGF5ZXJJZCwgcG9zaXRpb24uY2xvbmUoKSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlVG93ZXJQb3NpdGlvbih0b3dlcklkOiBzdHJpbmcsIHBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy50b3dlclBvc2l0aW9ucy5zZXQodG93ZXJJZCwgcG9zaXRpb24uY2xvbmUoKSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcblxuICAgIHRoaXMudW5pdHNUb0Rlc3Ryb3kubGVuZ3RoID0gMDtcblxuICAgIC8vIFByb2Nlc3MgZXhpc3RpbmcgdW5pdHNcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgdW5pdCA9IGVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIXVuaXQgfHwgIWhlYWx0aCkgY29udGludWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIHVuaXQgaXMgZXhwaXJlZFxuICAgICAgaWYgKHVuaXQuaXNFeHBpcmVkKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICAvLyBSZW1vdmUgdW5pdCBmcm9tIHdhdmUgdHJhY2tpbmdcbiAgICAgICAgdGhpcy53YXZlVW5pdHMuZGVsZXRlKGVudGl0eS5pZCk7XG5cbiAgICAgICAgdGhpcy51bml0c1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB1bml0IGlzIGRlYWRcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkICYmICF1bml0LmlzRGVhZCkge1xuICAgICAgICB1bml0LmRpZShjdXJyZW50VGltZSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuaXQgZnJvbSB3YXZlIHRyYWNraW5nXG4gICAgICAgIHRoaXMud2F2ZVVuaXRzLmRlbGV0ZShlbnRpdHkuaWQpO1xuXG4gICAgICAgIHRoaXMudW5pdHNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpbmFjdGl2ZSBvciBkZWFkIHVuaXRzXG4gICAgICBpZiAoIXVuaXQuaXNBY3RpdmUgfHwgdW5pdC5pc0RlYWQpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBVcGRhdGUgdW5pdCBiZWhhdmlvclxuICAgICAgdGhpcy51cGRhdGVVbml0QmVoYXZpb3IoZW50aXR5LCB0cmFuc2Zvcm0sIHVuaXQsIGN1cnJlbnRUaW1lLCBkZWx0YVRpbWUpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB3YXZlIGNvbXBsZXRpb25cbiAgICB0aGlzLmNoZWNrV2F2ZUNvbXBsZXRpb24oY3VycmVudFRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIHNwYXduaW5nIG5ldyB1bml0c1xuICAgIHRoaXMuaGFuZGxlVW5pdFNwYXduaW5nKGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIERlc3Ryb3kgZXhwaXJlZCB1bml0c1xuICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgdGhpcy51bml0c1RvRGVzdHJveSkge1xuICAgICAgdGhpcy53b3JsZC5kZXN0cm95RW50aXR5KGVudGl0eUlkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVVuaXRCZWhhdmlvcihcbiAgICBlbnRpdHk6IEVudGl0eSxcbiAgICB0cmFuc2Zvcm06IFRyYW5zZm9ybSxcbiAgICB1bml0OiBTdW1tb25lZFVuaXQsXG4gICAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgICBkZWx0YVRpbWU6IG51bWJlclxuICApOiB2b2lkIHtcbiAgICAvLyBTZWFyY2ggZm9yIHRhcmdldHMgcGVyaW9kaWNhbGx5XG4gICAgaWYgKHVuaXQuY2FuU2VhcmNoRm9yVGFyZ2V0cyhjdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMuZmluZFRhcmdldEZvclVuaXQodW5pdCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIHVuaXQudXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIHRvd2FyZHMgdGFyZ2V0IHBvc2l0aW9uIGlmIG5vIHNwZWNpZmljIHRhcmdldFxuICAgIGlmICghdW5pdC5jdXJyZW50VGFyZ2V0ICYmIHVuaXQudGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgIHRoaXMubW92ZVRvd2FyZHNQb3NpdGlvbihlbnRpdHksIHRyYW5zZm9ybSwgdW5pdCwgZGVsdGFUaW1lKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tYmF0IHdpdGggY3VycmVudCB0YXJnZXRcbiAgICBpZiAodW5pdC5jdXJyZW50VGFyZ2V0ICYmIHVuaXQuY2FuQXR0YWNrKGN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5oYW5kbGVVbml0QXR0YWNrKGVudGl0eSwgdW5pdCwgY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmluZFRhcmdldEZvclVuaXQodW5pdDogU3VtbW9uZWRVbml0LCB1bml0UG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQcmlvcml0eSAxOiBGaW5kIGVuZW15IHVuaXRzIHRvIGF0dGFja1xuICAgIGNvbnN0IGVuZW15VW5pdHMgPSB0aGlzLmZpbmRFbmVteVVuaXRzKHVuaXQub3duZXJJZCwgdW5pdFBvc2l0aW9uKTtcbiAgICBpZiAoZW5lbXlVbml0cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBUYXJnZXQgdGhlIGNsb3Nlc3QgZW5lbXkgdW5pdFxuICAgICAgY29uc3QgY2xvc2VzdFVuaXQgPSB0aGlzLmZpbmRDbG9zZXN0RW50aXR5KGVuZW15VW5pdHMsIHVuaXRQb3NpdGlvbik7XG4gICAgICBpZiAoY2xvc2VzdFVuaXQpIHtcbiAgICAgICAgdW5pdC5zZXRUYXJnZXQoY2xvc2VzdFVuaXQuaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJpb3JpdHkgMjogSWYgbm8gZW5lbXkgdW5pdHMsIHRhcmdldCBlbmVteSB0b3dlclxuICAgIGNvbnN0IGVuZW15VG93ZXIgPSB0aGlzLmZpbmRFbmVteVRvd2VyKHVuaXQub3duZXJJZCwgdW5pdFBvc2l0aW9uKTtcbiAgICBpZiAoZW5lbXlUb3dlcikge1xuICAgICAgdW5pdC5zZXRUYXJnZXQoZW5lbXlUb3dlci5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTm8gdGFyZ2V0cyBmb3VuZCwgY2xlYXIgdGFyZ2V0XG4gICAgdW5pdC5jbGVhclRhcmdldCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRW5lbXlVbml0cyhvd25lcklkOiBzdHJpbmcsIHVuaXRQb3NpdGlvbjogVmVjdG9yMyk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbmVteVVuaXRzOiBFbnRpdHlbXSA9IFtdO1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFN1bW1vbmVkVW5pdCwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgYWxsRW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHN1bW1vbmVkVW5pdCA9IGVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgIGlmICghc3VtbW9uZWRVbml0IHx8ICFoZWFsdGggfHwgIWNvbGxpZGVyKSBjb250aW51ZTtcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkIHx8ICFzdW1tb25lZFVuaXQuaXNBY3RpdmUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGVuZW15IHVuaXQgKGRpZmZlcmVudCBvd25lcilcbiAgICAgIGlmIChzdW1tb25lZFVuaXQub3duZXJJZCAhPT0gb3duZXJJZCAmJiBjb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgICAgZW5lbXlVbml0cy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuZW15VW5pdHM7XG4gIH1cblxuICBwcml2YXRlIGZpbmRFbmVteVRvd2VyKG93bmVySWQ6IHN0cmluZywgdW5pdFBvc2l0aW9uOiBWZWN0b3IzKTogRW50aXR5IHwgbnVsbCB7XG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aCwgQ29sbGlkZXJdKTtcblxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGFsbEVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcblxuICAgICAgaWYgKCF0b3dlciB8fCAhaGVhbHRoIHx8ICFjb2xsaWRlcikgY29udGludWU7XG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCB8fCAhdG93ZXIuaXNBY3RpdmUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIGVuZW15IHRvd2VyXG4gICAgICBpZiAodG93ZXIub3duZXJJZCAhPT0gb3duZXJJZCAmJiBjb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgZmluZENsb3Nlc3RFbnRpdHkoZW50aXRpZXM6IEVudGl0eVtdLCBmcm9tUG9zaXRpb246IFZlY3RvcjMpOiBFbnRpdHkgfCBudWxsIHtcbiAgICBsZXQgY2xvc2VzdEVudGl0eTogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmICghdHJhbnNmb3JtKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBmcm9tUG9zaXRpb24uZGlzdGFuY2VUbyh0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICBjbG9zZXN0RW50aXR5ID0gZW50aXR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0RW50aXR5O1xuICB9XG5cbiAgcHJpdmF0ZSBtb3ZlVG93YXJkc1Bvc2l0aW9uKFxuICAgIGVudGl0eTogRW50aXR5LFxuICAgIHRyYW5zZm9ybTogVHJhbnNmb3JtLFxuICAgIHVuaXQ6IFN1bW1vbmVkVW5pdCxcbiAgICBkZWx0YVRpbWU6IG51bWJlclxuICApOiB2b2lkIHtcbiAgICBpZiAoIXVuaXQudGFyZ2V0UG9zaXRpb24pIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRQb3MgPSB0cmFuc2Zvcm0ucG9zaXRpb247XG4gICAgY29uc3QgdGFyZ2V0UG9zID0gbmV3IFZlY3RvcjModW5pdC50YXJnZXRQb3NpdGlvbi54LCB1bml0LnRhcmdldFBvc2l0aW9uLnksIHVuaXQudGFyZ2V0UG9zaXRpb24ueik7XG5cbiAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFBvcykuc3ViKGN1cnJlbnRQb3MpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy50ZW1wVmVjdG9yLmxlbmd0aCgpO1xuXG4gICAgLy8gSWYgY2xvc2UgZW5vdWdoIHRvIHRhcmdldCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICBpZiAoZGlzdGFuY2UgPCAwLjUpIHtcbiAgICAgIHVuaXQudGFyZ2V0UG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBhbmQgbW92ZVxuICAgIHRoaXMudGVtcFZlY3Rvci5ub3JtYWxpemUoKTtcbiAgICBjb25zdCBtb3ZlRGlzdGFuY2UgPSB1bml0Lm1vdmVTcGVlZCAqIGRlbHRhVGltZTtcblxuICAgIGlmIChtb3ZlRGlzdGFuY2UgPCBkaXN0YW5jZSkge1xuICAgICAgLy8gTW92ZSB0b3dhcmRzIHRhcmdldFxuICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBjdXJyZW50UG9zLmNsb25lKCkuYWRkKHRoaXMudGVtcFZlY3Rvci5tdWx0aXBseVNjYWxhcihtb3ZlRGlzdGFuY2UpKTtcbiAgICAgIHRyYW5zZm9ybS5zZXRQb3NpdGlvbihuZXdQb3NpdGlvbi54LCBuZXdQb3NpdGlvbi55LCBuZXdQb3NpdGlvbi56KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXJyaXZlZCBhdCB0YXJnZXRcbiAgICAgIHRyYW5zZm9ybS5zZXRQb3NpdGlvbih0YXJnZXRQb3MueCwgdGFyZ2V0UG9zLnksIHRhcmdldFBvcy56KTtcbiAgICAgIHVuaXQudGFyZ2V0UG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtb3ZlbWVudCBjb21wb25lbnQgaWYgaXQgZXhpc3RzXG4gICAgY29uc3QgbW92ZW1lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAobW92ZW1lbnQpIHtcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LmNvcHkodGhpcy50ZW1wVmVjdG9yKS5tdWx0aXBseVNjYWxhcih1bml0Lm1vdmVTcGVlZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVVbml0QXR0YWNrKGVudGl0eTogRW50aXR5LCB1bml0OiBTdW1tb25lZFVuaXQsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXVuaXQuY3VycmVudFRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0RW50aXR5ID0gdGhpcy53b3JsZC5nZXRFbnRpdHkodW5pdC5jdXJyZW50VGFyZ2V0KTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgdW5pdC5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldEVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXRFbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG5cbiAgICBpZiAoIXRhcmdldFRyYW5zZm9ybSB8fCAhdGFyZ2V0SGVhbHRoKSB7XG4gICAgICB1bml0LmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHN0aWxsIGluIHJhbmdlXG4gICAgY29uc3QgdW5pdFRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXVuaXRUcmFuc2Zvcm0pIHJldHVybjtcblxuICAgIGNvbnN0IGRpc3RhbmNlID0gdW5pdFRyYW5zZm9ybS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgaWYgKGRpc3RhbmNlID4gdW5pdC5hdHRhY2tSYW5nZSkge1xuICAgICAgdW5pdC5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBzdGlsbCBhbGl2ZVxuICAgIGlmICh0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICB1bml0LmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBhdHRhY2tcbiAgICBpZiAodGhpcy5jb21iYXRTeXN0ZW0pIHtcbiAgICAgIC8vIFVzZSBjb21iYXQgc3lzdGVtIHRvIGhhbmRsZSBkYW1hZ2VcbiAgICAgIHRoaXMuY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKHRhcmdldEVudGl0eSwgdW5pdC5hdHRhY2tEYW1hZ2UsIGVudGl0eSwgJ21lbGVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIGRpcmVjdCBkYW1hZ2VcbiAgICAgIHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKHVuaXQuYXR0YWNrRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0RW50aXR5KTtcbiAgICB9XG5cbiAgICB1bml0LnBlcmZvcm1BdHRhY2soY3VycmVudFRpbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja1dhdmVDb21wbGV0aW9uKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHdhdmUgaXMgY29tcGxldGUgKGFsbCB1bml0cyBkZWFkIG9yIGV4cGlyZWQpXG4gICAgaWYgKHRoaXMuY3VycmVudFdhdmVJZCAmJiB0aGlzLndhdmVVbml0cy5zaXplID09PSAwKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgZG9uJ3Qgc3BhbSB0aGUgY2FsbGJhY2sgKG1pbmltdW0gMzAgc2Vjb25kcyBiZXR3ZWVuIHdhdmUgY29tcGxldGlvbnMpXG4gICAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RXYXZlQ29tcGxldGlvblRpbWUgPj0gMzApIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfjq8gV2F2ZSAke3RoaXMuY3VycmVudFdhdmVJZH0gY29tcGxldGVkISBBd2FyZGluZyBleHBlcmllbmNlIHRvIGFsbCBwbGF5ZXJzLmApO1xuXG4gICAgICAgIC8vIEF3YXJkIGV4cGVyaWVuY2UgdG8gYWxsIHBsYXllcnNcbiAgICAgICAgaWYgKHRoaXMub25XYXZlQ29tcGxldGUpIHtcbiAgICAgICAgICB0aGlzLm9uV2F2ZUNvbXBsZXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3RXYXZlQ29tcGxldGlvblRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5jdXJyZW50V2F2ZUlkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVVuaXRTcGF3bmluZyhjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCB0b3dlcnMgdG8gY2hlY2sgZm9yIHNwYXduaW5nXG4gICAgY29uc3QgdG93ZXJzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFRvd2VyLCBIZWFsdGhdKTtcblxuICAgIGZvciAoY29uc3QgdG93ZXJFbnRpdHkgb2YgdG93ZXJzKSB7XG4gICAgICBjb25zdCB0b3dlciA9IHRvd2VyRW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCB0b3dlclRyYW5zZm9ybSA9IHRvd2VyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuXG4gICAgICBpZiAoIXRvd2VyIHx8ICF0b3dlclRyYW5zZm9ybSkgY29udGludWU7XG4gICAgICBpZiAoIXRvd2VyLmlzQWN0aXZlIHx8IHRvd2VyLmlzRGVhZCkgY29udGludWU7XG5cbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgdGltZSB0byBzcGF3biB1bml0cyBmb3IgdGhpcyB0b3dlclxuICAgICAgY29uc3QgbGFzdFNwYXduID0gdGhpcy5sYXN0U3Bhd25UaW1lLmdldCh0b3dlci5vd25lcklkKSB8fCAwO1xuICAgICAgaWYgKGN1cnJlbnRUaW1lIC0gbGFzdFNwYXduID49IHRoaXMuc3Bhd25JbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnNwYXduVW5pdHNGb3JUb3dlcih0b3dlciwgdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgdGhpcy5sYXN0U3Bhd25UaW1lLnNldCh0b3dlci5vd25lcklkLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzcGF3blVuaXRzRm9yVG93ZXIodG93ZXI6IFRvd2VyLCB0b3dlclBvc2l0aW9uOiBWZWN0b3IzLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gU3RhcnQgYSBuZXcgd2F2ZSBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0b3dlciBzcGF3bmluZyBpbiB0aGlzIGN5Y2xlXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRXYXZlSWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFdhdmVJZCA9IGB3YXZlXyR7Y3VycmVudFRpbWV9YDtcbiAgICAgIHRoaXMud2F2ZVN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy53YXZlVW5pdHMuY2xlYXIoKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yKIFN0YXJ0aW5nIG5ldyB3YXZlOiAke3RoaXMuY3VycmVudFdhdmVJZH1gKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBvcHBvc2luZyB0b3dlciBwb3NpdGlvbiBmb3IgdGFyZ2V0aW5nXG4gICAgbGV0IG9wcG9zaW5nVG93ZXJQb3NpdGlvbiA9IHRoaXMuZmluZE9wcG9zaW5nVG93ZXJQb3NpdGlvbih0b3dlci5vd25lcklkKTtcblxuICAgIC8vIElmIG5vIG9wcG9zaW5nIHRvd2VyIGZvdW5kLCB1c2UgYSBkZWZhdWx0IHBvc2l0aW9uIGluIGZyb250IG9mIGN1cnJlbnQgdG93ZXJcbiAgICBpZiAoIW9wcG9zaW5nVG93ZXJQb3NpdGlvbikge1xuICAgICAgb3Bwb3NpbmdUb3dlclBvc2l0aW9uID0gdG93ZXJQb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVmVjdG9yMygwLCAwLCAyMCkpO1xuICAgIH1cblxuICAgIC8vIFNwYXduIDMgdW5pdHMgYW5kIHRyYWNrIHRoZW0gaW4gdGhlIHdhdmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgY29uc3QgdW5pdEVudGl0eSA9IHRoaXMuc3Bhd25Vbml0KHRvd2VyLm93bmVySWQsIHRvd2VyUG9zaXRpb24sIG9wcG9zaW5nVG93ZXJQb3NpdGlvbiwgaSwgY3VycmVudFRpbWUpO1xuICAgICAgaWYgKHVuaXRFbnRpdHkpIHtcbiAgICAgICAgdGhpcy53YXZlVW5pdHMuYWRkKHVuaXRFbnRpdHkuaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmluZE9wcG9zaW5nVG93ZXJQb3NpdGlvbihvd25lcklkOiBzdHJpbmcpOiBWZWN0b3IzIHwgbnVsbCB7XG4gICAgY29uc3QgdG93ZXJzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFRvd2VyLCBIZWFsdGhdKTtcblxuICAgIGZvciAoY29uc3QgdG93ZXJFbnRpdHkgb2YgdG93ZXJzKSB7XG4gICAgICBjb25zdCB0b3dlciA9IHRvd2VyRW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCB0b3dlclRyYW5zZm9ybSA9IHRvd2VyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuXG4gICAgICBpZiAoIXRvd2VyIHx8ICF0b3dlclRyYW5zZm9ybSkgY29udGludWU7XG4gICAgICBpZiAodG93ZXIub3duZXJJZCAhPT0gb3duZXJJZCkge1xuICAgICAgICByZXR1cm4gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgc3Bhd25Vbml0KFxuICAgIG93bmVySWQ6IHN0cmluZyxcbiAgICBzcGF3blBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIHRhcmdldFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIHVuaXRJbmRleDogbnVtYmVyLFxuICAgIGN1cnJlbnRUaW1lOiBudW1iZXJcbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCB1bml0RW50aXR5ID0gdGhpcy53b3JsZC5jcmVhdGVFbnRpdHkoKTtcbiAgICBjb25zdCB1bml0SWQgPSBgJHtvd25lcklkfV91bml0XyR7Y3VycmVudFRpbWV9XyR7dW5pdEluZGV4fWA7XG5cbiAgICAvLyBBZGQgb2Zmc2V0IHRvIHNwYXduIHBvc2l0aW9uIHRvIGF2b2lkIHN0YWNraW5nXG4gICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoXG4gICAgICAodW5pdEluZGV4IC0gMC41KSAqIDIsIC8vIFNwcmVhZCB1bml0cyBsZWZ0L3JpZ2h0XG4gICAgICAwLFxuICAgICAgMFxuICAgICk7XG4gICAgY29uc3QgYWN0dWFsU3Bhd25Qb3NpdGlvbiA9IHNwYXduUG9zaXRpb24uY2xvbmUoKS5hZGQob2Zmc2V0KTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy53b3JsZC5jcmVhdGVDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24oYWN0dWFsU3Bhd25Qb3NpdGlvbi54LCBhY3R1YWxTcGF3blBvc2l0aW9uLnksIGFjdHVhbFNwYXduUG9zaXRpb24ueik7XG4gICAgdW5pdEVudGl0eS5hZGRDb21wb25lbnQodHJhbnNmb3JtKTtcblxuICAgIC8vIEFkZCBTdW1tb25lZFVuaXQgY29tcG9uZW50XG4gICAgY29uc3Qgc3VtbW9uZWRVbml0ID0gdGhpcy53b3JsZC5jcmVhdGVDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBzdW1tb25lZFVuaXQub3duZXJJZCA9IG93bmVySWQ7XG4gICAgc3VtbW9uZWRVbml0LnVuaXRJZCA9IHVuaXRJZDtcbiAgICBzdW1tb25lZFVuaXQudGFyZ2V0UG9zaXRpb24gPSB7XG4gICAgICB4OiB0YXJnZXRQb3NpdGlvbi54LFxuICAgICAgeTogdGFyZ2V0UG9zaXRpb24ueSxcbiAgICAgIHo6IHRhcmdldFBvc2l0aW9uLnpcbiAgICB9O1xuICAgIHN1bW1vbmVkVW5pdC5zdW1tb25UaW1lID0gY3VycmVudFRpbWU7XG4gICAgdW5pdEVudGl0eS5hZGRDb21wb25lbnQoc3VtbW9uZWRVbml0KTtcblxuICAgIC8vIEFkZCBIZWFsdGggY29tcG9uZW50XG4gICAgY29uc3QgaGVhbHRoID0gbmV3IEhlYWx0aChzdW1tb25lZFVuaXQubWF4SGVhbHRoKTtcbiAgICB1bml0RW50aXR5LmFkZENvbXBvbmVudChoZWFsdGgpO1xuXG4gICAgLy8gQWRkIE1vdmVtZW50IGNvbXBvbmVudFxuICAgIGNvbnN0IG1vdmVtZW50ID0gdGhpcy53b3JsZC5jcmVhdGVDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIG1vdmVtZW50Lm1heFNwZWVkID0gc3VtbW9uZWRVbml0Lm1vdmVTcGVlZDtcbiAgICBtb3ZlbWVudC5mcmljdGlvbiA9IDAuOTtcbiAgICB1bml0RW50aXR5LmFkZENvbXBvbmVudChtb3ZlbWVudCk7XG5cbiAgICAvLyBBZGQgQ29sbGlkZXIgY29tcG9uZW50XG4gICAgY29uc3QgY29sbGlkZXIgPSB0aGlzLndvcmxkLmNyZWF0ZUNvbXBvbmVudChDb2xsaWRlcik7XG4gICAgY29sbGlkZXIudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7IC8vIFVzZSBzcGhlcmUgY29sbGlkZXIgZm9yIHVuaXRzXG4gICAgY29sbGlkZXIucmFkaXVzID0gMC41O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuRU5FTVk7IC8vIFVzZSBlbmVteSBsYXllciBmb3IgUFZQXG4gICAgY29sbGlkZXIuc2V0T2Zmc2V0KDAsIDAuNiwgMCk7IC8vIENlbnRlciBvbiB1bml0XG4gICAgdW5pdEVudGl0eS5hZGRDb21wb25lbnQoY29sbGlkZXIpO1xuXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZCh1bml0RW50aXR5KTtcblxuICAgIHJldHVybiB1bml0RW50aXR5O1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzIGZvciBleHRlcm5hbCBhY2Nlc3NcbiAgcHVibGljIGdldFVuaXRDb3VudChvd25lcklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IHVuaXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFN1bW1vbmVkVW5pdCwgSGVhbHRoXSk7XG4gICAgcmV0dXJuIHVuaXRzLmZpbHRlcihlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgdW5pdCA9IGVudGl0eS5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIHJldHVybiB1bml0ICYmIGhlYWx0aCAmJiB1bml0Lm93bmVySWQgPT09IG93bmVySWQgJiYgdW5pdC5pc0FjdGl2ZSAmJiAhdW5pdC5pc0RlYWQgJiYgIWhlYWx0aC5pc0RlYWQ7XG4gICAgfSkubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldEFsbFVuaXRzKCk6IEVudGl0eVtdIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFN1bW1vbmVkVW5pdCwgSGVhbHRoXSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0VW5pdHNCeU93bmVyKG93bmVySWQ6IHN0cmluZyk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBhbGxVbml0cyA9IHRoaXMuZ2V0QWxsVW5pdHMoKTtcbiAgICByZXR1cm4gYWxsVW5pdHMuZmlsdGVyKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCB1bml0ID0gZW50aXR5LmdldENvbXBvbmVudChTdW1tb25lZFVuaXQpO1xuICAgICAgcmV0dXJuIHVuaXQgJiYgdW5pdC5vd25lcklkID09PSBvd25lcklkO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCB3aGVuIHN5c3RlbSBpcyBkaXNhYmxlZFxuICAgIHRoaXMubGFzdFNwYXduVGltZS5jbGVhcigpO1xuICAgIHRoaXMucGxheWVyUG9zaXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy50b3dlclBvc2l0aW9ucy5jbGVhcigpO1xuICAgIHRoaXMud2F2ZVVuaXRzLmNsZWFyKCk7XG4gICAgdGhpcy5jdXJyZW50V2F2ZUlkID0gbnVsbDtcbiAgICB0aGlzLm9uV2F2ZUNvbXBsZXRlID0gdW5kZWZpbmVkO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwiSGVhbHRoIiwiU3VtbW9uZWRVbml0IiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIkNvbGxpZGVyVHlwZSIsIlRvd2VyIiwiU3VtbW9uZWRVbml0U3lzdGVtIiwic2V0Q29tYmF0U3lzdGVtIiwiY29tYmF0U3lzdGVtIiwic2V0V2F2ZUNvbXBsZXRlQ2FsbGJhY2siLCJjYWxsYmFjayIsIm9uV2F2ZUNvbXBsZXRlIiwidXBkYXRlUGxheWVyUG9zaXRpb24iLCJwbGF5ZXJJZCIsInBvc2l0aW9uIiwicGxheWVyUG9zaXRpb25zIiwic2V0IiwiY2xvbmUiLCJ1cGRhdGVUb3dlclBvc2l0aW9uIiwidG93ZXJJZCIsInRvd2VyUG9zaXRpb25zIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJ1bml0c1RvRGVzdHJveSIsImxlbmd0aCIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsInVuaXQiLCJoZWFsdGgiLCJpc0V4cGlyZWQiLCJ3YXZlVW5pdHMiLCJkZWxldGUiLCJpZCIsInB1c2giLCJpc0RlYWQiLCJkaWUiLCJpc0FjdGl2ZSIsInVwZGF0ZVVuaXRCZWhhdmlvciIsImNoZWNrV2F2ZUNvbXBsZXRpb24iLCJoYW5kbGVVbml0U3Bhd25pbmciLCJlbnRpdHlJZCIsIndvcmxkIiwiZGVzdHJveUVudGl0eSIsImNhblNlYXJjaEZvclRhcmdldHMiLCJmaW5kVGFyZ2V0Rm9yVW5pdCIsInVwZGF0ZVRhcmdldFNlYXJjaCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRQb3NpdGlvbiIsIm1vdmVUb3dhcmRzUG9zaXRpb24iLCJjYW5BdHRhY2siLCJoYW5kbGVVbml0QXR0YWNrIiwidW5pdFBvc2l0aW9uIiwiZW5lbXlVbml0cyIsImZpbmRFbmVteVVuaXRzIiwib3duZXJJZCIsImNsb3Nlc3RVbml0IiwiZmluZENsb3Nlc3RFbnRpdHkiLCJzZXRUYXJnZXQiLCJlbmVteVRvd2VyIiwiZmluZEVuZW15VG93ZXIiLCJjbGVhclRhcmdldCIsImFsbEVudGl0aWVzIiwicXVlcnlFbnRpdGllcyIsInN1bW1vbmVkVW5pdCIsImNvbGxpZGVyIiwibGF5ZXIiLCJFTkVNWSIsInRvd2VyIiwiZnJvbVBvc2l0aW9uIiwiY2xvc2VzdEVudGl0eSIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiY3VycmVudFBvcyIsInRhcmdldFBvcyIsIngiLCJ5IiwieiIsInRlbXBWZWN0b3IiLCJjb3B5Iiwic3ViIiwibm9ybWFsaXplIiwibW92ZURpc3RhbmNlIiwibW92ZVNwZWVkIiwibmV3UG9zaXRpb24iLCJhZGQiLCJtdWx0aXBseVNjYWxhciIsInNldFBvc2l0aW9uIiwibW92ZW1lbnQiLCJ2ZWxvY2l0eSIsInRhcmdldEVudGl0eSIsImdldEVudGl0eSIsInRhcmdldFRyYW5zZm9ybSIsInRhcmdldEhlYWx0aCIsInVuaXRUcmFuc2Zvcm0iLCJhdHRhY2tSYW5nZSIsInF1ZXVlRGFtYWdlIiwiYXR0YWNrRGFtYWdlIiwidGFrZURhbWFnZSIsInBlcmZvcm1BdHRhY2siLCJjdXJyZW50V2F2ZUlkIiwic2l6ZSIsImxhc3RXYXZlQ29tcGxldGlvblRpbWUiLCJjb25zb2xlIiwibG9nIiwidG93ZXJzIiwidG93ZXJFbnRpdHkiLCJ0b3dlclRyYW5zZm9ybSIsImxhc3RTcGF3biIsImxhc3RTcGF3blRpbWUiLCJnZXQiLCJzcGF3bkludGVydmFsIiwic3Bhd25Vbml0c0ZvclRvd2VyIiwidG93ZXJQb3NpdGlvbiIsIndhdmVTdGFydFRpbWUiLCJjbGVhciIsIm9wcG9zaW5nVG93ZXJQb3NpdGlvbiIsImZpbmRPcHBvc2luZ1Rvd2VyUG9zaXRpb24iLCJpIiwidW5pdEVudGl0eSIsInNwYXduVW5pdCIsInNwYXduUG9zaXRpb24iLCJ1bml0SW5kZXgiLCJjcmVhdGVFbnRpdHkiLCJ1bml0SWQiLCJvZmZzZXQiLCJhY3R1YWxTcGF3blBvc2l0aW9uIiwiY3JlYXRlQ29tcG9uZW50IiwiYWRkQ29tcG9uZW50Iiwic3VtbW9uVGltZSIsIm1heEhlYWx0aCIsIm1heFNwZWVkIiwiZnJpY3Rpb24iLCJ0eXBlIiwiU1BIRVJFIiwicmFkaXVzIiwic2V0T2Zmc2V0Iiwibm90aWZ5RW50aXR5QWRkZWQiLCJnZXRVbml0Q291bnQiLCJ1bml0cyIsImZpbHRlciIsImdldEFsbFVuaXRzIiwiZ2V0VW5pdHNCeU93bmVyIiwiYWxsVW5pdHMiLCJvbkRpc2FibGUiLCJ1bmRlZmluZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsIlNldCIsInRlbXBWZWN0b3IyIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/SummonedUnitSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/TowerSystem.ts":
/*!************************************!*\
  !*** ./src/systems/TowerSystem.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TowerSystem: function() { return /* binding */ TowerSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n/* harmony import */ var _ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/SummonedUnit */ \"(app-pages-browser)/./src/ecs/components/SummonedUnit.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n// Tower system for managing PVP tower AI, targeting, and shooting\n\n\n\n\n\n\n\n\nclass TowerSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setProjectileSystem(projectileSystem) {\n        this.projectileSystem = projectileSystem;\n    }\n    setTowerAttackCallback(callback) {\n        this.onTowerAttackCallback = callback;\n    }\n    setPlayerMapping(serverPlayerEntities, localSocketId) {\n        this.serverPlayerEntities = serverPlayerEntities;\n        this.localSocketId = localSocketId;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            if (!transform || !tower || !health) continue;\n            // Check if tower is dead\n            if (health.isDead && !tower.isDead) {\n                tower.die(currentTime);\n                continue;\n            }\n            // Skip inactive or dead towers\n            if (!tower.isActive || tower.isDead) continue;\n            // Search for targets periodically\n            if (tower.canSearchForTargets(currentTime)) {\n                this.searchForTarget(entity, transform, tower, currentTime);\n            }\n            // Validate current target (check if still alive and in range)\n            if (tower.currentTarget) {\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                if (!this.isValidTarget(targetEntity || null, transform, tower)) {\n                    tower.clearTarget();\n                }\n            }\n            // Attack current target if possible\n            if (tower.currentTarget && tower.canAttack(currentTime)) {\n                this.attackTarget(entity, transform, tower, currentTime);\n            }\n        }\n    }\n    searchForTarget(towerEntity, towerTransform, tower, currentTime) {\n        tower.updateTargetSearch(currentTime);\n        // Get all potential targets (players that are not the tower owner)\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        let closestTarget = null;\n        let closestDistance = Infinity;\n        let validTargetCount = 0;\n        for (const target of potentialTargets){\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (targetCollider && targetTransform) {\n                const distance = towerTransform.position.distanceTo(targetTransform.position);\n            }\n            if (!this.isValidTarget(target, towerTransform, tower)) continue;\n            validTargetCount++;\n            const targetTransform2 = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetTransform2) continue;\n            const distance = towerTransform.position.distanceTo(targetTransform2.position);\n            if (distance <= tower.targetSearchRange && distance < closestDistance) {\n                closestTarget = target;\n                closestDistance = distance;\n            }\n        }\n        if (closestTarget) {\n            tower.setTarget(closestTarget.id);\n        } else if (tower.currentTarget) {\n            // Clear target if no valid targets found\n            tower.clearTarget();\n        }\n    }\n    isValidTarget(target, towerTransform, tower) {\n        if (!target) {\n            return false;\n        }\n        const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n        const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n        // Must have required components and be alive\n        if (!targetHealth || !targetTransform || !targetCollider || targetHealth.isDead) {\n            return false;\n        }\n        // Must be a player (not an enemy or other tower)\n        if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.PLAYER && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.ENEMY) {\n            return false;\n        }\n        // Don't target other towers\n        if (target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)) {\n            return false;\n        }\n        // Check if this is a summoned unit\n        const summonedUnit = target.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit);\n        if (summonedUnit) {\n            // Only target enemy summoned units (different owner)\n            return summonedUnit.ownerId !== tower.ownerId;\n        }\n        // In PVP mode, identify if this is an enemy player\n        if (this.localSocketId && this.serverPlayerEntities.size > 0) {\n            // Check if this is the local player (PLAYER layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.PLAYER) {\n                const shouldTarget = tower.ownerId !== this.localSocketId;\n                return shouldTarget;\n            }\n            // Check if this is a remote player (ENEMY layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.CollisionLayer.ENEMY) {\n                // Find which player this entity belongs to\n                let targetPlayerId = null;\n                this.serverPlayerEntities.forEach((entityId, playerId)=>{\n                    if (entityId === target.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n                if (targetPlayerId) {\n                    const shouldTarget = tower.ownerId !== targetPlayerId;\n                    return shouldTarget;\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n    attackTarget(towerEntity, towerTransform, tower, currentTime) {\n        const targetEntity = this.world.getEntity(tower.currentTarget);\n        if (!targetEntity) {\n            tower.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            tower.clearTarget();\n            return;\n        }\n        // Calculate projectile spawn position (slightly above tower center)\n        this.tempVector2.copy(towerTransform.position);\n        this.tempVector2.y += 2; // Spawn projectiles 2 units above tower base\n        // Calculate direction from spawn position to target (not tower base)\n        this.tempVector.copy(targetTransform.position);\n        this.tempVector.sub(this.tempVector2);\n        const distance = this.tempVector.length();\n        // Check if target is still in range\n        if (distance > tower.attackRange) {\n            tower.clearTarget();\n            return;\n        }\n        // Special handling for very close targets - ensure we can always hit them\n        if (distance < 0.5) {\n            // For extremely close targets, create a more predictable trajectory\n            // Aim slightly above the target to account for gravity and ensure hit\n            this.tempVector.copy(targetTransform.position);\n            this.tempVector.y += 0.3; // Aim 0.3 units above target\n            this.tempVector.sub(this.tempVector2);\n            this.tempVector.normalize();\n        } else {\n            // Normalize direction for normal cases\n            this.tempVector.normalize();\n        }\n        // Create projectile\n        if (this.projectileSystem) {\n            const projectileConfig = {\n                speed: tower.projectileSpeed,\n                damage: tower.attackDamage,\n                lifetime: 2,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, this.tempVector2, this.tempVector, towerEntity.id, projectileConfig);\n            // Enable extremely strong homing for tower projectiles\n            const projectile = projectileEntity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_6__.Projectile);\n            if (projectile && tower.currentTarget) {\n                // Check if target is a summoned unit for special handling\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                const isSummonedUnit = (targetEntity === null || targetEntity === void 0 ? void 0 : targetEntity.getComponent(_ecs_components_SummonedUnit__WEBPACK_IMPORTED_MODULE_5__.SummonedUnit)) !== undefined;\n                if (isSummonedUnit) {\n                    // Make it IMPOSSIBLE for summoned units to dodge - perfect tracking\n                    projectile.setHoming(tower.currentTarget, 1.0, 8.0);\n                } else {\n                    // For players: very difficult to dodge but not impossible\n                    projectile.setHoming(tower.currentTarget, 0.95, 6.0);\n                }\n                // Add special tower projectile properties for enhanced tracking\n                projectile.maxTurnRate = isSummonedUnit ? 12.0 : 8.0; // Even faster turns for summoned units\n            }\n            // Mark projectile as tower projectile for special handling\n            const projectileRenderer = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (projectileRenderer) {\n                // Add metadata to identify this as a tower projectile\n                projectileEntity.isTowerProjectile = true;\n                projectileEntity.towerOwnerId = tower.ownerId;\n            }\n        }\n        // Broadcast attack to multiplayer if callback is set\n        if (this.onTowerAttackCallback) {\n            // We need to map the target entity back to a player ID\n            // For now, we'll use a placeholder - this will need to be improved with proper player mapping\n            const targetPlayerId = \"player_\".concat(tower.currentTarget);\n            this.onTowerAttackCallback(tower.ownerId, targetPlayerId, this.tempVector2, this.tempVector);\n        }\n        tower.performAttack(currentTime);\n    }\n    // Utility method to get all towers owned by a specific player\n    getTowersByOwner(ownerId) {\n        const allTowers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ]);\n        return allTowers.filter((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            return tower && tower.ownerId === ownerId;\n        });\n    }\n    // Utility method to get tower count for a player\n    getTowerCount(ownerId) {\n        return this.getTowersByOwner(ownerId).length;\n    }\n    // Utility method to check if a player has any active towers\n    hasActiveTowers(ownerId) {\n        const towers = this.getTowersByOwner(ownerId);\n        return towers.some((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            return tower && health && tower.isActive && !tower.isDead && !health.isDead;\n        });\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ];\n        this.projectileSystem = null;\n        // Player entity mapping for identifying tower owners vs enemies\n        this.serverPlayerEntities = new Map();\n        this.localSocketId = null;\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 25; // Run after movement and projectiles\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRWlCO0FBQ047QUFDRjtBQUNjO0FBQ0o7QUFDWTtBQUk5RCxNQUFNUyxvQkFBb0JSLCtDQUFNQTtJQXNCOUJTLG9CQUFvQkMsZ0JBQWtDLEVBQVE7UUFDbkUsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBR0E7SUFDMUI7SUFFT0MsdUJBQXVCQyxRQUF1RyxFQUFRO1FBQzNJLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRU9FLGlCQUFpQkMsb0JBQXlDLEVBQUVDLGFBQXFCLEVBQVE7UUFDOUYsSUFBSSxDQUFDRCxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxhQUFhLEdBQUdBO0lBQ3ZCO0lBRU9DLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRyxLQUFLLE1BQU0scUJBQXFCO1FBRTVELEtBQUssTUFBTUMsVUFBVUwsU0FBVTtZQUM3QixNQUFNTSxZQUFZRCxPQUFPRSxZQUFZLENBQUN4QixnRUFBU0E7WUFDL0MsTUFBTXlCLFFBQVFILE9BQU9FLFlBQVksQ0FBQ3RCLHdEQUFLQTtZQUN2QyxNQUFNd0IsU0FBU0osT0FBT0UsWUFBWSxDQUFDdkIsMERBQU1BO1lBRXpDLElBQUksQ0FBQ3NCLGFBQWEsQ0FBQ0UsU0FBUyxDQUFDQyxRQUFRO1lBRXJDLHlCQUF5QjtZQUN6QixJQUFJQSxPQUFPQyxNQUFNLElBQUksQ0FBQ0YsTUFBTUUsTUFBTSxFQUFFO2dCQUNsQ0YsTUFBTUcsR0FBRyxDQUFDVDtnQkFDVjtZQUNGO1lBRUEsK0JBQStCO1lBQy9CLElBQUksQ0FBQ00sTUFBTUksUUFBUSxJQUFJSixNQUFNRSxNQUFNLEVBQUU7WUFFckMsa0NBQWtDO1lBQ2xDLElBQUlGLE1BQU1LLG1CQUFtQixDQUFDWCxjQUFjO2dC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Syx1QkFBNEMsSUFBSTZGO2FBQ2hENUYsZ0JBQStCO1FBRXZDLHlDQUF5QzthQUNqQzRELGFBQWEsSUFBSTdFLHlEQUFPQTthQUN4QjBFLGNBQWMsSUFBSTFFLHlEQUFPQTtRQUkvQixJQUFJLENBQUNvQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDMEUsUUFBUSxHQUFHLElBQUkscUNBQXFDO0lBQzNEO0FBdVJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzPzZiMjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVG93ZXIgc3lzdGVtIGZvciBtYW5hZ2luZyBQVlAgdG93ZXIgQUksIHRhcmdldGluZywgYW5kIHNob290aW5nXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgSGVhbHRoIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9IZWFsdGgnO1xuaW1wb3J0IHsgVG93ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1Rvd2VyJztcbmltcG9ydCB7IFN1bW1vbmVkVW5pdCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvU3VtbW9uZWRVbml0JztcbmltcG9ydCB7IFByb2plY3RpbGUgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1Byb2plY3RpbGUnO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IFByb2plY3RpbGVTeXN0ZW0gfSBmcm9tICcuL1Byb2plY3RpbGVTeXN0ZW0nO1xuXG5leHBvcnQgY2xhc3MgVG93ZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aF07XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgdG93ZXIgYXR0YWNrcyBpbiBtdWx0aXBsYXllclxuICBwcml2YXRlIG9uVG93ZXJBdHRhY2tDYWxsYmFjaz86ICh0b3dlck93bmVySWQ6IHN0cmluZywgdGFyZ2V0UGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIFBsYXllciBlbnRpdHkgbWFwcGluZyBmb3IgaWRlbnRpZnlpbmcgdG93ZXIgb3duZXJzIHZzIGVuZW1pZXNcbiAgcHJpdmF0ZSBzZXJ2ZXJQbGF5ZXJFbnRpdGllczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBsb2NhbFNvY2tldElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIFJldXNhYmxlIG9iamVjdHMgdG8gcmVkdWNlIGFsbG9jYXRpb25zXG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyNTsgLy8gUnVuIGFmdGVyIG1vdmVtZW50IGFuZCBwcm9qZWN0aWxlc1xuICB9XG4gIFxuICBwdWJsaWMgc2V0UHJvamVjdGlsZVN5c3RlbShwcm9qZWN0aWxlU3lzdGVtOiBQcm9qZWN0aWxlU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtID0gcHJvamVjdGlsZVN5c3RlbTtcbiAgfVxuICBcbiAgcHVibGljIHNldFRvd2VyQXR0YWNrQ2FsbGJhY2soY2FsbGJhY2s6ICh0b3dlck93bmVySWQ6IHN0cmluZywgdGFyZ2V0UGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQbGF5ZXJNYXBwaW5nKHNlcnZlclBsYXllckVudGl0aWVzOiBNYXA8c3RyaW5nLCBudW1iZXI+LCBsb2NhbFNvY2tldElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNlcnZlclBsYXllckVudGl0aWVzID0gc2VydmVyUGxheWVyRW50aXRpZXM7XG4gICAgdGhpcy5sb2NhbFNvY2tldElkID0gbG9jYWxTb2NrZXRJZDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIXRyYW5zZm9ybSB8fCAhdG93ZXIgfHwgIWhlYWx0aCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRvd2VyIGlzIGRlYWRcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkICYmICF0b3dlci5pc0RlYWQpIHtcbiAgICAgICAgdG93ZXIuZGllKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNraXAgaW5hY3RpdmUgb3IgZGVhZCB0b3dlcnNcbiAgICAgIGlmICghdG93ZXIuaXNBY3RpdmUgfHwgdG93ZXIuaXNEZWFkKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gU2VhcmNoIGZvciB0YXJnZXRzIHBlcmlvZGljYWxseVxuICAgICAgaWYgKHRvd2VyLmNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWUpKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoRm9yVGFyZ2V0KGVudGl0eSwgdHJhbnNmb3JtLCB0b3dlciwgY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWYWxpZGF0ZSBjdXJyZW50IHRhcmdldCAoY2hlY2sgaWYgc3RpbGwgYWxpdmUgYW5kIGluIHJhbmdlKVxuICAgICAgaWYgKHRvd2VyLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RW50aXR5ID0gdGhpcy53b3JsZC5nZXRFbnRpdHkodG93ZXIuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkVGFyZ2V0KHRhcmdldEVudGl0eSB8fCBudWxsLCB0cmFuc2Zvcm0sIHRvd2VyKSkge1xuICAgICAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQXR0YWNrIGN1cnJlbnQgdGFyZ2V0IGlmIHBvc3NpYmxlXG4gICAgICBpZiAodG93ZXIuY3VycmVudFRhcmdldCAmJiB0b3dlci5jYW5BdHRhY2soY3VycmVudFRpbWUpKSB7XG4gICAgICAgIHRoaXMuYXR0YWNrVGFyZ2V0KGVudGl0eSwgdHJhbnNmb3JtLCB0b3dlciwgY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBzZWFyY2hGb3JUYXJnZXQodG93ZXJFbnRpdHk6IEVudGl0eSwgdG93ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSwgdG93ZXI6IFRvd2VyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdG93ZXIudXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lKTtcbiAgICBcbiAgICAvLyBHZXQgYWxsIHBvdGVudGlhbCB0YXJnZXRzIChwbGF5ZXJzIHRoYXQgYXJlIG5vdCB0aGUgdG93ZXIgb3duZXIpXG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBIZWFsdGgsIENvbGxpZGVyXSk7XG4gICAgXG4gICAgXG4gICAgbGV0IGNsb3Nlc3RUYXJnZXQ6IEVudGl0eSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgdmFsaWRUYXJnZXRDb3VudCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcG90ZW50aWFsVGFyZ2V0cykge1xuICAgICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIFxuICAgICAgaWYgKHRhcmdldENvbGxpZGVyICYmIHRhcmdldFRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRvd2VyVHJhbnNmb3JtLnBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYXJnZXQodGFyZ2V0LCB0b3dlclRyYW5zZm9ybSwgdG93ZXIpKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgdmFsaWRUYXJnZXRDb3VudCsrO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtMiA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtMikgY29udGludWU7XG4gICAgICBcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0yLnBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlIDw9IHRvd2VyLnRhcmdldFNlYXJjaFJhbmdlICYmIGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgIGNsb3Nlc3RUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBcbiAgICBpZiAoY2xvc2VzdFRhcmdldCkge1xuICAgICAgdG93ZXIuc2V0VGFyZ2V0KGNsb3Nlc3RUYXJnZXQuaWQpO1xuICAgIH0gZWxzZSBpZiAodG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgLy8gQ2xlYXIgdGFyZ2V0IGlmIG5vIHZhbGlkIHRhcmdldHMgZm91bmRcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGlzVmFsaWRUYXJnZXQodGFyZ2V0OiBFbnRpdHkgfCBudWxsLCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IHRhcmdldENvbGxpZGVyID0gdGFyZ2V0LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgXG4gICAgLy8gTXVzdCBoYXZlIHJlcXVpcmVkIGNvbXBvbmVudHMgYW5kIGJlIGFsaXZlXG4gICAgaWYgKCF0YXJnZXRIZWFsdGggfHwgIXRhcmdldFRyYW5zZm9ybSB8fCAhdGFyZ2V0Q29sbGlkZXIgfHwgdGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBNdXN0IGJlIGEgcGxheWVyIChub3QgYW4gZW5lbXkgb3Igb3RoZXIgdG93ZXIpXG4gICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyICE9PSBDb2xsaXNpb25MYXllci5QTEFZRVIgJiYgdGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLkVORU1ZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHRhcmdldCBvdGhlciB0b3dlcnNcbiAgICBpZiAodGFyZ2V0Lmhhc0NvbXBvbmVudChUb3dlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgc3VtbW9uZWQgdW5pdFxuICAgIGNvbnN0IHN1bW1vbmVkVW5pdCA9IHRhcmdldC5nZXRDb21wb25lbnQoU3VtbW9uZWRVbml0KTtcbiAgICBpZiAoc3VtbW9uZWRVbml0KSB7XG4gICAgICAvLyBPbmx5IHRhcmdldCBlbmVteSBzdW1tb25lZCB1bml0cyAoZGlmZmVyZW50IG93bmVyKVxuICAgICAgcmV0dXJuIHN1bW1vbmVkVW5pdC5vd25lcklkICE9PSB0b3dlci5vd25lcklkO1xuICAgIH1cblxuICAgIC8vIEluIFBWUCBtb2RlLCBpZGVudGlmeSBpZiB0aGlzIGlzIGFuIGVuZW15IHBsYXllclxuICAgIGlmICh0aGlzLmxvY2FsU29ja2V0SWQgJiYgdGhpcy5zZXJ2ZXJQbGF5ZXJFbnRpdGllcy5zaXplID4gMCkge1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBsb2NhbCBwbGF5ZXIgKFBMQVlFUiBsYXllcilcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFRhcmdldCA9IHRvd2VyLm93bmVySWQgIT09IHRoaXMubG9jYWxTb2NrZXRJZDtcbiAgICAgICAgcmV0dXJuIHNob3VsZFRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJlbW90ZSBwbGF5ZXIgKEVORU1ZIGxheWVyKVxuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWSkge1xuICAgICAgICAvLyBGaW5kIHdoaWNoIHBsYXllciB0aGlzIGVudGl0eSBiZWxvbmdzIHRvXG4gICAgICAgIGxldCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMuZm9yRWFjaCgoZW50aXR5SWQsIHBsYXllcklkKSA9PiB7XG4gICAgICAgICAgaWYgKGVudGl0eUlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgIHRhcmdldFBsYXllcklkID0gcGxheWVySWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRUYXJnZXQgPSB0b3dlci5vd25lcklkICE9PSB0YXJnZXRQbGF5ZXJJZDtcbiAgICAgICAgICByZXR1cm4gc2hvdWxkVGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICBwcml2YXRlIGF0dGFja1RhcmdldCh0b3dlckVudGl0eTogRW50aXR5LCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eSh0b3dlci5jdXJyZW50VGFyZ2V0ISk7XG4gICAgaWYgKCF0YXJnZXRFbnRpdHkpIHtcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIChzbGlnaHRseSBhYm92ZSB0b3dlciBjZW50ZXIpXG4gICAgdGhpcy50ZW1wVmVjdG9yMi5jb3B5KHRvd2VyVHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRlbXBWZWN0b3IyLnkgKz0gMjsgLy8gU3Bhd24gcHJvamVjdGlsZXMgMiB1bml0cyBhYm92ZSB0b3dlciBiYXNlXG5cbiAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIGZyb20gc3Bhd24gcG9zaXRpb24gdG8gdGFyZ2V0IChub3QgdG93ZXIgYmFzZSlcbiAgICB0aGlzLnRlbXBWZWN0b3IuY29weSh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGVtcFZlY3Rvci5zdWIodGhpcy50ZW1wVmVjdG9yMik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnRlbXBWZWN0b3IubGVuZ3RoKCk7XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgc3RpbGwgaW4gcmFuZ2VcbiAgICBpZiAoZGlzdGFuY2UgPiB0b3dlci5hdHRhY2tSYW5nZSkge1xuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB2ZXJ5IGNsb3NlIHRhcmdldHMgLSBlbnN1cmUgd2UgY2FuIGFsd2F5cyBoaXQgdGhlbVxuICAgIGlmIChkaXN0YW5jZSA8IDAuNSkge1xuICAgICAgLy8gRm9yIGV4dHJlbWVseSBjbG9zZSB0YXJnZXRzLCBjcmVhdGUgYSBtb3JlIHByZWRpY3RhYmxlIHRyYWplY3RvcnlcbiAgICAgIC8vIEFpbSBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0IHRvIGFjY291bnQgZm9yIGdyYXZpdHkgYW5kIGVuc3VyZSBoaXRcbiAgICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICB0aGlzLnRlbXBWZWN0b3IueSArPSAwLjM7IC8vIEFpbSAwLjMgdW5pdHMgYWJvdmUgdGFyZ2V0XG4gICAgICB0aGlzLnRlbXBWZWN0b3Iuc3ViKHRoaXMudGVtcFZlY3RvcjIpO1xuICAgICAgdGhpcy50ZW1wVmVjdG9yLm5vcm1hbGl6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3JtYWxpemUgZGlyZWN0aW9uIGZvciBub3JtYWwgY2FzZXNcbiAgICAgIHRoaXMudGVtcFZlY3Rvci5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIHByb2plY3RpbGVcbiAgICBpZiAodGhpcy5wcm9qZWN0aWxlU3lzdGVtKSB7XG4gICAgICBjb25zdCBwcm9qZWN0aWxlQ29uZmlnID0ge1xuICAgICAgICBzcGVlZDogdG93ZXIucHJvamVjdGlsZVNwZWVkLFxuICAgICAgICBkYW1hZ2U6IHRvd2VyLmF0dGFja0RhbWFnZSxcbiAgICAgICAgbGlmZXRpbWU6IDIsIC8vIDUgc2Vjb25kIGxpZmV0aW1lXG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvamVjdGlsZUVudGl0eSA9IHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVQcm9qZWN0aWxlKFxuICAgICAgICB0aGlzLndvcmxkLFxuICAgICAgICB0aGlzLnRlbXBWZWN0b3IyLCAvLyBzcGF3biBwb3NpdGlvblxuICAgICAgICB0aGlzLnRlbXBWZWN0b3IsICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdG93ZXJFbnRpdHkuaWQsICAgLy8gdG93ZXIgYXMgb3duZXJcbiAgICAgICAgcHJvamVjdGlsZUNvbmZpZ1xuICAgICAgKTtcblxuICAgICAgLy8gRW5hYmxlIGV4dHJlbWVseSBzdHJvbmcgaG9taW5nIGZvciB0b3dlciBwcm9qZWN0aWxlc1xuICAgICAgY29uc3QgcHJvamVjdGlsZSA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgICAgaWYgKHByb2plY3RpbGUgJiYgdG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBzdW1tb25lZCB1bml0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHRvd2VyLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBjb25zdCBpc1N1bW1vbmVkVW5pdCA9IHRhcmdldEVudGl0eT8uZ2V0Q29tcG9uZW50KFN1bW1vbmVkVW5pdCkgIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoaXNTdW1tb25lZFVuaXQpIHtcbiAgICAgICAgICAvLyBNYWtlIGl0IElNUE9TU0lCTEUgZm9yIHN1bW1vbmVkIHVuaXRzIHRvIGRvZGdlIC0gcGVyZmVjdCB0cmFja2luZ1xuICAgICAgICAgIHByb2plY3RpbGUuc2V0SG9taW5nKHRvd2VyLmN1cnJlbnRUYXJnZXQsIDEuMCwgOC4wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb3IgcGxheWVyczogdmVyeSBkaWZmaWN1bHQgdG8gZG9kZ2UgYnV0IG5vdCBpbXBvc3NpYmxlXG4gICAgICAgICAgcHJvamVjdGlsZS5zZXRIb21pbmcodG93ZXIuY3VycmVudFRhcmdldCwgMC45NSwgNi4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzcGVjaWFsIHRvd2VyIHByb2plY3RpbGUgcHJvcGVydGllcyBmb3IgZW5oYW5jZWQgdHJhY2tpbmdcbiAgICAgICAgcHJvamVjdGlsZS5tYXhUdXJuUmF0ZSA9IGlzU3VtbW9uZWRVbml0ID8gMTIuMCA6IDguMDsgLy8gRXZlbiBmYXN0ZXIgdHVybnMgZm9yIHN1bW1vbmVkIHVuaXRzXG4gICAgICB9XG5cbiAgICAgIC8vIE1hcmsgcHJvamVjdGlsZSBhcyB0b3dlciBwcm9qZWN0aWxlIGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICBjb25zdCBwcm9qZWN0aWxlUmVuZGVyZXIgPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHByb2plY3RpbGVSZW5kZXJlcikge1xuICAgICAgICAvLyBBZGQgbWV0YWRhdGEgdG8gaWRlbnRpZnkgdGhpcyBhcyBhIHRvd2VyIHByb2plY3RpbGVcbiAgICAgICAgKHByb2plY3RpbGVFbnRpdHkgYXMgYW55KS5pc1Rvd2VyUHJvamVjdGlsZSA9IHRydWU7XG4gICAgICAgIChwcm9qZWN0aWxlRW50aXR5IGFzIGFueSkudG93ZXJPd25lcklkID0gdG93ZXIub3duZXJJZDtcbiAgICAgIH1cblxuICAgIH1cbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgYXR0YWNrIHRvIG11bHRpcGxheWVyIGlmIGNhbGxiYWNrIGlzIHNldFxuICAgIGlmICh0aGlzLm9uVG93ZXJBdHRhY2tDYWxsYmFjaykge1xuICAgICAgLy8gV2UgbmVlZCB0byBtYXAgdGhlIHRhcmdldCBlbnRpdHkgYmFjayB0byBhIHBsYXllciBJRFxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIGEgcGxhY2Vob2xkZXIgLSB0aGlzIHdpbGwgbmVlZCB0byBiZSBpbXByb3ZlZCB3aXRoIHByb3BlciBwbGF5ZXIgbWFwcGluZ1xuICAgICAgY29uc3QgdGFyZ2V0UGxheWVySWQgPSBgcGxheWVyXyR7dG93ZXIuY3VycmVudFRhcmdldH1gO1xuICAgICAgdGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2sodG93ZXIub3duZXJJZCwgdGFyZ2V0UGxheWVySWQsIHRoaXMudGVtcFZlY3RvcjIsIHRoaXMudGVtcFZlY3Rvcik7XG4gICAgfVxuICAgIFxuICAgIHRvd2VyLnBlcmZvcm1BdHRhY2soY3VycmVudFRpbWUpO1xuICB9XG4gIFxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBnZXQgYWxsIHRvd2VycyBvd25lZCBieSBhIHNwZWNpZmljIHBsYXllclxuICBwdWJsaWMgZ2V0VG93ZXJzQnlPd25lcihvd25lcklkOiBzdHJpbmcpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgYWxsVG93ZXJzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIFRvd2VyLCBIZWFsdGhdKTtcbiAgICByZXR1cm4gYWxsVG93ZXJzLmZpbHRlcihlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgdG93ZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRvd2VyKTtcbiAgICAgIHJldHVybiB0b3dlciAmJiB0b3dlci5vd25lcklkID09PSBvd25lcklkO1xuICAgIH0pO1xuICB9XG4gIFxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBnZXQgdG93ZXIgY291bnQgZm9yIGEgcGxheWVyXG4gIHB1YmxpYyBnZXRUb3dlckNvdW50KG93bmVySWQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VG93ZXJzQnlPd25lcihvd25lcklkKS5sZW5ndGg7XG4gIH1cbiAgXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNoZWNrIGlmIGEgcGxheWVyIGhhcyBhbnkgYWN0aXZlIHRvd2Vyc1xuICBwdWJsaWMgaGFzQWN0aXZlVG93ZXJzKG93bmVySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRvd2VycyA9IHRoaXMuZ2V0VG93ZXJzQnlPd25lcihvd25lcklkKTtcbiAgICByZXR1cm4gdG93ZXJzLnNvbWUoZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICByZXR1cm4gdG93ZXIgJiYgaGVhbHRoICYmIHRvd2VyLmlzQWN0aXZlICYmICF0b3dlci5pc0RlYWQgJiYgIWhlYWx0aC5pc0RlYWQ7XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiVG93ZXIiLCJTdW1tb25lZFVuaXQiLCJQcm9qZWN0aWxlIiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIlRvd2VyU3lzdGVtIiwic2V0UHJvamVjdGlsZVN5c3RlbSIsInByb2plY3RpbGVTeXN0ZW0iLCJzZXRUb3dlckF0dGFja0NhbGxiYWNrIiwiY2FsbGJhY2siLCJvblRvd2VyQXR0YWNrQ2FsbGJhY2siLCJzZXRQbGF5ZXJNYXBwaW5nIiwic2VydmVyUGxheWVyRW50aXRpZXMiLCJsb2NhbFNvY2tldElkIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJ0b3dlciIsImhlYWx0aCIsImlzRGVhZCIsImRpZSIsImlzQWN0aXZlIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsInNlYXJjaEZvclRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRFbnRpdHkiLCJ3b3JsZCIsImdldEVudGl0eSIsImlzVmFsaWRUYXJnZXQiLCJjbGVhclRhcmdldCIsImNhbkF0dGFjayIsImF0dGFja1RhcmdldCIsInRvd2VyRW50aXR5IiwidG93ZXJUcmFuc2Zvcm0iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsImNsb3Nlc3RUYXJnZXQiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInZhbGlkVGFyZ2V0Q291bnQiLCJ0YXJnZXQiLCJ0YXJnZXRDb2xsaWRlciIsInRhcmdldFRyYW5zZm9ybSIsImRpc3RhbmNlIiwicG9zaXRpb24iLCJkaXN0YW5jZVRvIiwidGFyZ2V0VHJhbnNmb3JtMiIsInRhcmdldFNlYXJjaFJhbmdlIiwic2V0VGFyZ2V0IiwiaWQiLCJ0YXJnZXRIZWFsdGgiLCJsYXllciIsIlBMQVlFUiIsIkVORU1ZIiwiaGFzQ29tcG9uZW50Iiwic3VtbW9uZWRVbml0Iiwib3duZXJJZCIsInNpemUiLCJzaG91bGRUYXJnZXQiLCJ0YXJnZXRQbGF5ZXJJZCIsImZvckVhY2giLCJlbnRpdHlJZCIsInBsYXllcklkIiwidGVtcFZlY3RvcjIiLCJjb3B5IiwieSIsInRlbXBWZWN0b3IiLCJzdWIiLCJsZW5ndGgiLCJhdHRhY2tSYW5nZSIsIm5vcm1hbGl6ZSIsInByb2plY3RpbGVDb25maWciLCJzcGVlZCIsInByb2plY3RpbGVTcGVlZCIsImRhbWFnZSIsImF0dGFja0RhbWFnZSIsImxpZmV0aW1lIiwib3BhY2l0eSIsInByb2plY3RpbGVFbnRpdHkiLCJjcmVhdGVQcm9qZWN0aWxlIiwicHJvamVjdGlsZSIsImlzU3VtbW9uZWRVbml0IiwidW5kZWZpbmVkIiwic2V0SG9taW5nIiwibWF4VHVyblJhdGUiLCJwcm9qZWN0aWxlUmVuZGVyZXIiLCJpc1Rvd2VyUHJvamVjdGlsZSIsInRvd2VyT3duZXJJZCIsInBlcmZvcm1BdHRhY2siLCJnZXRUb3dlcnNCeU93bmVyIiwiYWxsVG93ZXJzIiwiZmlsdGVyIiwiZ2V0VG93ZXJDb3VudCIsImhhc0FjdGl2ZVRvd2VycyIsInRvd2VycyIsInNvbWUiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/TowerSystem.ts\n"));

/***/ })

}]);