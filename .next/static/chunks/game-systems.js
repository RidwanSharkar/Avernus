"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["game-systems"],{

/***/ "(app-pages-browser)/./src/core/DamageCalculator.ts":
/*!**************************************!*\
  !*** ./src/core/DamageCalculator.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDamage: function() { return /* binding */ calculateDamage; },\n/* harmony export */   getCriticalChance: function() { return /* binding */ getCriticalChance; },\n/* harmony export */   getCriticalDamageMultiplier: function() { return /* binding */ getCriticalDamageMultiplier; },\n/* harmony export */   getGlobalRuneCounts: function() { return /* binding */ getGlobalRuneCounts; },\n/* harmony export */   setGlobalCritDamageRuneCount: function() { return /* binding */ setGlobalCritDamageRuneCount; },\n/* harmony export */   setGlobalCriticalRuneCount: function() { return /* binding */ setGlobalCriticalRuneCount; }\n/* harmony export */ });\n// Core damage calculation system with critical hit mechanics\n// Placed in core/ for performance and shared access across all systems\n// Global rune counts - will be updated by the GameState context\nlet globalCriticalRuneCount = 0;\nlet globalCritDamageRuneCount = 0;\nfunction setGlobalCriticalRuneCount(count) {\n    globalCriticalRuneCount = count;\n}\nfunction setGlobalCritDamageRuneCount(count) {\n    globalCritDamageRuneCount = count;\n}\nfunction calculateDamage(baseAmount) {\n    // Base crit chance is 11%, each rune adds 3%\n    const criticalChance = 0.11 + globalCriticalRuneCount * 0.03;\n    const isCritical = Math.random() < criticalChance;\n    // Base crit damage multiplier is 2x, each crit damage rune adds 0.15x\n    const criticalDamageMultiplier = 2.0 + globalCritDamageRuneCount * 0.15;\n    const rawDamage = isCritical ? baseAmount * criticalDamageMultiplier : baseAmount;\n    // Round down to integer to avoid floating point precision issues\n    const damage = Math.floor(rawDamage);\n    return {\n        damage,\n        isCritical\n    };\n}\n// Utility functions for debugging and testing\nfunction getCriticalChance() {\n    return 0.11 + globalCriticalRuneCount * 0.03;\n}\nfunction getCriticalDamageMultiplier() {\n    return 2.0 + globalCritDamageRuneCount * 0.15;\n}\nfunction getGlobalRuneCounts() {\n    return {\n        criticalRunes: globalCriticalRuneCount,\n        critDamageRunes: globalCritDamageRuneCount\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0RhbWFnZUNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQzdELHVFQUF1RTtBQU92RSxnRUFBZ0U7QUFDaEUsSUFBSUEsMEJBQTBCO0FBQzlCLElBQUlDLDRCQUE0QjtBQUV6QixTQUFTQywyQkFBMkJDLEtBQWE7SUFDdERILDBCQUEwQkc7QUFDNUI7QUFFTyxTQUFTQyw2QkFBNkJELEtBQWE7SUFDeERGLDRCQUE0QkU7QUFDOUI7QUFFTyxTQUFTRSxnQkFBZ0JDLFVBQWtCO0lBQ2hELDZDQUE2QztJQUM3QyxNQUFNQyxpQkFBaUIsT0FBUVAsMEJBQTBCO0lBQ3pELE1BQU1RLGFBQWFDLEtBQUtDLE1BQU0sS0FBS0g7SUFFbkMsc0VBQXNFO0lBQ3RFLE1BQU1JLDJCQUEyQixNQUFPViw0QkFBNEI7SUFDcEUsTUFBTVcsWUFBWUosYUFBYUYsYUFBYUssMkJBQTJCTDtJQUV2RSxpRUFBaUU7SUFDakUsTUFBTU8sU0FBU0osS0FBS0ssS0FBSyxDQUFDRjtJQUUxQixPQUFPO1FBQUVDO1FBQVFMO0lBQVc7QUFDOUI7QUFFQSw4Q0FBOEM7QUFDdkMsU0FBU087SUFDZCxPQUFPLE9BQVFmLDBCQUEwQjtBQUMzQztBQUVPLFNBQVNnQjtJQUNkLE9BQU8sTUFBT2YsNEJBQTRCO0FBQzVDO0FBRU8sU0FBU2dCO0lBQ2QsT0FBTztRQUNMQyxlQUFlbEI7UUFDZm1CLGlCQUFpQmxCO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvRGFtYWdlQ2FsY3VsYXRvci50cz8yNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgZGFtYWdlIGNhbGN1bGF0aW9uIHN5c3RlbSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3Ncbi8vIFBsYWNlZCBpbiBjb3JlLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHNoYXJlZCBhY2Nlc3MgYWNyb3NzIGFsbCBzeXN0ZW1zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFtYWdlUmVzdWx0IHtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIGlzQ3JpdGljYWw6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBydW5lIGNvdW50cyAtIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgR2FtZVN0YXRlIGNvbnRleHRcbmxldCBnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCA9IDA7XG5sZXQgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0aWNhbFJ1bmVDb3VudChjb3VudDogbnVtYmVyKSB7XG4gIGdsb2JhbENyaXRpY2FsUnVuZUNvdW50ID0gY291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50KGNvdW50OiBudW1iZXIpIHtcbiAgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IGNvdW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGFtYWdlKGJhc2VBbW91bnQ6IG51bWJlcik6IERhbWFnZVJlc3VsdCB7XG4gIC8vIEJhc2UgY3JpdCBjaGFuY2UgaXMgMTElLCBlYWNoIHJ1bmUgYWRkcyAzJVxuICBjb25zdCBjcml0aWNhbENoYW5jZSA9IDAuMTEgKyAoZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQgKiAwLjAzKTtcbiAgY29uc3QgaXNDcml0aWNhbCA9IE1hdGgucmFuZG9tKCkgPCBjcml0aWNhbENoYW5jZTtcbiAgXG4gIC8vIEJhc2UgY3JpdCBkYW1hZ2UgbXVsdGlwbGllciBpcyAyeCwgZWFjaCBjcml0IGRhbWFnZSBydW5lIGFkZHMgMC4xNXhcbiAgY29uc3QgY3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyID0gMi4wICsgKGdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQgKiAwLjE1KTtcbiAgY29uc3QgcmF3RGFtYWdlID0gaXNDcml0aWNhbCA/IGJhc2VBbW91bnQgKiBjcml0aWNhbERhbWFnZU11bHRpcGxpZXIgOiBiYXNlQW1vdW50O1xuICBcbiAgLy8gUm91bmQgZG93biB0byBpbnRlZ2VyIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXNcbiAgY29uc3QgZGFtYWdlID0gTWF0aC5mbG9vcihyYXdEYW1hZ2UpO1xuICBcbiAgcmV0dXJuIHsgZGFtYWdlLCBpc0NyaXRpY2FsIH07XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcml0aWNhbENoYW5jZSgpOiBudW1iZXIge1xuICByZXR1cm4gMC4xMSArIChnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCAqIDAuMDMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyKCk6IG51bWJlciB7XG4gIHJldHVybiAyLjAgKyAoZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCAqIDAuMTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsUnVuZUNvdW50cygpOiB7IGNyaXRpY2FsUnVuZXM6IG51bWJlcjsgY3JpdERhbWFnZVJ1bmVzOiBudW1iZXIgfSB7XG4gIHJldHVybiB7XG4gICAgY3JpdGljYWxSdW5lczogZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQsXG4gICAgY3JpdERhbWFnZVJ1bmVzOiBnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50Iiwic2V0R2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJjb3VudCIsInNldEdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJiYXNlQW1vdW50IiwiY3JpdGljYWxDaGFuY2UiLCJpc0NyaXRpY2FsIiwiTWF0aCIsInJhbmRvbSIsImNyaXRpY2FsRGFtYWdlTXVsdGlwbGllciIsInJhd0RhbWFnZSIsImRhbWFnZSIsImZsb29yIiwiZ2V0Q3JpdGljYWxDaGFuY2UiLCJnZXRDcml0aWNhbERhbWFnZU11bHRpcGxpZXIiLCJnZXRHbG9iYWxSdW5lQ291bnRzIiwiY3JpdGljYWxSdW5lcyIsImNyaXREYW1hZ2VSdW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/DamageCalculator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/Engine.ts":
/*!****************************!*\
  !*** ./src/core/Engine.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: function() { return /* binding */ Engine; }\n/* harmony export */ });\n/* harmony import */ var _ecs_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/World */ \"(app-pages-browser)/./src/ecs/World.ts\");\n/* harmony import */ var _GameLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameLoop */ \"(app-pages-browser)/./src/core/GameLoop.ts\");\n/* harmony import */ var _InputManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InputManager */ \"(app-pages-browser)/./src/core/InputManager.ts\");\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Main game engine with ECS integration\n\n\n\n\nclass Engine extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    async initialize(canvas) {\n        if (this.isInitialized) {\n            return;\n        }\n        this.canvas = canvas;\n        this.inputManager.initialize(canvas);\n        this.isInitialized = true;\n        this.emit(\"initialized\");\n    }\n    start() {\n        if (!this.isInitialized) {\n            throw new Error(\"Engine must be initialized before starting\");\n        }\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.gameLoop.start();\n        this.emit(\"started\");\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.gameLoop.stop();\n        this.emit(\"stopped\");\n    }\n    pause() {\n        if (this.isRunning) {\n            this.gameLoop.pause();\n            this.emit(\"paused\");\n        }\n    }\n    resume() {\n        if (this.isRunning) {\n            this.gameLoop.resume();\n            this.emit(\"resumed\");\n        }\n    }\n    getWorld() {\n        return this.world;\n    }\n    getInputManager() {\n        return this.inputManager;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isEngineRunning() {\n        return this.isRunning;\n    }\n    getCurrentFPS() {\n        return this.gameLoop.getCurrentFPS();\n    }\n    getPerformanceStats() {\n        return {\n            fps: this.gameLoop.getCurrentFPS(),\n            frameTime: this.frameTime,\n            updateTime: this.updateTime,\n            renderTime: this.renderTime\n        };\n    }\n    enableDebugMode(enabled) {\n        this.debugMode = enabled;\n    }\n    isDebugMode() {\n        return this.debugMode;\n    }\n    setupGameLoop() {\n        // Handle fixed timestep updates (physics)\n        this.gameLoop.on(\"fixedUpdate\", (param)=>{\n            let { fixedDeltaTime } = param;\n            const startTime = performance.now();\n            this.world.fixedUpdate(fixedDeltaTime);\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n        });\n        // Handle variable timestep updates (game logic)\n        this.gameLoop.on(\"update\", (param)=>{\n            let { deltaTime } = param;\n            const startTime = performance.now();\n            // Update world systems first so they can read input deltas\n            this.world.update(deltaTime);\n            // Update input manager after systems have processed input\n            this.inputManager.update();\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n            this.emit(\"update\", {\n                deltaTime\n            });\n        });\n        // Handle rendering\n        this.gameLoop.on(\"render\", (param)=>{\n            let { deltaTime, interpolation } = param;\n            const startTime = performance.now();\n            // Render world\n            this.world.render(deltaTime);\n            if (this.debugMode) {\n                this.renderTime = performance.now() - startTime;\n                this.frameTime = this.updateTime + this.renderTime;\n            }\n            this.emit(\"render\", {\n                deltaTime,\n                interpolation\n            });\n        });\n    }\n    destroy() {\n        this.stop();\n        // Clean up systems\n        this.world.destroy();\n        this.inputManager.destroy();\n        // Clear event listeners\n        this.removeAllListeners();\n        this.isInitialized = false;\n    }\n    // Utility methods for common operations\n    requestPointerLock() {\n        this.inputManager.requestPointerLock();\n    }\n    exitPointerLock() {\n        this.inputManager.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.inputManager.isKeyPressed(key);\n    }\n    isMouseButtonPressed(button) {\n        return this.inputManager.isMouseButtonPressed(button);\n    }\n    getMouseDelta() {\n        return this.inputManager.getMouseDelta();\n    }\n    constructor(config = {}){\n        super();\n        this.canvas = null;\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.debugMode = false;\n        // Performance monitoring\n        this.frameTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.world = new _ecs_World__WEBPACK_IMPORTED_MODULE_0__.World();\n        this.gameLoop = new _GameLoop__WEBPACK_IMPORTED_MODULE_1__.GameLoop();\n        this.inputManager = new _InputManager__WEBPACK_IMPORTED_MODULE_2__.InputManager();\n        this.debugMode = config.enableDebug || false;\n        this.setupGameLoop();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QztBQUNKO0FBQ0U7QUFDUTtBQUNNO0FBUTdDLE1BQU1JLGVBQWVELDZEQUFZQTtJQXlCdEMsTUFBYUUsV0FBV0MsTUFBeUIsRUFBaUI7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QjtRQUNGO1FBRUEsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRSxZQUFZLENBQUNILFVBQVUsQ0FBQ0M7UUFFN0IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRSxJQUFJLENBQUM7SUFFWjtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNILGFBQWEsRUFBRTtZQUN2QixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFFQSxJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJLENBQUNBLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsS0FBSztRQUNuQixJQUFJLENBQUNELElBQUksQ0FBQztJQUdaO0lBRU9LLE9BQWE7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0YsU0FBUyxFQUFFO1FBRXJCLElBQUksQ0FBQ0EsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO1FBQ2xCLElBQUksQ0FBQ0wsSUFBSSxDQUFDO0lBR1o7SUFFT00sUUFBYztRQUNuQixJQUFJLElBQUksQ0FBQ0gsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0MsUUFBUSxDQUFDRSxLQUFLO1lBQ25CLElBQUksQ0FBQ04sSUFBSSxDQUFDO1FBQ1o7SUFDRjtJQUVPTyxTQUFlO1FBQ3BCLElBQUksSUFBSSxDQUFDSixTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQyxRQUFRLENBQUNHLE1BQU07WUFDcEIsSUFBSSxDQUFDUCxJQUFJLENBQUM7UUFDWjtJQUNGO0lBRU9RLFdBQWtCO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDQyxLQUFLO0lBQ25CO0lBRU9DLGtCQUFnQztRQUNyQyxPQUFPLElBQUksQ0FBQ1gsWUFBWTtJQUMxQjtJQUVPWSxZQUFzQztRQUMzQyxPQUFPLElBQUksQ0FBQ2QsTUFBTTtJQUNwQjtJQUVPZSxrQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNULFNBQVM7SUFDdkI7SUFFT1UsZ0JBQXdCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVCxRQUFRLENBQUNTLGFBQWE7SUFDcEM7SUFFT0Msc0JBQXNCO1FBQzNCLE9BQU87WUFDTEMsS0FBSyxJQUFJLENBQUNYLFFBQVEsQ0FBQ1MsYUFBYTtZQUNoQ0csV0FBVyxJQUFJLENBQUNBLFNBQVM7WUFDekJDLFlBQVksSUFBSSxDQUFDQSxVQUFVO1lBQzNCQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM3QjtJQUNGO0lBRU9DLGdCQUFnQkMsT0FBZ0IsRUFBUTtRQUM3QyxJQUFJLENBQUNDLFNBQVMsR0FBR0Q7SUFDbkI7SUFFT0UsY0FBdUI7UUFDNUIsT0FBTyxJQUFJLENBQUNELFNBQVM7SUFDdkI7SUFFUUUsZ0JBQXNCO1FBQzVCLDBDQUEwQztRQUMxQyxJQUFJLENBQUNuQixRQUFRLENBQUNvQixFQUFFLENBQUMsZUFBZTtnQkFBQyxFQUFFQyxjQUFjLEVBQUU7WUFDakQsTUFBTUMsWUFBWUMsWUFBWUMsR0FBRztZQUVqQyxJQUFJLENBQUNuQixLQUFLLENBQUNvQixXQUFXLENBQUNKO1lBRXZCLElBQUksSUFBSSxDQUFDSixTQUFTLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQ0osVUFBVSxHQUFHVSxZQUFZQyxHQUFHLEtBQUtGO1lBQ3hDO1FBQ0Y7UUFFQSxnREFBZ0Q7UUFDaEQsSUFBSSxDQUFDdEIsUUFBUSxDQUFDb0IsRUFBRSxDQUFDLFVBQVU7Z0JBQUMsRUFBRU0sU0FBUyxFQUFFO1lBQ3ZDLE1BQU1KLFlBQVlDLFlBQVlDLEdBQUc7WUFFakMsMkRBQTJEO1lBQzNELElBQUksQ0FBQ25CLEtBQUssQ0FBQ3NCLE1BQU0sQ0FBQ0Q7WUFFbEIsMERBQTBEO1lBQzFELElBQUksQ0FBQy9CLFlBQVksQ0FBQ2dDLE1BQU07WUFFeEIsSUFBSSxJQUFJLENBQUNWLFNBQVMsRUFBRTtnQkFDbEIsSUFBSSxDQUFDSixVQUFVLEdBQUdVLFlBQVlDLEdBQUcsS0FBS0Y7WUFDeEM7WUFFQSxJQUFJLENBQUMxQixJQUFJLENBQUMsVUFBVTtnQkFBRThCO1lBQVU7UUFDbEM7UUFFQSxtQkFBbUI7UUFDbkIsSUFBSSxDQUFDMUIsUUFBUSxDQUFDb0IsRUFBRSxDQUFDLFVBQVU7Z0JBQUMsRUFBRU0sU0FBUyxFQUFFRSxhQUFhLEVBQUU7WUFDdEQsTUFBTU4sWUFBWUMsWUFBWUMsR0FBRztZQUVqQyxlQUFlO1lBQ2YsSUFBSSxDQUFDbkIsS0FBSyxDQUFDd0IsTUFBTSxDQUFDSDtZQUVsQixJQUFJLElBQUksQ0FBQ1QsU0FBUyxFQUFFO2dCQUNsQixJQUFJLENBQUNILFVBQVUsR0FBR1MsWUFBWUMsR0FBRyxLQUFLRjtnQkFDdEMsSUFBSSxDQUFDVixTQUFTLEdBQUcsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSSxDQUFDQyxVQUFVO1lBQ3BEO1lBRUEsSUFBSSxDQUFDbEIsSUFBSSxDQUFDLFVBQVU7Z0JBQUU4QjtnQkFBV0U7WUFBYztRQUNqRDtJQUNGO0lBRU9FLFVBQWdCO1FBQ3JCLElBQUksQ0FBQzdCLElBQUk7UUFFVCxtQkFBbUI7UUFDbkIsSUFBSSxDQUFDSSxLQUFLLENBQUN5QixPQUFPO1FBQ2xCLElBQUksQ0FBQ25DLFlBQVksQ0FBQ21DLE9BQU87UUFFekIsd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ0Msa0JBQWtCO1FBRXZCLElBQUksQ0FBQ3JDLGFBQWEsR0FBRztJQUN2QjtJQUVBLHdDQUF3QztJQUNqQ3NDLHFCQUEyQjtRQUNoQyxJQUFJLENBQUNyQyxZQUFZLENBQUNxQyxrQkFBa0I7SUFDdEM7SUFFT0Msa0JBQXdCO1FBQzdCLElBQUksQ0FBQ3RDLFlBQVksQ0FBQ3NDLGVBQWU7SUFDbkM7SUFFT0MsYUFBYUMsR0FBVyxFQUFXO1FBQ3hDLE9BQU8sSUFBSSxDQUFDeEMsWUFBWSxDQUFDdUMsWUFBWSxDQUFDQztJQUN4QztJQUVPQyxxQkFBcUJDLE1BQWMsRUFBVztRQUNuRCxPQUFPLElBQUksQ0FBQzFDLFlBQVksQ0FBQ3lDLG9CQUFvQixDQUFDQztJQUNoRDtJQUVPQyxnQkFBMEM7UUFDL0MsT0FBTyxJQUFJLENBQUMzQyxZQUFZLENBQUMyQyxhQUFhO0lBQ3hDO0lBbExBQyxZQUFZQyxTQUF1QixDQUFDLENBQUMsQ0FBRTtRQUNyQyxLQUFLO2FBWEMvQyxTQUFtQzthQUNuQ0MsZ0JBQWdCO2FBQ2hCSyxZQUFZO2FBQ1prQixZQUFZO1FBRXBCLHlCQUF5QjthQUNqQkwsWUFBWTthQUNaQyxhQUFhO2FBQ2JDLGFBQWE7UUFLbkIsSUFBSSxDQUFDVCxLQUFLLEdBQUcsSUFBSWxCLDZDQUFLQTtRQUN0QixJQUFJLENBQUNhLFFBQVEsR0FBRyxJQUFJWiwrQ0FBUUE7UUFDNUIsSUFBSSxDQUFDTyxZQUFZLEdBQUcsSUFBSU4sdURBQVlBO1FBQ3BDLElBQUksQ0FBQzRCLFNBQVMsR0FBR3VCLE9BQU9DLFdBQVcsSUFBSTtRQUV2QyxJQUFJLENBQUN0QixhQUFhO0lBQ3BCO0FBMEtGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb3JlL0VuZ2luZS50cz8yZjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1haW4gZ2FtZSBlbmdpbmUgd2l0aCBFQ1MgaW50ZWdyYXRpb25cbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgR2FtZUxvb3AgfSBmcm9tICcuL0dhbWVMb29wJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJy4vSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0AvdXRpbHMvRXZlbnRFbWl0dGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBFbmdpbmVDb25maWcge1xuICBjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgZW5hYmxlRGVidWc/OiBib29sZWFuO1xuICB0YXJnZXRGUFM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBFbmdpbmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBnYW1lTG9vcDogR2FtZUxvb3A7XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc1J1bm5pbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWJ1Z01vZGUgPSBmYWxzZTtcblxuICAvLyBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gIHByaXZhdGUgZnJhbWVUaW1lID0gMDtcbiAgcHJpdmF0ZSB1cGRhdGVUaW1lID0gMDtcbiAgcHJpdmF0ZSByZW5kZXJUaW1lID0gMDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEVuZ2luZUNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLndvcmxkID0gbmV3IFdvcmxkKCk7XG4gICAgdGhpcy5nYW1lTG9vcCA9IG5ldyBHYW1lTG9vcCgpO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyID0gbmV3IElucHV0TWFuYWdlcigpO1xuICAgIHRoaXMuZGVidWdNb2RlID0gY29uZmlnLmVuYWJsZURlYnVnIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5zZXR1cEdhbWVMb29wKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLmluaXRpYWxpemUoY2FudmFzKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnKTtcbiAgICBcbiAgfVxuXG4gIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmdpbmUgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgc3RhcnRpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5nYW1lTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnBhdXNlKCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnJlc3VtZSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFdvcmxkKCk6IFdvcmxkIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dE1hbmFnZXIoKTogSW5wdXRNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXI7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgcHVibGljIGlzRW5naW5lUnVubmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1J1bm5pbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdhbWVMb29wLmdldEN1cnJlbnRGUFMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcHM6IHRoaXMuZ2FtZUxvb3AuZ2V0Q3VycmVudEZQUygpLFxuICAgICAgZnJhbWVUaW1lOiB0aGlzLmZyYW1lVGltZSxcbiAgICAgIHVwZGF0ZVRpbWU6IHRoaXMudXBkYXRlVGltZSxcbiAgICAgIHJlbmRlclRpbWU6IHRoaXMucmVuZGVyVGltZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVuYWJsZURlYnVnTW9kZShlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBlbmFibGVkO1xuICB9XG5cbiAgcHVibGljIGlzRGVidWdNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRlYnVnTW9kZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBHYW1lTG9vcCgpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgZml4ZWQgdGltZXN0ZXAgdXBkYXRlcyAocGh5c2ljcylcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdmaXhlZFVwZGF0ZScsICh7IGZpeGVkRGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICB0aGlzLndvcmxkLmZpeGVkVXBkYXRlKGZpeGVkRGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXMgKGdhbWUgbG9naWMpXG4gICAgdGhpcy5nYW1lTG9vcC5vbigndXBkYXRlJywgKHsgZGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgd29ybGQgc3lzdGVtcyBmaXJzdCBzbyB0aGV5IGNhbiByZWFkIGlucHV0IGRlbHRhc1xuICAgICAgdGhpcy53b3JsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGlucHV0IG1hbmFnZXIgYWZ0ZXIgc3lzdGVtcyBoYXZlIHByb2Nlc3NlZCBpbnB1dFxuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIudXBkYXRlKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGRlbHRhVGltZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZW5kZXJpbmdcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdyZW5kZXInLCAoeyBkZWx0YVRpbWUsIGludGVycG9sYXRpb24gfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciB3b3JsZFxuICAgICAgdGhpcy53b3JsZC5yZW5kZXIoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IHRoaXMudXBkYXRlVGltZSArIHRoaXMucmVuZGVyVGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICB0aGlzLndvcmxkLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZChrZXkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXb3JsZCIsIkdhbWVMb29wIiwiSW5wdXRNYW5hZ2VyIiwiRXZlbnRFbWl0dGVyIiwiRW5naW5lIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImlzSW5pdGlhbGl6ZWQiLCJpbnB1dE1hbmFnZXIiLCJlbWl0Iiwic3RhcnQiLCJFcnJvciIsImlzUnVubmluZyIsImdhbWVMb29wIiwic3RvcCIsInBhdXNlIiwicmVzdW1lIiwiZ2V0V29ybGQiLCJ3b3JsZCIsImdldElucHV0TWFuYWdlciIsImdldENhbnZhcyIsImlzRW5naW5lUnVubmluZyIsImdldEN1cnJlbnRGUFMiLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwiZnBzIiwiZnJhbWVUaW1lIiwidXBkYXRlVGltZSIsInJlbmRlclRpbWUiLCJlbmFibGVEZWJ1Z01vZGUiLCJlbmFibGVkIiwiZGVidWdNb2RlIiwiaXNEZWJ1Z01vZGUiLCJzZXR1cEdhbWVMb29wIiwib24iLCJmaXhlZERlbHRhVGltZSIsInN0YXJ0VGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZml4ZWRVcGRhdGUiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJpbnRlcnBvbGF0aW9uIiwicmVuZGVyIiwiZGVzdHJveSIsInJlbW92ZUFsbExpc3RlbmVycyIsInJlcXVlc3RQb2ludGVyTG9jayIsImV4aXRQb2ludGVyTG9jayIsImlzS2V5UHJlc3NlZCIsImtleSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwiZ2V0TW91c2VEZWx0YSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiZW5hYmxlRGVidWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/Engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/GameLoop.ts":
/*!******************************!*\
  !*** ./src/core/GameLoop.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameLoop: function() { return /* binding */ GameLoop; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Optimized game loop with fixed timestep physics\n\nclass GameLoop extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.lastTime = performance.now();\n        this.accumulator = 0;\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = 0;\n        }\n    }\n    getCurrentFPS() {\n        return this.currentFPS;\n    }\n    getFixedTimeStep() {\n        return this.fixedTimeStep;\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning) return;\n        // Calculate delta time and clamp it to prevent large jumps\n        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.maxFrameTime);\n        this.lastTime = currentTime;\n        this.currentTime = currentTime;\n        // Update FPS counter\n        this.updateFPS(deltaTime);\n        // Accumulate time for fixed timestep physics\n        this.accumulator += deltaTime;\n        // Fixed timestep physics updates\n        let subSteps = 0;\n        while(this.accumulator >= this.fixedTimeStep && subSteps < this.maxSubSteps){\n            this.emit(\"fixedUpdate\", {\n                fixedDeltaTime: this.fixedTimeStep\n            });\n            this.accumulator -= this.fixedTimeStep;\n            subSteps++;\n        }\n        // Variable timestep game logic update\n        this.emit(\"update\", {\n            deltaTime\n        });\n        // Calculate interpolation factor for smooth rendering\n        const interpolation = this.accumulator / this.fixedTimeStep;\n        // Render with interpolation\n        this.emit(\"render\", {\n            deltaTime,\n            interpolation\n        });\n        // Schedule next frame\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    updateFPS(deltaTime) {\n        this.frameCount++;\n        this.fpsUpdateTime += deltaTime;\n        // Update FPS every second\n        if (this.fpsUpdateTime >= 1.0) {\n            this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);\n            this.frameCount = 0;\n            this.fpsUpdateTime = 0;\n        }\n    }\n    pause() {\n        if (this.isRunning) {\n            this.stop();\n        }\n    }\n    resume() {\n        if (!this.isRunning) {\n            this.start();\n        }\n    }\n    isPaused() {\n        return !this.isRunning;\n    }\n    // Get current time for systems that need it\n    getCurrentTime() {\n        return this.currentTime;\n    }\n    // Get accumulator ratio for interpolation\n    getInterpolationRatio() {\n        return this.accumulator / this.fixedTimeStep;\n    }\n    constructor(){\n        super();\n        this.isRunning = false;\n        this.lastTime = 0;\n        this.accumulator = 0;\n        this.currentTime = 0;\n        this.frameId = 0;\n        // Performance settings\n        this.fixedTimeStep = 1 / 60 // 60 FPS physics\n        ;\n        this.maxFrameTime = 1 / 30 // Prevent spiral of death at 30 FPS\n        ;\n        this.maxSubSteps = 5 // Maximum physics substeps per frame\n        ;\n        // Performance monitoring\n        this.frameCount = 0;\n        this.fpsUpdateTime = 0;\n        this.currentFPS = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0dhbWVMb29wLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBQ0U7QUFRN0MsTUFBTUMsaUJBQWlCRCw2REFBWUE7SUFxQmpDRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7UUFFcEIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVlDLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLHNCQUFzQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDOUQ7SUFFT0MsT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNLLE9BQU8sRUFBRTtZQUNoQksscUJBQXFCLElBQUksQ0FBQ0wsT0FBTztZQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNqQjtJQUNGO0lBRU9NLGdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtJQUVPQyxtQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNDLGFBQWE7SUFDM0I7SUFFUVAsU0FBU1EsV0FBbUIsRUFBUTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLEVBQUU7UUFFckIsMkRBQTJEO1FBQzNELE1BQU1nQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsY0FBYyxJQUFJLENBQUNkLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQ2tCLFlBQVk7UUFDbEYsSUFBSSxDQUFDbEIsUUFBUSxHQUFHYztRQUNoQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFFbkIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssU0FBUyxDQUFDSjtRQUVmLDZDQUE2QztRQUM3QyxJQUFJLENBQUNaLFdBQVcsSUFBSVk7UUFFcEIsaUNBQWlDO1FBQ2pDLElBQUlLLFdBQVc7UUFDZixNQUFPLElBQUksQ0FBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUNVLGFBQWEsSUFBSU8sV0FBVyxJQUFJLENBQUNDLFdBQVcsQ0FBRTtZQUM1RSxJQUFJLENBQUNDLElBQUksQ0FBQyxlQUFlO2dCQUFFQyxnQkFBZ0IsSUFBSSxDQUFDVixhQUFhO1lBQUM7WUFDOUQsSUFBSSxDQUFDVixXQUFXLElBQUksSUFBSSxDQUFDVSxhQUFhO1lBQ3RDTztRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVU7WUFBRVA7UUFBVTtRQUVoQyxzREFBc0Q7UUFDdEQsTUFBTVMsZ0JBQWdCLElBQUksQ0FBQ3JCLFdBQVcsR0FBRyxJQUFJLENBQUNVLGFBQWE7UUFFM0QsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ1MsSUFBSSxDQUFDLFVBQVU7WUFBRVA7WUFBV1M7UUFBYztRQUUvQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHQyxzQkFBc0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzlEO0lBRVFZLFVBQVVKLFNBQWlCLEVBQVE7UUFDekMsSUFBSSxDQUFDVSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLElBQUlYO1FBRXRCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ1csYUFBYSxJQUFJLEtBQUs7WUFDN0IsSUFBSSxDQUFDZixVQUFVLEdBQUdLLEtBQUtXLEtBQUssQ0FBQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWE7WUFDakUsSUFBSSxDQUFDRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVPRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ1MsSUFBSTtRQUNYO0lBQ0Y7SUFFT3FCLFNBQWU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNELEtBQUs7UUFDWjtJQUNGO0lBRU9nQyxXQUFvQjtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDL0IsU0FBUztJQUN4QjtJQUVBLDRDQUE0QztJQUNyQ2dDLGlCQUF5QjtRQUM5QixPQUFPLElBQUksQ0FBQ2pCLFdBQVc7SUFDekI7SUFFQSwwQ0FBMEM7SUFDbkNrQix3QkFBZ0M7UUFDckMsT0FBTyxJQUFJLENBQUM3QixXQUFXLEdBQUcsSUFBSSxDQUFDVSxhQUFhO0lBQzlDO0lBdEdBb0IsYUFBYztRQUNaLEtBQUs7YUFqQkNsQyxZQUFZO2FBQ1pDLFdBQVc7YUFDWEcsY0FBYzthQUNkVyxjQUFjO2FBQ2RWLFVBQVU7UUFFbEIsdUJBQXVCO2FBQ05TLGdCQUFnQixJQUFJLEdBQUksaUJBQWlCOzthQUN6Q0ssZUFBZSxJQUFJLEdBQUssb0NBQW9DOzthQUM1REcsY0FBYyxFQUFVLHFDQUFxQzs7UUFFOUUseUJBQXlCO2FBQ2pCSSxhQUFhO2FBQ2JDLGdCQUFnQjthQUNoQmYsYUFBYTtJQUlyQjtBQXFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9HYW1lTG9vcC50cz82ZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9wdGltaXplZCBnYW1lIGxvb3Agd2l0aCBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZUxvb3BFdmVudHMge1xuICB1cGRhdGU6IHsgZGVsdGFUaW1lOiBudW1iZXIgfTtcbiAgZml4ZWRVcGRhdGU6IHsgZml4ZWREZWx0YVRpbWU6IG51bWJlciB9O1xuICByZW5kZXI6IHsgZGVsdGFUaW1lOiBudW1iZXI7IGludGVycG9sYXRpb246IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2FtZUxvb3AgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBhY2N1bXVsYXRvciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFRpbWUgPSAwO1xuICBwcml2YXRlIGZyYW1lSWQgPSAwO1xuXG4gIC8vIFBlcmZvcm1hbmNlIHNldHRpbmdzXG4gIHByaXZhdGUgcmVhZG9ubHkgZml4ZWRUaW1lU3RlcCA9IDEgLyA2MDsgLy8gNjAgRlBTIHBoeXNpY3NcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGcmFtZVRpbWUgPSAxIC8gMzA7ICAvLyBQcmV2ZW50IHNwaXJhbCBvZiBkZWF0aCBhdCAzMCBGUFNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTdWJTdGVwcyA9IDU7ICAgICAgICAvLyBNYXhpbXVtIHBoeXNpY3Mgc3Vic3RlcHMgcGVyIGZyYW1lXG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuICBwcml2YXRlIGZwc1VwZGF0ZVRpbWUgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRGUFMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVMb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGUFM7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rml4ZWRUaW1lU3RlcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZVN0ZXA7XG4gIH1cblxuICBwcml2YXRlIGdhbWVMb29wKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGEgdGltZSBhbmQgY2xhbXAgaXQgdG8gcHJldmVudCBsYXJnZSBqdW1wc1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMCwgdGhpcy5tYXhGcmFtZVRpbWUpO1xuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnVwZGF0ZUZQUyhkZWx0YVRpbWUpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB0aW1lIGZvciBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YVRpbWU7XG5cbiAgICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZXNcbiAgICBsZXQgc3ViU3RlcHMgPSAwO1xuICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IHRoaXMuZml4ZWRUaW1lU3RlcCAmJiBzdWJTdGVwcyA8IHRoaXMubWF4U3ViU3RlcHMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZml4ZWRVcGRhdGUnLCB7IGZpeGVkRGVsdGFUaW1lOiB0aGlzLmZpeGVkVGltZVN0ZXAgfSk7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IHRoaXMuZml4ZWRUaW1lU3RlcDtcbiAgICAgIHN1YlN0ZXBzKys7XG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGUgdGltZXN0ZXAgZ2FtZSBsb2dpYyB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZGVsdGFUaW1lIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHRoaXMuYWNjdW11bGF0b3IgLyB0aGlzLmZpeGVkVGltZVN0ZXA7XG5cbiAgICAvLyBSZW5kZXIgd2l0aCBpbnRlcnBvbGF0aW9uXG4gICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcblxuICAgIC8vIFNjaGVkdWxlIG5leHQgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lTG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRlBTKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHNVcGRhdGVUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIC8vIFVwZGF0ZSBGUFMgZXZlcnkgc2Vjb25kXG4gICAgaWYgKHRoaXMuZnBzVXBkYXRlVGltZSA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3VycmVudEZQUyA9IE1hdGgucm91bmQodGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcHNVcGRhdGVUaW1lKTtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICB0aGlzLmZwc1VwZGF0ZVRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgdGltZSBmb3Igc3lzdGVtcyB0aGF0IG5lZWQgaXRcbiAgcHVibGljIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cblxuICAvLyBHZXQgYWNjdW11bGF0b3IgcmF0aW8gZm9yIGludGVycG9sYXRpb25cbiAgcHVibGljIGdldEludGVycG9sYXRpb25SYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yIC8gdGhpcy5maXhlZFRpbWVTdGVwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiR2FtZUxvb3AiLCJzdGFydCIsImlzUnVubmluZyIsImxhc3RUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhY2N1bXVsYXRvciIsImZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnYW1lTG9vcCIsImJpbmQiLCJzdG9wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRDdXJyZW50RlBTIiwiY3VycmVudEZQUyIsImdldEZpeGVkVGltZVN0ZXAiLCJmaXhlZFRpbWVTdGVwIiwiY3VycmVudFRpbWUiLCJkZWx0YVRpbWUiLCJNYXRoIiwibWluIiwibWF4RnJhbWVUaW1lIiwidXBkYXRlRlBTIiwic3ViU3RlcHMiLCJtYXhTdWJTdGVwcyIsImVtaXQiLCJmaXhlZERlbHRhVGltZSIsImludGVycG9sYXRpb24iLCJmcmFtZUNvdW50IiwiZnBzVXBkYXRlVGltZSIsInJvdW5kIiwicGF1c2UiLCJyZXN1bWUiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwiZ2V0SW50ZXJwb2xhdGlvblJhdGlvIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/GameLoop.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/InputManager.ts":
/*!**********************************!*\
  !*** ./src/core/InputManager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: function() { return /* binding */ InputManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Centralized input handling system\n\nclass InputManager extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initialize(canvas) {\n        this.canvas = canvas;\n        // Add canvas-specific event listeners to ensure we capture events\n        // that might be handled by React Three Fiber\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        canvas.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        canvas.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    // Don't automatically request pointer lock - let systems handle this\n    // canvas.addEventListener('click', () => {\n    //   if (!this.isPointerLocked) {\n    //     this.requestPointerLock();\n    //   }\n    // });\n    }\n    requestPointerLock() {\n        if (this.canvas) {\n            this.canvas.requestPointerLock();\n        }\n    }\n    exitPointerLock() {\n        document.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.keys.has(key.toLowerCase());\n    }\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    getMousePosition() {\n        return {\n            ...this.mousePosition\n        };\n    }\n    getMouseDelta() {\n        return {\n            ...this.mouseDelta\n        };\n    }\n    getInputState() {\n        return {\n            keys: new Set(this.keys),\n            mouse: {\n                x: this.mousePosition.x,\n                y: this.mousePosition.y,\n                deltaX: this.mouseDelta.x,\n                deltaY: this.mouseDelta.y,\n                buttons: new Set(this.mouseButtons)\n            }\n        };\n    }\n    checkDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return false;\n        const now = Date.now();\n        // Only return true if we have a valid double-tap sequence:\n        // 1. We have a valid first tap (press + release)\n        // 2. We're currently in a double-tap sequence\n        // 3. The second press happened within the threshold after the first release\n        if (timing.hasValidFirstTap && timing.isInDoubleTapSequence && timing.secondPressTime > 0) {\n            const timeBetweenTaps = timing.secondPressTime - timing.firstReleaseTime;\n            return timeBetweenTaps <= this.DOUBLE_TAP_THRESHOLD;\n        }\n        return false;\n    }\n    resetDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (timing) {\n            timing.firstPressTime = 0;\n            timing.firstReleaseTime = 0;\n            timing.secondPressTime = 0;\n            timing.isInDoubleTapSequence = false;\n            timing.hasValidFirstTap = false;\n        }\n    }\n    update() {\n        // Reset mouse delta each frame\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n        // Clean up old timing entries to prevent memory leaks\n        this.cleanupOldTimings();\n    }\n    cleanupOldTimings() {\n        const now = Date.now();\n        const CLEANUP_THRESHOLD = 5000; // 5 seconds\n        const keysToDelete = [];\n        // Use forEach instead of for...of to avoid ES2015 iteration issues\n        this.keyTimings.forEach((timing, key)=>{\n            // Remove entries that haven't been used in a while\n            const lastActivity = Math.max(timing.firstPressTime, timing.firstReleaseTime, timing.secondPressTime);\n            if (lastActivity > 0 && now - lastActivity > CLEANUP_THRESHOLD) {\n                keysToDelete.push(key);\n            }\n        });\n        // Delete the keys after iteration to avoid modifying map during iteration\n        keysToDelete.forEach((key)=>this.keyTimings.delete(key));\n    }\n    // Debug method to help track double tap detection\n    getDoubleTapDebugInfo(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return null;\n        const now = Date.now();\n        return {\n            key: keyLower,\n            firstPressTime: timing.firstPressTime,\n            firstReleaseTime: timing.firstReleaseTime,\n            secondPressTime: timing.secondPressTime,\n            hasValidFirstTap: timing.hasValidFirstTap,\n            isInDoubleTapSequence: timing.isInDoubleTapSequence,\n            timeSinceFirstPress: timing.firstPressTime > 0 ? now - timing.firstPressTime : 0,\n            timeSinceFirstRelease: timing.firstReleaseTime > 0 ? now - timing.firstReleaseTime : 0,\n            timeSinceSecondPress: timing.secondPressTime > 0 ? now - timing.secondPressTime : 0,\n            threshold: this.DOUBLE_TAP_THRESHOLD\n        };\n    }\n    setupEventListeners() {\n        // Keyboard events\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\n        // Mouse events\n        document.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.addEventListener(\"wheel\", this.onWheel.bind(this), {\n            passive: false\n        });\n        // Pointer lock events\n        document.addEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.addEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        // Prevent context menu\n        document.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n        // Handle window focus/blur to reset input state\n        window.addEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.addEventListener(\"focus\", this.onWindowFocus.bind(this));\n    }\n    onKeyDown(event) {\n        const key = event.key.toLowerCase();\n        if (!this.keys.has(key)) {\n            this.keys.add(key);\n            this.emit(\"keyDown\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key timing for double-tap detection\n            const now = Date.now();\n            let timing = this.keyTimings.get(key);\n            if (!timing) {\n                timing = {\n                    firstPressTime: 0,\n                    firstReleaseTime: 0,\n                    secondPressTime: 0,\n                    isInDoubleTapSequence: false,\n                    hasValidFirstTap: false\n                };\n                this.keyTimings.set(key, timing);\n            }\n            // Handle double-tap sequence logic\n            if (!timing.hasValidFirstTap) {\n                // This is the first press\n                timing.firstPressTime = now;\n                timing.isInDoubleTapSequence = false;\n                timing.hasValidFirstTap = false; // Will be set to true on release\n            } else if (timing.hasValidFirstTap && !timing.isInDoubleTapSequence) {\n                // This could be the second press - check if it's within threshold\n                const timeSinceFirstRelease = now - timing.firstReleaseTime;\n                if (timeSinceFirstRelease <= this.DOUBLE_TAP_THRESHOLD) {\n                    // Valid second press\n                    timing.secondPressTime = now;\n                    timing.isInDoubleTapSequence = true;\n                } else {\n                    // Too late for double-tap, treat as new first press\n                    timing.firstPressTime = now;\n                    timing.firstReleaseTime = 0;\n                    timing.secondPressTime = 0;\n                    timing.isInDoubleTapSequence = false;\n                    timing.hasValidFirstTap = false;\n                }\n            }\n        }\n        // Prevent default for game keys\n        if (this.isGameKey(key)) {\n            event.preventDefault();\n        }\n    }\n    onKeyUp(event) {\n        const key = event.key.toLowerCase();\n        if (this.keys.has(key)) {\n            this.keys.delete(key);\n            this.emit(\"keyUp\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key release timing for double-tap detection\n            const timing = this.keyTimings.get(key);\n            if (timing) {\n                const now = Date.now();\n                if (!timing.hasValidFirstTap && timing.firstPressTime > 0) {\n                    // This completes the first tap\n                    timing.firstReleaseTime = now;\n                    timing.hasValidFirstTap = true;\n                } else if (timing.isInDoubleTapSequence) {\n                    // This completes the double-tap sequence\n                    // The double-tap detection should have already been triggered\n                    // Reset for next potential sequence\n                    setTimeout(()=>{\n                        if (timing) {\n                            timing.firstPressTime = 0;\n                            timing.firstReleaseTime = 0;\n                            timing.secondPressTime = 0;\n                            timing.isInDoubleTapSequence = false;\n                            timing.hasValidFirstTap = false;\n                        }\n                    }, 100); // Small delay to allow dash system to process\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n        this.emit(\"mouseDown\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n        this.emit(\"mouseUp\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseMove(event) {\n        if (this.isPointerLocked) {\n            // Use movement deltas when pointer is locked\n            this.mouseDelta.x += event.movementX;\n            this.mouseDelta.y += event.movementY;\n        } else {\n            // Use absolute position when not locked\n            this.previousMousePosition.x = this.mousePosition.x;\n            this.previousMousePosition.y = this.mousePosition.y;\n            this.mousePosition.x = event.clientX;\n            this.mousePosition.y = event.clientY;\n            // Calculate delta from previous position\n            const deltaX = this.mousePosition.x - this.previousMousePosition.x;\n            const deltaY = this.mousePosition.y - this.previousMousePosition.y;\n            // Accumulate delta for this frame\n            this.mouseDelta.x += deltaX;\n            this.mouseDelta.y += deltaY;\n        }\n        this.emit(\"mouseMove\", {\n            x: this.mousePosition.x,\n            y: this.mousePosition.y,\n            deltaX: this.mouseDelta.x,\n            deltaY: this.mouseDelta.y\n        });\n    }\n    onWheel(event) {\n        this.emit(\"wheel\", {\n            deltaX: event.deltaX,\n            deltaY: event.deltaY,\n            deltaZ: event.deltaZ\n        });\n        event.preventDefault();\n    }\n    onPointerLockChange() {\n        this.isPointerLocked = document.pointerLockElement !== null;\n    }\n    onPointerLockError() {\n        // console.warn('Pointer lock failed');\n        this.isPointerLocked = false;\n    }\n    onWindowBlur() {\n        // Clear all input state when window loses focus\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n    }\n    onWindowFocus() {\n        // Reset mouse delta when window regains focus\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n    isGameKey(key) {\n        // Define which keys should have their default behavior prevented\n        const gameKeys = [\n            \"w\",\n            \"a\",\n            \"s\",\n            \"d\",\n            \" \",\n            \"shift\",\n            \"tab\",\n            \"escape\"\n        ];\n        return gameKeys.includes(key);\n    }\n    destroy() {\n        // Remove document event listeners\n        document.removeEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.removeEventListener(\"keyup\", this.onKeyUp.bind(this));\n        document.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        document.removeEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.removeEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        window.removeEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.removeEventListener(\"focus\", this.onWindowFocus.bind(this));\n        // Remove canvas event listeners if canvas exists\n        if (this.canvas) {\n            this.canvas.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n            this.canvas.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n            this.canvas.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n            this.canvas.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        }\n        // Clear state\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n        this.removeAllListeners();\n    }\n    constructor(){\n        super();\n        this.keys = new Set();\n        this.mouseButtons = new Set();\n        this.mousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.mouseDelta = {\n            x: 0,\n            y: 0\n        };\n        this.previousMousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.isPointerLocked = false;\n        this.canvas = null;\n        // Double-tap detection for dash system\n        this.keyTimings = new Map();\n        this.DOUBLE_TAP_THRESHOLD = 200 // 200ms window for double-tap (reduced from 250ms)\n        ;\n        this.setupEventListeners();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUFvQztBQUNnQjtBQXNCN0MsTUFBTUMscUJBQXFCRCw2REFBWUE7SUF3QnJDRSxXQUFXQyxNQUF5QixFQUFRO1FBQ2pELElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUVkLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0NBLE9BQU9DLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQy9ESCxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ0csU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMzREgsT0FBT0MsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNJLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDL0RILE9BQU9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDSyxPQUFPLENBQUNILElBQUksQ0FBQyxJQUFJLEdBQUc7WUFBRUksU0FBUztRQUFNO1FBQzNFUCxPQUFPQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUNPLElBQU1BLEVBQUVDLGNBQWM7SUFFOUQscUVBQXFFO0lBQ3JFLDJDQUEyQztJQUMzQyxpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU07SUFDTixNQUFNO0lBQ1I7SUFFT0MscUJBQTJCO1FBQ2hDLElBQUksSUFBSSxDQUFDVixNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ1Usa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFT0Msa0JBQXdCO1FBQzdCQyxTQUFTRCxlQUFlO0lBQzFCO0lBRU9FLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxHQUFHLENBQUNGLElBQUlHLFdBQVc7SUFDdEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0osR0FB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Q1ksSUFBSSxDQUFDdUUsS0FBSztRQUNmLElBQUksQ0FBQ2xFLFlBQVksQ0FBQ2tFLEtBQUs7UUFDdkIsSUFBSSxDQUFDbEQsVUFBVSxDQUFDa0QsS0FBSztRQUNyQixJQUFJLENBQUNLLGtCQUFrQjtJQUN6QjtJQXBYQUMsYUFBYztRQUNaLEtBQUs7YUFuQkM3RSxPQUFPLElBQUlXO2FBQ1hOLGVBQWUsSUFBSU07YUFDbkJKLGdCQUFnQjtZQUFFTSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUM3QkwsYUFBYTtZQUFFSSxHQUFHO1lBQUdDLEdBQUc7UUFBRTthQUMxQnNELHdCQUF3QjtZQUFFdkQsR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDckNtRCxrQkFBa0I7YUFDbEJoRixTQUFtQztRQUUzQyx1Q0FBdUM7YUFDL0JvQyxhQUFhLElBQUl5RDthQU9SaEQsdUJBQXVCLElBQUssbURBQW1EOztRQUk5RixJQUFJLENBQUNrQixtQkFBbUI7SUFDMUI7QUFrWEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvSW5wdXRNYW5hZ2VyLnRzPzBkMTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2VudHJhbGl6ZWQgaW5wdXQgaGFuZGxpbmcgc3lzdGVtXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRFdmVudHMge1xuICBrZXlEb3duOiB7IGtleTogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfTtcbiAga2V5VXA6IHsga2V5OiBzdHJpbmc7IGNvZGU6IHN0cmluZyB9O1xuICBtb3VzZURvd246IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlVXA6IHsgYnV0dG9uOiBudW1iZXI7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIG1vdXNlTW92ZTogeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgZGVsdGFYOiBudW1iZXI7IGRlbHRhWTogbnVtYmVyIH07XG4gIHdoZWVsOiB7IGRlbHRhWDogbnVtYmVyOyBkZWx0YVk6IG51bWJlcjsgZGVsdGFaOiBudW1iZXIgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dFN0YXRlIHtcbiAga2V5czogU2V0PHN0cmluZz47XG4gIG1vdXNlOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBkZWx0YVg6IG51bWJlcjtcbiAgICBkZWx0YVk6IG51bWJlcjtcbiAgICBidXR0b25zOiBTZXQ8bnVtYmVyPjtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIElucHV0TWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUga2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBwcml2YXRlIG1vdXNlQnV0dG9ucyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBwcml2YXRlIG1vdXNlUG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgcHJpdmF0ZSBtb3VzZURlbHRhID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgcHJldmlvdXNNb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8vIERvdWJsZS10YXAgZGV0ZWN0aW9uIGZvciBkYXNoIHN5c3RlbVxuICBwcml2YXRlIGtleVRpbWluZ3MgPSBuZXcgTWFwPHN0cmluZywgeyBcbiAgICBmaXJzdFByZXNzVGltZTogbnVtYmVyO1xuICAgIGZpcnN0UmVsZWFzZVRpbWU6IG51bWJlcjtcbiAgICBzZWNvbmRQcmVzc1RpbWU6IG51bWJlcjtcbiAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IGJvb2xlYW47XG4gICAgaGFzVmFsaWRGaXJzdFRhcDogYm9vbGVhbjtcbiAgfT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBET1VCTEVfVEFQX1RIUkVTSE9MRCA9IDIwMDsgLy8gMjAwbXMgd2luZG93IGZvciBkb3VibGUtdGFwIChyZWR1Y2VkIGZyb20gMjUwbXMpXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICBcbiAgICAvLyBBZGQgY2FudmFzLXNwZWNpZmljIGV2ZW50IGxpc3RlbmVycyB0byBlbnN1cmUgd2UgY2FwdHVyZSBldmVudHNcbiAgICAvLyB0aGF0IG1pZ2h0IGJlIGhhbmRsZWQgYnkgUmVhY3QgVGhyZWUgRmliZXJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbC5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIFxuICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgcmVxdWVzdCBwb2ludGVyIGxvY2sgLSBsZXQgc3lzdGVtcyBoYW5kbGUgdGhpc1xuICAgIC8vIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAvLyAgIGlmICghdGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAvLyAgICAgdGhpcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcbiAgfVxuXG4gIHB1YmxpYyByZXF1ZXN0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZXhpdFBvaW50ZXJMb2NrKCk6IHZvaWQge1xuICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICB9XG5cbiAgcHVibGljIGlzS2V5UHJlc3NlZChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmtleXMuaGFzKGtleS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc01vdXNlQnV0dG9uUHJlc3NlZChidXR0b246IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1vdXNlQnV0dG9ucy5oYXMoYnV0dG9uKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNb3VzZVBvc2l0aW9uKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb3VzZVBvc2l0aW9uIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IC4uLnRoaXMubW91c2VEZWx0YSB9O1xuICB9XG5cbiAgcHVibGljIGdldElucHV0U3RhdGUoKTogSW5wdXRTdGF0ZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IG5ldyBTZXQodGhpcy5rZXlzKSxcbiAgICAgIG1vdXNlOiB7XG4gICAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgICB5OiB0aGlzLm1vdXNlUG9zaXRpb24ueSxcbiAgICAgICAgZGVsdGFYOiB0aGlzLm1vdXNlRGVsdGEueCxcbiAgICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICAgICAgYnV0dG9uczogbmV3IFNldCh0aGlzLm1vdXNlQnV0dG9ucyksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgY2hlY2tEb3VibGVUYXAoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIE9ubHkgcmV0dXJuIHRydWUgaWYgd2UgaGF2ZSBhIHZhbGlkIGRvdWJsZS10YXAgc2VxdWVuY2U6XG4gICAgLy8gMS4gV2UgaGF2ZSBhIHZhbGlkIGZpcnN0IHRhcCAocHJlc3MgKyByZWxlYXNlKVxuICAgIC8vIDIuIFdlJ3JlIGN1cnJlbnRseSBpbiBhIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAvLyAzLiBUaGUgc2Vjb25kIHByZXNzIGhhcHBlbmVkIHdpdGhpbiB0aGUgdGhyZXNob2xkIGFmdGVyIHRoZSBmaXJzdCByZWxlYXNlXG4gICAgaWYgKHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwICYmIFxuICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlICYmIFxuICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID4gMCkge1xuICAgICAgXG4gICAgICBjb25zdCB0aW1lQmV0d2VlblRhcHMgPSB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lIC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWU7XG4gICAgICByZXR1cm4gdGltZUJldHdlZW5UYXBzIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldERvdWJsZVRhcChrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXlMb3dlcik7XG4gICAgaWYgKHRpbWluZykge1xuICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lID0gMDtcbiAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gMDtcbiAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIGVhY2ggZnJhbWVcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIG9sZCB0aW1pbmcgZW50cmllcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgIHRoaXMuY2xlYW51cE9sZFRpbWluZ3MoKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBjbGVhbnVwT2xkVGltaW5ncygpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IENMRUFOVVBfVEhSRVNIT0xEID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSBmb3JFYWNoIGluc3RlYWQgb2YgZm9yLi4ub2YgdG8gYXZvaWQgRVMyMDE1IGl0ZXJhdGlvbiBpc3N1ZXNcbiAgICB0aGlzLmtleVRpbWluZ3MuZm9yRWFjaCgodGltaW5nLCBrZXkpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIHRoYXQgaGF2ZW4ndCBiZWVuIHVzZWQgaW4gYSB3aGlsZVxuICAgICAgY29uc3QgbGFzdEFjdGl2aXR5ID0gTWF0aC5tYXgoXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSwgXG4gICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLCBcbiAgICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgaWYgKGxhc3RBY3Rpdml0eSA+IDAgJiYgbm93IC0gbGFzdEFjdGl2aXR5ID4gQ0xFQU5VUF9USFJFU0hPTEQpIHtcbiAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBEZWxldGUgdGhlIGtleXMgYWZ0ZXIgaXRlcmF0aW9uIHRvIGF2b2lkIG1vZGlmeWluZyBtYXAgZHVyaW5nIGl0ZXJhdGlvblxuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiB0aGlzLmtleVRpbWluZ3MuZGVsZXRlKGtleSkpO1xuICB9XG4gIFxuICAvLyBEZWJ1ZyBtZXRob2QgdG8gaGVscCB0cmFjayBkb3VibGUgdGFwIGRldGVjdGlvblxuICBwdWJsaWMgZ2V0RG91YmxlVGFwRGVidWdJbmZvKGtleTogc3RyaW5nKTogYW55IHtcbiAgICBjb25zdCBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5TG93ZXIpO1xuICAgIFxuICAgIGlmICghdGltaW5nKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleUxvd2VyLFxuICAgICAgZmlyc3RQcmVzc1RpbWU6IHRpbWluZy5maXJzdFByZXNzVGltZSxcbiAgICAgIGZpcnN0UmVsZWFzZVRpbWU6IHRpbWluZy5maXJzdFJlbGVhc2VUaW1lLFxuICAgICAgc2Vjb25kUHJlc3NUaW1lOiB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lLFxuICAgICAgaGFzVmFsaWRGaXJzdFRhcDogdGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAsXG4gICAgICBpc0luRG91YmxlVGFwU2VxdWVuY2U6IHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UsXG4gICAgICB0aW1lU2luY2VGaXJzdFByZXNzOiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UHJlc3NUaW1lIDogMCxcbiAgICAgIHRpbWVTaW5jZUZpcnN0UmVsZWFzZTogdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPiAwID8gbm93IC0gdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgOiAwLFxuICAgICAgdGltZVNpbmNlU2Vjb25kUHJlc3M6IHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPiAwID8gbm93IC0gdGltaW5nLnNlY29uZFByZXNzVGltZSA6IDAsXG4gICAgICB0aHJlc2hvbGQ6IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTERcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIEtleWJvYXJkIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIE1vdXNlIGV2ZW50c1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIC8vIFBvaW50ZXIgbG9jayBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Qb2ludGVyTG9ja0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2Vycm9yJywgdGhpcy5vblBvaW50ZXJMb2NrRXJyb3IuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBQcmV2ZW50IGNvbnRleHQgbWVudVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IGZvY3VzL2JsdXIgdG8gcmVzZXQgaW5wdXQgc3RhdGVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKCF0aGlzLmtleXMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMua2V5cy5hZGQoa2V5KTtcbiAgICAgIHRoaXMuZW1pdCgna2V5RG93bicsIHsga2V5OiBldmVudC5rZXksIGNvZGU6IGV2ZW50LmNvZGUgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGtleSB0aW1pbmcgZm9yIGRvdWJsZS10YXAgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5KTtcbiAgICAgIFxuICAgICAgaWYgKCF0aW1pbmcpIHtcbiAgICAgICAgdGltaW5nID0geyBcbiAgICAgICAgICBmaXJzdFByZXNzVGltZTogMCwgXG4gICAgICAgICAgZmlyc3RSZWxlYXNlVGltZTogMCwgXG4gICAgICAgICAgc2Vjb25kUHJlc3NUaW1lOiAwLFxuICAgICAgICAgIGlzSW5Eb3VibGVUYXBTZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgaGFzVmFsaWRGaXJzdFRhcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXlUaW1pbmdzLnNldChrZXksIHRpbWluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBkb3VibGUtdGFwIHNlcXVlbmNlIGxvZ2ljXG4gICAgICBpZiAoIXRpbWluZy5oYXNWYWxpZEZpcnN0VGFwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHByZXNzXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSA9IG5vdztcbiAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlOyAvLyBXaWxsIGJlIHNldCB0byB0cnVlIG9uIHJlbGVhc2VcbiAgICAgIH0gZWxzZSBpZiAodGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgIXRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSB0aGUgc2Vjb25kIHByZXNzIC0gY2hlY2sgaWYgaXQncyB3aXRoaW4gdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0UmVsZWFzZSA9IG5vdyAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lO1xuICAgICAgICBpZiAodGltZVNpbmNlRmlyc3RSZWxlYXNlIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBWYWxpZCBzZWNvbmQgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvbyBsYXRlIGZvciBkb3VibGUtdGFwLCB0cmVhdCBhcyBuZXcgZmlyc3QgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSBub3c7XG4gICAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGZvciBnYW1lIGtleXNcbiAgICBpZiAodGhpcy5pc0dhbWVLZXkoa2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBpZiAodGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmtleXMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2tleVVwJywgeyBrZXk6IGV2ZW50LmtleSwgY29kZTogZXZlbnQuY29kZSB9KTtcblxuICAgICAgLy8gVHJhY2sga2V5IHJlbGVhc2UgdGltaW5nIGZvciBkb3VibGUtdGFwIGRldGVjdGlvblxuICAgICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXkpO1xuICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCAmJiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGZpcnN0IHRhcFxuICAgICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAgICAgICAvLyBUaGUgZG91YmxlLXRhcCBkZXRlY3Rpb24gc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgIC8vIFJlc2V0IGZvciBuZXh0IHBvdGVudGlhbCBzZXF1ZW5jZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IDA7XG4gICAgICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gYWxsb3cgZGFzaCBzeXN0ZW0gdG8gcHJvY2Vzc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMubW91c2VCdXR0b25zLmFkZChldmVudC5idXR0b24pO1xuICAgIHRoaXMuZW1pdCgnbW91c2VEb3duJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZVVwKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuZGVsZXRlKGV2ZW50LmJ1dHRvbik7XG4gICAgdGhpcy5lbWl0KCdtb3VzZVVwJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAgIC8vIFVzZSBtb3ZlbWVudCBkZWx0YXMgd2hlbiBwb2ludGVyIGlzIGxvY2tlZFxuICAgICAgdGhpcy5tb3VzZURlbHRhLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgdGhpcy5tb3VzZURlbHRhLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgYWJzb2x1dGUgcG9zaXRpb24gd2hlbiBub3QgbG9ja2VkXG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi54ID0gdGhpcy5tb3VzZVBvc2l0aW9uLng7XG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi55ID0gdGhpcy5tb3VzZVBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YSBmcm9tIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1vdXNlUG9zaXRpb24ueCAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLng7XG4gICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1vdXNlUG9zaXRpb24ueSAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIC8vIEFjY3VtdWxhdGUgZGVsdGEgZm9yIHRoaXMgZnJhbWVcbiAgICAgIHRoaXMubW91c2VEZWx0YS54ICs9IGRlbHRhWDtcbiAgICAgIHRoaXMubW91c2VEZWx0YS55ICs9IGRlbHRhWTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ21vdXNlTW92ZScsIHtcbiAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnksXG4gICAgICBkZWx0YVg6IHRoaXMubW91c2VEZWx0YS54LFxuICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25XaGVlbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnd2hlZWwnLCB7XG4gICAgICBkZWx0YVg6IGV2ZW50LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuICAgICAgZGVsdGFaOiBldmVudC5kZWx0YVosXG4gICAgfSk7XG4gICAgXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0NoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUG9pbnRlckxvY2tlZCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAhPT0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0Vycm9yKCk6IHZvaWQge1xuICAgIC8vIGNvbnNvbGUud2FybignUG9pbnRlciBsb2NrIGZhaWxlZCcpO1xuICAgIHRoaXMuaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uV2luZG93Qmx1cigpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbGwgaW5wdXQgc3RhdGUgd2hlbiB3aW5kb3cgbG9zZXMgZm9jdXNcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldpbmRvd0ZvY3VzKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIHdoZW4gd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0dhbWVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBEZWZpbmUgd2hpY2gga2V5cyBzaG91bGQgaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIHByZXZlbnRlZFxuICAgIGNvbnN0IGdhbWVLZXlzID0gWyd3JywgJ2EnLCAncycsICdkJywgJyAnLCAnc2hpZnQnLCAndGFiJywgJ2VzY2FwZSddO1xuICAgIHJldHVybiBnYW1lS2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vblBvaW50ZXJMb2NrQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrZXJyb3InLCB0aGlzLm9uUG9pbnRlckxvY2tFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFJlbW92ZSBjYW52YXMgZXZlbnQgbGlzdGVuZXJzIGlmIGNhbnZhcyBleGlzdHNcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhdGVcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJJbnB1dE1hbmFnZXIiLCJpbml0aWFsaXplIiwiY2FudmFzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VEb3duIiwiYmluZCIsIm9uTW91c2VVcCIsIm9uTW91c2VNb3ZlIiwib25XaGVlbCIsInBhc3NpdmUiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZXF1ZXN0UG9pbnRlckxvY2siLCJleGl0UG9pbnRlckxvY2siLCJkb2N1bWVudCIsImlzS2V5UHJlc3NlZCIsImtleSIsImtleXMiLCJoYXMiLCJ0b0xvd2VyQ2FzZSIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiYnV0dG9uIiwibW91c2VCdXR0b25zIiwiZ2V0TW91c2VQb3NpdGlvbiIsIm1vdXNlUG9zaXRpb24iLCJnZXRNb3VzZURlbHRhIiwibW91c2VEZWx0YSIsImdldElucHV0U3RhdGUiLCJTZXQiLCJtb3VzZSIsIngiLCJ5IiwiZGVsdGFYIiwiZGVsdGFZIiwiYnV0dG9ucyIsImNoZWNrRG91YmxlVGFwIiwia2V5TG93ZXIiLCJ0aW1pbmciLCJrZXlUaW1pbmdzIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImhhc1ZhbGlkRmlyc3RUYXAiLCJpc0luRG91YmxlVGFwU2VxdWVuY2UiLCJzZWNvbmRQcmVzc1RpbWUiLCJ0aW1lQmV0d2VlblRhcHMiLCJmaXJzdFJlbGVhc2VUaW1lIiwiRE9VQkxFX1RBUF9USFJFU0hPTEQiLCJyZXNldERvdWJsZVRhcCIsImZpcnN0UHJlc3NUaW1lIiwidXBkYXRlIiwiY2xlYW51cE9sZFRpbWluZ3MiLCJDTEVBTlVQX1RIUkVTSE9MRCIsImtleXNUb0RlbGV0ZSIsImZvckVhY2giLCJsYXN0QWN0aXZpdHkiLCJNYXRoIiwibWF4IiwicHVzaCIsImRlbGV0ZSIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsInRpbWVTaW5jZUZpcnN0UHJlc3MiLCJ0aW1lU2luY2VGaXJzdFJlbGVhc2UiLCJ0aW1lU2luY2VTZWNvbmRQcmVzcyIsInRocmVzaG9sZCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJvbktleURvd24iLCJvbktleVVwIiwib25Qb2ludGVyTG9ja0NoYW5nZSIsIm9uUG9pbnRlckxvY2tFcnJvciIsIndpbmRvdyIsIm9uV2luZG93Qmx1ciIsIm9uV2luZG93Rm9jdXMiLCJldmVudCIsImFkZCIsImVtaXQiLCJjb2RlIiwic2V0IiwiaXNHYW1lS2V5Iiwic2V0VGltZW91dCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNQb2ludGVyTG9ja2VkIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwicHJldmlvdXNNb3VzZVBvc2l0aW9uIiwiZGVsdGFaIiwicG9pbnRlckxvY2tFbGVtZW50IiwiY2xlYXIiLCJnYW1lS2V5cyIsImluY2x1ZGVzIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJjb25zdHJ1Y3RvciIsIk1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/InputManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/Entity.ts":
/*!***************************!*\
  !*** ./src/ecs/Entity.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ Component; },\n/* harmony export */   Entity: function() { return /* binding */ Entity; }\n/* harmony export */ });\n// Entity Component System - Entity Management\nclass Entity {\n    addComponent(component) {\n        // Use explicit componentType if available, fallback to constructor name\n        const componentName = component.componentType || component.constructor.name;\n        this.components.set(componentName, component);\n        return component;\n    }\n    removeComponent(componentType) {\n        this.components.delete(componentType.name);\n    }\n    getComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        let component = this.components.get(requestedType);\n        // If not found with explicit type, try searching by constructor name as fallback\n        if (!component && componentType.componentType) {\n            component = this.components.get(componentType.name);\n            if (component) {}\n        }\n        // If still not found, search through all components to find a match by type\n        if (!component) {\n            const entries = Array.from(this.components.entries());\n            for (const [key, comp] of entries){\n                if (comp instanceof componentType) {\n                    // Reduce spam - only log occasionally for instanceof fallback usage\n                    if (Math.random() < 0.01) {}\n                    component = comp;\n                    break;\n                }\n            }\n        }\n        if (component) {\n            const actualType = component.componentType || component.constructor.name;\n            if (actualType !== requestedType && !component.constructor.name.match(/^[a-z]$/)) {\n            // Only warn if it's not a minified single-letter class name\n            }\n        } else {\n            // Reduce spam - only log occasionally for missing components\n            if (Math.random() < 0.001) {}\n        }\n        return component;\n    }\n    hasComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        // Check with explicit type first\n        if (this.components.has(requestedType)) {\n            return true;\n        }\n        // If not found with explicit type, try constructor name as fallback\n        if (componentType.componentType && this.components.has(componentType.name)) {\n            return true;\n        }\n        // If still not found, search through all components to find a match by type\n        const components = Array.from(this.components.values());\n        for (const comp of components){\n            if (comp instanceof componentType) {\n                return true;\n            }\n        }\n        return false;\n    }\n    hasComponents(componentTypes) {\n        return componentTypes.every((type)=>this.hasComponent(type));\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getComponentNames() {\n        return Array.from(this.components.keys());\n    }\n    isActive() {\n        return this.active;\n    }\n    setActive(active) {\n        this.active = active;\n    }\n    destroy() {\n        this.components.clear();\n        this.active = false;\n    }\n    constructor(){\n        this.components = new Map();\n        this.active = true;\n        this.id = Entity.nextId++;\n    }\n}\nEntity.nextId = 1;\nclass Component {\n    constructor(){\n        this.enabled = true;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBRU9DLFdBQW9CO1FBQ3pCLE9BQU8sSUFBSSxDQUFDQyxNQUFNO0lBQ3BCO0lBRU9DLFVBQVVELE1BQWUsRUFBUTtRQUN0QyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7SUFDaEI7SUFFT0UsVUFBZ0I7UUFDckIsSUFBSSxDQUFDN0IsVUFBVSxDQUFDOEIsS0FBSztRQUNyQixJQUFJLENBQUNILE1BQU0sR0FBRztJQUNoQjtJQXZHQTdCLGFBQWM7YUFITkUsYUFBYSxJQUFJK0I7YUFDakJKLFNBQVM7UUFHZixJQUFJLENBQUNLLEVBQUUsR0FBR3ZDLE9BQU93QyxNQUFNO0lBQ3pCO0FBc0dGO0FBOUdheEMsT0FDSXdDLFNBQW1CO0FBK0c3QixNQUFlQzs7YUFDYkMsVUFBVTs7QUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9FbnRpdHkudHM/NWYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEVudGl0eSBNYW5hZ2VtZW50XG5leHBvcnQgdHlwZSBFbnRpdHlJZCA9IG51bWJlcjtcblxuZXhwb3J0IGNsYXNzIEVudGl0eSB7XG4gIHByaXZhdGUgc3RhdGljIG5leHRJZDogRW50aXR5SWQgPSAxO1xuICBwdWJsaWMgcmVhZG9ubHkgaWQ6IEVudGl0eUlkO1xuICBwcml2YXRlIGNvbXBvbmVudHMgPSBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50PigpO1xuICBwcml2YXRlIGFjdGl2ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pZCA9IEVudGl0eS5uZXh0SWQrKztcbiAgfVxuXG4gIHB1YmxpYyBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50OiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IChjb21wb25lbnQgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IHZvaWQge1xuICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50VHlwZTogbmV3ICgpID0+IFQpOiBUIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgY29tcG9uZW50VHlwZSBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGNvbnN0cnVjdG9yIG5hbWVcbiAgICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICBsZXQgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzLmdldChyZXF1ZXN0ZWRUeXBlKTtcbiAgICBcbiAgICAvLyBJZiBub3QgZm91bmQgd2l0aCBleHBsaWNpdCB0eXBlLCB0cnkgc2VhcmNoaW5nIGJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoIWNvbXBvbmVudCAmJiAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50cy5nZXQoY29tcG9uZW50VHlwZS5uYW1lKTtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSWYgc3RpbGwgbm90IGZvdW5kLCBzZWFyY2ggdGhyb3VnaCBhbGwgY29tcG9uZW50cyB0byBmaW5kIGEgbWF0Y2ggYnkgdHlwZVxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMuZW50cmllcygpKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgY29tcF0gb2YgZW50cmllcykge1xuICAgICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgaW5zdGFuY2VvZiBmYWxsYmFjayB1c2FnZVxuICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSkgeyAvLyBPbmx5IGxvZyAxJSBvZiB0aGUgdGltZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSAoY29tcG9uZW50IGFzIGFueSkuY29tcG9uZW50VHlwZSB8fCBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChhY3R1YWxUeXBlICE9PSByZXF1ZXN0ZWRUeXBlICYmICFjb21wb25lbnQuY29uc3RydWN0b3IubmFtZS5tYXRjaCgvXlthLXpdJC8pKSB7XG4gICAgICAgIC8vIE9ubHkgd2FybiBpZiBpdCdzIG5vdCBhIG1pbmlmaWVkIHNpbmdsZS1sZXR0ZXIgY2xhc3MgbmFtZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgbWlzc2luZyBjb21wb25lbnRzXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDAxKSB7IC8vIE9ubHkgbG9nIDAuMSUgb2YgdGhlIHRpbWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvbXBvbmVudCBhcyBUO1xuICB9XG5cbiAgcHVibGljIGhhc0NvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IGJvb2xlYW4ge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IHJlcXVlc3RlZFR5cGUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIENoZWNrIHdpdGggZXhwbGljaXQgdHlwZSBmaXJzdFxuICAgIGlmICh0aGlzLmNvbXBvbmVudHMuaGFzKHJlcXVlc3RlZFR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm90IGZvdW5kIHdpdGggZXhwbGljaXQgdHlwZSwgdHJ5IGNvbnN0cnVjdG9yIG5hbWUgYXMgZmFsbGJhY2tcbiAgICBpZiAoKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlICYmIHRoaXMuY29tcG9uZW50cy5oYXMoY29tcG9uZW50VHlwZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgc2VhcmNoIHRocm91Z2ggYWxsIGNvbXBvbmVudHMgdG8gZmluZCBhIG1hdGNoIGJ5IHR5cGVcbiAgICBjb25zdCBjb21wb25lbnRzID0gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wb25lbnRzKSB7XG4gICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzOiAobmV3ICgpID0+IENvbXBvbmVudClbXSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjb21wb25lbnRUeXBlcy5ldmVyeSh0eXBlID0+IHRoaXMuaGFzQ29tcG9uZW50KHR5cGUpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxDb21wb25lbnRzKCk6IENvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMudmFsdWVzKCkpO1xuICB9XG5cbiAgcHVibGljIGdldENvbXBvbmVudE5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMua2V5cygpKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gIH1cblxuICBwdWJsaWMgc2V0QWN0aXZlKGFjdGl2ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jb21wb25lbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50IHtcbiAgcHVibGljIGVuYWJsZWQgPSB0cnVlO1xuICBcbiAgcHVibGljIGFic3RyYWN0IHJlc2V0KCk6IHZvaWQ7IC8vIEZvciBvYmplY3QgcG9vbGluZ1xufVxuIl0sIm5hbWVzIjpbIkVudGl0eSIsImFkZENvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbXBvbmVudE5hbWUiLCJjb21wb25lbnRUeXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiY29tcG9uZW50cyIsInNldCIsInJlbW92ZUNvbXBvbmVudCIsImRlbGV0ZSIsImdldENvbXBvbmVudCIsInJlcXVlc3RlZFR5cGUiLCJnZXQiLCJlbnRyaWVzIiwiQXJyYXkiLCJmcm9tIiwia2V5IiwiY29tcCIsIk1hdGgiLCJyYW5kb20iLCJhY3R1YWxUeXBlIiwibWF0Y2giLCJoYXNDb21wb25lbnQiLCJoYXMiLCJ2YWx1ZXMiLCJoYXNDb21wb25lbnRzIiwiY29tcG9uZW50VHlwZXMiLCJldmVyeSIsInR5cGUiLCJnZXRBbGxDb21wb25lbnRzIiwiZ2V0Q29tcG9uZW50TmFtZXMiLCJrZXlzIiwiaXNBY3RpdmUiLCJhY3RpdmUiLCJzZXRBY3RpdmUiLCJkZXN0cm95IiwiY2xlYXIiLCJNYXAiLCJpZCIsIm5leHRJZCIsIkNvbXBvbmVudCIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/Entity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/System.ts":
/*!***************************!*\
  !*** ./src/ecs/System.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; },\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; },\n/* harmony export */   System: function() { return /* binding */ System; }\n/* harmony export */ });\n// Entity Component System - Base System Classes\nclass System {\n    matchesEntity(entity) {\n        return entity.isActive() && entity.hasComponents(this.requiredComponents);\n    }\n    constructor(){\n        this.enabled = true;\n        this.priority = 0 // Lower numbers run first\n        ;\n    }\n}\nclass RenderSystem extends System {\n}\nclass PhysicsSystem extends System {\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUd6QyxNQUFlQTtJQU9iQyxjQUFjQyxNQUFjLEVBQVc7UUFDNUMsT0FBT0EsT0FBT0MsUUFBUSxNQUFNRCxPQUFPRSxhQUFhLENBQUMsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7O2FBUE9DLFVBQVU7YUFDVkMsV0FBVyxFQUFHLDBCQUEwQjs7O0FBWWpEO0FBRU8sTUFBZUMscUJBQXFCUjtBQUUzQztBQUVPLE1BQWVTLHNCQUFzQlQ7QUFFNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9TeXN0ZW0udHM/YTgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEJhc2UgU3lzdGVtIENsYXNzZXNcbmltcG9ydCB7IEVudGl0eSwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50czogKG5ldyAoKSA9PiBDb21wb25lbnQpW107XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgcHVibGljIHByaW9yaXR5ID0gMDsgLy8gTG93ZXIgbnVtYmVycyBydW4gZmlyc3RcblxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkO1xuXG4gIHB1YmxpYyBtYXRjaGVzRW50aXR5KGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKHRoaXMucmVxdWlyZWRDb21wb25lbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkPyhlbnRpdHk6IEVudGl0eSk6IHZvaWQ7XG4gIHB1YmxpYyBvbkVudGl0eVJlbW92ZWQ/KGVudGl0eTogRW50aXR5KTogdm9pZDtcbiAgcHVibGljIG9uRW5hYmxlPygpOiB2b2lkO1xuICBwdWJsaWMgb25EaXNhYmxlPygpOiB2b2lkO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgYWJzdHJhY3QgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJtYXRjaGVzRW50aXR5IiwiZW50aXR5IiwiaXNBY3RpdmUiLCJoYXNDb21wb25lbnRzIiwicmVxdWlyZWRDb21wb25lbnRzIiwiZW5hYmxlZCIsInByaW9yaXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/System.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/World.ts":
/*!**************************!*\
  !*** ./src/ecs/World.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: function() { return /* binding */ World; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Entity Component System - World Management\n\n\n\nclass World {\n    // Entity management\n    createEntity() {\n        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity();\n        this.entities.set(entity.id, entity);\n        return entity;\n    }\n    destroyEntity(entityId) {\n        this.entitiesToDestroy.push(entityId);\n    }\n    // Notify systems that an entity has been fully configured and is ready\n    notifyEntityAdded(entity) {\n        for (const system of this.systems){\n            if (system.onEntityAdded && system.matchesEntity(entity)) {\n                system.onEntityAdded(entity);\n            }\n        }\n    }\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    // System management\n    addSystem(system) {\n        var _system_onEnable;\n        this.systems.push(system);\n        this.systems.sort((a, b)=>a.priority - b.priority);\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem) {\n            this.renderSystems.push(system);\n        }\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem) {\n            this.physicsSystems.push(system);\n        }\n        (_system_onEnable = system.onEnable) === null || _system_onEnable === void 0 ? void 0 : _system_onEnable.call(system);\n    }\n    getSystem(systemClass) {\n        return this.systems.find((system)=>system instanceof systemClass);\n    }\n    removeSystem(systemType) {\n        const index = this.systems.findIndex((s)=>s instanceof systemType);\n        if (index !== -1) {\n            var _system_onDisable;\n            const system = this.systems[index];\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n            this.systems.splice(index, 1);\n            // Remove from specialized arrays\n            const renderIndex = this.renderSystems.findIndex((s)=>s === system);\n            if (renderIndex !== -1) this.renderSystems.splice(renderIndex, 1);\n            const physicsIndex = this.physicsSystems.findIndex((s)=>s === system);\n            if (physicsIndex !== -1) this.physicsSystems.splice(physicsIndex, 1);\n        }\n    }\n    // Component pooling for performance\n    createComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const typeName = componentType.componentType || componentType.name;\n        // Disable pooling for components that have prototype method issues in production\n        const problematicComponents = [\n            \"Health\",\n            \"HealthBar\",\n            \"Transform\",\n            \"Movement\",\n            \"Collider\",\n            \"Renderer\",\n            \"Enemy\",\n            \"Projectile\",\n            \"Animation\"\n        ];\n        if (problematicComponents.includes(typeName)) {\n            return new componentType();\n        }\n        let pool = this.componentPools.get(typeName);\n        if (!pool) {\n            pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__.ObjectPool(()=>new componentType(), (obj)=>obj.reset(), 100);\n            this.componentPools.set(typeName, pool);\n        }\n        return pool.acquire();\n    }\n    returnComponent(component) {\n        const pool = this.componentPools.get(component.constructor.name);\n        if (pool) {\n            pool.release(component);\n        }\n    }\n    // Main update loop\n    update(deltaTime) {\n        // Clean up destroyed entities\n        this.cleanupDestroyedEntities();\n        // Update all systems\n        for (const system of this.systems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.update(matchingEntities, deltaTime);\n        }\n    }\n    // Fixed timestep physics update\n    fixedUpdate(fixedDeltaTime) {\n        for (const system of this.physicsSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.fixedUpdate(matchingEntities, fixedDeltaTime);\n        }\n    }\n    // Render update\n    render(deltaTime) {\n        for (const system of this.renderSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.render(matchingEntities, deltaTime);\n        }\n    }\n    // Get entities that match a system's requirements\n    getEntitiesForSystem(system) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (system.matchesEntity(entity)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Clean up destroyed entities\n    cleanupDestroyedEntities() {\n        for (const entityId of this.entitiesToDestroy){\n            const entity = this.entities.get(entityId);\n            if (entity) {\n                // Notify systems about entity removal\n                for (const system of this.systems){\n                    if (system.onEntityRemoved && system.matchesEntity(entity)) {\n                        system.onEntityRemoved(entity);\n                    }\n                }\n                // Return components to pools\n                for (const component of entity.getAllComponents()){\n                    this.returnComponent(component);\n                }\n                entity.destroy();\n                this.entities.delete(entityId);\n            }\n        }\n        this.entitiesToDestroy.length = 0;\n    }\n    // Query entities by components\n    queryEntities(componentTypes) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (entity.isActive() && entity.hasComponents(componentTypes)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Event system\n    emitEvent(eventType, eventData) {\n        if (!this.events.has(eventType)) {\n            this.events.set(eventType, []);\n        }\n        this.events.get(eventType).push(eventData);\n    }\n    getEvents(eventType) {\n        return this.events.get(eventType) || [];\n    }\n    clearEvents(eventType) {\n        this.events.set(eventType, []);\n    }\n    destroy() {\n        // Clean up all entities\n        for (const entity of Array.from(this.entities.values())){\n            entity.destroy();\n        }\n        this.entities.clear();\n        // Clean up systems\n        for (const system of this.systems){\n            var _system_onDisable;\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n        }\n        this.systems.length = 0;\n        this.renderSystems.length = 0;\n        this.physicsSystems.length = 0;\n        // Clear component pools\n        this.componentPools.clear();\n        // Clear events\n        this.events.clear();\n    }\n    constructor(){\n        this.entities = new Map();\n        this.systems = [];\n        this.renderSystems = [];\n        this.physicsSystems = [];\n        this.componentPools = new Map();\n        this.entitiesToDestroy = [];\n        this.events = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNDLE9BQU8sQ0FBRTtnQkFDakNEO2FBQUFBLG9CQUFBQSxPQUFPMEIsU0FBUyxjQUFoQjFCLHdDQUFBQSx1QkFBQUE7UUFDRjtRQUNBLElBQUksQ0FBQ0MsT0FBTyxDQUFDeUQsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQzNDLGFBQWEsQ0FBQzJDLE1BQU0sR0FBRztRQUM1QixJQUFJLENBQUMxQyxjQUFjLENBQUMwQyxNQUFNLEdBQUc7UUFFN0Isd0JBQXdCO1FBQ3hCLElBQUksQ0FBQ3JCLGNBQWMsQ0FBQ2lDLEtBQUs7UUFFekIsZUFBZTtRQUNmLElBQUksQ0FBQ0osTUFBTSxDQUFDSSxLQUFLO0lBQ25COzthQTNOUTlFLFdBQVcsSUFBSStFO2FBQ2Z0RSxVQUFvQixFQUFFO2FBQ3RCYyxnQkFBZ0MsRUFBRTthQUNsQ0MsaUJBQWtDLEVBQUU7YUFDcENxQixpQkFBaUIsSUFBSWtDO2FBQ3JCMUUsb0JBQWdDLEVBQUU7YUFDbENxRSxTQUFTLElBQUlLOztBQXNOdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9Xb3JsZC50cz8zMTQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gV29ybGQgTWFuYWdlbWVudFxuaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlJZCwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuaW1wb3J0IHsgU3lzdGVtLCBSZW5kZXJTeXN0ZW0sIFBoeXNpY3NTeXN0ZW0gfSBmcm9tICcuL1N5c3RlbSc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuZXhwb3J0IGNsYXNzIFdvcmxkIHtcbiAgcHJpdmF0ZSBlbnRpdGllcyA9IG5ldyBNYXA8RW50aXR5SWQsIEVudGl0eT4oKTtcbiAgcHJpdmF0ZSBzeXN0ZW1zOiBTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIHJlbmRlclN5c3RlbXM6IFJlbmRlclN5c3RlbVtdID0gW107XG4gIHByaXZhdGUgcGh5c2ljc1N5c3RlbXM6IFBoeXNpY3NTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIGNvbXBvbmVudFBvb2xzID0gbmV3IE1hcDxzdHJpbmcsIE9iamVjdFBvb2w8YW55Pj4oKTtcbiAgcHJpdmF0ZSBlbnRpdGllc1RvRGVzdHJveTogRW50aXR5SWRbXSA9IFtdO1xuICBwcml2YXRlIGV2ZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcblxuICAvLyBFbnRpdHkgbWFuYWdlbWVudFxuICBwdWJsaWMgY3JlYXRlRW50aXR5KCk6IEVudGl0eSB7XG4gICAgY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eSgpO1xuICAgIHRoaXMuZW50aXRpZXMuc2V0KGVudGl0eS5pZCwgZW50aXR5KTtcbiAgICByZXR1cm4gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3lFbnRpdHkoZW50aXR5SWQ6IEVudGl0eUlkKTogdm9pZCB7XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5wdXNoKGVudGl0eUlkKTtcbiAgfVxuXG4gIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgYW4gZW50aXR5IGhhcyBiZWVuIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIGlzIHJlYWR5XG4gIHB1YmxpYyBub3RpZnlFbnRpdHlBZGRlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eUFkZGVkICYmIHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgc3lzdGVtLm9uRW50aXR5QWRkZWQoZW50aXR5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RW50aXR5KGVudGl0eUlkOiBFbnRpdHlJZCk6IEVudGl0eSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBbGxFbnRpdGllcygpOiBFbnRpdHlbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSk7XG4gIH1cblxuICAvLyBTeXN0ZW0gbWFuYWdlbWVudFxuICBwdWJsaWMgYWRkU3lzdGVtKHN5c3RlbTogU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB0aGlzLnN5c3RlbXMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuXG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFJlbmRlclN5c3RlbSkge1xuICAgICAgdGhpcy5yZW5kZXJTeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB9XG4gICAgaWYgKHN5c3RlbSBpbnN0YW5jZW9mIFBoeXNpY3NTeXN0ZW0pIHtcbiAgICAgIHRoaXMucGh5c2ljc1N5c3RlbXMucHVzaChzeXN0ZW0pO1xuICAgIH1cblxuICAgIHN5c3RlbS5vbkVuYWJsZT8uKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0U3lzdGVtPFQgZXh0ZW5kcyBTeXN0ZW0+KHN5c3RlbUNsYXNzOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3lzdGVtcy5maW5kKHN5c3RlbSA9PiBzeXN0ZW0gaW5zdGFuY2VvZiBzeXN0ZW1DbGFzcykgYXMgVCB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVTeXN0ZW0oc3lzdGVtVHlwZTogbmV3ICgpID0+IFN5c3RlbSk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zeXN0ZW1zLmZpbmRJbmRleChzID0+IHMgaW5zdGFuY2VvZiBzeXN0ZW1UeXBlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjb25zdCBzeXN0ZW0gPSB0aGlzLnN5c3RlbXNbaW5kZXhdO1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgICB0aGlzLnN5c3RlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gc3BlY2lhbGl6ZWQgYXJyYXlzXG4gICAgICBjb25zdCByZW5kZXJJbmRleCA9IHRoaXMucmVuZGVyU3lzdGVtcy5maW5kSW5kZXgocyA9PiBzID09PSBzeXN0ZW0pO1xuICAgICAgaWYgKHJlbmRlckluZGV4ICE9PSAtMSkgdGhpcy5yZW5kZXJTeXN0ZW1zLnNwbGljZShyZW5kZXJJbmRleCwgMSk7XG5cbiAgICAgIGNvbnN0IHBoeXNpY3NJbmRleCA9IHRoaXMucGh5c2ljc1N5c3RlbXMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3lzdGVtKTtcbiAgICAgIGlmIChwaHlzaWNzSW5kZXggIT09IC0xKSB0aGlzLnBoeXNpY3NTeXN0ZW1zLnNwbGljZShwaHlzaWNzSW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXBvbmVudCBwb29saW5nIGZvciBwZXJmb3JtYW5jZVxuICBwdWJsaWMgY3JlYXRlQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogVCB7XG4gICAgLy8gVXNlIGV4cGxpY2l0IGNvbXBvbmVudFR5cGUgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBjb25zdHJ1Y3RvciBuYW1lXG4gICAgY29uc3QgdHlwZU5hbWUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIFxuICAgIC8vIERpc2FibGUgcG9vbGluZyBmb3IgY29tcG9uZW50cyB0aGF0IGhhdmUgcHJvdG90eXBlIG1ldGhvZCBpc3N1ZXMgaW4gcHJvZHVjdGlvblxuICAgIGNvbnN0IHByb2JsZW1hdGljQ29tcG9uZW50cyA9IFsnSGVhbHRoJywgJ0hlYWx0aEJhcicsICdUcmFuc2Zvcm0nLCAnTW92ZW1lbnQnLCAnQ29sbGlkZXInLCAnUmVuZGVyZXInLCAnRW5lbXknLCAnUHJvamVjdGlsZScsICdBbmltYXRpb24nXTtcbiAgICBpZiAocHJvYmxlbWF0aWNDb21wb25lbnRzLmluY2x1ZGVzKHR5cGVOYW1lKSkge1xuICAgICAgcmV0dXJuIG5ldyBjb21wb25lbnRUeXBlKCk7XG4gICAgfVxuICAgIFxuICAgIGxldCBwb29sID0gdGhpcy5jb21wb25lbnRQb29scy5nZXQodHlwZU5hbWUpO1xuICAgIFxuICAgIGlmICghcG9vbCkge1xuICAgICAgcG9vbCA9IG5ldyBPYmplY3RQb29sPFQ+KCgpID0+IG5ldyBjb21wb25lbnRUeXBlKCksIChvYmopID0+IG9iai5yZXNldCgpLCAxMDApO1xuICAgICAgdGhpcy5jb21wb25lbnRQb29scy5zZXQodHlwZU5hbWUsIHBvb2wpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9vbC5hY3F1aXJlKCk7XG4gIH1cblxuICBwdWJsaWMgcmV0dXJuQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudDogVCk6IHZvaWQge1xuICAgIGNvbnN0IHBvb2wgPSB0aGlzLmNvbXBvbmVudFBvb2xzLmdldChjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHBvb2wucmVsZWFzZShjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1haW4gdXBkYXRlIGxvb3BcbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICAgIHRoaXMuY2xlYW51cERlc3Ryb3llZEVudGl0aWVzKCk7XG5cbiAgICAvLyBVcGRhdGUgYWxsIHN5c3RlbXNcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLnVwZGF0ZShtYXRjaGluZ0VudGl0aWVzLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpeGVkIHRpbWVzdGVwIHBoeXNpY3MgdXBkYXRlXG4gIHB1YmxpYyBmaXhlZFVwZGF0ZShmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5waHlzaWNzU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0uZml4ZWRVcGRhdGUobWF0Y2hpbmdFbnRpdGllcywgZml4ZWREZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlciB1cGRhdGVcbiAgcHVibGljIHJlbmRlcihkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMucmVuZGVyU3lzdGVtcykge1xuICAgICAgaWYgKCFzeXN0ZW0uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nRW50aXRpZXMgPSB0aGlzLmdldEVudGl0aWVzRm9yU3lzdGVtKHN5c3RlbSk7XG4gICAgICBzeXN0ZW0ucmVuZGVyKG1hdGNoaW5nRW50aXRpZXMsIGRlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGVudGl0aWVzIHRoYXQgbWF0Y2ggYSBzeXN0ZW0ncyByZXF1aXJlbWVudHNcbiAgcHJpdmF0ZSBnZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW06IFN5c3RlbSk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRpdGllczogRW50aXR5W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBBcnJheS5mcm9tKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpKSB7XG4gICAgICBpZiAoc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIENsZWFuIHVwIGRlc3Ryb3llZCBlbnRpdGllc1xuICBwcml2YXRlIGNsZWFudXBEZXN0cm95ZWRFbnRpdGllcygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kpIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuZW50aXRpZXMuZ2V0KGVudGl0eUlkKTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgLy8gTm90aWZ5IHN5c3RlbXMgYWJvdXQgZW50aXR5IHJlbW92YWxcbiAgICAgICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5zeXN0ZW1zKSB7XG4gICAgICAgICAgaWYgKHN5c3RlbS5vbkVudGl0eVJlbW92ZWQgJiYgc3lzdGVtLm1hdGNoZXNFbnRpdHkoZW50aXR5KSkge1xuICAgICAgICAgICAgc3lzdGVtLm9uRW50aXR5UmVtb3ZlZChlbnRpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmV0dXJuIGNvbXBvbmVudHMgdG8gcG9vbHNcbiAgICAgICAgZm9yIChjb25zdCBjb21wb25lbnQgb2YgZW50aXR5LmdldEFsbENvbXBvbmVudHMoKSkge1xuICAgICAgICAgIHRoaXMucmV0dXJuQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVudGl0eS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZW50aXRpZXMuZGVsZXRlKGVudGl0eUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnRpdGllc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gUXVlcnkgZW50aXRpZXMgYnkgY29tcG9uZW50c1xuICBwdWJsaWMgcXVlcnlFbnRpdGllcyhjb21wb25lbnRUeXBlczogKG5ldyAoKSA9PiBDb21wb25lbnQpW10pOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgaWYgKGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKGNvbXBvbmVudFR5cGVzKSkge1xuICAgICAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBlbnRpdGllcztcbiAgfVxuXG4gIC8vIEV2ZW50IHN5c3RlbVxuICBwdWJsaWMgZW1pdEV2ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudERhdGE6IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ldmVudHMuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIFtdKTtcbiAgICB9XG4gICAgdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSkhLnB1c2goZXZlbnREYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFdmVudHMoZXZlbnRUeXBlOiBzdHJpbmcpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpIHx8IFtdO1xuICB9XG5cbiAgcHVibGljIGNsZWFyRXZlbnRzKGV2ZW50VHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50VHlwZSwgW10pO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIGVudGl0aWVzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgZW50aXR5LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbnRpdGllcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYW4gdXAgc3lzdGVtc1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgc3lzdGVtLm9uRGlzYWJsZT8uKCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVuZGVyU3lzdGVtcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucGh5c2ljc1N5c3RlbXMubGVuZ3RoID0gMDtcblxuICAgIC8vIENsZWFyIGNvbXBvbmVudCBwb29sc1xuICAgIHRoaXMuY29tcG9uZW50UG9vbHMuY2xlYXIoKTtcbiAgICBcbiAgICAvLyBDbGVhciBldmVudHNcbiAgICB0aGlzLmV2ZW50cy5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRW50aXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSIsIk9iamVjdFBvb2wiLCJXb3JsZCIsImNyZWF0ZUVudGl0eSIsImVudGl0eSIsImVudGl0aWVzIiwic2V0IiwiaWQiLCJkZXN0cm95RW50aXR5IiwiZW50aXR5SWQiLCJlbnRpdGllc1RvRGVzdHJveSIsInB1c2giLCJub3RpZnlFbnRpdHlBZGRlZCIsInN5c3RlbSIsInN5c3RlbXMiLCJvbkVudGl0eUFkZGVkIiwibWF0Y2hlc0VudGl0eSIsImdldEVudGl0eSIsImdldCIsImdldEFsbEVudGl0aWVzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiYWRkU3lzdGVtIiwic29ydCIsImEiLCJiIiwicHJpb3JpdHkiLCJyZW5kZXJTeXN0ZW1zIiwicGh5c2ljc1N5c3RlbXMiLCJvbkVuYWJsZSIsImdldFN5c3RlbSIsInN5c3RlbUNsYXNzIiwiZmluZCIsInJlbW92ZVN5c3RlbSIsInN5c3RlbVR5cGUiLCJpbmRleCIsImZpbmRJbmRleCIsInMiLCJvbkRpc2FibGUiLCJzcGxpY2UiLCJyZW5kZXJJbmRleCIsInBoeXNpY3NJbmRleCIsImNyZWF0ZUNvbXBvbmVudCIsImNvbXBvbmVudFR5cGUiLCJ0eXBlTmFtZSIsIm5hbWUiLCJwcm9ibGVtYXRpY0NvbXBvbmVudHMiLCJpbmNsdWRlcyIsInBvb2wiLCJjb21wb25lbnRQb29scyIsIm9iaiIsInJlc2V0IiwiYWNxdWlyZSIsInJldHVybkNvbXBvbmVudCIsImNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicmVsZWFzZSIsInVwZGF0ZSIsImRlbHRhVGltZSIsImNsZWFudXBEZXN0cm95ZWRFbnRpdGllcyIsImVuYWJsZWQiLCJtYXRjaGluZ0VudGl0aWVzIiwiZ2V0RW50aXRpZXNGb3JTeXN0ZW0iLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwicmVuZGVyIiwib25FbnRpdHlSZW1vdmVkIiwiZ2V0QWxsQ29tcG9uZW50cyIsImRlc3Ryb3kiLCJkZWxldGUiLCJsZW5ndGgiLCJxdWVyeUVudGl0aWVzIiwiY29tcG9uZW50VHlwZXMiLCJpc0FjdGl2ZSIsImhhc0NvbXBvbmVudHMiLCJlbWl0RXZlbnQiLCJldmVudFR5cGUiLCJldmVudERhdGEiLCJldmVudHMiLCJoYXMiLCJnZXRFdmVudHMiLCJjbGVhckV2ZW50cyIsImNsZWFyIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/World.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Collider.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Collider.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collider: function() { return /* binding */ Collider; },\n/* harmony export */   ColliderType: function() { return /* binding */ ColliderType; },\n/* harmony export */   CollisionLayer: function() { return /* binding */ CollisionLayer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Collider component for collision detection\n\n\nvar ColliderType;\n(function(ColliderType) {\n    ColliderType[\"SPHERE\"] = \"sphere\";\n    ColliderType[\"BOX\"] = \"box\";\n    ColliderType[\"CAPSULE\"] = \"capsule\";\n    ColliderType[\"CYLINDER\"] = \"cylinder\";\n})(ColliderType || (ColliderType = {}));\nvar CollisionLayer;\n(function(CollisionLayer) {\n    CollisionLayer[CollisionLayer[\"DEFAULT\"] = 1] = \"DEFAULT\";\n    CollisionLayer[CollisionLayer[\"PLAYER\"] = 2] = \"PLAYER\";\n    CollisionLayer[CollisionLayer[\"ENEMY\"] = 4] = \"ENEMY\";\n    CollisionLayer[CollisionLayer[\"PROJECTILE\"] = 8] = \"PROJECTILE\";\n    CollisionLayer[CollisionLayer[\"ENVIRONMENT\"] = 16] = \"ENVIRONMENT\";\n    CollisionLayer[CollisionLayer[\"PICKUP\"] = 32] = \"PICKUP\";\n})(CollisionLayer || (CollisionLayer = {}));\nclass Collider extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    getDefaultMask(layer) {\n        switch(layer){\n            case 2:\n                return 4 | 16 | 32;\n            case 4:\n                return 2 | 8 | 16;\n            case 8:\n                return 2 | 4 | 16;\n            case 16:\n                return 2 | 4 | 8;\n            case 32:\n                return 2;\n            default:\n                return 0xFFFFFFFF; // Collide with everything\n        }\n    }\n    static createSphere(radius) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return new Collider(\"sphere\", radius, layer);\n    }\n    static createBox(size) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const collider = new Collider(\"box\", 0, layer);\n        collider.size.copy(size);\n        return collider;\n    }\n    static createCapsule(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"capsule\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    static createCylinder(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"cylinder\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    setOffset(x, y, z) {\n        this.offset.set(x, y, z);\n        this.boundsNeedUpdate = true;\n    }\n    setLayer(layer) {\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n    }\n    setMask(mask) {\n        this.mask = mask;\n    }\n    canCollideWith(other) {\n        return (this.mask & other.layer) !== 0 && (other.mask & this.layer) !== 0;\n    }\n    updateBounds(worldPosition) {\n        if (!this.boundsNeedUpdate && !this.isStatic) {\n            return;\n        }\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                this.boundingSphere.set(center, this.radius);\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.radius * 2, this.radius * 2));\n                break;\n            case \"box\":\n                this.bounds.setFromCenterAndSize(center, this.size);\n                this.boundingSphere.setFromPoints([\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-this.size.x / 2, -this.size.y / 2, -this.size.z / 2)),\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.size.x / 2, this.size.y / 2, this.size.z / 2))\n                ]);\n                break;\n            case \"capsule\":\n                const capsuleRadius = Math.max(this.radius, this.size.x / 2, this.size.z / 2);\n                this.boundingSphere.set(center, Math.max(capsuleRadius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(capsuleRadius * 2, this.height, capsuleRadius * 2));\n                break;\n            case \"cylinder\":\n                this.boundingSphere.set(center, Math.max(this.radius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.height, this.radius * 2));\n                break;\n        }\n        this.boundsNeedUpdate = false;\n    }\n    intersects(other, thisPosition, otherPosition) {\n        // Update bounds if needed\n        this.updateBounds(thisPosition);\n        other.updateBounds(otherPosition);\n        // Quick bounding sphere check first\n        if (!this.boundingSphere.intersectsSphere(other.boundingSphere)) {\n            return false;\n        }\n        // More precise collision detection based on collider types\n        return this.preciseIntersection(other, thisPosition, otherPosition);\n    }\n    preciseIntersection(other, thisPosition, otherPosition) {\n        const thisCenter = thisPosition.clone().add(this.offset);\n        const otherCenter = otherPosition.clone().add(other.offset);\n        // Sphere vs Sphere\n        if (this.type === \"sphere\" && other.type === \"sphere\") {\n            const distance = thisCenter.distanceTo(otherCenter);\n            return distance <= this.radius + other.radius;\n        }\n        // Box vs Box\n        if (this.type === \"box\" && other.type === \"box\") {\n            return this.bounds.intersectsBox(other.bounds);\n        }\n        // Sphere vs Box\n        if (this.type === \"sphere\" && other.type === \"box\" || this.type === \"box\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const box = this.type === \"box\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            box.bounds.clampPoint(sphereCenter, closestPoint);\n            return sphereCenter.distanceTo(closestPoint) <= sphere.radius;\n        }\n        // Sphere vs Cylinder (for pillar collisions)\n        if (this.type === \"sphere\" && other.type === \"cylinder\" || this.type === \"cylinder\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const cylinder = this.type === \"cylinder\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const cylinderCenter = this.type === \"cylinder\" ? thisCenter : otherCenter;\n            // Check if sphere is within cylinder's height range\n            const heightDiff = Math.abs(sphereCenter.y - cylinderCenter.y);\n            if (heightDiff > cylinder.height / 2 + sphere.radius) {\n                return false; // Sphere is above or below cylinder\n            }\n            // Check horizontal distance (XZ plane)\n            const horizontalDistance = Math.sqrt(Math.pow(sphereCenter.x - cylinderCenter.x, 2) + Math.pow(sphereCenter.z - cylinderCenter.z, 2));\n            return horizontalDistance <= sphere.radius + cylinder.radius;\n        }\n        // For other combinations, fall back to bounding box intersection\n        return this.bounds.intersectsBox(other.bounds);\n    }\n    getClosestPoint(point, worldPosition) {\n        this.updateBounds(worldPosition);\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                const direction = point.clone().sub(center).normalize();\n                return center.clone().add(direction.multiplyScalar(this.radius));\n            case \"box\":\n                const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, closestPoint);\n                return closestPoint;\n            default:\n                // For other types, use bounding box\n                const boxClosest = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, boxClosest);\n                return boxClosest;\n        }\n    }\n    getVolume() {\n        switch(this.type){\n            case \"sphere\":\n                return 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n            case \"box\":\n                return this.size.x * this.size.y * this.size.z;\n            case \"cylinder\":\n                return Math.PI * Math.pow(this.radius, 2) * this.height;\n            case \"capsule\":\n                const sphereVolume = 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n                const cylinderVolume = Math.PI * Math.pow(this.radius, 2) * (this.height - 2 * this.radius);\n                return sphereVolume + cylinderVolume;\n            default:\n                return 1;\n        }\n    }\n    reset() {\n        this.type = \"sphere\";\n        this.radius = 0.5;\n        this.size.set(1, 1, 1);\n        this.height = 2;\n        this.offset.set(0, 0, 0);\n        this.layer = 1;\n        this.mask = this.getDefaultMask(1);\n        this.isTrigger = false;\n        this.isStatic = false;\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n        this.onCollisionEnter = undefined;\n        this.onCollisionStay = undefined;\n        this.onCollisionExit = undefined;\n        this.onTriggerEnter = undefined;\n        this.onTriggerStay = undefined;\n        this.onTriggerExit = undefined;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Collider(this.type, this.radius, this.layer);\n        clone.size.copy(this.size);\n        clone.height = this.height;\n        clone.offset.copy(this.offset);\n        clone.mask = this.mask;\n        clone.isTrigger = this.isTrigger;\n        clone.isStatic = this.isStatic;\n        return clone;\n    }\n    constructor(type = \"sphere\", radius = 0.5, layer = 1){\n        super();\n        this.componentType = \"Collider\" // Instance identifier\n        ;\n        this.type = type;\n        this.radius = radius;\n        this.size = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.height = 2;\n        this.offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n        this.isTrigger = false;\n        this.isStatic = false;\n        // Initialize bounds\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n    }\n}\nCollider.componentType = \"Collider\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Db2xsaWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDZDQUE2QztBQUNpQjtBQUN4Qjs7VUFFMUJJOzs7OztHQUFBQSxpQkFBQUE7O1VBT0FDOzs7Ozs7O0dBQUFBLG1CQUFBQTtBQVNMLE1BQU1DLGlCQUFpQkgsOENBQVNBO0lBaUQ3QkksZUFBZUMsS0FBcUIsRUFBVTtRQUNwRCxPQUFRQTtZQUNOO2dCQUNFLE9BQU9IO1lBQ1Q7Z0JBQ0UsT0FBT0E7WUFDVDtnQkFDRSxPQUFPQTtZQUNUO2dCQUNFLE9BQU9BO1lBQ1Q7Z0JBQ0U7WUFDRjtnQkFDRSxPQUFPLFlBQVksMEJBQTBCO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFjSSxhQUFhQyxNQUFjLEVBQTREO1lBQTFERixRQUFBQTtRQUN6QyxPQUFPLElBQUlGLG1CQUE4QkksUUFBUUY7SUFDbkQ7SUFFQSxPQUFjRyxVQUFVQyxJQUFhLEVBQTREO1lBQTFESixRQUFBQTtRQUNyQyxNQUFNSyxXQUFXLElBQUlQLGdCQUEyQixHQUFHRTtRQUNuREssU0FBU0QsSUFBSSxDQUFDRSxJQUFJLENBQUNGO1FBQ25CLE9BQU9DO0lBQ1Q7SUFFQSxPQUFjRSxjQUFjTCxNQUFjLEVBQUVNLE1BQWMsRUFBNEQ7WUFBMURSLFFBQUFBO1FBQzFELE1BQU1LLFdBQVcsSUFBSVAsb0JBQStCSSxRQUFRRjtRQUM1REssU0FBU0csTUFBTSxHQUFHQTtRQUNsQixPQUFPSDtJQUNUO0lBRUEsT0FBY0ksZUFBZVAsTUFBYyxFQUFFTSxNQUFjLEVBQTREO1lBQTFEUixRQUFBQTtRQUMzRCxNQUFNSyxXQUFXLElBQUlQLHFCQUFnQ0ksUUFBUUY7UUFDN0RLLFNBQVNHLE1BQU0sR0FBR0E7UUFDbEIsT0FBT0g7SUFDVDtJQUVPSyxVQUFVQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFRO1FBQ3RELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUNK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QjtRQUNwQixJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJckMsc0RBQUlBO1FBQ3RCLElBQUksQ0FBQ29DLGNBQWMsR0FBRyxJQUFJbkMsd0RBQU1BO1FBQ2hDLElBQUksQ0FBQ3NCLGdCQUFnQixHQUFHO0lBQzFCO0FBZ1BGO0FBL1JhbEIsU0FDWWtGLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXIudHM/MzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsaWRlciBjb21wb25lbnQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMsIFNwaGVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBDb2xsaWRlclR5cGUge1xuICBTUEhFUkUgPSAnc3BoZXJlJyxcbiAgQk9YID0gJ2JveCcsXG4gIENBUFNVTEUgPSAnY2Fwc3VsZScsXG4gIENZTElOREVSID0gJ2N5bGluZGVyJ1xufVxuXG5leHBvcnQgZW51bSBDb2xsaXNpb25MYXllciB7XG4gIERFRkFVTFQgPSAxLFxuICBQTEFZRVIgPSAyLFxuICBFTkVNWSA9IDQsXG4gIFBST0pFQ1RJTEUgPSA4LFxuICBFTlZJUk9OTUVOVCA9IDE2LFxuICBQSUNLVVAgPSAzMlxufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB0eXBlOiBDb2xsaWRlclR5cGU7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjsgLy8gRm9yIHNwaGVyZSBhbmQgY3lsaW5kZXJcbiAgcHVibGljIHNpemU6IFZlY3RvcjM7IC8vIEZvciBib3ggKHdpZHRoLCBoZWlnaHQsIGRlcHRoKVxuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7IC8vIEZvciBjYXBzdWxlIGFuZCBjeWxpbmRlclxuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzOyAvLyBPZmZzZXQgZnJvbSB0cmFuc2Zvcm0gcG9zaXRpb25cbiAgcHVibGljIGxheWVyOiBDb2xsaXNpb25MYXllcjtcbiAgcHVibGljIG1hc2s6IG51bWJlcjsgLy8gV2hpY2ggbGF5ZXJzIHRoaXMgY29sbGlkZXIgY2FuIGNvbGxpZGUgd2l0aFxuICBwdWJsaWMgaXNUcmlnZ2VyOiBib29sZWFuOyAvLyBJZiB0cnVlLCBkb2Vzbid0IGJsb2NrIG1vdmVtZW50IGJ1dCBzdGlsbCBkZXRlY3RzIGNvbGxpc2lvbnNcbiAgcHVibGljIGlzU3RhdGljOiBib29sZWFuOyAvLyBJZiB0cnVlLCBjb2xsaWRlciBkb2Vzbid0IG1vdmUgKG9wdGltaXphdGlvbilcbiAgXG4gIC8vIENhY2hlZCBib3VuZHMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBib3VuZHM6IEJveDM7XG4gIHB1YmxpYyBib3VuZGluZ1NwaGVyZTogU3BoZXJlO1xuICBwdWJsaWMgYm91bmRzTmVlZFVwZGF0ZTogYm9vbGVhbjtcbiAgXG4gIC8vIENvbGxpc2lvbiBjYWxsYmFja3NcbiAgcHVibGljIG9uQ29sbGlzaW9uRW50ZXI/OiAob3RoZXI6IENvbGxpZGVyLCBlbnRpdHk6IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIG9uQ29sbGlzaW9uU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25Db2xsaXNpb25FeGl0PzogKG90aGVyOiBDb2xsaWRlciwgZW50aXR5OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBvblRyaWdnZXJFbnRlcj86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyRXhpdD86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IENvbGxpZGVyVHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkUsXG4gICAgcmFkaXVzOiBudW1iZXIgPSAwLjUsXG4gICAgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSAyO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2sobGF5ZXIpO1xuICAgIHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYm91bmRzXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1hc2sobGF5ZXI6IENvbGxpc2lvbkxheWVyKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGxheWVyKSB7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBMQVlFUjpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLkVORU1ZIHwgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQgfCBDb2xsaXNpb25MYXllci5QSUNLVVA7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLkVORU1ZOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRSB8IENvbGxpc2lvbkxheWVyLkVOVklST05NRU5UO1xuICAgICAgY2FzZSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuRU5FTVkgfCBDb2xsaXNpb25MYXllci5FTlZJUk9OTUVOVDtcbiAgICAgIGNhc2UgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQ6XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25MYXllci5QTEFZRVIgfCBDb2xsaXNpb25MYXllci5FTkVNWSB8IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBJQ0tVUDpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLlBMQVlFUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAweEZGRkZGRkZGOyAvLyBDb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3BoZXJlKHJhZGl1czogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIHJldHVybiBuZXcgQ29sbGlkZXIoQ29sbGlkZXJUeXBlLlNQSEVSRSwgcmFkaXVzLCBsYXllcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUJveChzaXplOiBWZWN0b3IzLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5CT1gsIDAsIGxheWVyKTtcbiAgICBjb2xsaWRlci5zaXplLmNvcHkoc2l6ZSk7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYXBzdWxlKHJhZGl1czogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk6IENvbGxpZGVyIHtcbiAgICBjb25zdCBjb2xsaWRlciA9IG5ldyBDb2xsaWRlcihDb2xsaWRlclR5cGUuQ0FQU1VMRSwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ3lsaW5kZXIocmFkaXVzOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5DWUxJTkRFUiwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPZmZzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0LnNldCh4LCB5LCB6KTtcbiAgICB0aGlzLmJvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNldExheWVyKGxheWVyOiBDb2xsaXNpb25MYXllcik6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLm1hc2sgPSB0aGlzLmdldERlZmF1bHRNYXNrKGxheWVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXNrKG1hc2s6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cblxuICBwdWJsaWMgY2FuQ29sbGlkZVdpdGgob3RoZXI6IENvbGxpZGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBvdGhlci5sYXllcikgIT09IDAgJiYgKG90aGVyLm1hc2sgJiB0aGlzLmxheWVyKSAhPT0gMDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVCb3VuZHMod29ybGRQb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ib3VuZHNOZWVkVXBkYXRlICYmICF0aGlzLmlzU3RhdGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuU1BIRVJFOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQk9YOlxuICAgICAgICB0aGlzLmJvdW5kcy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgICAgY2VudGVyLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IzKC10aGlzLnNpemUueC8yLCAtdGhpcy5zaXplLnkvMiwgLXRoaXMuc2l6ZS56LzIpKSxcbiAgICAgICAgICBjZW50ZXIuY2xvbmUoKS5hZGQobmV3IFZlY3RvcjModGhpcy5zaXplLngvMiwgdGhpcy5zaXplLnkvMiwgdGhpcy5zaXplLnovMikpXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQ0FQU1VMRTpcbiAgICAgICAgY29uc3QgY2Fwc3VsZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLnNpemUueCAvIDIsIHRoaXMuc2l6ZS56IC8gMik7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KGNlbnRlciwgTWF0aC5tYXgoY2Fwc3VsZVJhZGl1cywgdGhpcy5oZWlnaHQgLyAyKSk7XG4gICAgICAgIHRoaXMuYm91bmRzLnNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgbmV3IFZlY3RvcjMoXG4gICAgICAgICAgY2Fwc3VsZVJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCBjYXBzdWxlUmFkaXVzICogMlxuICAgICAgICApKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNZTElOREVSOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodCAvIDIpKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyAqIDJcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGludGVyc2VjdHMob3RoZXI6IENvbGxpZGVyLCB0aGlzUG9zaXRpb246IFZlY3RvcjMsIG90aGVyUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAvLyBVcGRhdGUgYm91bmRzIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlQm91bmRzKHRoaXNQb3NpdGlvbik7XG4gICAgb3RoZXIudXBkYXRlQm91bmRzKG90aGVyUG9zaXRpb24pO1xuXG4gICAgLy8gUXVpY2sgYm91bmRpbmcgc3BoZXJlIGNoZWNrIGZpcnN0XG4gICAgaWYgKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNTcGhlcmUob3RoZXIuYm91bmRpbmdTcGhlcmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9yZSBwcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmFzZWQgb24gY29sbGlkZXIgdHlwZXNcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyLCB0aGlzUG9zaXRpb24sIG90aGVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyOiBDb2xsaWRlciwgdGhpc1Bvc2l0aW9uOiBWZWN0b3IzLCBvdGhlclBvc2l0aW9uOiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGhpc0NlbnRlciA9IHRoaXNQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgY29uc3Qgb3RoZXJDZW50ZXIgPSBvdGhlclBvc2l0aW9uLmNsb25lKCkuYWRkKG90aGVyLm9mZnNldCk7XG5cbiAgICAvLyBTcGhlcmUgdnMgU3BoZXJlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXNDZW50ZXIuZGlzdGFuY2VUbyhvdGhlckNlbnRlcik7XG4gICAgICByZXR1cm4gZGlzdGFuY2UgPD0gKHRoaXMucmFkaXVzICsgb3RoZXIucmFkaXVzKTtcbiAgICB9XG5cbiAgICAvLyBCb3ggdnMgQm94XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLkJPWCAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuaW50ZXJzZWN0c0JveChvdGhlci5ib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFNwaGVyZSB2cyBCb3hcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB8fFxuICAgICAgICAodGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YICYmIG90aGVyLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUpKSB7XG4gICAgICBjb25zdCBzcGhlcmUgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBib3ggPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5CT1ggPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBzcGhlcmVDZW50ZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBib3guYm91bmRzLmNsYW1wUG9pbnQoc3BoZXJlQ2VudGVyLCBjbG9zZXN0UG9pbnQpO1xuICAgICAgcmV0dXJuIHNwaGVyZUNlbnRlci5kaXN0YW5jZVRvKGNsb3Nlc3RQb2ludCkgPD0gc3BoZXJlLnJhZGl1cztcbiAgICB9XG5cbiAgICAvLyBTcGhlcmUgdnMgQ3lsaW5kZXIgKGZvciBwaWxsYXIgY29sbGlzaW9ucylcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIpIHx8XG4gICAgICAgICh0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSkge1xuICAgICAgY29uc3Qgc3BoZXJlID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFID8gdGhpcyA6IG90aGVyO1xuICAgICAgY29uc3QgY3lsaW5kZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiA/IHRoaXMgOiBvdGhlcjtcbiAgICAgIGNvbnN0IHNwaGVyZUNlbnRlciA9IHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSA/IHRoaXNDZW50ZXIgOiBvdGhlckNlbnRlcjtcbiAgICAgIGNvbnN0IGN5bGluZGVyQ2VudGVyID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNwaGVyZSBpcyB3aXRoaW4gY3lsaW5kZXIncyBoZWlnaHQgcmFuZ2VcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhzcGhlcmVDZW50ZXIueSAtIGN5bGluZGVyQ2VudGVyLnkpO1xuICAgICAgaWYgKGhlaWdodERpZmYgPiAoY3lsaW5kZXIuaGVpZ2h0IC8gMiArIHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3BoZXJlIGlzIGFib3ZlIG9yIGJlbG93IGN5bGluZGVyXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKFhaIHBsYW5lKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzcGhlcmVDZW50ZXIueCAtIGN5bGluZGVyQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KHNwaGVyZUNlbnRlci56IC0gY3lsaW5kZXJDZW50ZXIueiwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBob3Jpem9udGFsRGlzdGFuY2UgPD0gKHNwaGVyZS5yYWRpdXMgKyBjeWxpbmRlci5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBjb21iaW5hdGlvbnMsIGZhbGwgYmFjayB0byBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3gob3RoZXIuYm91bmRzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDbG9zZXN0UG9pbnQocG9pbnQ6IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcyh3b3JsZFBvc2l0aW9uKTtcbiAgICBjb25zdCBjZW50ZXIgPSB3b3JsZFBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKSk7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkJPWDpcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuY2xhbXBQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yIG90aGVyIHR5cGVzLCB1c2UgYm91bmRpbmcgYm94XG4gICAgICAgIGNvbnN0IGJveENsb3Nlc3QgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmJvdW5kcy5jbGFtcFBvaW50KHBvaW50LCBib3hDbG9zZXN0KTtcbiAgICAgICAgcmV0dXJuIGJveENsb3Nlc3Q7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZvbHVtZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIHJldHVybiAoNC8zKSAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMyk7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5CT1g6XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55ICogdGhpcy5zaXplLno7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5DWUxJTkRFUjpcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNBUFNVTEU6XG4gICAgICAgIGNvbnN0IHNwaGVyZVZvbHVtZSA9ICg0LzMpICogTWF0aC5QSSAqIE1hdGgucG93KHRoaXMucmFkaXVzLCAzKTtcbiAgICAgICAgY29uc3QgY3lsaW5kZXJWb2x1bWUgPSBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICogKHRoaXMuaGVpZ2h0IC0gMiAqIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHNwaGVyZVZvbHVtZSArIGN5bGluZGVyVm9sdW1lO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjU7XG4gICAgdGhpcy5zaXplLnNldCgxLCAxLCAxKTtcbiAgICB0aGlzLmhlaWdodCA9IDI7XG4gICAgdGhpcy5vZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2soQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk7XG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uQ29sbGlzaW9uRW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvblN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvbkV4aXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpZ2dlclN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFeGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IENvbGxpZGVyKHRoaXMudHlwZSwgdGhpcy5yYWRpdXMsIHRoaXMubGF5ZXIpO1xuICAgIGNsb25lLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTtcbiAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgIGNsb25lLmlzVHJpZ2dlciA9IHRoaXMuaXNUcmlnZ2VyO1xuICAgIGNsb25lLmlzU3RhdGljID0gdGhpcy5pc1N0YXRpYztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwaGVyZSIsIkNvbXBvbmVudCIsIkNvbGxpZGVyVHlwZSIsIkNvbGxpc2lvbkxheWVyIiwiQ29sbGlkZXIiLCJnZXREZWZhdWx0TWFzayIsImxheWVyIiwiY3JlYXRlU3BoZXJlIiwicmFkaXVzIiwiY3JlYXRlQm94Iiwic2l6ZSIsImNvbGxpZGVyIiwiY29weSIsImNyZWF0ZUNhcHN1bGUiLCJoZWlnaHQiLCJjcmVhdGVDeWxpbmRlciIsInNldE9mZnNldCIsIngiLCJ5IiwieiIsIm9mZnNldCIsInNldCIsImJvdW5kc05lZWRVcGRhdGUiLCJzZXRMYXllciIsIm1hc2siLCJzZXRNYXNrIiwiY2FuQ29sbGlkZVdpdGgiLCJvdGhlciIsInVwZGF0ZUJvdW5kcyIsIndvcmxkUG9zaXRpb24iLCJpc1N0YXRpYyIsImNlbnRlciIsImNsb25lIiwiYWRkIiwidHlwZSIsImJvdW5kaW5nU3BoZXJlIiwiYm91bmRzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJzZXRGcm9tUG9pbnRzIiwiY2Fwc3VsZVJhZGl1cyIsIk1hdGgiLCJtYXgiLCJpbnRlcnNlY3RzIiwidGhpc1Bvc2l0aW9uIiwib3RoZXJQb3NpdGlvbiIsImludGVyc2VjdHNTcGhlcmUiLCJwcmVjaXNlSW50ZXJzZWN0aW9uIiwidGhpc0NlbnRlciIsIm90aGVyQ2VudGVyIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiaW50ZXJzZWN0c0JveCIsInNwaGVyZSIsImJveCIsInNwaGVyZUNlbnRlciIsImNsb3Nlc3RQb2ludCIsImNsYW1wUG9pbnQiLCJjeWxpbmRlciIsImN5bGluZGVyQ2VudGVyIiwiaGVpZ2h0RGlmZiIsImFicyIsImhvcml6b250YWxEaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJnZXRDbG9zZXN0UG9pbnQiLCJwb2ludCIsImRpcmVjdGlvbiIsInN1YiIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiYm94Q2xvc2VzdCIsImdldFZvbHVtZSIsIlBJIiwic3BoZXJlVm9sdW1lIiwiY3lsaW5kZXJWb2x1bWUiLCJyZXNldCIsImlzVHJpZ2dlciIsIm9uQ29sbGlzaW9uRW50ZXIiLCJ1bmRlZmluZWQiLCJvbkNvbGxpc2lvblN0YXkiLCJvbkNvbGxpc2lvbkV4aXQiLCJvblRyaWdnZXJFbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvblRyaWdnZXJFeGl0IiwiZW5hYmxlZCIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Collider.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Enemy.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Enemy.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: function() { return /* binding */ Enemy; },\n/* harmony export */   EnemyType: function() { return /* binding */ EnemyType; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Enemy component for identifying enemy entities\n\nvar EnemyType;\n(function(EnemyType) {\n    EnemyType[\"DUMMY\"] = \"dummy\";\n    EnemyType[\"GRUNT\"] = \"grunt\";\n    EnemyType[\"ELITE\"] = \"elite\";\n    EnemyType[\"BOSS\"] = \"boss\";\n})(EnemyType || (EnemyType = {}));\nclass Enemy extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    calculateExperienceReward() {\n        const baseExp = {\n            [\"dummy\"]: 5,\n            [\"grunt\"]: 10,\n            [\"elite\"]: 25,\n            [\"boss\"]: 100\n        };\n        return baseExp[this.type] * this.level;\n    }\n    calculateAggroRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 5,\n            [\"elite\"]: 8,\n            [\"boss\"]: 12\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 1.5,\n            [\"elite\"]: 2,\n            [\"boss\"]: 3\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackDamage() {\n        const baseDamage = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 15,\n            [\"elite\"]: 25,\n            [\"boss\"]: 50\n        };\n        return baseDamage[this.type] * this.level;\n    }\n    calculateAttackCooldown() {\n        const baseCooldown = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 2,\n            [\"elite\"]: 1.5,\n            [\"boss\"]: 1\n        };\n        return baseCooldown[this.type];\n    }\n    calculateMovementSpeed() {\n        const baseSpeed = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 3,\n            [\"elite\"]: 0,\n            [\"boss\"]: 2.5\n        };\n        return baseSpeed[this.type];\n    }\n    canAttack(currentTime) {\n        if (!this.isAggressive || this.isDead || this.attackDamage === 0) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    takeDamage() {\n    // This will be handled by the Health component\n    // This method is for enemy-specific damage reactions\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.deathTime = currentTime;\n    }\n    canRespawnNow(currentTime) {\n        if (!this.canRespawn || !this.isDead) {\n            return false;\n        }\n        return currentTime - this.deathTime >= this.respawnTime;\n    }\n    respawn() {\n        this.isDead = false;\n        this.deathTime = 0;\n        this.lastAttackTime = 0;\n        // Clear freeze status on respawn\n        this.unfreeze();\n        // Clear venom status on respawn\n        this.removeVenom();\n    }\n    freeze(duration, currentTime) {\n        if (this.isDead) return; // Can't freeze dead enemies\n        this.isFrozen = true;\n        this.freezeStartTime = currentTime;\n        this.freezeDuration = duration;\n        // Set movement speed to 0 when frozen\n        this.movementSpeed = 0;\n    }\n    unfreeze() {\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        // Restore original movement speed\n        this.movementSpeed = this.originalMovementSpeed;\n    }\n    updateFreezeStatus(currentTime) {\n        if (!this.isFrozen) return;\n        const elapsed = currentTime - this.freezeStartTime;\n        if (elapsed >= this.freezeDuration) {\n            this.unfreeze();\n        }\n    }\n    canMove() {\n        return !this.isFrozen && !this.isDead;\n    }\n    applyVenom(duration, damagePerSecond, currentTime) {\n        if (this.isDead) return; // Can't apply venom to dead enemies\n        this.isVenomous = true;\n        this.venomStartTime = currentTime;\n        this.venomDuration = duration;\n        this.venomDamagePerSecond = damagePerSecond;\n        this.lastVenomDamageTime = currentTime;\n    }\n    removeVenom() {\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    updateVenomStatus(currentTime) {\n        if (!this.isVenomous) return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n        const elapsed = currentTime - this.venomStartTime;\n        if (elapsed >= this.venomDuration) {\n            this.removeVenom();\n            return {\n                shouldDealDamage: false,\n                damage: 0\n            };\n        }\n        // Check if we should deal damage (every second)\n        const timeSinceLastDamage = currentTime - this.lastVenomDamageTime;\n        if (timeSinceLastDamage >= 1.0) {\n            this.lastVenomDamageTime = currentTime;\n            return {\n                shouldDealDamage: true,\n                damage: this.venomDamagePerSecond\n            };\n        }\n        return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n    }\n    setLevel(newLevel) {\n        this.level = Math.max(1, newLevel);\n        this.experienceReward = this.calculateExperienceReward();\n        this.attackDamage = this.calculateAttackDamage();\n    }\n    getDisplayName() {\n        const typeNames = {\n            [\"dummy\"]: \"Training Dummy\",\n            [\"grunt\"]: \"Grunt\",\n            [\"elite\"]: \"Elite\",\n            [\"boss\"]: \"Boss\"\n        };\n        return \"\".concat(typeNames[this.type], \" (Lv.\").concat(this.level, \")\");\n    }\n    reset() {\n        this.type = \"dummy\";\n        this.level = 1;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = false;\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30;\n        this.canRespawn = true;\n        this.enabled = true;\n        // Reset freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Reset venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    clone() {\n        const clone = new Enemy(this.type, this.level);\n        clone.experienceReward = this.experienceReward;\n        clone.isAggressive = this.isAggressive;\n        clone.aggroRange = this.aggroRange;\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.movementSpeed = this.movementSpeed;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.respawnTime = this.respawnTime;\n        clone.canRespawn = this.canRespawn;\n        // Clone freeze status\n        clone.isFrozen = this.isFrozen;\n        clone.freezeStartTime = this.freezeStartTime;\n        clone.freezeDuration = this.freezeDuration;\n        clone.originalMovementSpeed = this.originalMovementSpeed;\n        // Clone venom status\n        clone.isVenomous = this.isVenomous;\n        clone.venomStartTime = this.venomStartTime;\n        clone.venomDuration = this.venomDuration;\n        clone.venomDamagePerSecond = this.venomDamagePerSecond;\n        clone.lastVenomDamageTime = this.lastVenomDamageTime;\n        return clone;\n    }\n    constructor(type = \"dummy\", level = 1){\n        super();\n        this.componentType = \"Enemy\" // Instance identifier\n        ;\n        this.type = type;\n        this.level = level;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = type !== \"dummy\";\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30; // 30 seconds default respawn time\n        this.canRespawn = true;\n        // Initialize freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Initialize venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n}\nEnemy.componentType = \"Enemy\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9FbmVteS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBaUQ7QUFDWDs7VUFFMUJDOzs7OztHQUFBQSxjQUFBQTtBQU9MLE1BQU1DLGNBQWNGLDhDQUFTQTtJQWtFMUJHLDRCQUFvQztRQUMxQyxNQUFNQyxVQUFVO1lBQ2QsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUN4QztJQUVRQyxzQkFBOEI7UUFDcEMsTUFBTUMsWUFBWTtZQUNoQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsU0FBUyxDQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDO0lBQzdCO0lBRVFJLHVCQUErQjtRQUNyQyxNQUFNRCxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDSCxJQUFJLENBQUM7SUFDN0I7SUFFUUssd0JBQWdDO1FBQ3RDLE1BQU1DLGFBQWE7WUFDakIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLFVBQVUsQ0FBQyxJQUFJLENBQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUMzQztJQUVRTSwwQkFBa0M7UUFDeEMsTUFBTUMsZUFBZTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixF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SUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG1CQUFtQixHQUFHO0lBQzdCO0FBcVBGO0FBclRhL0MsTUFDWWlFLGdCQUFnQixRQUFTLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvRW5lbXkudHM/M2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmVteSBjb21wb25lbnQgZm9yIGlkZW50aWZ5aW5nIGVuZW15IGVudGl0aWVzXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBFbmVteVR5cGUge1xuICBEVU1NWSA9ICdkdW1teScsXG4gIEdSVU5UID0gJ2dydW50JyxcbiAgRUxJVEUgPSAnZWxpdGUnLFxuICBCT1NTID0gJ2Jvc3MnXG59XG5cbmV4cG9ydCBjbGFzcyBFbmVteSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHR5cGU6IEVuZW15VHlwZTtcbiAgcHVibGljIGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyBleHBlcmllbmNlUmV3YXJkOiBudW1iZXI7XG4gIHB1YmxpYyBpc0FnZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBhZ2dyb1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tSYW5nZTogbnVtYmVyO1xuICBwdWJsaWMgYXR0YWNrRGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tDb29sZG93bjogbnVtYmVyO1xuICBwdWJsaWMgbGFzdEF0dGFja1RpbWU6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcmVzcGF3blRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNhblJlc3Bhd246IGJvb2xlYW47XG4gIFxuICAvLyBGcmVlemUgc3RhdHVzIGVmZmVjdFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcmVlemVTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGZyZWV6ZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvcmlnaW5hbE1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgXG4gIC8vIFZlbm9tIGRlYnVmZiBlZmZlY3RcbiAgcHVibGljIGlzVmVub21vdXM6IGJvb2xlYW47XG4gIHB1YmxpYyB2ZW5vbVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EYW1hZ2VQZXJTZWNvbmQ6IG51bWJlcjtcbiAgcHVibGljIGxhc3RWZW5vbURhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBFbmVteVR5cGUgPSBFbmVteVR5cGUuRFVNTVksXG4gICAgbGV2ZWw6IG51bWJlciA9IDFcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLmV4cGVyaWVuY2VSZXdhcmQgPSB0aGlzLmNhbGN1bGF0ZUV4cGVyaWVuY2VSZXdhcmQoKTtcbiAgICB0aGlzLmlzQWdncmVzc2l2ZSA9IHR5cGUgIT09IEVuZW15VHlwZS5EVU1NWTtcbiAgICB0aGlzLmFnZ3JvUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tSYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tEYW1hZ2UoKTtcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tDb29sZG93bigpO1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMuY2FsY3VsYXRlTW92ZW1lbnRTcGVlZCgpO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMucmVzcGF3blRpbWUgPSAzMDsgLy8gMzAgc2Vjb25kcyBkZWZhdWx0IHJlc3Bhd24gdGltZVxuICAgIHRoaXMuY2FuUmVzcGF3biA9IHRydWU7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBmcmVlemUgc3RhdHVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHZlbm9tIHN0YXR1c1xuICAgIHRoaXMuaXNWZW5vbW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSAwO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IDA7XG4gICAgdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCA9IDA7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VFeHAgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogNSxcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAxMCxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAyNSxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEwMFxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VFeHBbdGhpcy50eXBlXSAqIHRoaXMubGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlUmFuZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBhZ2dyb1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogOCxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEyXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja1JhbmdlKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVJhbmdlID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgYXR0YWNrXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDIsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAzXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VEYW1hZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBkZWFsIGRhbWFnZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDE1LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDI1LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogNTBcbiAgICB9O1xuICAgIHJldHVybiBiYXNlRGFtYWdlW3RoaXMudHlwZV0gKiB0aGlzLmxldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBdHRhY2tDb29sZG93bigpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VDb29sZG93biA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGF0dGFja1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDIsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VDb29sZG93blt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVNwZWVkID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgbW92ZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDMsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMCwgLy8gRWxpdGUgZW5lbWllcyBhcmUgc3RhdGlvbmFyeSBsaWtlIHRyYWluaW5nIGR1bW1pZXNcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDIuNVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VTcGVlZFt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWdncmVzc2l2ZSB8fCB0aGlzLmlzRGVhZCB8fCB0aGlzLmF0dGFja0RhbWFnZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBwdWJsaWMgdGFrZURhbWFnZSgpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgSGVhbHRoIGNvbXBvbmVudFxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGZvciBlbmVteS1zcGVjaWZpYyBkYW1hZ2UgcmVhY3Rpb25zXG4gIH1cblxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2FuUmVzcGF3biB8fCAhdGhpcy5pc0RlYWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMuZGVhdGhUaW1lKSA+PSB0aGlzLnJlc3Bhd25UaW1lO1xuICB9XG5cbiAgcHVibGljIHJlc3Bhd24oKTogdm9pZCB7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgLy8gQ2xlYXIgZnJlZXplIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy51bmZyZWV6ZSgpO1xuICAgIC8vIENsZWFyIHZlbm9tIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICB9XG4gIFxuICBwdWJsaWMgZnJlZXplKGR1cmF0aW9uOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RlYWQpIHJldHVybjsgLy8gQ2FuJ3QgZnJlZXplIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIC8vIFNldCBtb3ZlbWVudCBzcGVlZCB0byAwIHdoZW4gZnJvemVuXG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gMDtcbiAgfVxuICBcbiAgcHVibGljIHVuZnJlZXplKCk6IHZvaWQge1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyZWV6ZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IDA7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBtb3ZlbWVudCBzcGVlZFxuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlRnJlZXplU3RhdHVzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNGcm96ZW4pIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmZyZWV6ZVN0YXJ0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aGlzLmZyZWV6ZUR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnVuZnJlZXplKCk7XG4gICAgfVxuICB9XG4gIFxuICBwdWJsaWMgY2FuTW92ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNGcm96ZW4gJiYgIXRoaXMuaXNEZWFkO1xuICB9XG4gIFxuICBwdWJsaWMgYXBwbHlWZW5vbShkdXJhdGlvbjogbnVtYmVyLCBkYW1hZ2VQZXJTZWNvbmQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBhcHBseSB2ZW5vbSB0byBkZWFkIGVuZW1pZXNcbiAgICBcbiAgICB0aGlzLmlzVmVub21vdXMgPSB0cnVlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gZGFtYWdlUGVyU2Vjb25kO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgcmVtb3ZlVmVub20oKTogdm9pZCB7XG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVmVub21TdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHsgc2hvdWxkRGVhbERhbWFnZTogYm9vbGVhbjsgZGFtYWdlOiBudW1iZXIgfSB7XG4gICAgaWYgKCF0aGlzLmlzVmVub21vdXMpIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IGZhbHNlLCBkYW1hZ2U6IDAgfTtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLnZlbm9tU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMudmVub21EdXJhdGlvbikge1xuICAgICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogZmFsc2UsIGRhbWFnZTogMCB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZGVhbCBkYW1hZ2UgKGV2ZXJ5IHNlY29uZClcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0RGFtYWdlID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWU7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3REYW1hZ2UgPj0gMS4wKSB7XG4gICAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IHRydWUsIGRhbWFnZTogdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzaG91bGREZWFsRGFtYWdlOiBmYWxzZSwgZGFtYWdlOiAwIH07XG4gIH1cblxuICBwdWJsaWMgc2V0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGV2ZWwgPSBNYXRoLm1heCgxLCBuZXdMZXZlbCk7XG4gICAgdGhpcy5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5jYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICB9XG5cbiAgcHVibGljIGdldERpc3BsYXlOYW1lKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06ICdUcmFpbmluZyBEdW1teScsXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogJ0dydW50JyxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAnRWxpdGUnLFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogJ0Jvc3MnXG4gICAgfTtcbiAgICByZXR1cm4gYCR7dHlwZU5hbWVzW3RoaXMudHlwZV19IChMdi4ke3RoaXMubGV2ZWx9KWA7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy50eXBlID0gRW5lbXlUeXBlLkRVTU1ZO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuaXNBZ2dyZXNzaXZlID0gZmFsc2U7XG4gICAgdGhpcy5hZ2dyb1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBZ2dyb1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24oKTtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSB0aGlzLmNhbGN1bGF0ZU1vdmVtZW50U3BlZWQoKTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLnJlc3Bhd25UaW1lID0gMzA7XG4gICAgdGhpcy5jYW5SZXNwYXduID0gdHJ1ZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFJlc2V0IGZyZWV6ZSBzdGF0dXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZnJlZXplRHVyYXRpb24gPSAwO1xuICAgIHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkID0gdGhpcy5tb3ZlbWVudFNwZWVkO1xuICAgIFxuICAgIC8vIFJlc2V0IHZlbm9tIHN0YXR1c1xuICAgIHRoaXMuaXNWZW5vbW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSAwO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IDA7XG4gICAgdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCA9IDA7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBFbmVteSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRW5lbXkodGhpcy50eXBlLCB0aGlzLmxldmVsKTtcbiAgICBjbG9uZS5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5leHBlcmllbmNlUmV3YXJkO1xuICAgIGNsb25lLmlzQWdncmVzc2l2ZSA9IHRoaXMuaXNBZ2dyZXNzaXZlO1xuICAgIGNsb25lLmFnZ3JvUmFuZ2UgPSB0aGlzLmFnZ3JvUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUubW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICBjbG9uZS5yZXNwYXduVGltZSA9IHRoaXMucmVzcGF3blRpbWU7XG4gICAgY2xvbmUuY2FuUmVzcGF3biA9IHRoaXMuY2FuUmVzcGF3bjtcbiAgICBcbiAgICAvLyBDbG9uZSBmcmVlemUgc3RhdHVzXG4gICAgY2xvbmUuaXNGcm96ZW4gPSB0aGlzLmlzRnJvemVuO1xuICAgIGNsb25lLmZyZWV6ZVN0YXJ0VGltZSA9IHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGNsb25lLmZyZWV6ZUR1cmF0aW9uID0gdGhpcy5mcmVlemVEdXJhdGlvbjtcbiAgICBjbG9uZS5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBDbG9uZSB2ZW5vbSBzdGF0dXNcbiAgICBjbG9uZS5pc1Zlbm9tb3VzID0gdGhpcy5pc1Zlbm9tb3VzO1xuICAgIGNsb25lLnZlbm9tU3RhcnRUaW1lID0gdGhpcy52ZW5vbVN0YXJ0VGltZTtcbiAgICBjbG9uZS52ZW5vbUR1cmF0aW9uID0gdGhpcy52ZW5vbUR1cmF0aW9uO1xuICAgIGNsb25lLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZDtcbiAgICBjbG9uZS5sYXN0VmVub21EYW1hZ2VUaW1lID0gdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lO1xuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIkVuZW15VHlwZSIsIkVuZW15IiwiY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCIsImJhc2VFeHAiLCJ0eXBlIiwibGV2ZWwiLCJjYWxjdWxhdGVBZ2dyb1JhbmdlIiwiYmFzZVJhbmdlIiwiY2FsY3VsYXRlQXR0YWNrUmFuZ2UiLCJjYWxjdWxhdGVBdHRhY2tEYW1hZ2UiLCJiYXNlRGFtYWdlIiwiY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24iLCJiYXNlQ29vbGRvd24iLCJjYWxjdWxhdGVNb3ZlbWVudFNwZWVkIiwiYmFzZVNwZWVkIiwiY2FuQXR0YWNrIiwiY3VycmVudFRpbWUiLCJpc0FnZ3Jlc3NpdmUiLCJpc0RlYWQiLCJhdHRhY2tEYW1hZ2UiLCJsYXN0QXR0YWNrVGltZSIsImF0dGFja0Nvb2xkb3duIiwicGVyZm9ybUF0dGFjayIsInRha2VEYW1hZ2UiLCJkaWUiLCJkZWF0aFRpbWUiLCJjYW5SZXNwYXduTm93IiwiY2FuUmVzcGF3biIsInJlc3Bhd25UaW1lIiwicmVzcGF3biIsInVuZnJlZXplIiwicmVtb3ZlVmVub20iLCJmcmVlemUiLCJkdXJhdGlvbiIsImlzRnJvemVuIiwiZnJlZXplU3RhcnRUaW1lIiwiZnJlZXplRHVyYXRpb24iLCJtb3ZlbWVudFNwZWVkIiwib3JpZ2luYWxNb3ZlbWVudFNwZWVkIiwidXBkYXRlRnJlZXplU3RhdHVzIiwiZWxhcHNlZCIsImNhbk1vdmUiLCJhcHBseVZlbm9tIiwiZGFtYWdlUGVyU2Vjb25kIiwiaXNWZW5vbW91cyIsInZlbm9tU3RhcnRUaW1lIiwidmVub21EdXJhdGlvbiIsInZlbm9tRGFtYWdlUGVyU2Vjb25kIiwibGFzdFZlbm9tRGFtYWdlVGltZSIsInVwZGF0ZVZlbm9tU3RhdHVzIiwic2hvdWxkRGVhbERhbWFnZSIsImRhbWFnZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJzZXRMZXZlbCIsIm5ld0xldmVsIiwiTWF0aCIsIm1heCIsImV4cGVyaWVuY2VSZXdhcmQiLCJnZXREaXNwbGF5TmFtZSIsInR5cGVOYW1lcyIsInJlc2V0IiwiYWdncm9SYW5nZSIsImF0dGFja1JhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Enemy.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Health.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Health.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Health: function() { return /* binding */ Health; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _Shield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n// Health component for damage and healing\n\n\nclass Health extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    takeDamage(amount) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000, entity = arguments.length > 2 ? arguments[2] : void 0, bypassInvulnerability = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n        if (this.isDead || !bypassInvulnerability && this.isInvulnerable || amount <= 0) {\n            return false;\n        }\n        let finalDamage = amount;\n        // Check if entity has a shield component and absorb damage through it first\n        if (entity) {\n            const shield = entity.getComponent(_Shield__WEBPACK_IMPORTED_MODULE_1__.Shield);\n            if (shield) {\n                finalDamage = shield.absorbDamage(amount);\n            }\n        }\n        // Apply remaining damage to health\n        if (finalDamage > 0) {\n            this.currentHealth = Math.max(0, this.currentHealth - finalDamage);\n            this.lastDamageTime = currentTime;\n            // Start invulnerability period\n            this.isInvulnerable = true;\n            this.invulnerabilityTimer = this.invulnerabilityDuration;\n            // Check if dead\n            if (this.currentHealth <= 0) {\n                this.isDead = true;\n            }\n        }\n        return true;\n    }\n    heal(amount) {\n        if (this.isDead || amount <= 0) {\n            return false;\n        }\n        const oldHealth = this.currentHealth;\n        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);\n        return this.currentHealth > oldHealth;\n    }\n    setMaxHealth(newMaxHealth) {\n        const healthRatio = this.getHealthRatio();\n        this.maxHealth = Math.max(1, newMaxHealth);\n        this.currentHealth = Math.floor(this.maxHealth * healthRatio);\n    }\n    getHealthRatio() {\n        return this.maxHealth > 0 ? this.currentHealth / this.maxHealth : 0;\n    }\n    getHealthPercentage() {\n        return this.getHealthRatio() * 100;\n    }\n    isFullHealth() {\n        return this.currentHealth >= this.maxHealth;\n    }\n    isLowHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.25;\n        return this.getHealthRatio() <= threshold;\n    }\n    isCriticalHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.1;\n        return this.getHealthRatio() <= threshold;\n    }\n    revive(healthAmount) {\n        this.isDead = false;\n        this.currentHealth = healthAmount !== undefined ? Math.min(this.maxHealth, healthAmount) : this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    update(deltaTime) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000;\n        // Update invulnerability timer\n        if (this.isInvulnerable) {\n            this.invulnerabilityTimer -= deltaTime;\n            if (this.invulnerabilityTimer <= 0) {\n                this.isInvulnerable = false;\n                this.invulnerabilityTimer = 0;\n            }\n        }\n        // Handle regeneration\n        if (this.canRegenerate && !this.isDead && !this.isFullHealth()) {\n            const timeSinceLastDamage = currentTime - this.lastDamageTime;\n            if (timeSinceLastDamage >= this.regenerationDelay) {\n                this.heal(this.regenerationRate * deltaTime);\n            }\n        }\n    }\n    setInvulnerable(duration) {\n        this.isInvulnerable = true;\n        this.invulnerabilityTimer = duration;\n    }\n    removeInvulnerability() {\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    enableRegeneration() {\n        let rate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n        this.canRegenerate = true;\n        this.regenerationRate = rate;\n        this.regenerationDelay = delay;\n    }\n    disableRegeneration() {\n        this.canRegenerate = false;\n    }\n    reset() {\n        this.currentHealth = this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5;\n        this.regenerationDelay = 3;\n        this.lastDamageTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Health(this.maxHealth);\n        clone.currentHealth = this.currentHealth;\n        clone.isInvulnerable = this.isInvulnerable;\n        clone.invulnerabilityDuration = this.invulnerabilityDuration;\n        clone.invulnerabilityTimer = this.invulnerabilityTimer;\n        clone.isDead = this.isDead;\n        clone.canRegenerate = this.canRegenerate;\n        clone.regenerationRate = this.regenerationRate;\n        clone.regenerationDelay = this.regenerationDelay;\n        clone.lastDamageTime = this.lastDamageTime;\n        return clone;\n    }\n    constructor(maxHealth = 100){\n        super();\n        this.componentType = \"Health\" // Instance identifier\n        ;\n        this.maxHealth = maxHealth;\n        this.currentHealth = maxHealth; // Always start with full health\n        this.isInvulnerable = false;\n        this.invulnerabilityDuration = 0.5; // 0.5 seconds of invulnerability after damage\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5; // Health per second\n        this.regenerationDelay = 3; // Seconds after damage before regeneration starts\n        this.lastDamageTime = 0;\n    }\n}\nHealth.componentType = \"Health\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQ0o7QUFDSjtBQUUzQixNQUFNRSxlQUFlRiw4Q0FBU0E7SUE2QjVCRyxXQUFXQyxNQUFjLEVBQTBHO1lBQXhHQyxjQUFBQSxpRUFBc0JDLEtBQUtDLEdBQUcsS0FBSyxNQUFNQyx1REFBY0Msd0JBQUFBLGlFQUFpQztRQUN4SCxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFLLENBQUNELHlCQUF5QixJQUFJLENBQUNFLGNBQWMsSUFBS1AsVUFBVSxHQUFHO1lBQ2pGLE9BQU87UUFDVDtRQUVBLElBQUlRLGNBQWNSO1FBRWxCLDRFQUE0RTtRQUM1RSxJQUFJSSxRQUFRO1lBQ1YsTUFBTUssU0FBU0wsT0FBT00sWUFBWSxDQUFDYiwyQ0FBTUE7WUFDekMsSUFBSVksUUFBUTtnQkFDVkQsY0FBY0MsT0FBT0UsWUFBWSxDQUFDWDtZQUNwQztRQUNGO1FBRUEsbUNBQW1DO1FBQ25DLElBQUlRLGNBQWMsR0FBRztZQUNuQixJQUFJLENBQUNJLGFBQWEsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDRixhQUFhLEdBQUdKO1lBQ3RELElBQUksQ0FBQ08sY0FBYyxHQUFHZDtZQUV0QiwrQkFBK0I7WUFDL0IsSUFBSSxDQUFDTSxjQUFjLEdBQUc7WUFDdEIsSUFBSSxDQUFDUyxvQkFBb0IsR0FBRyxJQUFJLENBQUNDLHVCQUF1QjtZQUV4RCxnQkFBZ0I7WUFDaEIsSUFBSSxJQUFJLENBQUNMLGFBQWEsSUFBSSxHQUFHO2dCQUMzQixJQUFJLENBQUNOLE1BQU0sR0FBRztZQUNoQjtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRU9ZLEtBQUtsQixNQUFjLEVBQVc7UUFDbkMsSUFBSSxJQUFJLENBQUNNLE1BQU0sSUFBSU4sVUFBVSxHQUFHO1lBQzlCLE9BQU87UUFDVDtRQUVBLE1BQU1tQixZQUFZLElBQUksQ0FBQ1As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LENBQUNELG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1YsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDK0IsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0csZ0JBQWdCLEdBQUcsR0FBRyxvQkFBb0I7UUFDL0MsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRyxHQUFHLGtEQUFrRDtRQUM5RSxJQUFJLENBQUN4QixjQUFjLEdBQUc7SUFDeEI7QUFpSkY7QUE1S2FqQixPQUNZc0QsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHM/NWY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggY29tcG9uZW50IGZvciBkYW1hZ2UgYW5kIGhlYWxpbmdcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5pbXBvcnQgeyBTaGllbGQgfSBmcm9tICcuL1NoaWVsZCc7XG5cbmV4cG9ydCBjbGFzcyBIZWFsdGggZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ0hlYWx0aCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIGN1cnJlbnRIZWFsdGg6IG51bWJlcjtcbiAgcHVibGljIG1heEhlYWx0aDogbnVtYmVyO1xuICBwdWJsaWMgaXNJbnZ1bG5lcmFibGU6IGJvb2xlYW47XG4gIHB1YmxpYyBpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaW52dWxuZXJhYmlsaXR5VGltZXI6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGNhblJlZ2VuZXJhdGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZWdlbmVyYXRpb25SYXRlOiBudW1iZXI7XG4gIHB1YmxpYyByZWdlbmVyYXRpb25EZWxheTogbnVtYmVyO1xuICBwdWJsaWMgbGFzdERhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtYXhIZWFsdGg6IG51bWJlciA9IDEwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5tYXhIZWFsdGggPSBtYXhIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gbWF4SGVhbHRoOyAvLyBBbHdheXMgc3RhcnQgd2l0aCBmdWxsIGhlYWx0aFxuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gMC41OyAvLyAwLjUgc2Vjb25kcyBvZiBpbnZ1bG5lcmFiaWxpdHkgYWZ0ZXIgZGFtYWdlXG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1OyAvLyBIZWFsdGggcGVyIHNlY29uZFxuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzOyAvLyBTZWNvbmRzIGFmdGVyIGRhbWFnZSBiZWZvcmUgcmVnZW5lcmF0aW9uIHN0YXJ0c1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIHRha2VEYW1hZ2UoYW1vdW50OiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpIC8gMTAwMCwgZW50aXR5PzogYW55LCBieXBhc3NJbnZ1bG5lcmFiaWxpdHk6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmlzRGVhZCB8fCAoIWJ5cGFzc0ludnVsbmVyYWJpbGl0eSAmJiB0aGlzLmlzSW52dWxuZXJhYmxlKSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmaW5hbERhbWFnZSA9IGFtb3VudDtcblxuICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgYSBzaGllbGQgY29tcG9uZW50IGFuZCBhYnNvcmIgZGFtYWdlIHRocm91Z2ggaXQgZmlyc3RcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIGZpbmFsRGFtYWdlID0gc2hpZWxkLmFic29yYkRhbWFnZShhbW91bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHJlbWFpbmluZyBkYW1hZ2UgdG8gaGVhbHRoXG4gICAgaWYgKGZpbmFsRGFtYWdlID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50SGVhbHRoIC0gZmluYWxEYW1hZ2UpO1xuICAgICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBpbnZ1bG5lcmFiaWxpdHkgcGVyaW9kXG4gICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuXG4gICAgICAvLyBDaGVjayBpZiBkZWFkXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGhlYWwoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5taW4odGhpcy5tYXhIZWFsdGgsIHRoaXMuY3VycmVudEhlYWx0aCArIGFtb3VudCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+IG9sZEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXhIZWFsdGgobmV3TWF4SGVhbHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBoZWFsdGhSYXRpbyA9IHRoaXMuZ2V0SGVhbHRoUmF0aW8oKTtcbiAgICB0aGlzLm1heEhlYWx0aCA9IE1hdGgubWF4KDEsIG5ld01heEhlYWx0aCk7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5mbG9vcih0aGlzLm1heEhlYWx0aCAqIGhlYWx0aFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFsdGhSYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm1heEhlYWx0aCA+IDAgPyB0aGlzLmN1cnJlbnRIZWFsdGggLyB0aGlzLm1heEhlYWx0aCA6IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0SGVhbHRoUGVyY2VudGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgKiAxMDA7XG4gIH1cblxuICBwdWJsaWMgaXNGdWxsSGVhbHRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFsdGggPj0gdGhpcy5tYXhIZWFsdGg7XG4gIH1cblxuICBwdWJsaWMgaXNMb3dIZWFsdGgodGhyZXNob2xkOiBudW1iZXIgPSAwLjI1KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSA8PSB0aHJlc2hvbGQ7XG4gIH1cblxuICBwdWJsaWMgaXNDcml0aWNhbEhlYWx0aCh0aHJlc2hvbGQ6IG51bWJlciA9IDAuMSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgPD0gdGhyZXNob2xkO1xuICB9XG5cbiAgcHVibGljIHJldml2ZShoZWFsdGhBbW91bnQ/OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IGhlYWx0aEFtb3VudCAhPT0gdW5kZWZpbmVkID8gXG4gICAgICBNYXRoLm1pbih0aGlzLm1heEhlYWx0aCwgaGVhbHRoQW1vdW50KSA6IFxuICAgICAgdGhpcy5tYXhIZWFsdGg7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlciA9IERhdGUubm93KCkgLyAxMDAwKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGludnVsbmVyYWJpbGl0eSB0aW1lclxuICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XG4gICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIGlmICh0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVnZW5lcmF0aW9uXG4gICAgaWYgKHRoaXMuY2FuUmVnZW5lcmF0ZSAmJiAhdGhpcy5pc0RlYWQgJiYgIXRoaXMuaXNGdWxsSGVhbHRoKCkpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5KSB7XG4gICAgICAgIHRoaXMuaGVhbCh0aGlzLnJlZ2VuZXJhdGlvblJhdGUgKiBkZWx0YVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnZ1bG5lcmFibGUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSB0cnVlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSBkdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVJbnZ1bG5lcmFiaWxpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVJlZ2VuZXJhdGlvbihyYXRlOiBudW1iZXIgPSA1LCBkZWxheTogbnVtYmVyID0gMyk6IHZvaWQge1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IHRydWU7XG4gICAgdGhpcy5yZWdlbmVyYXRpb25SYXRlID0gcmF0ZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBwdWJsaWMgZGlzYWJsZVJlZ2VuZXJhdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1O1xuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogSGVhbHRoIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBIZWFsdGgodGhpcy5tYXhIZWFsdGgpO1xuICAgIGNsb25lLmN1cnJlbnRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgY2xvbmUuaXNJbnZ1bG5lcmFibGUgPSB0aGlzLmlzSW52dWxuZXJhYmxlO1xuICAgIGNsb25lLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gdGhpcy5pbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjtcbiAgICBjbG9uZS5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXI7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuY2FuUmVnZW5lcmF0ZSA9IHRoaXMuY2FuUmVnZW5lcmF0ZTtcbiAgICBjbG9uZS5yZWdlbmVyYXRpb25SYXRlID0gdGhpcy5yZWdlbmVyYXRpb25SYXRlO1xuICAgIGNsb25lLnJlZ2VuZXJhdGlvbkRlbGF5ID0gdGhpcy5yZWdlbmVyYXRpb25EZWxheTtcbiAgICBjbG9uZS5sYXN0RGFtYWdlVGltZSA9IHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiSGVhbHRoIiwidGFrZURhbWFnZSIsImFtb3VudCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVudGl0eSIsImJ5cGFzc0ludnVsbmVyYWJpbGl0eSIsImlzRGVhZCIsImlzSW52dWxuZXJhYmxlIiwiZmluYWxEYW1hZ2UiLCJzaGllbGQiLCJnZXRDb21wb25lbnQiLCJhYnNvcmJEYW1hZ2UiLCJjdXJyZW50SGVhbHRoIiwiTWF0aCIsIm1heCIsImxhc3REYW1hZ2VUaW1lIiwiaW52dWxuZXJhYmlsaXR5VGltZXIiLCJpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbiIsImhlYWwiLCJvbGRIZWFsdGgiLCJtaW4iLCJtYXhIZWFsdGgiLCJzZXRNYXhIZWFsdGgiLCJuZXdNYXhIZWFsdGgiLCJoZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiZmxvb3IiLCJnZXRIZWFsdGhQZXJjZW50YWdlIiwiaXNGdWxsSGVhbHRoIiwiaXNMb3dIZWFsdGgiLCJ0aHJlc2hvbGQiLCJpc0NyaXRpY2FsSGVhbHRoIiwicmV2aXZlIiwiaGVhbHRoQW1vdW50IiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiY2FuUmVnZW5lcmF0ZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJyZWdlbmVyYXRpb25EZWxheSIsInJlZ2VuZXJhdGlvblJhdGUiLCJzZXRJbnZ1bG5lcmFibGUiLCJkdXJhdGlvbiIsInJlbW92ZUludnVsbmVyYWJpbGl0eSIsImVuYWJsZVJlZ2VuZXJhdGlvbiIsInJhdGUiLCJkZWxheSIsImRpc2FibGVSZWdlbmVyYXRpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Health.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/HealthBar.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/HealthBar.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBar: function() { return /* binding */ HealthBar; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Health bar component for rendering health bars above entities\n\n\nclass HealthBar extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    createHealthBarMeshes() {\n        this.group = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group();\n        // Create border (slightly larger than background)\n        const borderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width + this.borderWidth * 2, this.height + this.borderWidth * 2);\n        const borderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.borderColor,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.borderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(borderGeometry, borderMaterial);\n        this.borderMesh.position.z = -0.001; // Slightly behind\n        this.group.add(this.borderMesh);\n        // Create background\n        const backgroundGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const backgroundMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.backgroundColor,\n            transparent: true,\n            opacity: 0.7\n        });\n        this.backgroundMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(backgroundGeometry, backgroundMaterial);\n        this.group.add(this.backgroundMesh);\n        // Create health bar (starts full width)\n        const healthGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const healthMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.healthColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        this.healthMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(healthGeometry, healthMaterial);\n        this.healthMesh.position.z = 0.001; // Slightly in front\n        this.group.add(this.healthMesh);\n        // Make health bar always face camera\n        this.group.lookAt(0, 0, 1);\n    }\n    updateHealthBar(healthRatio, cameraPosition, worldPosition, deltaTime) {\n        this.currentHealthRatio = Math.max(0, Math.min(1, healthRatio));\n        // Animate health bar changes\n        if (Math.abs(this.lastHealthRatio - this.currentHealthRatio) > 0.01) {\n            this.lastHealthRatio = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this.lastHealthRatio, this.currentHealthRatio, this.animationSpeed * deltaTime);\n        } else {\n            this.lastHealthRatio = this.currentHealthRatio;\n        }\n        // Update health bar width and position\n        this.updateHealthMesh();\n        // Update health bar color based on health ratio\n        this.updateHealthColor();\n        // Update visibility based on distance and health\n        this.updateVisibility(cameraPosition, worldPosition);\n        // Update position and rotation to face camera\n        this.updatePositionAndRotation(cameraPosition, worldPosition);\n        // Update damage flash\n        this.updateDamageFlash(deltaTime);\n    }\n    updateHealthMesh() {\n        // Update scale to represent health\n        this.healthMesh.scale.x = this.lastHealthRatio;\n        // Adjust position so health bar shrinks from right to left\n        const offsetX = this.width * (1 - this.lastHealthRatio) / 2;\n        this.healthMesh.position.x = -offsetX;\n    }\n    updateHealthColor() {\n        let color;\n        if (this.currentHealthRatio <= this.criticalHealthThreshold) {\n            color = this.criticalHealthColor;\n        } else if (this.currentHealthRatio <= this.lowHealthThreshold) {\n            // Interpolate between low health and critical health colors\n            const t = (this.currentHealthRatio - this.criticalHealthThreshold) / (this.lowHealthThreshold - this.criticalHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.criticalHealthColor, this.lowHealthColor, t);\n        } else {\n            // Interpolate between health and low health colors\n            const t = (this.currentHealthRatio - this.lowHealthThreshold) / (1 - this.lowHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.lowHealthColor, this.healthColor, t);\n        }\n        this.healthMesh.material.color.copy(color);\n    }\n    updateVisibility(cameraPosition, worldPosition) {\n        // Calculate distance to camera\n        const distance = cameraPosition.distanceTo(worldPosition);\n        // Determine if should be visible\n        let shouldBeVisible = distance <= this.fadeDistance;\n        // Hide when full health if configured\n        if (!this.showWhenFull && this.currentHealthRatio >= 0.99) {\n            shouldBeVisible = false;\n        }\n        // Update visibility\n        this.isVisible = shouldBeVisible;\n        this.group.visible = this.isVisible;\n        // Fade based on distance\n        if (this.isVisible && distance > this.fadeDistance * 0.7) {\n            const fadeRatio = 1 - (distance - this.fadeDistance * 0.7) / (this.fadeDistance * 0.3);\n            const opacity = Math.max(0.1, fadeRatio);\n            this.backgroundMesh.material.opacity = opacity * 0.7;\n            this.healthMesh.material.opacity = opacity * 0.9;\n            this.borderMesh.material.opacity = opacity * 0.8;\n        } else if (this.isVisible) {\n            this.backgroundMesh.material.opacity = 0.7;\n            this.healthMesh.material.opacity = 0.9;\n            this.borderMesh.material.opacity = 0.8;\n        }\n    }\n    updatePositionAndRotation(cameraPosition, worldPosition) {\n        // Position health bar above entity\n        const barPosition = worldPosition.clone().add(this.offset);\n        this.group.position.copy(barPosition);\n        // Make health bar face camera\n        this.group.lookAt(cameraPosition);\n    }\n    updateDamageFlash(deltaTime) {\n        if (this.damageFlashTimer > 0) {\n            this.damageFlashTimer -= deltaTime;\n            // Flash effect - make health bar brighter\n            const flashIntensity = this.damageFlashTimer / this.damageFlashDuration;\n            const flashColor = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            // Mix current color with white for flash effect\n            const currentColor = this.healthMesh.material.color.clone();\n            currentColor.lerp(flashColor, flashIntensity * 0.5);\n            this.healthMesh.material.color.copy(currentColor);\n        }\n    }\n    triggerDamageFlash() {\n        this.damageFlashTimer = this.damageFlashDuration;\n    }\n    setHealthRatio(ratio) {\n        const oldRatio = this.currentHealthRatio;\n        this.currentHealthRatio = Math.max(0, Math.min(1, ratio));\n        // Trigger damage flash if health decreased\n        if (this.currentHealthRatio < oldRatio) {\n            this.triggerDamageFlash();\n        }\n    }\n    getGroup() {\n        return this.group;\n    }\n    dispose() {\n        // Clean up geometries and materials\n        this.backgroundMesh.geometry.dispose();\n        this.backgroundMesh.material.dispose();\n        this.healthMesh.geometry.dispose();\n        this.healthMesh.material.dispose();\n        this.borderMesh.geometry.dispose();\n        this.borderMesh.material.dispose();\n        // Remove from parent if it has one\n        if (this.group.parent) {\n            this.group.parent.remove(this.group);\n        }\n    }\n    reset() {\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.isVisible = true;\n        this.damageFlashTimer = 0;\n        this.enabled = true;\n        // Reset visual state\n        this.updateHealthMesh();\n        this.updateHealthColor();\n    }\n    clone() {\n        const config = {\n            width: this.width,\n            height: this.height,\n            offset: this.offset.clone(),\n            backgroundColor: this.backgroundColor.clone(),\n            healthColor: this.healthColor.clone(),\n            lowHealthColor: this.lowHealthColor.clone(),\n            criticalHealthColor: this.criticalHealthColor.clone(),\n            borderColor: this.borderColor.clone(),\n            borderWidth: this.borderWidth,\n            showWhenFull: this.showWhenFull,\n            fadeDistance: this.fadeDistance,\n            lowHealthThreshold: this.lowHealthThreshold,\n            criticalHealthThreshold: this.criticalHealthThreshold\n        };\n        return new HealthBar(config);\n    }\n    constructor(config = {}){\n        var _config_offset, _config_backgroundColor, _config_healthColor, _config_lowHealthColor, _config_criticalHealthColor, _config_borderColor;\n        super();\n        this.componentType = \"HealthBar\" // Instance identifier\n        ;\n        // Configuration\n        this.width = config.width || 1.0;\n        this.height = config.height || 0.1;\n        this.offset = ((_config_offset = config.offset) === null || _config_offset === void 0 ? void 0 : _config_offset.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0);\n        this.backgroundColor = ((_config_backgroundColor = config.backgroundColor) === null || _config_backgroundColor === void 0 ? void 0 : _config_backgroundColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x333333);\n        this.healthColor = ((_config_healthColor = config.healthColor) === null || _config_healthColor === void 0 ? void 0 : _config_healthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x00ff00);\n        this.lowHealthColor = ((_config_lowHealthColor = config.lowHealthColor) === null || _config_lowHealthColor === void 0 ? void 0 : _config_lowHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xffff00);\n        this.criticalHealthColor = ((_config_criticalHealthColor = config.criticalHealthColor) === null || _config_criticalHealthColor === void 0 ? void 0 : _config_criticalHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xff0000);\n        this.borderColor = ((_config_borderColor = config.borderColor) === null || _config_borderColor === void 0 ? void 0 : _config_borderColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);\n        this.borderWidth = config.borderWidth || 0.02;\n        this.showWhenFull = config.showWhenFull !== undefined ? config.showWhenFull : false;\n        this.fadeDistance = config.fadeDistance || 20;\n        this.lowHealthThreshold = config.lowHealthThreshold || 0.5;\n        this.criticalHealthThreshold = config.criticalHealthThreshold || 0.25;\n        // State\n        this.isVisible = true;\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.animationSpeed = 5.0; // How fast health bar animates\n        this.damageFlashTimer = 0;\n        this.damageFlashDuration = 0.2;\n        // Create rendering objects\n        this.createHealthBarMeshes();\n    }\n}\nHealthBar.componentType = \"HealthBar\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQzJEO0FBQ3JGO0FBa0IvQixNQUFNUSxrQkFBa0JELDhDQUFTQTtJQTZEOUJFLHdCQUE4QjtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJUix1REFBS0E7UUFFdEIsa0RBQWtEO1FBQ2xELE1BQU1TLGlCQUFpQixJQUFJUCwrREFBYUEsQ0FDdEMsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxXQUFXLEdBQUc7UUFFbkMsTUFBTUUsaUJBQWlCLElBQUlWLG1FQUFpQkEsQ0FBQztZQUMzQ1csT0FBTyxJQUFJLENBQUNDLFdBQVc7WUFDdkJDLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSWpCLHNEQUFJQSxDQUFDUSxnQkFBZ0JJO1FBQzNDLElBQUksQ0FBQ0ssVUFBVSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBRyxDQUFDLE9BQU8sa0JBQWtCO1FBQ3ZELElBQUksQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUMsSUFBSSxDQUFDSCxVQUFVO1FBRTlCLG9CQUFvQjtRQUNwQixNQUFNSSxxQkFBcUIsSUFBSXBCLCtEQUFhQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNwRSxNQUFNVyxxQkFBcUIsSUFBSXBCLG1FQUFpQkEsQ0FBQztZQUMvQ1csT0FBTyxJQUFJLENBQUNVLGVBQWU7WUFDM0JSLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSXhCLHNEQUFJQSxDQUFDcUIsb0JBQW9CQztRQUNuRCxJQUFJLENBQUNmLEtBQUssQ0FBQ2EsR0FBRyxDQUFDLElBQUksQ0FBQ0ksY0FB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LEdBQUc7UUFDdkIsSUFBSSxDQUFDRSxjQUFjLEdBQUcsS0FBSywrQkFBK0I7UUFDMUQsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBRztRQUUzQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbEUscUJBQXFCO0lBQzVCO0FBcU9GO0FBaFNhRCxVQUNZbUYsZ0JBQWdCLFlBQWEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHM/MzQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgR3JvdXAsIE1lc2gsIFBsYW5lR2VvbWV0cnksIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRoVXRpbHMsIE1hdGVyaWFsIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQmFyQ29uZmlnIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgb2Zmc2V0PzogVmVjdG9yMztcbiAgYmFja2dyb3VuZENvbG9yPzogQ29sb3I7XG4gIGhlYWx0aENvbG9yPzogQ29sb3I7XG4gIGxvd0hlYWx0aENvbG9yPzogQ29sb3I7XG4gIGNyaXRpY2FsSGVhbHRoQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyV2lkdGg/OiBudW1iZXI7XG4gIHNob3dXaGVuRnVsbD86IGJvb2xlYW47XG4gIGZhZGVEaXN0YW5jZT86IG51bWJlcjtcbiAgbG93SGVhbHRoVGhyZXNob2xkPzogbnVtYmVyO1xuICBjcml0aWNhbEhlYWx0aFRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGhCYXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoQmFyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzO1xuICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGhlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGxvd0hlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGNyaXRpY2FsSGVhbHRoQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyV2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHNob3dXaGVuRnVsbDogYm9vbGVhbjtcbiAgcHVibGljIGZhZGVEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgbG93SGVhbHRoVGhyZXNob2xkOiBudW1iZXI7XG4gIHB1YmxpYyBjcml0aWNhbEhlYWx0aFRocmVzaG9sZDogbnVtYmVyO1xuXG4gIC8vIFJlbmRlcmluZyBvYmplY3RzXG4gIHB1YmxpYyBncm91cCE6IEdyb3VwO1xuICBwdWJsaWMgYmFja2dyb3VuZE1lc2ghOiBNZXNoO1xuICBwdWJsaWMgaGVhbHRoTWVzaCE6IE1lc2g7XG4gIHB1YmxpYyBib3JkZXJNZXNoITogTWVzaDtcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc1Zpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyBjdXJyZW50SGVhbHRoUmF0aW86IG51bWJlcjtcbiAgcHVibGljIGxhc3RIZWFsdGhSYXRpbzogbnVtYmVyO1xuICBwdWJsaWMgYW5pbWF0aW9uU3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoVGltZXI6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoRHVyYXRpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhlYWx0aEJhckNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxLjA7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IDAuMTtcbiAgICB0aGlzLm9mZnNldCA9IGNvbmZpZy5vZmZzZXQ/LmNsb25lKCkgfHwgbmV3IFZlY3RvcjMoMCwgMS41LCAwKTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I/LmNsb25lKCkgfHwgbmV3IENvbG9yKDB4MzMzMzMzKTtcbiAgICB0aGlzLmhlYWx0aENvbG9yID0gY29uZmlnLmhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweDAwZmYwMCk7XG4gICAgdGhpcy5sb3dIZWFsdGhDb2xvciA9IGNvbmZpZy5sb3dIZWFsdGhDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHhmZmZmMDApO1xuICAgIHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvciA9IGNvbmZpZy5jcml0aWNhbEhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweGZmMDAwMCk7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZy5ib3JkZXJDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMC4wMjtcbiAgICB0aGlzLnNob3dXaGVuRnVsbCA9IGNvbmZpZy5zaG93V2hlbkZ1bGwgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zaG93V2hlbkZ1bGwgOiBmYWxzZTtcbiAgICB0aGlzLmZhZGVEaXN0YW5jZSA9IGNvbmZpZy5mYWRlRGlzdGFuY2UgfHwgMjA7XG4gICAgdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQgPSBjb25maWcubG93SGVhbHRoVGhyZXNob2xkIHx8IDAuNTtcbiAgICB0aGlzLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkID0gY29uZmlnLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIHx8IDAuMjU7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmxhc3RIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gNS4wOyAvLyBIb3cgZmFzdCBoZWFsdGggYmFyIGFuaW1hdGVzXG4gICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyID0gMDtcbiAgICB0aGlzLmRhbWFnZUZsYXNoRHVyYXRpb24gPSAwLjI7XG5cbiAgICAvLyBDcmVhdGUgcmVuZGVyaW5nIG9iamVjdHNcbiAgICB0aGlzLmNyZWF0ZUhlYWx0aEJhck1lc2hlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVIZWFsdGhCYXJNZXNoZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgLy8gQ3JlYXRlIGJvcmRlciAoc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gYmFja2dyb3VuZClcbiAgICBjb25zdCBib3JkZXJHZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KFxuICAgICAgdGhpcy53aWR0aCArIHRoaXMuYm9yZGVyV2lkdGggKiAyLCBcbiAgICAgIHRoaXMuaGVpZ2h0ICsgdGhpcy5ib3JkZXJXaWR0aCAqIDJcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlck1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgdGhpcy5ib3JkZXJNZXNoID0gbmV3IE1lc2goYm9yZGVyR2VvbWV0cnksIGJvcmRlck1hdGVyaWFsKTtcbiAgICB0aGlzLmJvcmRlck1lc2gucG9zaXRpb24ueiA9IC0wLjAwMTsgLy8gU2xpZ2h0bHkgYmVoaW5kXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5ib3JkZXJNZXNoKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgYmFja2dyb3VuZEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goYmFja2dyb3VuZEdlb21ldHJ5LCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuYmFja2dyb3VuZE1lc2gpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWx0aCBiYXIgKHN0YXJ0cyBmdWxsIHdpZHRoKVxuICAgIGNvbnN0IGhlYWx0aEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhlYWx0aE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5oZWFsdGhDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC45XG4gICAgfSk7XG4gICAgdGhpcy5oZWFsdGhNZXNoID0gbmV3IE1lc2goaGVhbHRoR2VvbWV0cnksIGhlYWx0aE1hdGVyaWFsKTtcbiAgICB0aGlzLmhlYWx0aE1lc2gucG9zaXRpb24ueiA9IDAuMDAxOyAvLyBTbGlnaHRseSBpbiBmcm9udFxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuaGVhbHRoTWVzaCk7XG5cbiAgICAvLyBNYWtlIGhlYWx0aCBiYXIgYWx3YXlzIGZhY2UgY2FtZXJhXG4gICAgdGhpcy5ncm91cC5sb29rQXQoMCwgMCwgMSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSGVhbHRoQmFyKFxuICAgIGhlYWx0aFJhdGlvOiBudW1iZXIsIFxuICAgIGNhbWVyYVBvc2l0aW9uOiBWZWN0b3IzLCBcbiAgICB3b3JsZFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRlbHRhVGltZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaGVhbHRoUmF0aW8pKTtcblxuICAgIC8vIEFuaW1hdGUgaGVhbHRoIGJhciBjaGFuZ2VzXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEhlYWx0aFJhdGlvIC0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8pID4gMC4wMSkge1xuICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8sIFxuICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbywgXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW87XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBjb2xvciBiYXNlZCBvbiBoZWFsdGggcmF0aW9cbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbG9yKCk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KGNhbWVyYVBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gdG8gZmFjZSBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGRhbWFnZSBmbGFzaFxuICAgIHRoaXMudXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoTWVzaCgpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc2NhbGUgdG8gcmVwcmVzZW50IGhlYWx0aFxuICAgIHRoaXMuaGVhbHRoTWVzaC5zY2FsZS54ID0gdGhpcy5sYXN0SGVhbHRoUmF0aW87XG4gICAgXG4gICAgLy8gQWRqdXN0IHBvc2l0aW9uIHNvIGhlYWx0aCBiYXIgc2hyaW5rcyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggKiAoMSAtIHRoaXMubGFzdEhlYWx0aFJhdGlvKSkgLyAyO1xuICAgIHRoaXMuaGVhbHRoTWVzaC5wb3NpdGlvbi54ID0gLW9mZnNldFg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhlYWx0aENvbG9yKCk6IHZvaWQge1xuICAgIGxldCBjb2xvcjogQ29sb3I7XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIDw9IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIGNvbG9yID0gdGhpcy5jcml0aWNhbEhlYWx0aENvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPD0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gbG93IGhlYWx0aCBhbmQgY3JpdGljYWwgaGVhbHRoIGNvbG9yc1xuICAgICAgY29uc3QgdCA9ICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyAtIHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKHRoaXMubG93SGVhbHRoVGhyZXNob2xkIC0gdGhpcy5jcml0aWNhbEhlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5jcml0aWNhbEhlYWx0aENvbG9yLCB0aGlzLmxvd0hlYWx0aENvbG9yLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBoZWFsdGggYW5kIGxvdyBoZWFsdGggY29sb3JzXG4gICAgICBjb25zdCB0ID0gKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIC0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKDEgLSB0aGlzLmxvd0hlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5sb3dIZWFsdGhDb2xvciwgdGhpcy5oZWFsdGhDb2xvciwgdCk7XG4gICAgfVxuXG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY29weShjb2xvcik7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2FtZXJhXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmFQb3NpdGlvbi5kaXN0YW5jZVRvKHdvcmxkUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiBzaG91bGQgYmUgdmlzaWJsZVxuICAgIGxldCBzaG91bGRCZVZpc2libGUgPSBkaXN0YW5jZSA8PSB0aGlzLmZhZGVEaXN0YW5jZTtcbiAgICBcbiAgICAvLyBIaWRlIHdoZW4gZnVsbCBoZWFsdGggaWYgY29uZmlndXJlZFxuICAgIGlmICghdGhpcy5zaG93V2hlbkZ1bGwgJiYgdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPj0gMC45OSkge1xuICAgICAgc2hvdWxkQmVWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpc2liaWxpdHlcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHNob3VsZEJlVmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcblxuICAgIC8vIEZhZGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZGlzdGFuY2UgPiB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykge1xuICAgICAgY29uc3QgZmFkZVJhdGlvID0gMSAtICgoZGlzdGFuY2UgLSB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykgLyAodGhpcy5mYWRlRGlzdGFuY2UgKiAwLjMpKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjEsIGZhZGVSYXRpbyk7XG4gICAgICBcbiAgICAgICh0aGlzLmJhY2tncm91bmRNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gb3BhY2l0eSAqIDAuNztcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSBvcGFjaXR5ICogMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IG9wYWNpdHkgKiAwLjg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgKHRoaXMuYmFja2dyb3VuZE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSAwLjc7XG4gICAgICAodGhpcy5oZWFsdGhNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuODtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQb3NpdGlvbiBoZWFsdGggYmFyIGFib3ZlIGVudGl0eVxuICAgIGNvbnN0IGJhclBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5ncm91cC5wb3NpdGlvbi5jb3B5KGJhclBvc2l0aW9uKTtcblxuICAgIC8vIE1ha2UgaGVhbHRoIGJhciBmYWNlIGNhbWVyYVxuICAgIHRoaXMuZ3JvdXAubG9va0F0KGNhbWVyYVBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYW1hZ2VGbGFzaFRpbWVyID4gMCkge1xuICAgICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIFxuICAgICAgLy8gRmxhc2ggZWZmZWN0IC0gbWFrZSBoZWFsdGggYmFyIGJyaWdodGVyXG4gICAgICBjb25zdCBmbGFzaEludGVuc2l0eSA9IHRoaXMuZGFtYWdlRmxhc2hUaW1lciAvIHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZsYXNoQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIE1peCBjdXJyZW50IGNvbG9yIHdpdGggd2hpdGUgZm9yIGZsYXNoIGVmZmVjdFxuICAgICAgY29uc3QgY3VycmVudENvbG9yID0gKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY2xvbmUoKTtcbiAgICAgIGN1cnJlbnRDb2xvci5sZXJwKGZsYXNoQ29sb3IsIGZsYXNoSW50ZW5zaXR5ICogMC41KTtcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLmNvcHkoY3VycmVudENvbG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJpZ2dlckRhbWFnZUZsYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlRmxhc2hUaW1lciA9IHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFsdGhSYXRpbyhyYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkUmF0aW8gPSB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbztcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhdGlvKSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkYW1hZ2UgZmxhc2ggaWYgaGVhbHRoIGRlY3JlYXNlZFxuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA8IG9sZFJhdGlvKSB7XG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VGbGFzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRHcm91cCgpOiBHcm91cCB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAodGhpcy5iYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuaGVhbHRoTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuYm9yZGVyTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBpZiBpdCBoYXMgb25lXG4gICAgaWYgKHRoaXMuZ3JvdXAucGFyZW50KSB7XG4gICAgICB0aGlzLmdyb3VwLnBhcmVudC5yZW1vdmUodGhpcy5ncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRhbWFnZUZsYXNoVGltZXIgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgdmlzdWFsIHN0YXRlXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb2xvcigpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEhlYWx0aEJhciB7XG4gICAgY29uc3QgY29uZmlnOiBIZWFsdGhCYXJDb25maWcgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLmNsb25lKCksXG4gICAgICBoZWFsdGhDb2xvcjogdGhpcy5oZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgbG93SGVhbHRoQ29sb3I6IHRoaXMubG93SGVhbHRoQ29sb3IuY2xvbmUoKSxcbiAgICAgIGNyaXRpY2FsSGVhbHRoQ29sb3I6IHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IuY2xvbmUoKSxcbiAgICAgIGJvcmRlcldpZHRoOiB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgc2hvd1doZW5GdWxsOiB0aGlzLnNob3dXaGVuRnVsbCxcbiAgICAgIGZhZGVEaXN0YW5jZTogdGhpcy5mYWRlRGlzdGFuY2UsXG4gICAgICBsb3dIZWFsdGhUaHJlc2hvbGQ6IHRoaXMubG93SGVhbHRoVGhyZXNob2xkLFxuICAgICAgY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQ6IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGRcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBuZXcgSGVhbHRoQmFyKGNvbmZpZyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJHcm91cCIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNYXRoVXRpbHMiLCJDb21wb25lbnQiLCJIZWFsdGhCYXIiLCJjcmVhdGVIZWFsdGhCYXJNZXNoZXMiLCJncm91cCIsImJvcmRlckdlb21ldHJ5Iiwid2lkdGgiLCJib3JkZXJXaWR0aCIsImhlaWdodCIsImJvcmRlck1hdGVyaWFsIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImJvcmRlck1lc2giLCJwb3NpdGlvbiIsInoiLCJhZGQiLCJiYWNrZ3JvdW5kR2VvbWV0cnkiLCJiYWNrZ3JvdW5kTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kTWVzaCIsImhlYWx0aEdlb21ldHJ5IiwiaGVhbHRoTWF0ZXJpYWwiLCJoZWFsdGhDb2xvciIsImhlYWx0aE1lc2giLCJsb29rQXQiLCJ1cGRhdGVIZWFsdGhCYXIiLCJoZWFsdGhSYXRpbyIsImNhbWVyYVBvc2l0aW9uIiwid29ybGRQb3NpdGlvbiIsImRlbHRhVGltZSIsImN1cnJlbnRIZWFsdGhSYXRpbyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhYnMiLCJsYXN0SGVhbHRoUmF0aW8iLCJsZXJwIiwiYW5pbWF0aW9uU3BlZWQiLCJ1cGRhdGVIZWFsdGhNZXNoIiwidXBkYXRlSGVhbHRoQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5IiwidXBkYXRlUG9zaXRpb25BbmRSb3RhdGlvbiIsInVwZGF0ZURhbWFnZUZsYXNoIiwic2NhbGUiLCJ4Iiwib2Zmc2V0WCIsImNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIiwiY3JpdGljYWxIZWFsdGhDb2xvciIsImxvd0hlYWx0aFRocmVzaG9sZCIsInQiLCJsZXJwQ29sb3JzIiwibG93SGVhbHRoQ29sb3IiLCJtYXRlcmlhbCIsImNvcHkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJzaG91bGRCZVZpc2libGUiLCJmYWRlRGlzdGFuY2UiLCJzaG93V2hlbkZ1bGwiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwiZmFkZVJhdGlvIiwiYmFyUG9zaXRpb24iLCJjbG9uZSIsIm9mZnNldCIsImRhbWFnZUZsYXNoVGltZXIiLCJmbGFzaEludGVuc2l0eSIsImRhbWFnZUZsYXNoRHVyYXRpb24iLCJmbGFzaENvbG9yIiwiY3VycmVudENvbG9yIiwidHJpZ2dlckRhbWFnZUZsYXNoIiwic2V0SGVhbHRoUmF0aW8iLCJyYXRpbyIsIm9sZFJhdGlvIiwiZ2V0R3JvdXAiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJwYXJlbnQiLCJyZW1vdmUiLCJyZXNldCIsImVuYWJsZWQiLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/HealthBar.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Movement.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Movement.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Movement: function() { return /* binding */ Movement; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Movement component for velocity and movement properties\n\n\nclass Movement extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    addForce(force) {\n        this.acceleration.add(force);\n    }\n    addImpulse(impulse) {\n        this.velocity.add(impulse);\n    }\n    jump() {\n        if (this.canJump && (this.isGrounded || this.canFly)) {\n            this.velocity.y = this.jumpForce;\n            this.isGrounded = false;\n        }\n    }\n    setMoveDirection(direction) {\n        let strength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n        this.moveDirection.copy(direction).normalize();\n        this.inputStrength = Math.max(0, Math.min(1, strength));\n    }\n    freeze(duration) {\n        const currentTime = Date.now();\n        this.isFrozen = true;\n        this.frozenUntil = currentTime + duration;\n    // console.log(`🧊 Player frozen for ${duration}ms until ${this.frozenUntil} (current: ${currentTime})`);\n    }\n    slow(duration) {\n        let speedMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n        const currentTime = Date.now();\n        this.isSlowed = true;\n        this.slowedUntil = currentTime + duration;\n        this.movementSpeedMultiplier = speedMultiplier;\n    // console.log(`🐌 Player slowed to ${speedMultiplier * 100}% speed for ${duration}ms until ${this.slowedUntil}`);\n    }\n    updateDebuffs() {\n        const currentTime = Date.now();\n        // Check frozen state\n        if (this.isFrozen && currentTime >= this.frozenUntil) {\n            this.isFrozen = false;\n            this.frozenUntil = 0;\n            console.log(\"\\uD83E\\uDDCA Player unfrozen\");\n        }\n        // Check slowed state\n        if (this.isSlowed && currentTime >= this.slowedUntil) {\n            this.isSlowed = false;\n            this.slowedUntil = 0;\n            this.movementSpeedMultiplier = 1.0;\n            console.log(\"\\uD83D\\uDC0C Player no longer slowed\");\n        }\n    }\n    getEffectiveMaxSpeed() {\n        if (this.isFrozen) {\n            return 0; // Completely frozen\n        }\n        return this.maxSpeed * this.movementSpeedMultiplier;\n    }\n    startDash(direction, currentPosition, currentTime) {\n        // Check if already dashing\n        if (this.isDashing) {\n            return false;\n        }\n        // Find first available charge\n        const availableChargeIndex = this.dashCharges.findIndex((charge)=>charge.isAvailable);\n        if (availableChargeIndex === -1) {\n            return false; // No charges available\n        }\n        // Start the dash\n        this.isDashing = true;\n        this.dashDirection.copy(direction).normalize();\n        this.dashStartTime = currentTime;\n        this.dashStartPosition.copy(currentPosition);\n        // Consume the charge\n        this.dashCharges[availableChargeIndex].isAvailable = false;\n        this.dashCharges[availableChargeIndex].cooldownStartTime = currentTime;\n        // Set cooldown timer for this specific charge (6 seconds)\n        setTimeout(()=>{\n            this.dashCharges[availableChargeIndex].isAvailable = true;\n            this.dashCharges[availableChargeIndex].cooldownStartTime = null;\n        }, 6000); // 6 second cooldown\n        return true;\n    }\n    updateDash(currentTime) {\n        if (!this.isDashing) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.dashStartTime;\n        const progress = Math.min(elapsed / this.dashDuration, 1);\n        if (progress >= 1) {\n            // Dash complete\n            this.isDashing = false;\n            const finalPosition = this.dashStartPosition.clone().add(this.dashDirection.clone().multiplyScalar(this.dashDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad, same as old implementation)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.dashDirection.clone().multiplyScalar(this.dashDistance * easeOutQuad);\n        const newPosition = this.dashStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelDash() {\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n    }\n    stop() {\n        this.velocity.set(0, 0, 0);\n        this.acceleration.set(0, 0, 0);\n        this.moveDirection.set(0, 0, 0);\n        this.inputStrength = 0;\n    }\n    getSpeed() {\n        return this.velocity.length();\n    }\n    getHorizontalSpeed() {\n        return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);\n    }\n    isMoving() {\n        return this.getSpeed() > 0.01;\n    }\n    isMovingHorizontally() {\n        return this.getHorizontalSpeed() > 0.01;\n    }\n    isFalling() {\n        return this.velocity.y < -0.1;\n    }\n    isRising() {\n        return this.velocity.y > 0.1;\n    }\n    getAvailableDashCharges() {\n        return this.dashCharges.filter((charge)=>charge.isAvailable).length;\n    }\n    getDashChargeStatus() {\n        const currentTime = Date.now() / 1000;\n        return this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownRemaining: charge.cooldownStartTime ? Math.max(0, 6 - (currentTime - charge.cooldownStartTime)) : 0\n            }));\n    }\n    startCharge(direction, currentPosition, currentTime) {\n        // Check if already charging or dashing\n        if (this.isCharging || this.isDashing) {\n            return false;\n        }\n        // Start the charge\n        this.isCharging = true;\n        this.chargeDirection.copy(direction).normalize();\n        this.chargeStartTime = currentTime;\n        this.chargeStartPosition.copy(currentPosition);\n        return true;\n    }\n    updateCharge(currentTime) {\n        if (!this.isCharging) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.chargeStartTime;\n        const progress = Math.min(elapsed / this.chargeDuration, 1);\n        if (progress >= 1) {\n            // Charge complete\n            this.isCharging = false;\n            const finalPosition = this.chargeStartPosition.clone().add(this.chargeDirection.clone().multiplyScalar(this.chargeDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.chargeDirection.clone().multiplyScalar(this.chargeDistance * easeOutQuad);\n        const newPosition = this.chargeStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelCharge() {\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n    }\n    clampVelocity() {\n        // Get effective max speed (considering debuffs)\n        const effectiveMaxSpeed = this.getEffectiveMaxSpeed();\n        // Clamp horizontal velocity to effective max speed\n        const horizontalVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.velocity.x, 0, this.velocity.z);\n        const horizontalSpeed = horizontalVelocity.length();\n        if (horizontalSpeed > effectiveMaxSpeed) {\n            if (effectiveMaxSpeed === 0) {\n                // Completely frozen - stop all horizontal movement\n                this.velocity.x = 0;\n                this.velocity.z = 0;\n            } else {\n                horizontalVelocity.normalize().multiplyScalar(effectiveMaxSpeed);\n                this.velocity.x = horizontalVelocity.x;\n                this.velocity.z = horizontalVelocity.z;\n            }\n        }\n    }\n    applyFriction(deltaTime) {\n        if (!this.canMove) return;\n        // Apply friction to horizontal movement\n        const frictionForce = Math.pow(this.friction, deltaTime);\n        this.velocity.x *= frictionForce;\n        this.velocity.z *= frictionForce;\n        // Stop very small velocities to prevent jitter\n        if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;\n        if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;\n    }\n    applyGravity(deltaTime) {\n        if (!this.canFly) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.velocity) {\n            this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.velocity.set(0, 0, 0);\n        }\n        if (!this.acceleration) {\n            this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.acceleration.set(0, 0, 0);\n        }\n        if (!this.moveDirection) {\n            this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.moveDirection.set(0, 0, 0);\n        }\n        this.inputStrength = 0;\n        this.isGrounded = false;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        this.maxSpeed = 5.0;\n        this.friction = 0.8;\n        this.jumpForce = 20.0;\n        this.gravity = -12.5;\n        this.enabled = true;\n        // Reset debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Reset dash properties\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35;\n        this.dashDistance = 4;\n        this.dashStartPosition.set(0, 0, 0);\n        // Reset dash charges\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Reset charge properties\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35;\n        this.chargeDistance = 9;\n        this.chargeStartPosition.set(0, 0, 0);\n    }\n    clone() {\n        const clone = new Movement(this.maxSpeed, this.friction, this.jumpForce, this.gravity);\n        clone.velocity.copy(this.velocity);\n        clone.acceleration.copy(this.acceleration);\n        clone.moveDirection.copy(this.moveDirection);\n        clone.inputStrength = this.inputStrength;\n        clone.isGrounded = this.isGrounded;\n        clone.canMove = this.canMove;\n        clone.canJump = this.canJump;\n        clone.canFly = this.canFly;\n        // Clone debuff states\n        clone.isFrozen = this.isFrozen;\n        clone.frozenUntil = this.frozenUntil;\n        clone.isSlowed = this.isSlowed;\n        clone.slowedUntil = this.slowedUntil;\n        clone.movementSpeedMultiplier = this.movementSpeedMultiplier;\n        // Clone dash properties\n        clone.isDashing = this.isDashing;\n        clone.dashDirection.copy(this.dashDirection);\n        clone.dashStartTime = this.dashStartTime;\n        clone.dashDuration = this.dashDuration;\n        clone.dashDistance = this.dashDistance;\n        clone.dashStartPosition.copy(this.dashStartPosition);\n        // Clone dash charges\n        clone.maxDashCharges = this.maxDashCharges;\n        clone.dashCharges = this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownStartTime: charge.cooldownStartTime\n            }));\n        // Clone charge properties\n        clone.isCharging = this.isCharging;\n        clone.chargeDirection.copy(this.chargeDirection);\n        clone.chargeStartTime = this.chargeStartTime;\n        clone.chargeDuration = this.chargeDuration;\n        clone.chargeDistance = this.chargeDistance;\n        clone.chargeStartPosition.copy(this.chargeStartPosition);\n        return clone;\n    }\n    constructor(maxSpeed = 3.75, friction = 0.8, jumpForce = 20.0, gravity = -12.5){\n        super();\n        this.componentType = \"Movement\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.maxSpeed = maxSpeed;\n        this.friction = friction;\n        this.isGrounded = false;\n        this.jumpForce = jumpForce;\n        this.gravity = gravity;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        // Initialize debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.inputStrength = 0;\n        // Initialize dash properties\n        this.isDashing = false;\n        this.dashDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35; // 350ms dash duration (same as old implementation)\n        this.dashDistance = 4; // Increased from 3.125 for more noticeable dash\n        this.dashStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize multiple dash charges (3 charges, each with 6s cooldown)\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Initialize sword charge properties\n        this.isCharging = false;\n        this.chargeDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35; // 350ms charge duration\n        this.chargeDistance = 9; // Sword charge distance\n        this.chargeStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nMovement.componentType = \"Movement\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFBMEQ7QUFDVjtBQUNWO0FBRS9CLE1BQU1FLGlCQUFpQkQsOENBQVNBO0lBd0c5QkUsU0FBU0MsS0FBYyxFQUFRO1FBQ3BDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUNGO0lBQ3hCO0lBRU9HLFdBQVdDLE9BQWdCLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxRQUFRLENBQUNILEdBQUcsQ0FBQ0U7SUFDcEI7SUFFT0UsT0FBYTtRQUNsQixJQUFJLElBQUksQ0FBQ0MsT0FBTyxJQUFLLEtBQUksQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ3BELElBQUksQ0FBQ0osUUFBUSxDQUFDSyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1lBQ2hDLElBQUksQ0FBQ0gsVUFBVSxHQUFHO1FBQ3BCO0lBQ0Y7SUFFT0ksaUJBQWlCQyxTQUFrQixFQUFnQztZQUE5QkMsV0FBQUEsaUVBQW1CO1FBQzdELElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNILFdBQVdJLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR1A7SUFDL0M7SUFFT1EsT0FBT0MsUUFBZ0IsRUFBUTtRQUNwQyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO1FBQzVCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixjQUFjRDtJQUNqQyx5R0FBeUc7SUFDM0c7SUFFT00sS0FBS04sUUFBZ0IsRUFBdUM7WUFBckNPLGtCQUFBQSxpRUFBMEI7UUFDdEQsTUFBTU4sY0FBY0MsS0FBS0MsR0FBRztRQUM1QixJQUFJLENBQUNLLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR1IsY0FBY0Q7UUFD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QXVCLEdBQUc7UUFFL0IsSUFBSSxDQUFDbEIsYUFBYSxHQUFHLElBQUluQix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7UUFDdkMsSUFBSSxDQUFDc0IsYUFBYSxHQUFHO1FBRXJCLDZCQUE2QjtRQUM3QixJQUFJLENBQUN1QixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDTSxhQUFhLEdBQUcsSUFBSW5ELHlEQUFPQSxDQUFDLEdBQUcsR0FBRztRQUN2QyxJQUFJLENBQUNvRCxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDUyxZQUFZLEdBQUcsTUFBTSxtREFBbUQ7UUFDN0UsSUFBSSxDQUFDSSxZQUFZLEdBQUcsR0FBRyxnREFBZ0Q7UUFDdkUsSUFBSSxDQUFDWixpQkFBaUIsR0FBRyxJQUFJckQseURBQU9BLENBQUMsR0FBRyxHQUFHO1FBRTNDLHNFQUFzRTtRQUN0RSxJQUFJLENBQUM4RyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDL0QsV0FBVyxHQUFHZ0UsTUFBTUMsSUFBSSxDQUFDO1lBQUV2QyxRQUFRLElBQUksQ0FBQ3FDLGNBQWM7UUFBQyxHQUFHLElBQU87Z0JBQ3BFNUQsYUFBYTtnQkFDYkksbUJBQW1CO1lBQ3JCO1FBRUEscUNBQXFDO1FBQ3JDLElBQUksQ0FBQ2tDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJekYseURBQU9BLENBQUMsR0FBRyxHQUFHO1FBQ3pDLElBQUksQ0FBQzBGLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNHLGNBQWMsR0FBRyxNQUFNLHdCQUF3QjtRQUNwRCxJQUFJLENBQUNDLGNBQWMsR0FBRyxHQUFHLHdCQUF3QjtRQUNqRCxJQUFJLENBQUNILG1CQUFtQixHQUFHLElBQUkzRix5REFBT0EsQ0FBQyxHQUFHLEdBQUc7SUFDL0M7QUF1V0Y7QUE3Y2FFLFNBQ1lnSCxnQkFBZ0IsV0FBWSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL01vdmVtZW50LnRzPzE4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTW92ZW1lbnQgY29tcG9uZW50IGZvciB2ZWxvY2l0eSBhbmQgbW92ZW1lbnQgcHJvcGVydGllc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgTW92ZW1lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnTW92ZW1lbnQnOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnTW92ZW1lbnQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB2ZWxvY2l0eTogVmVjdG9yMztcbiAgcHVibGljIGFjY2VsZXJhdGlvbjogVmVjdG9yMztcbiAgcHVibGljIG1heFNwZWVkOiBudW1iZXI7XG4gIHB1YmxpYyBmcmljdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgaXNHcm91bmRlZDogYm9vbGVhbjtcbiAgcHVibGljIGp1bXBGb3JjZTogbnVtYmVyO1xuICBwdWJsaWMgZ3Jhdml0eTogbnVtYmVyO1xuXG4gIC8vIE1vdmVtZW50IGZsYWdzXG4gIHB1YmxpYyBjYW5Nb3ZlOiBib29sZWFuO1xuICBwdWJsaWMgY2FuSnVtcDogYm9vbGVhbjtcbiAgcHVibGljIGNhbkZseTogYm9vbGVhbjtcblxuICAvLyBEZWJ1ZmYgc3RhdGVzIGZvciBQVlBcbiAgcHVibGljIGlzRnJvemVuOiBib29sZWFuO1xuICBwdWJsaWMgZnJvemVuVW50aWw6IG51bWJlcjtcbiAgcHVibGljIGlzU2xvd2VkOiBib29sZWFuO1xuICBwdWJsaWMgc2xvd2VkVW50aWw6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWRNdWx0aXBsaWVyOiBudW1iZXI7XG5cbiAgLy8gSW5wdXQtYmFzZWQgbW92ZW1lbnRcbiAgcHVibGljIG1vdmVEaXJlY3Rpb246IFZlY3RvcjM7XG4gIHB1YmxpYyBpbnB1dFN0cmVuZ3RoOiBudW1iZXI7XG5cbiAgLy8gRGFzaC9WYXVsdCBzeXN0ZW1cbiAgcHVibGljIGlzRGFzaGluZzogYm9vbGVhbjtcbiAgcHVibGljIGRhc2hEaXJlY3Rpb246IFZlY3RvcjM7XG4gIHB1YmxpYyBkYXNoU3RhcnRUaW1lOiBudW1iZXI7XG4gIHB1YmxpYyBkYXNoRHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGRhc2hEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgZGFzaFN0YXJ0UG9zaXRpb246IFZlY3RvcjM7XG4gIFxuICAvLyBNdWx0aXBsZSBkYXNoIGNoYXJnZXMgc3lzdGVtXG4gIHB1YmxpYyBkYXNoQ2hhcmdlczogQXJyYXk8e1xuICAgIGlzQXZhaWxhYmxlOiBib29sZWFuO1xuICAgIGNvb2xkb3duU3RhcnRUaW1lOiBudW1iZXIgfCBudWxsO1xuICB9PjtcbiAgcHVibGljIG1heERhc2hDaGFyZ2VzOiBudW1iZXI7XG5cbiAgLy8gU3dvcmQgQ2hhcmdlIGFiaWxpdHkgc3lzdGVtIChzZXBhcmF0ZSBmcm9tIGRhc2hlcylcbiAgcHVibGljIGlzQ2hhcmdpbmc6IGJvb2xlYW47XG4gIHB1YmxpYyBjaGFyZ2VEaXJlY3Rpb246IFZlY3RvcjM7XG4gIHB1YmxpYyBjaGFyZ2VTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNoYXJnZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBjaGFyZ2VEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgY2hhcmdlU3RhcnRQb3NpdGlvbjogVmVjdG9yMztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtYXhTcGVlZDogbnVtYmVyID0gMy43NSxcbiAgICBmcmljdGlvbjogbnVtYmVyID0gMC44LFxuICAgIGp1bXBGb3JjZTogbnVtYmVyID0gMjAuMCxcbiAgICBncmF2aXR5OiBudW1iZXIgPSAtMTIuNVxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMubWF4U3BlZWQgPSBtYXhTcGVlZDtcbiAgICB0aGlzLmZyaWN0aW9uID0gZnJpY3Rpb247XG4gICAgdGhpcy5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5qdW1wRm9yY2UgPSBqdW1wRm9yY2U7XG4gICAgdGhpcy5ncmF2aXR5ID0gZ3Jhdml0eTtcbiAgICBcbiAgICB0aGlzLmNhbk1vdmUgPSB0cnVlO1xuICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgdGhpcy5jYW5GbHkgPSBmYWxzZTtcblxuICAgIC8vIEluaXRpYWxpemUgZGVidWZmIHN0YXRlc1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyb3plblVudGlsID0gMDtcbiAgICB0aGlzLmlzU2xvd2VkID0gZmFsc2U7XG4gICAgdGhpcy5zbG93ZWRVbnRpbCA9IDA7XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDEuMDtcbiAgICBcbiAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkYXNoIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGFzaERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kYXNoRHVyYXRpb24gPSAwLjM1OyAvLyAzNTBtcyBkYXNoIGR1cmF0aW9uIChzYW1lIGFzIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICB0aGlzLmRhc2hEaXN0YW5jZSA9IDQ7IC8vIEluY3JlYXNlZCBmcm9tIDMuMTI1IGZvciBtb3JlIG5vdGljZWFibGUgZGFzaFxuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIG11bHRpcGxlIGRhc2ggY2hhcmdlcyAoMyBjaGFyZ2VzLCBlYWNoIHdpdGggNnMgY29vbGRvd24pXG4gICAgdGhpcy5tYXhEYXNoQ2hhcmdlcyA9IDM7XG4gICAgdGhpcy5kYXNoQ2hhcmdlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMubWF4RGFzaENoYXJnZXMgfSwgKCkgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IG51bGxcbiAgICB9KSk7XG5cbiAgICAvLyBJbml0aWFsaXplIHN3b3JkIGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5jaGFyZ2VEdXJhdGlvbiA9IDAuMzU7IC8vIDM1MG1zIGNoYXJnZSBkdXJhdGlvblxuICAgIHRoaXMuY2hhcmdlRGlzdGFuY2UgPSA5OyAvLyBTd29yZCBjaGFyZ2UgZGlzdGFuY2VcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRGb3JjZShmb3JjZTogVmVjdG9yMyk6IHZvaWQge1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uLmFkZChmb3JjZSk7XG4gIH1cblxuICBwdWJsaWMgYWRkSW1wdWxzZShpbXB1bHNlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5hZGQoaW1wdWxzZSk7XG4gIH1cblxuICBwdWJsaWMganVtcCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jYW5KdW1wICYmICh0aGlzLmlzR3JvdW5kZWQgfHwgdGhpcy5jYW5GbHkpKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgPSB0aGlzLmp1bXBGb3JjZTtcbiAgICAgIHRoaXMuaXNHcm91bmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRNb3ZlRGlyZWN0aW9uKGRpcmVjdGlvbjogVmVjdG9yMywgc3RyZW5ndGg6IG51bWJlciA9IDEuMCk6IHZvaWQge1xuICAgIHRoaXMubW92ZURpcmVjdGlvbi5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCk7XG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc3RyZW5ndGgpKTtcbiAgfVxuXG4gIHB1YmxpYyBmcmVlemUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzRnJvemVuID0gdHJ1ZTtcbiAgICB0aGlzLmZyb3plblVudGlsID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbjtcbiAgICAvLyBjb25zb2xlLmxvZyhg8J+niiBQbGF5ZXIgZnJvemVuIGZvciAke2R1cmF0aW9ufW1zIHVudGlsICR7dGhpcy5mcm96ZW5VbnRpbH0gKGN1cnJlbnQ6ICR7Y3VycmVudFRpbWV9KWApO1xuICB9XG5cbiAgcHVibGljIHNsb3coZHVyYXRpb246IG51bWJlciwgc3BlZWRNdWx0aXBsaWVyOiBudW1iZXIgPSAwLjUpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5pc1Nsb3dlZCA9IHRydWU7XG4gICAgdGhpcy5zbG93ZWRVbnRpbCA9IGN1cnJlbnRUaW1lICsgZHVyYXRpb247XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IHNwZWVkTXVsdGlwbGllcjtcbiAgICAvLyBjb25zb2xlLmxvZyhg8J+QjCBQbGF5ZXIgc2xvd2VkIHRvICR7c3BlZWRNdWx0aXBsaWVyICogMTAwfSUgc3BlZWQgZm9yICR7ZHVyYXRpb259bXMgdW50aWwgJHt0aGlzLnNsb3dlZFVudGlsfWApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZURlYnVmZnMoKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIENoZWNrIGZyb3plbiBzdGF0ZVxuICAgIGlmICh0aGlzLmlzRnJvemVuICYmIGN1cnJlbnRUaW1lID49IHRoaXMuZnJvemVuVW50aWwpIHtcbiAgICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgICAgY29uc29sZS5sb2coJ/Cfp4ogUGxheWVyIHVuZnJvemVuJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHNsb3dlZCBzdGF0ZVxuICAgIGlmICh0aGlzLmlzU2xvd2VkICYmIGN1cnJlbnRUaW1lID49IHRoaXMuc2xvd2VkVW50aWwpIHtcbiAgICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2xvd2VkVW50aWwgPSAwO1xuICAgICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDEuMDtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5CMIFBsYXllciBubyBsb25nZXIgc2xvd2VkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldEVmZmVjdGl2ZU1heFNwZWVkKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuaXNGcm96ZW4pIHtcbiAgICAgIHJldHVybiAwOyAvLyBDb21wbGV0ZWx5IGZyb3plblxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXhTcGVlZCAqIHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXI7XG4gIH1cblxuICBwdWJsaWMgc3RhcnREYXNoKGRpcmVjdGlvbjogVmVjdG9yMywgY3VycmVudFBvc2l0aW9uOiBWZWN0b3IzLCBjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBkYXNoaW5nXG4gICAgaWYgKHRoaXMuaXNEYXNoaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRmluZCBmaXJzdCBhdmFpbGFibGUgY2hhcmdlXG4gICAgY29uc3QgYXZhaWxhYmxlQ2hhcmdlSW5kZXggPSB0aGlzLmRhc2hDaGFyZ2VzLmZpbmRJbmRleChjaGFyZ2UgPT4gY2hhcmdlLmlzQXZhaWxhYmxlKTtcbiAgICBpZiAoYXZhaWxhYmxlQ2hhcmdlSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIGNoYXJnZXMgYXZhaWxhYmxlXG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGRhc2hcbiAgICB0aGlzLmlzRGFzaGluZyA9IHRydWU7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLmRhc2hTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLmNvcHkoY3VycmVudFBvc2l0aW9uKTtcblxuICAgIC8vIENvbnN1bWUgdGhlIGNoYXJnZVxuICAgIHRoaXMuZGFzaENoYXJnZXNbYXZhaWxhYmxlQ2hhcmdlSW5kZXhdLmlzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uY29vbGRvd25TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcblxuICAgIC8vIFNldCBjb29sZG93biB0aW1lciBmb3IgdGhpcyBzcGVjaWZpYyBjaGFyZ2UgKDYgc2Vjb25kcylcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGFzaENoYXJnZXNbYXZhaWxhYmxlQ2hhcmdlSW5kZXhdLmlzQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGFzaENoYXJnZXNbYXZhaWxhYmxlQ2hhcmdlSW5kZXhdLmNvb2xkb3duU3RhcnRUaW1lID0gbnVsbDtcbiAgICB9LCA2MDAwKTsgLy8gNiBzZWNvbmQgY29vbGRvd25cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZURhc2goY3VycmVudFRpbWU6IG51bWJlcik6IHsgaXNDb21wbGV0ZTogYm9vbGVhbjsgbmV3UG9zaXRpb246IFZlY3RvcjMgfCBudWxsIH0ge1xuICAgIGlmICghdGhpcy5pc0Rhc2hpbmcpIHtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbjogbnVsbCB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuZGFzaFN0YXJ0VGltZTtcbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyB0aGlzLmRhc2hEdXJhdGlvbiwgMSk7XG5cbiAgICBpZiAocHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgLy8gRGFzaCBjb21wbGV0ZVxuICAgICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGZpbmFsUG9zaXRpb24gPSB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgLmFkZCh0aGlzLmRhc2hEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmRhc2hEaXN0YW5jZSkpO1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogdHJ1ZSwgbmV3UG9zaXRpb246IGZpbmFsUG9zaXRpb24gfTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgY3VycmVudCBwb3NpdGlvbiB1c2luZyBlYXNpbmcgKGVhc2Utb3V0IHF1YWQsIHNhbWUgYXMgb2xkIGltcGxlbWVudGF0aW9uKVxuICAgIGNvbnN0IGVhc2VPdXRRdWFkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMik7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5kYXNoRGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGhpcy5kYXNoRGlzdGFuY2UgKiBlYXNlT3V0UXVhZCk7XG4gICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLmNsb25lKCkuYWRkKGRpc3BsYWNlbWVudCk7XG5cbiAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb24gfTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxEYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmRhc2hTdGFydFRpbWUgPSAwO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubW92ZURpcmVjdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRTcGVlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5Lmxlbmd0aCgpO1xuICB9XG5cbiAgcHVibGljIGdldEhvcml6b250YWxTcGVlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy52ZWxvY2l0eS54ICogdGhpcy52ZWxvY2l0eS54ICsgdGhpcy52ZWxvY2l0eS56ICogdGhpcy52ZWxvY2l0eS56KTtcbiAgfVxuXG4gIHB1YmxpYyBpc01vdmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTcGVlZCgpID4gMC4wMTtcbiAgfVxuXG4gIHB1YmxpYyBpc01vdmluZ0hvcml6b250YWxseSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5nZXRIb3Jpem9udGFsU3BlZWQoKSA+IDAuMDE7XG4gIH1cblxuICBwdWJsaWMgaXNGYWxsaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5LnkgPCAtMC4xO1xuICB9XG5cbiAgcHVibGljIGlzUmlzaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5LnkgPiAwLjE7XG4gIH1cblxuICBwdWJsaWMgZ2V0QXZhaWxhYmxlRGFzaENoYXJnZXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5kYXNoQ2hhcmdlcy5maWx0ZXIoY2hhcmdlID0+IGNoYXJnZS5pc0F2YWlsYWJsZSkubGVuZ3RoO1xuICB9XG5cbiAgcHVibGljIGdldERhc2hDaGFyZ2VTdGF0dXMoKTogQXJyYXk8eyBpc0F2YWlsYWJsZTogYm9vbGVhbjsgY29vbGRvd25SZW1haW5pbmc6IG51bWJlciB9PiB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICByZXR1cm4gdGhpcy5kYXNoQ2hhcmdlcy5tYXAoY2hhcmdlID0+ICh7XG4gICAgICBpc0F2YWlsYWJsZTogY2hhcmdlLmlzQXZhaWxhYmxlLFxuICAgICAgY29vbGRvd25SZW1haW5pbmc6IGNoYXJnZS5jb29sZG93blN0YXJ0VGltZSBcbiAgICAgICAgPyBNYXRoLm1heCgwLCA2IC0gKGN1cnJlbnRUaW1lIC0gY2hhcmdlLmNvb2xkb3duU3RhcnRUaW1lKSlcbiAgICAgICAgOiAwXG4gICAgfSkpO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0Q2hhcmdlKGRpcmVjdGlvbjogVmVjdG9yMywgY3VycmVudFBvc2l0aW9uOiBWZWN0b3IzLCBjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBjaGFyZ2luZyBvciBkYXNoaW5nXG4gICAgaWYgKHRoaXMuaXNDaGFyZ2luZyB8fCB0aGlzLmlzRGFzaGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IHRoZSBjaGFyZ2VcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuY2hhcmdlRGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbi5jb3B5KGN1cnJlbnRQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVDaGFyZ2UoY3VycmVudFRpbWU6IG51bWJlcik6IHsgaXNDb21wbGV0ZTogYm9vbGVhbjsgbmV3UG9zaXRpb246IFZlY3RvcjMgfCBudWxsIH0ge1xuICAgIGlmICghdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb246IG51bGwgfTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmNoYXJnZVN0YXJ0VGltZTtcbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKGVsYXBzZWQgLyB0aGlzLmNoYXJnZUR1cmF0aW9uLCAxKTtcblxuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAvLyBDaGFyZ2UgY29tcGxldGVcbiAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgY29uc3QgZmluYWxQb3NpdGlvbiA9IHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbi5jbG9uZSgpXG4gICAgICAgIC5hZGQodGhpcy5jaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmNoYXJnZURpc3RhbmNlKSk7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiB0cnVlLCBuZXdQb3NpdGlvbjogZmluYWxQb3NpdGlvbiB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IHBvc2l0aW9uIHVzaW5nIGVhc2luZyAoZWFzZS1vdXQgcXVhZClcbiAgICBjb25zdCBlYXNlT3V0UXVhZCA9IDEgLSBNYXRoLnBvdygxIC0gcHJvZ3Jlc3MsIDIpO1xuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuY2hhcmdlRGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGhpcy5jaGFyZ2VEaXN0YW5jZSAqIGVhc2VPdXRRdWFkKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbi5jbG9uZSgpLmFkZChkaXNwbGFjZW1lbnQpO1xuXG4gICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uIH07XG4gIH1cblxuICBwdWJsaWMgY2FuY2VsQ2hhcmdlKCk6IHZvaWQge1xuICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcmdlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0VGltZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgY2xhbXBWZWxvY2l0eSgpOiB2b2lkIHtcbiAgICAvLyBHZXQgZWZmZWN0aXZlIG1heCBzcGVlZCAoY29uc2lkZXJpbmcgZGVidWZmcylcbiAgICBjb25zdCBlZmZlY3RpdmVNYXhTcGVlZCA9IHRoaXMuZ2V0RWZmZWN0aXZlTWF4U3BlZWQoKTtcbiAgICBcbiAgICAvLyBDbGFtcCBob3Jpem9udGFsIHZlbG9jaXR5IHRvIGVmZmVjdGl2ZSBtYXggc3BlZWRcbiAgICBjb25zdCBob3Jpem9udGFsVmVsb2NpdHkgPSBuZXcgVmVjdG9yMyh0aGlzLnZlbG9jaXR5LngsIDAsIHRoaXMudmVsb2NpdHkueik7XG4gICAgY29uc3QgaG9yaXpvbnRhbFNwZWVkID0gaG9yaXpvbnRhbFZlbG9jaXR5Lmxlbmd0aCgpO1xuICAgIFxuICAgIGlmIChob3Jpem9udGFsU3BlZWQgPiBlZmZlY3RpdmVNYXhTcGVlZCkge1xuICAgICAgaWYgKGVmZmVjdGl2ZU1heFNwZWVkID09PSAwKSB7XG4gICAgICAgIC8vIENvbXBsZXRlbHkgZnJvemVuIC0gc3RvcCBhbGwgaG9yaXpvbnRhbCBtb3ZlbWVudFxuICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSAwO1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnogPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9yaXpvbnRhbFZlbG9jaXR5Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGVmZmVjdGl2ZU1heFNwZWVkKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gaG9yaXpvbnRhbFZlbG9jaXR5Lng7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueiA9IGhvcml6b250YWxWZWxvY2l0eS56O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhcHBseUZyaWN0aW9uKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNhbk1vdmUpIHJldHVybjtcblxuICAgIC8vIEFwcGx5IGZyaWN0aW9uIHRvIGhvcml6b250YWwgbW92ZW1lbnRcbiAgICBjb25zdCBmcmljdGlvbkZvcmNlID0gTWF0aC5wb3codGhpcy5mcmljdGlvbiwgZGVsdGFUaW1lKTtcbiAgICB0aGlzLnZlbG9jaXR5LnggKj0gZnJpY3Rpb25Gb3JjZTtcbiAgICB0aGlzLnZlbG9jaXR5LnogKj0gZnJpY3Rpb25Gb3JjZTtcblxuICAgIC8vIFN0b3AgdmVyeSBzbWFsbCB2ZWxvY2l0aWVzIHRvIHByZXZlbnQgaml0dGVyXG4gICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueCkgPCAwLjAxKSB0aGlzLnZlbG9jaXR5LnggPSAwO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnZlbG9jaXR5LnopIDwgMC4wMSkgdGhpcy52ZWxvY2l0eS56ID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBhcHBseUdyYXZpdHkoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuRmx5KSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgKz0gdGhpcy5ncmF2aXR5ICogZGVsdGFUaW1lO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICAvLyBFbnN1cmUgVmVjdG9yMyBvYmplY3RzIGFyZSBwcm9wZXJseSBpbml0aWFsaXplZFxuICAgIGlmICghdGhpcy52ZWxvY2l0eSkge1xuICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLmFjY2VsZXJhdGlvbikge1xuICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2NlbGVyYXRpb24uc2V0KDAsIDAsIDApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXRoaXMubW92ZURpcmVjdGlvbikge1xuICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubW92ZURpcmVjdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuaW5wdXRTdHJlbmd0aCA9IDA7XG4gICAgdGhpcy5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW5Nb3ZlID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkp1bXAgPSB0cnVlO1xuICAgIHRoaXMuY2FuRmx5ID0gZmFsc2U7XG4gICAgdGhpcy5tYXhTcGVlZCA9IDUuMDtcbiAgICB0aGlzLmZyaWN0aW9uID0gMC44O1xuICAgIHRoaXMuanVtcEZvcmNlID0gMjAuMDtcbiAgICB0aGlzLmdyYXZpdHkgPSAtMTIuNTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgLy8gUmVzZXQgZGVidWZmIHN0YXRlc1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyb3plblVudGlsID0gMDtcbiAgICB0aGlzLmlzU2xvd2VkID0gZmFsc2U7XG4gICAgdGhpcy5zbG93ZWRVbnRpbCA9IDA7XG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IDEuMDtcblxuICAgIC8vIFJlc2V0IGRhc2ggcHJvcGVydGllc1xuICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmRhc2hTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZGFzaER1cmF0aW9uID0gMC4zNTtcbiAgICB0aGlzLmRhc2hEaXN0YW5jZSA9IDQ7XG4gICAgdGhpcy5kYXNoU3RhcnRQb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgXG4gICAgLy8gUmVzZXQgZGFzaCBjaGFyZ2VzXG4gICAgdGhpcy5tYXhEYXNoQ2hhcmdlcyA9IDM7XG4gICAgdGhpcy5kYXNoQ2hhcmdlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRoaXMubWF4RGFzaENoYXJnZXMgfSwgKCkgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IG51bGxcbiAgICB9KSk7XG5cbiAgICAvLyBSZXNldCBjaGFyZ2UgcHJvcGVydGllc1xuICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY2hhcmdlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5jaGFyZ2VEdXJhdGlvbiA9IDAuMzU7XG4gICAgdGhpcy5jaGFyZ2VEaXN0YW5jZSA9IDk7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBNb3ZlbWVudCB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgTW92ZW1lbnQodGhpcy5tYXhTcGVlZCwgdGhpcy5mcmljdGlvbiwgdGhpcy5qdW1wRm9yY2UsIHRoaXMuZ3Jhdml0eSk7XG4gICAgY2xvbmUudmVsb2NpdHkuY29weSh0aGlzLnZlbG9jaXR5KTtcbiAgICBjbG9uZS5hY2NlbGVyYXRpb24uY29weSh0aGlzLmFjY2VsZXJhdGlvbik7XG4gICAgY2xvbmUubW92ZURpcmVjdGlvbi5jb3B5KHRoaXMubW92ZURpcmVjdGlvbik7XG4gICAgY2xvbmUuaW5wdXRTdHJlbmd0aCA9IHRoaXMuaW5wdXRTdHJlbmd0aDtcbiAgICBjbG9uZS5pc0dyb3VuZGVkID0gdGhpcy5pc0dyb3VuZGVkO1xuICAgIGNsb25lLmNhbk1vdmUgPSB0aGlzLmNhbk1vdmU7XG4gICAgY2xvbmUuY2FuSnVtcCA9IHRoaXMuY2FuSnVtcDtcbiAgICBjbG9uZS5jYW5GbHkgPSB0aGlzLmNhbkZseTtcblxuICAgIC8vIENsb25lIGRlYnVmZiBzdGF0ZXNcbiAgICBjbG9uZS5pc0Zyb3plbiA9IHRoaXMuaXNGcm96ZW47XG4gICAgY2xvbmUuZnJvemVuVW50aWwgPSB0aGlzLmZyb3plblVudGlsO1xuICAgIGNsb25lLmlzU2xvd2VkID0gdGhpcy5pc1Nsb3dlZDtcbiAgICBjbG9uZS5zbG93ZWRVbnRpbCA9IHRoaXMuc2xvd2VkVW50aWw7XG4gICAgY2xvbmUubW92ZW1lbnRTcGVlZE11bHRpcGxpZXIgPSB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyO1xuXG4gICAgLy8gQ2xvbmUgZGFzaCBwcm9wZXJ0aWVzXG4gICAgY2xvbmUuaXNEYXNoaW5nID0gdGhpcy5pc0Rhc2hpbmc7XG4gICAgY2xvbmUuZGFzaERpcmVjdGlvbi5jb3B5KHRoaXMuZGFzaERpcmVjdGlvbik7XG4gICAgY2xvbmUuZGFzaFN0YXJ0VGltZSA9IHRoaXMuZGFzaFN0YXJ0VGltZTtcbiAgICBjbG9uZS5kYXNoRHVyYXRpb24gPSB0aGlzLmRhc2hEdXJhdGlvbjtcbiAgICBjbG9uZS5kYXNoRGlzdGFuY2UgPSB0aGlzLmRhc2hEaXN0YW5jZTtcbiAgICBjbG9uZS5kYXNoU3RhcnRQb3NpdGlvbi5jb3B5KHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24pO1xuICAgIFxuICAgIC8vIENsb25lIGRhc2ggY2hhcmdlc1xuICAgIGNsb25lLm1heERhc2hDaGFyZ2VzID0gdGhpcy5tYXhEYXNoQ2hhcmdlcztcbiAgICBjbG9uZS5kYXNoQ2hhcmdlcyA9IHRoaXMuZGFzaENoYXJnZXMubWFwKGNoYXJnZSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IGNoYXJnZS5pc0F2YWlsYWJsZSxcbiAgICAgIGNvb2xkb3duU3RhcnRUaW1lOiBjaGFyZ2UuY29vbGRvd25TdGFydFRpbWVcbiAgICB9KSk7XG5cbiAgICAvLyBDbG9uZSBjaGFyZ2UgcHJvcGVydGllc1xuICAgIGNsb25lLmlzQ2hhcmdpbmcgPSB0aGlzLmlzQ2hhcmdpbmc7XG4gICAgY2xvbmUuY2hhcmdlRGlyZWN0aW9uLmNvcHkodGhpcy5jaGFyZ2VEaXJlY3Rpb24pO1xuICAgIGNsb25lLmNoYXJnZVN0YXJ0VGltZSA9IHRoaXMuY2hhcmdlU3RhcnRUaW1lO1xuICAgIGNsb25lLmNoYXJnZUR1cmF0aW9uID0gdGhpcy5jaGFyZ2VEdXJhdGlvbjtcbiAgICBjbG9uZS5jaGFyZ2VEaXN0YW5jZSA9IHRoaXMuY2hhcmdlRGlzdGFuY2U7XG4gICAgY2xvbmUuY2hhcmdlU3RhcnRQb3NpdGlvbi5jb3B5KHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbik7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29tcG9uZW50IiwiTW92ZW1lbnQiLCJhZGRGb3JjZSIsImZvcmNlIiwiYWNjZWxlcmF0aW9uIiwiYWRkIiwiYWRkSW1wdWxzZSIsImltcHVsc2UiLCJ2ZWxvY2l0eSIsImp1bXAiLCJjYW5KdW1wIiwiaXNHcm91bmRlZCIsImNhbkZseSIsInkiLCJqdW1wRm9yY2UiLCJzZXRNb3ZlRGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwic3RyZW5ndGgiLCJtb3ZlRGlyZWN0aW9uIiwiY29weSIsIm5vcm1hbGl6ZSIsImlucHV0U3RyZW5ndGgiLCJNYXRoIiwibWF4IiwibWluIiwiZnJlZXplIiwiZHVyYXRpb24iLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJpc0Zyb3plbiIsImZyb3plblVudGlsIiwic2xvdyIsInNwZWVkTXVsdGlwbGllciIsImlzU2xvd2VkIiwic2xvd2VkVW50aWwiLCJtb3ZlbWVudFNwZWVkTXVsdGlwbGllciIsInVwZGF0ZURlYnVmZnMiLCJjb25zb2xlIiwibG9nIiwiZ2V0RWZmZWN0aXZlTWF4U3BlZWQiLCJtYXhTcGVlZCIsInN0YXJ0RGFzaCIsImN1cnJlbnRQb3NpdGlvbiIsImlzRGFzaGluZyIsImF2YWlsYWJsZUNoYXJnZUluZGV4IiwiZGFzaENoYXJnZXMiLCJmaW5kSW5kZXgiLCJjaGFyZ2UiLCJpc0F2YWlsYWJsZSIsImRhc2hEaXJlY3Rpb24iLCJkYXNoU3RhcnRUaW1lIiwiZGFzaFN0YXJ0UG9zaXRpb24iLCJjb29sZG93blN0YXJ0VGltZSIsInNldFRpbWVvdXQiLCJ1cGRhdGVEYXNoIiwiaXNDb21wbGV0ZSIsIm5ld1Bvc2l0aW9uIiwiZWxhcHNlZCIsInByb2dyZXNzIiwiZGFzaER1cmF0aW9uIiwiZmluYWxQb3NpdGlvbiIsImNsb25lIiwibXVsdGlwbHlTY2FsYXIiLCJkYXNoRGlzdGFuY2UiLCJlYXNlT3V0UXVhZCIsInBvdyIsImRpc3BsYWNlbWVudCIsImNhbmNlbERhc2giLCJzZXQiLCJzdG9wIiwiZ2V0U3BlZWQiLCJsZW5ndGgiLCJnZXRIb3Jpem9udGFsU3BlZWQiLCJzcXJ0IiwieCIsInoiLCJpc01vdmluZyIsImlzTW92aW5nSG9yaXpvbnRhbGx5IiwiaXNGYWxsaW5nIiwiaXNSaXNpbmciLCJnZXRBdmFpbGFibGVEYXNoQ2hhcmdlcyIsImZpbHRlciIsImdldERhc2hDaGFyZ2VTdGF0dXMiLCJtYXAiLCJjb29sZG93blJlbWFpbmluZyIsInN0YXJ0Q2hhcmdlIiwiaXNDaGFyZ2luZyIsImNoYXJnZURpcmVjdGlvbiIsImNoYXJnZVN0YXJ0VGltZSIsImNoYXJnZVN0YXJ0UG9zaXRpb24iLCJ1cGRhdGVDaGFyZ2UiLCJjaGFyZ2VEdXJhdGlvbiIsImNoYXJnZURpc3RhbmNlIiwiY2FuY2VsQ2hhcmdlIiwiY2xhbXBWZWxvY2l0eSIsImVmZmVjdGl2ZU1heFNwZWVkIiwiaG9yaXpvbnRhbFZlbG9jaXR5IiwiaG9yaXpvbnRhbFNwZWVkIiwiYXBwbHlGcmljdGlvbiIsImRlbHRhVGltZSIsImNhbk1vdmUiLCJmcmljdGlvbkZvcmNlIiwiZnJpY3Rpb24iLCJhYnMiLCJhcHBseUdyYXZpdHkiLCJncmF2aXR5IiwicmVzZXQiLCJlbmFibGVkIiwibWF4RGFzaENoYXJnZXMiLCJBcnJheSIsImZyb20iLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Movement.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Projectile.ts":
/*!******************************************!*\
  !*** ./src/ecs/components/Projectile.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: function() { return /* binding */ Projectile; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Projectile component for bullets, spells, and other projectiles\n\n\nclass Projectile extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setDirection(direction) {\n        this.velocity.copy(direction).normalize().multiplyScalar(this.speed);\n    }\n    addGravity(gravity) {\n        this.gravity = gravity;\n    }\n    setPiercing(piercing) {\n        this.piercing = piercing;\n    }\n    setExplosive(radius) {\n        this.explosionRadius = radius;\n    }\n    setBouncing(maxBounces) {\n        this.maxBounces = maxBounces;\n    }\n    setMaxDistance(maxDistance) {\n        this.maxDistance = maxDistance;\n    }\n    setStartPosition(position) {\n        this.startPosition.copy(position);\n    }\n    hasHitTarget(entityId) {\n        return this.hitTargets.has(entityId);\n    }\n    addHitTarget(entityId) {\n        this.hitTargets.add(entityId);\n    }\n    canHitTarget(entityId) {\n        // Can't hit owner\n        if (entityId === this.owner) return false;\n        // If piercing, can hit targets multiple times\n        if (this.piercing) return true;\n        // Otherwise, can only hit each target once\n        return !this.hasHitTarget(entityId);\n    }\n    isExpired() {\n        return this.lifetime >= this.maxLifetime || this.distanceTraveled >= this.maxDistance;\n    }\n    canBounce() {\n        return this.bounces < this.maxBounces;\n    }\n    bounce(normal) {\n        if (!this.canBounce()) return;\n        // Reflect velocity off the surface normal\n        const reflection = this.velocity.clone().reflect(normal);\n        this.velocity.copy(reflection);\n        this.bounces++;\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        // Track distance traveled\n        const distanceThisFrame = this.velocity.length() * deltaTime;\n        this.distanceTraveled += distanceThisFrame;\n        // Apply gravity if enabled\n        if (this.gravity !== 0) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    getPosition(transform) {\n        return transform.clone();\n    }\n    getPredictedPosition(transform, deltaTime) {\n        const predicted = transform.clone();\n        predicted.add(this.velocity.clone().multiplyScalar(deltaTime));\n        return predicted;\n    }\n    reset() {\n        this.velocity.set(0, 0, 0);\n        this.speed = 20;\n        this.damage = 10;\n        this.lifetime = 0;\n        this.maxLifetime = 5;\n        this.piercing = false;\n        this.hitTargets.clear();\n        this.explosionRadius = 0;\n        this.gravity = 0;\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = -1;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity;\n        this.startPosition.set(0, 0, 0);\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Projectile(this.speed, this.damage, this.maxLifetime, this.owner);\n        clone.velocity.copy(this.velocity);\n        clone.lifetime = this.lifetime;\n        clone.piercing = this.piercing;\n        clone.hitTargets = new Set(this.hitTargets);\n        clone.explosionRadius = this.explosionRadius;\n        clone.gravity = this.gravity;\n        clone.bounces = this.bounces;\n        clone.maxBounces = this.maxBounces;\n        clone.distanceTraveled = this.distanceTraveled;\n        clone.maxDistance = this.maxDistance;\n        clone.startPosition.copy(this.startPosition);\n        return clone;\n    }\n    constructor(speed = 20, damage = 10, maxLifetime = 5, owner = -1){\n        super();\n        this.componentType = \"Projectile\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.speed = speed;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = maxLifetime;\n        this.piercing = false;\n        this.hitTargets = new Set();\n        this.explosionRadius = 0;\n        this.gravity = 0; // Most projectiles ignore gravity\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = owner;\n        this.distanceTraveled = 0;\n        this.maxDistance = Infinity; // Default to no distance limit\n        this.startPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nProjectile.componentType = \"Projectile\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRS9CLE1BQU1FLG1CQUFtQkQsOENBQVNBO0lBNENoQ0UsYUFBYUMsU0FBa0IsRUFBUTtRQUM1QyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixXQUFXRyxTQUFTLEdBQUdDLGNBQWMsQ0FBQyxJQUFJLENBQUNDLEtBQUs7SUFDckU7SUFFT0MsV0FBV0MsT0FBZSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVPQyxZQUFZQyxRQUFpQixFQUFRO1FBQzFDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNsQjtJQUVPQyxhQUFhQyxNQUFjLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO0lBQ3pCO0lBRU9FLFlBQVlDLFVBQWtCLEVBQVE7UUFDM0MsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBRU9DLGVBQWVDLFdBQW1CLEVBQVE7UUFDL0MsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO0lBQ3JCO0lBRU9DLGlCQUFpQkMsUUFBaUIsRUFBUTtRQUMvQyxJQUFJLENBQUNDLGFBQWEsQ0FBQ2pCLElBQUksQ0FBQ2dCO0lBQzFCO0lBRU9FLGFBQWFDLFFBQWdCLEVBQVc7UUFDN0MsT0FBTyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDRjtJQUM3QjtJQUVPRyxhQUFhSCxRQUFnQixFQUFRO1FBQzFDLElBQUksQ0FBQ0MsVUFBVSxDQUFDRyxHQUFHLENBQUNKO0lBQ3RCO0lBRU9LLGFBQWFMLFFBQWdCLEVBQVc7UUFDN0Msa0JBQWtCO1FBQ2xCLElBQUlBLGFBQWEsSUFBSSxDQUFDTSxLQUFLLEVBQUUsT0FBTztRQUVwQyw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUNsQixRQUFRLEVBQUUsT0FBTztRQUUxQiwyQ0FBMkM7UUFD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MEQsZ0JBQWdCLGFBQWMsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzPzcwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvamVjdGlsZSBjb21wb25lbnQgZm9yIGJ1bGxldHMsIHNwZWxscywgYW5kIG90aGVyIHByb2plY3RpbGVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0aWxlIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Byb2plY3RpbGUnOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnUHJvamVjdGlsZSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgc3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZTogbnVtYmVyO1xuICBwdWJsaWMgbGlmZXRpbWU6IG51bWJlcjtcbiAgcHVibGljIG1heExpZmV0aW1lOiBudW1iZXI7XG4gIHB1YmxpYyBwaWVyY2luZzogYm9vbGVhbjtcbiAgcHVibGljIGhpdFRhcmdldHM6IFNldDxudW1iZXI+OyAvLyBFbnRpdHkgSURzIHRoYXQgaGF2ZSBiZWVuIGhpdFxuICBwdWJsaWMgZXhwbG9zaW9uUmFkaXVzOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG4gIHB1YmxpYyBib3VuY2VzOiBudW1iZXI7XG4gIHB1YmxpYyBtYXhCb3VuY2VzOiBudW1iZXI7XG4gIHB1YmxpYyBvd25lcjogbnVtYmVyOyAvLyBFbnRpdHkgSUQgb2YgdGhlIG93bmVyXG4gIHB1YmxpYyBkaXN0YW5jZVRyYXZlbGVkOiBudW1iZXI7IC8vIFRyYWNrIGRpc3RhbmNlIHRyYXZlbGVkXG4gIHB1YmxpYyBtYXhEaXN0YW5jZTogbnVtYmVyOyAvLyBNYXhpbXVtIGRpc3RhbmNlIGJlZm9yZSBleHBpcmluZ1xuICBwdWJsaWMgc3RhcnRQb3NpdGlvbjogVmVjdG9yMzsgLy8gU3RhcnRpbmcgcG9zaXRpb24gZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3BlZWQ6IG51bWJlciA9IDIwLFxuICAgIGRhbWFnZTogbnVtYmVyID0gMTAsXG4gICAgbWF4TGlmZXRpbWU6IG51bWJlciA9IDUsXG4gICAgb3duZXI6IG51bWJlciA9IC0xXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuc3BlZWQgPSBzcGVlZDtcbiAgICB0aGlzLmRhbWFnZSA9IGRhbWFnZTtcbiAgICB0aGlzLmxpZmV0aW1lID0gMDtcbiAgICB0aGlzLm1heExpZmV0aW1lID0gbWF4TGlmZXRpbWU7XG4gICAgdGhpcy5waWVyY2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaGl0VGFyZ2V0cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV4cGxvc2lvblJhZGl1cyA9IDA7XG4gICAgdGhpcy5ncmF2aXR5ID0gMDsgLy8gTW9zdCBwcm9qZWN0aWxlcyBpZ25vcmUgZ3Jhdml0eVxuICAgIHRoaXMuYm91bmNlcyA9IDA7XG4gICAgdGhpcy5tYXhCb3VuY2VzID0gMDtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGVkID0gMDtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7IC8vIERlZmF1bHQgdG8gbm8gZGlzdGFuY2UgbGltaXRcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zcGVlZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkR3Jhdml0eShncmF2aXR5OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICB9XG5cbiAgcHVibGljIHNldFBpZXJjaW5nKHBpZXJjaW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5waWVyY2luZyA9IHBpZXJjaW5nO1xuICB9XG5cbiAgcHVibGljIHNldEV4cGxvc2l2ZShyYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gcmFkaXVzO1xuICB9XG5cbiAgcHVibGljIHNldEJvdW5jaW5nKG1heEJvdW5jZXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IG1heEJvdW5jZXM7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF4RGlzdGFuY2UobWF4RGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTdGFydFBvc2l0aW9uKHBvc2l0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICB9XG5cbiAgcHVibGljIGhhc0hpdFRhcmdldChlbnRpdHlJZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGl0VGFyZ2V0cy5oYXMoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGFkZEhpdFRhcmdldChlbnRpdHlJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5oaXRUYXJnZXRzLmFkZChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgY2FuSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDYW4ndCBoaXQgb3duZXJcbiAgICBpZiAoZW50aXR5SWQgPT09IHRoaXMub3duZXIpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBJZiBwaWVyY2luZywgY2FuIGhpdCB0YXJnZXRzIG11bHRpcGxlIHRpbWVzXG4gICAgaWYgKHRoaXMucGllcmNpbmcpIHJldHVybiB0cnVlO1xuICAgIFxuICAgIC8vIE90aGVyd2lzZSwgY2FuIG9ubHkgaGl0IGVhY2ggdGFyZ2V0IG9uY2VcbiAgICByZXR1cm4gIXRoaXMuaGFzSGl0VGFyZ2V0KGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0V4cGlyZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGlmZXRpbWUgPj0gdGhpcy5tYXhMaWZldGltZSB8fCB0aGlzLmRpc3RhbmNlVHJhdmVsZWQgPj0gdGhpcy5tYXhEaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5Cb3VuY2UoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmNlcyA8IHRoaXMubWF4Qm91bmNlcztcbiAgfVxuXG4gIHB1YmxpYyBib3VuY2Uobm9ybWFsOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNhbkJvdW5jZSgpKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVmbGVjdCB2ZWxvY2l0eSBvZmYgdGhlIHN1cmZhY2Ugbm9ybWFsXG4gICAgY29uc3QgcmVmbGVjdGlvbiA9IHRoaXMudmVsb2NpdHkuY2xvbmUoKS5yZWZsZWN0KG5vcm1hbCk7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KHJlZmxlY3Rpb24pO1xuICAgIHRoaXMuYm91bmNlcysrO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGlmZXRpbWUgKz0gZGVsdGFUaW1lO1xuICAgIFxuICAgIC8vIFRyYWNrIGRpc3RhbmNlIHRyYXZlbGVkXG4gICAgY29uc3QgZGlzdGFuY2VUaGlzRnJhbWUgPSB0aGlzLnZlbG9jaXR5Lmxlbmd0aCgpICogZGVsdGFUaW1lO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxlZCArPSBkaXN0YW5jZVRoaXNGcmFtZTtcbiAgICBcbiAgICAvLyBBcHBseSBncmF2aXR5IGlmIGVuYWJsZWRcbiAgICBpZiAodGhpcy5ncmF2aXR5ICE9PSAwKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgKz0gdGhpcy5ncmF2aXR5ICogZGVsdGFUaW1lO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRQb3NpdGlvbih0cmFuc2Zvcm06IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtLmNsb25lKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0UHJlZGljdGVkUG9zaXRpb24odHJhbnNmb3JtOiBWZWN0b3IzLCBkZWx0YVRpbWU6IG51bWJlcik6IFZlY3RvcjMge1xuICAgIGNvbnN0IHByZWRpY3RlZCA9IHRyYW5zZm9ybS5jbG9uZSgpO1xuICAgIHByZWRpY3RlZC5hZGQodGhpcy52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSkpO1xuICAgIHJldHVybiBwcmVkaWN0ZWQ7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5zcGVlZCA9IDIwO1xuICAgIHRoaXMuZGFtYWdlID0gMTA7XG4gICAgdGhpcy5saWZldGltZSA9IDA7XG4gICAgdGhpcy5tYXhMaWZldGltZSA9IDU7XG4gICAgdGhpcy5waWVyY2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaGl0VGFyZ2V0cy5jbGVhcigpO1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gMDtcbiAgICB0aGlzLmdyYXZpdHkgPSAwO1xuICAgIHRoaXMuYm91bmNlcyA9IDA7XG4gICAgdGhpcy5tYXhCb3VuY2VzID0gMDtcbiAgICB0aGlzLm93bmVyID0gLTE7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGVkID0gMDtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgdGhpcy5zdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IFByb2plY3RpbGUge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFByb2plY3RpbGUodGhpcy5zcGVlZCwgdGhpcy5kYW1hZ2UsIHRoaXMubWF4TGlmZXRpbWUsIHRoaXMub3duZXIpO1xuICAgIGNsb25lLnZlbG9jaXR5LmNvcHkodGhpcy52ZWxvY2l0eSk7XG4gICAgY2xvbmUubGlmZXRpbWUgPSB0aGlzLmxpZmV0aW1lO1xuICAgIGNsb25lLnBpZXJjaW5nID0gdGhpcy5waWVyY2luZztcbiAgICBjbG9uZS5oaXRUYXJnZXRzID0gbmV3IFNldCh0aGlzLmhpdFRhcmdldHMpO1xuICAgIGNsb25lLmV4cGxvc2lvblJhZGl1cyA9IHRoaXMuZXhwbG9zaW9uUmFkaXVzO1xuICAgIGNsb25lLmdyYXZpdHkgPSB0aGlzLmdyYXZpdHk7XG4gICAgY2xvbmUuYm91bmNlcyA9IHRoaXMuYm91bmNlcztcbiAgICBjbG9uZS5tYXhCb3VuY2VzID0gdGhpcy5tYXhCb3VuY2VzO1xuICAgIGNsb25lLmRpc3RhbmNlVHJhdmVsZWQgPSB0aGlzLmRpc3RhbmNlVHJhdmVsZWQ7XG4gICAgY2xvbmUubWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlO1xuICAgIGNsb25lLnN0YXJ0UG9zaXRpb24uY29weSh0aGlzLnN0YXJ0UG9zaXRpb24pO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb21wb25lbnQiLCJQcm9qZWN0aWxlIiwic2V0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwidmVsb2NpdHkiLCJjb3B5Iiwibm9ybWFsaXplIiwibXVsdGlwbHlTY2FsYXIiLCJzcGVlZCIsImFkZEdyYXZpdHkiLCJncmF2aXR5Iiwic2V0UGllcmNpbmciLCJwaWVyY2luZyIsInNldEV4cGxvc2l2ZSIsInJhZGl1cyIsImV4cGxvc2lvblJhZGl1cyIsInNldEJvdW5jaW5nIiwibWF4Qm91bmNlcyIsInNldE1heERpc3RhbmNlIiwibWF4RGlzdGFuY2UiLCJzZXRTdGFydFBvc2l0aW9uIiwicG9zaXRpb24iLCJzdGFydFBvc2l0aW9uIiwiaGFzSGl0VGFyZ2V0IiwiZW50aXR5SWQiLCJoaXRUYXJnZXRzIiwiaGFzIiwiYWRkSGl0VGFyZ2V0IiwiYWRkIiwiY2FuSGl0VGFyZ2V0Iiwib3duZXIiLCJpc0V4cGlyZWQiLCJsaWZldGltZSIsIm1heExpZmV0aW1lIiwiZGlzdGFuY2VUcmF2ZWxlZCIsImNhbkJvdW5jZSIsImJvdW5jZXMiLCJib3VuY2UiLCJub3JtYWwiLCJyZWZsZWN0aW9uIiwiY2xvbmUiLCJyZWZsZWN0IiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiZGlzdGFuY2VUaGlzRnJhbWUiLCJsZW5ndGgiLCJ5IiwiZ2V0UG9zaXRpb24iLCJ0cmFuc2Zvcm0iLCJnZXRQcmVkaWN0ZWRQb3NpdGlvbiIsInByZWRpY3RlZCIsInJlc2V0Iiwic2V0IiwiZGFtYWdlIiwiY2xlYXIiLCJJbmZpbml0eSIsImVuYWJsZWQiLCJTZXQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Projectile.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Renderer.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Renderer.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Renderer component for 3D rendering data\n\n\nclass Renderer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setGeometry(geometry) {\n        if (this.geometry && this.geometry !== geometry) {\n            this.geometry.dispose();\n        }\n        this.geometry = geometry;\n        this.needsUpdate = true;\n    }\n    setMaterial(material) {\n        if (this.material && this.material !== material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n        }\n        this.material = material;\n        this.needsUpdate = true;\n    }\n    createMesh() {\n        if (!this.geometry || !this.material) {\n            return null;\n        }\n        if (this.mesh) {\n            this.disposeMesh();\n        }\n        this.mesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, this.material);\n        this.mesh.castShadow = this.castShadow;\n        this.mesh.receiveShadow = this.receiveShadow;\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        this.needsUpdate = false;\n        return this.mesh;\n    }\n    updateMesh() {\n        if (!this.mesh) return;\n        // Handle shadow properties for both Mesh and Group\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = this.castShadow;\n            this.mesh.receiveShadow = this.receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            // Apply shadow properties to all meshes in the group\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = this.castShadow;\n                    child.receiveShadow = this.receiveShadow;\n                }\n            });\n        }\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        if (this.needsUpdate && this.geometry && this.material && this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.geometry = this.geometry;\n            this.mesh.material = this.material;\n            this.needsUpdate = false;\n        }\n    }\n    setVisible(visible) {\n        this.visible = visible;\n        if (this.mesh) {\n            this.mesh.visible = visible;\n        }\n    }\n    setCastShadow(castShadow) {\n        this.castShadow = castShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = castShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = castShadow;\n                }\n            });\n        }\n    }\n    setReceiveShadow(receiveShadow) {\n        this.receiveShadow = receiveShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.receiveShadow = receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.receiveShadow = receiveShadow;\n                }\n            });\n        }\n    }\n    // Animation methods\n    setupAnimations(animations) {\n        if (!this.mesh) return;\n        this.animations = animations;\n        if (animations.length > 0) {\n            this.animationMixer = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(this.mesh);\n        }\n    }\n    playAnimation(name) {\n        let loop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, fadeTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n        if (!this.animationMixer) return null;\n        const clip = this.animations.find((clip)=>clip.name === name);\n        if (!clip) return null;\n        // Stop current animation\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n        }\n        // Start new animation\n        const action = this.animationMixer.clipAction(clip);\n        action.setLoop(loop ? _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat : _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopOnce, loop ? Infinity : 1);\n        action.fadeIn(fadeTime);\n        action.play();\n        this.currentAnimation = action;\n        return action;\n    }\n    stopAnimation() {\n        let fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n            this.currentAnimation = null;\n        }\n    }\n    updateAnimations(deltaTime) {\n        if (this.animationMixer) {\n            this.animationMixer.update(deltaTime);\n        }\n    }\n    // Instancing methods\n    setupInstancing(instancedMesh, instanceId) {\n        this.isInstanced = true;\n        this.instancedMesh = instancedMesh;\n        this.instanceId = instanceId;\n    }\n    updateInstanceMatrix(matrix) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    setInstanceVisible(visible) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            // For instanced meshes, we can hide instances by scaling them to 0\n            const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            this.instancedMesh.getMatrixAt(this.instanceId, matrix);\n            if (!visible) {\n                matrix.scale(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\n            }\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    disposeMesh() {\n        if (this.mesh) {\n            if (this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            this.mesh = null;\n        }\n    }\n    dispose() {\n        this.disposeMesh();\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n            this.material = null;\n        }\n        if (this.animationMixer) {\n            this.animationMixer.stopAllAction();\n            this.animationMixer = null;\n        }\n        this.animations = [];\n        this.currentAnimation = null;\n        this.instancedMesh = null;\n    }\n    reset() {\n        this.dispose();\n        this.castShadow = true;\n        this.receiveShadow = true;\n        this.frustumCulled = true;\n        this.visible = true;\n        this.renderOrder = 0;\n        this.needsUpdate = true;\n        this.isInstanced = false;\n        this.instanceId = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Renderer({\n            castShadow: this.castShadow,\n            receiveShadow: this.receiveShadow,\n            frustumCulled: this.frustumCulled,\n            visible: this.visible,\n            renderOrder: this.renderOrder\n        });\n        // Note: We don't clone the actual geometry/material/mesh as they should be shared\n        // The cloned component will need to have its geometry and material set separately\n        return clone;\n    }\n    constructor(options = {}){\n        super();\n        this.componentType = \"Renderer\" // Instance identifier\n        ;\n        this.mesh = null;\n        this.geometry = null;\n        this.material = null;\n        // Animation properties\n        this.animationMixer = null;\n        this.animations = [];\n        this.currentAnimation = null;\n        // Instancing support\n        this.isInstanced = false;\n        this.instancedMesh = null;\n        this.instanceId = -1;\n        var _options_castShadow;\n        this.castShadow = (_options_castShadow = options.castShadow) !== null && _options_castShadow !== void 0 ? _options_castShadow : true;\n        var _options_receiveShadow;\n        this.receiveShadow = (_options_receiveShadow = options.receiveShadow) !== null && _options_receiveShadow !== void 0 ? _options_receiveShadow : true;\n        var _options_frustumCulled;\n        this.frustumCulled = (_options_frustumCulled = options.frustumCulled) !== null && _options_frustumCulled !== void 0 ? _options_frustumCulled : true;\n        var _options_visible;\n        this.visible = (_options_visible = options.visible) !== null && _options_visible !== void 0 ? _options_visible : true;\n        var _options_renderOrder;\n        this.renderOrder = (_options_renderOrder = options.renderOrder) !== null && _options_renderOrder !== void 0 ? _options_renderOrder : 0;\n        this.needsUpdate = true;\n    }\n}\nRenderer.componentType = \"Renderer\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQ0FBMkM7QUFDMEk7QUFDL0k7QUFVL0IsTUFBTVEsaUJBQWlCRCw4Q0FBU0E7SUFrQzlCRSxZQUFZQyxRQUF3QixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUtBLFVBQVU7WUFDL0MsSUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQU87UUFDdkI7UUFDQSxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxXQUFXLEdBQUc7SUFDckI7SUFFT0MsWUFBWUMsUUFBK0IsRUFBUTtRQUN4RCxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLQSxVQUFVO1lBQy9DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDQSxRQUFRLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVAsT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0csUUFBUSxDQUFDSCxPQUFPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixXQUFXLEdBQUc7SUFDckI7SUFFT08sYUFBMEI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNNLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ0MsV0FBVztRQUNsQjtRQUVBLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlwQixzREFBSUEsQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRSxJQUFJLENBQUNJLFFBQVE7UUFDakQsSUFBSSxDQUFDTSxJQUFJLENBQUNFLFVBQVUs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LENBQUFBLHlCQUFBQSxRQUFRakQsYUFBYSxjQUFyQmlELG9DQUFBQSx5QkFBeUI7WUFDL0JBO1FBQWYsSUFBSSxDQUFDaEQsT0FBTyxHQUFHZ0QsQ0FBQUEsbUJBQUFBLFFBQVFoRCxPQUFPLGNBQWZnRCw4QkFBQUEsbUJBQW1CO1lBQ2ZBO1FBQW5CLElBQUksQ0FBQy9DLFdBQVcsR0FBRytDLENBQUFBLHVCQUFBQSxRQUFRL0MsV0FBVyxjQUFuQitDLGtDQUFBQSx1QkFBdUI7UUFDMUMsSUFBSSxDQUFDN0QsV0FBVyxHQUFHO0lBQ3JCO0FBK09GO0FBL1FhSixTQUNZa0UsZ0JBQWdCLFdBQVksMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cz9lMjc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlcmVyIGNvbXBvbmVudCBmb3IgM0QgcmVuZGVyaW5nIGRhdGFcbmltcG9ydCB7IE1lc2gsIEdyb3VwLCBCdWZmZXJHZW9tZXRyeSwgTWF0ZXJpYWwsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25BY3Rpb24sIEluc3RhbmNlZE1lc2gsIExvb3BSZXBlYXQsIExvb3BPbmNlLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyT3B0aW9ucyB7XG4gIGNhc3RTaGFkb3c/OiBib29sZWFuO1xuICByZWNlaXZlU2hhZG93PzogYm9vbGVhbjtcbiAgZnJ1c3R1bUN1bGxlZD86IGJvb2xlYW47XG4gIHZpc2libGU/OiBib29sZWFuO1xuICByZW5kZXJPcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgbWVzaDogTWVzaCB8IEdyb3VwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnZW9tZXRyeTogQnVmZmVyR2VvbWV0cnkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbCB8IE1hdGVyaWFsW10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhc3RTaGFkb3c6IGJvb2xlYW47XG4gIHB1YmxpYyByZWNlaXZlU2hhZG93OiBib29sZWFuO1xuICBwdWJsaWMgZnJ1c3R1bUN1bGxlZDogYm9vbGVhbjtcbiAgcHVibGljIHZpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJPcmRlcjogbnVtYmVyO1xuICBwdWJsaWMgbmVlZHNVcGRhdGU6IGJvb2xlYW47XG5cbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgcHVibGljIGFuaW1hdGlvbk1peGVyOiBBbmltYXRpb25NaXhlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgYW5pbWF0aW9uczogQW5pbWF0aW9uQ2xpcFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50QW5pbWF0aW9uOiBBbmltYXRpb25BY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvLyBJbnN0YW5jaW5nIHN1cHBvcnRcbiAgcHVibGljIGlzSW5zdGFuY2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBpbnN0YW5jZUlkOiBudW1iZXIgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IG9wdGlvbnMuY2FzdFNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IG9wdGlvbnMucmVjZWl2ZVNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IG9wdGlvbnMuZnJ1c3R1bUN1bGxlZCA/PyB0cnVlO1xuICAgIHRoaXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSBvcHRpb25zLnJlbmRlck9yZGVyID8/IDA7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0R2VvbWV0cnkoZ2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF0ZXJpYWwobWF0ZXJpYWw6IE1hdGVyaWFsIHwgTWF0ZXJpYWxbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICYmIHRoaXMubWF0ZXJpYWwgIT09IG1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNZXNoKCk6IE1lc2ggfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMubWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgICB0aGlzLm1lc2gucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICB0aGlzLm1lc2guZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICB0aGlzLm1lc2gucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1lc2g7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlTWVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIHNoYWRvdyBwcm9wZXJ0aWVzIGZvciBib3RoIE1lc2ggYW5kIEdyb3VwXG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgICAgdGhpcy5tZXNoLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lc2ggaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgLy8gQXBwbHkgc2hhZG93IHByb3BlcnRpZXMgdG8gYWxsIG1lc2hlcyBpbiB0aGUgZ3JvdXBcbiAgICAgIHRoaXMubWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5tZXNoLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdGhpcy5tZXNoLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIGlmICh0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5tYXRlcmlhbCAmJiB0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICB0aGlzLm1lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldENhc3RTaGFkb3coY2FzdFNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFJlY2VpdmVTaGFkb3cocmVjZWl2ZVNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9uIG1ldGhvZHNcbiAgcHVibGljIHNldHVwQW5pbWF0aW9ucyhhbmltYXRpb25zOiBBbmltYXRpb25DbGlwW10pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHRoaXMubWVzaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHBsYXlBbmltYXRpb24obmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuID0gdHJ1ZSwgZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IEFuaW1hdGlvbkFjdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25NaXhlcikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjbGlwID0gdGhpcy5hbmltYXRpb25zLmZpbmQoY2xpcCA9PiBjbGlwLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghY2xpcCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLmZhZGVPdXQoZmFkZVRpbWUpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGlvbk1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG4gICAgYWN0aW9uLnNldExvb3AobG9vcCA/IExvb3BSZXBlYXQgOiBMb29wT25jZSwgbG9vcCA/IEluZmluaXR5IDogMSk7XG4gICAgYWN0aW9uLmZhZGVJbihmYWRlVGltZSk7XG4gICAgYWN0aW9uLnBsYXkoKTtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcHVibGljIHN0b3BBbmltYXRpb24oZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5mYWRlT3V0KGZhZGVUaW1lKTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbnMoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnN0YW5jaW5nIG1ldGhvZHNcbiAgcHVibGljIHNldHVwSW5zdGFuY2luZyhpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoLCBpbnN0YW5jZUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RhbmNlZE1lc2ggPSBpbnN0YW5jZWRNZXNoO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSW5zdGFuY2VNYXRyaXgobWF0cml4OiBNYXRyaXg0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdGhpcy5pbnN0YW5jZWRNZXNoICYmIHRoaXMuaW5zdGFuY2VJZCA+PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB0aGlzLmluc3RhbmNlZE1lc2ggJiYgdGhpcy5pbnN0YW5jZUlkID49IDApIHtcbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgbWVzaGVzLCB3ZSBjYW4gaGlkZSBpbnN0YW5jZXMgYnkgc2NhbGluZyB0aGVtIHRvIDBcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgXG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgbWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KHRoaXMuaW5zdGFuY2VJZCwgbWF0cml4KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2VNZXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGlmICh0aGlzLm1lc2gucGFyZW50KSB7XG4gICAgICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcblxuICAgIGlmICh0aGlzLmdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2VkTWVzaCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gLTE7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBSZW5kZXJlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgY2FzdFNoYWRvdzogdGhpcy5jYXN0U2hhZG93LFxuICAgICAgcmVjZWl2ZVNoYWRvdzogdGhpcy5yZWNlaXZlU2hhZG93LFxuICAgICAgZnJ1c3R1bUN1bGxlZDogdGhpcy5mcnVzdHVtQ3VsbGVkLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgcmVuZGVyT3JkZXI6IHRoaXMucmVuZGVyT3JkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9uZSB0aGUgYWN0dWFsIGdlb21ldHJ5L21hdGVyaWFsL21lc2ggYXMgdGhleSBzaG91bGQgYmUgc2hhcmVkXG4gICAgLy8gVGhlIGNsb25lZCBjb21wb25lbnQgd2lsbCBuZWVkIHRvIGhhdmUgaXRzIGdlb21ldHJ5IGFuZCBtYXRlcmlhbCBzZXQgc2VwYXJhdGVseVxuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJHcm91cCIsIkFuaW1hdGlvbk1peGVyIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJDb21wb25lbnQiLCJSZW5kZXJlciIsInNldEdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibmVlZHNVcGRhdGUiLCJzZXRNYXRlcmlhbCIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNyZWF0ZU1lc2giLCJtZXNoIiwiZGlzcG9zZU1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ2aXNpYmxlIiwicmVuZGVyT3JkZXIiLCJ1cGRhdGVNZXNoIiwidHJhdmVyc2UiLCJjaGlsZCIsInNldFZpc2libGUiLCJzZXRDYXN0U2hhZG93Iiwic2V0UmVjZWl2ZVNoYWRvdyIsInNldHVwQW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJsZW5ndGgiLCJhbmltYXRpb25NaXhlciIsInBsYXlBbmltYXRpb24iLCJuYW1lIiwibG9vcCIsImZhZGVUaW1lIiwiY2xpcCIsImZpbmQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmFkZU91dCIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzZXRMb29wIiwiSW5maW5pdHkiLCJmYWRlSW4iLCJwbGF5Iiwic3RvcEFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbnMiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJzZXR1cEluc3RhbmNpbmciLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VJZCIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4Iiwic2V0SW5zdGFuY2VWaXNpYmxlIiwiZ2V0TWF0cml4QXQiLCJzY2FsZSIsInBhcmVudCIsInJlbW92ZSIsInN0b3BBbGxBY3Rpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Renderer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Shield.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Shield.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shield: function() { return /* binding */ Shield; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n\nclass Shield extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /**\n   * Absorb damage with the shield. Returns the amount of damage that passed through.\n   */ absorbDamage(damage) {\n        if (this.currentShield <= 0) {\n            return damage; // No shield left, all damage passes through\n        }\n        const damageAbsorbed = Math.min(damage, this.currentShield);\n        this.currentShield -= damageAbsorbed;\n        this.lastDamageTime = Date.now();\n        this.isRegenerating = false;\n        // Return the damage that wasn't absorbed\n        return damage - damageAbsorbed;\n    }\n    /**\n   * Update shield regeneration based on delta time\n   */ update(deltaTime) {\n        if (this.currentShield >= this.maxShield) {\n            this.isRegenerating = false;\n            return;\n        }\n        const timeSinceLastDamage = (Date.now() - this.lastDamageTime) / 1000;\n        if (timeSinceLastDamage >= this.regenDelay) {\n            if (!this.isRegenerating) {\n                this.isRegenerating = true;\n            }\n            const regenAmount = this.regenRate * deltaTime;\n            this.currentShield = Math.min(this.maxShield, this.currentShield + regenAmount);\n        }\n    }\n    /**\n   * Get shield percentage (0-1)\n   */ getShieldPercentage() {\n        return this.maxShield > 0 ? this.currentShield / this.maxShield : 0;\n    }\n    /**\n   * Check if shield is at full capacity\n   */ isFullShield() {\n        return this.currentShield >= this.maxShield;\n    }\n    /**\n   * Check if shield is completely depleted\n   */ isShieldDepleted() {\n        return this.currentShield <= 0;\n    }\n    /**\n   * Instantly restore shield to full (for testing or special abilities)\n   */ restoreShield() {\n        this.currentShield = this.maxShield;\n        this.isRegenerating = false;\n    }\n    /**\n   * Set shield values (useful for multiplayer sync)\n   */ setShield(current, max) {\n        this.currentShield = Math.max(0, Math.min(max, current));\n        this.maxShield = max;\n    }\n    /**\n   * Reset shield to initial state (required by Component interface)\n   */ reset() {\n        this.currentShield = this.maxShield;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n        this.enabled = true;\n    }\n    constructor(maxShield = 200, regenRate = 20, regenDelay = 5){\n        super();\n        this.componentType = \"Shield\" // Instance identifier\n        ;\n        this.maxShield = maxShield;\n        this.currentShield = maxShield;\n        this.regenRate = regenRate;\n        this.regenDelay = regenDelay;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n    }\n}\nShield.componentType = \"Shield\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFL0IsTUFBTUMsZUFBZUQsOENBQVNBO0lBb0JuQzs7R0FFQyxHQUNELGFBQW9CRyxNQUFjLEVBQVU7UUFDMUMsSUFBSSxJQUFJLENBQUNDLGFBQWEsSUFBSSxHQUFHO1lBQzNCLE9BQU9ELFFBQVEsNENBQTRDO1FBQzdEO1FBRUEsTUFBTUUsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUNKLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1FBQzFELElBQUksQ0FBQ0EsYUFBYSxJQUFJQztRQUN0QixJQUFJLENBQUNHLGNBQWMsR0FBR0MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUV0Qix5Q0FBeUM7UUFDekMsT0FBT1IsU0FBU0U7SUFDbEI7SUFFQTs7R0FFQyxHQUNELE9BQWNRLFNBQWlCLEVBQVE7UUFDckMsSUFBSSxJQUFJLENBQUNULGFBQWEsSUFBSSxJQUFJLENBQUNVLFNBQVMsRUFBRTtZQUN4QyxJQUFJLENBQUNILGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTUksc0JBQXNCLENBQUNOLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNGLGNBQWMsSUFBSTtRQUVqRSxJQUFJTyx1QkFBdUIsSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0wsY0FBYyxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRztZQUN4QjtZQUVBLE1BQU1NLGNBQWMsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1lBQ3JDLElBQUksQ0FBQ1QsYUFBYSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxTQUFTLEVBQUUsSUFBSSxDQUFDVixhQUFhLEdBQUdhO1FBQ3JFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUFxQztRQUNuQyxPQUFPLElBQUksQ0FBQ0gsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTLEdBQUc7SUFDcEU7SUFFQTs7R0FFQyxHQUNELGVBQStCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVixhQUFhLElBQUksSUFBSSxDQUFDVSxTQUFTO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxtQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUNWLGFBQWEsSUFBSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsZ0JBQTZCO1FBQzNCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ1UsU0FBUztRQUNuQyxJQUFJLENBQUNILGNBQWMsR0FBRztJQUN4QjtJQUVBOztHQUVDLEdBQ0QsVUFBaUJhLE9BQWUsRUFBRUMsR0FBVyxFQUFRO1FBQ25ELElBQUksQ0FBQ3JCLGFBQWEsR0FBR0UsS0FBS21CLEdBQUcsQ0FBQyxHQUFHbkIsS0FBS0MsR0FBRyxDQUFDa0IsS0FBS0Q7UUFDL0MsSUFBSSxDQUFDVixTQUFTLEdBQUdXO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxRQUFxQjtRQUNuQixJQUFJLENBQUNyQixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTO1FBQ25DLElBQUksQ0FBQ04sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2dCLE9BQU8sR0FBRztJQUNqQjtJQTdGQUMsWUFBWWQsWUFBb0IsR0FBRyxFQUFFSSxZQUFvQixFQUFFLEVBQUVGLGFBQXFCLENBQUMsQ0FBRTtRQUNuRixLQUFLO2FBVFNhLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFVOUQsSUFBSSxDQUFDZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHVTtRQUNyQixJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ1IsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3hCO0FBc0ZGO0FBeEdhVixPQUNZNEIsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHM/MmM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgU2hpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1NoaWVsZCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdTaGllbGQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBtYXhTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIGN1cnJlbnRTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuUmF0ZTogbnVtYmVyOyAvLyBTaGllbGQgcmVnZW5lcmF0ZWQgcGVyIHNlY29uZFxuICBwdWJsaWMgcmVnZW5EZWxheTogbnVtYmVyOyAvLyBTZWNvbmRzIGJlZm9yZSByZWdlbiBzdGFydHNcbiAgcHVibGljIGxhc3REYW1hZ2VUaW1lOiBudW1iZXI7IC8vIFRpbWVzdGFtcCBvZiBsYXN0IGRhbWFnZSB0YWtlblxuICBwdWJsaWMgaXNSZWdlbmVyYXRpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWF4U2hpZWxkOiBudW1iZXIgPSAyMDAsIHJlZ2VuUmF0ZTogbnVtYmVyID0gMjAsIHJlZ2VuRGVsYXk6IG51bWJlciA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4U2hpZWxkO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IG1heFNoaWVsZDtcbiAgICB0aGlzLnJlZ2VuUmF0ZSA9IHJlZ2VuUmF0ZTtcbiAgICB0aGlzLnJlZ2VuRGVsYXkgPSByZWdlbkRlbGF5O1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnNvcmIgZGFtYWdlIHdpdGggdGhlIHNoaWVsZC4gUmV0dXJucyB0aGUgYW1vdW50IG9mIGRhbWFnZSB0aGF0IHBhc3NlZCB0aHJvdWdoLlxuICAgKi9cbiAgcHVibGljIGFic29yYkRhbWFnZShkYW1hZ2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA8PSAwKSB7XG4gICAgICByZXR1cm4gZGFtYWdlOyAvLyBObyBzaGllbGQgbGVmdCwgYWxsIGRhbWFnZSBwYXNzZXMgdGhyb3VnaFxuICAgIH1cblxuICAgIGNvbnN0IGRhbWFnZUFic29yYmVkID0gTWF0aC5taW4oZGFtYWdlLCB0aGlzLmN1cnJlbnRTaGllbGQpO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCAtPSBkYW1hZ2VBYnNvcmJlZDtcbiAgICB0aGlzLmxhc3REYW1hZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhbWFnZSB0aGF0IHdhc24ndCBhYnNvcmJlZFxuICAgIHJldHVybiBkYW1hZ2UgLSBkYW1hZ2VBYnNvcmJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2hpZWxkIHJlZ2VuZXJhdGlvbiBiYXNlZCBvbiBkZWx0YSB0aW1lXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA+PSB0aGlzLm1heFNoaWVsZCkge1xuICAgICAgdGhpcy5pc1JlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdERhbWFnZVRpbWUpIC8gMTAwMDtcbiAgICBcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuRGVsYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlZ2VuZXJhdGluZykge1xuICAgICAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVnZW5BbW91bnQgPSB0aGlzLnJlZ2VuUmF0ZSAqIGRlbHRhVGltZTtcbiAgICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWluKHRoaXMubWF4U2hpZWxkLCB0aGlzLmN1cnJlbnRTaGllbGQgKyByZWdlbkFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzaGllbGQgcGVyY2VudGFnZSAoMC0xKVxuICAgKi9cbiAgcHVibGljIGdldFNoaWVsZFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTaGllbGQgPiAwID8gdGhpcy5jdXJyZW50U2hpZWxkIC8gdGhpcy5tYXhTaGllbGQgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNoaWVsZCBpcyBhdCBmdWxsIGNhcGFjaXR5XG4gICAqL1xuICBwdWJsaWMgaXNGdWxsU2hpZWxkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPj0gdGhpcy5tYXhTaGllbGQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2hpZWxkIGlzIGNvbXBsZXRlbHkgZGVwbGV0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NoaWVsZERlcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50bHkgcmVzdG9yZSBzaGllbGQgdG8gZnVsbCAoZm9yIHRlc3Rpbmcgb3Igc3BlY2lhbCBhYmlsaXRpZXMpXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZVNoaWVsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTaGllbGQgPSB0aGlzLm1heFNoaWVsZDtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNoaWVsZCB2YWx1ZXMgKHVzZWZ1bCBmb3IgbXVsdGlwbGF5ZXIgc3luYylcbiAgICovXG4gIHB1YmxpYyBzZXRTaGllbGQoY3VycmVudDogbnVtYmVyLCBtYXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgY3VycmVudCkpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHNoaWVsZCB0byBpbml0aWFsIHN0YXRlIChyZXF1aXJlZCBieSBDb21wb25lbnQgaW50ZXJmYWNlKVxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IHRoaXMubWF4U2hpZWxkO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiYWJzb3JiRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFNoaWVsZCIsImRhbWFnZUFic29yYmVkIiwiTWF0aCIsIm1pbiIsImxhc3REYW1hZ2VUaW1lIiwiRGF0ZSIsIm5vdyIsImlzUmVnZW5lcmF0aW5nIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwibWF4U2hpZWxkIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuRGVsYXkiLCJyZWdlbkFtb3VudCIsInJlZ2VuUmF0ZSIsImdldFNoaWVsZFBlcmNlbnRhZ2UiLCJpc0Z1bGxTaGllbGQiLCJpc1NoaWVsZERlcGxldGVkIiwicmVzdG9yZVNoaWVsZCIsInNldFNoaWVsZCIsImN1cnJlbnQiLCJtYXgiLCJyZXNldCIsImVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Shield.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Tower.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Tower.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: function() { return /* binding */ Tower; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Tower component for PVP home base towers\n\nclass Tower extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    getDisplayName() {\n        return \"Tower \".concat(this.towerIndex + 1, \" (Owner: \").concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.towerIndex = 0;\n        this.attackRange = 8;\n        this.attackDamage = 10;\n        this.attackCooldown = 1.5;\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20;\n        this.currentTarget = null;\n        this.targetSearchRange = 9;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Tower(this.ownerId, this.towerIndex);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.projectileSpeed = this.projectileSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.targetSearchRange = this.targetSearchRange;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        return clone;\n    }\n    constructor(ownerId = \"\", towerIndex = 0){\n        super();\n        this.componentType = \"Tower\";\n        this.ownerId = ownerId;\n        this.towerIndex = towerIndex;\n        // Combat configuration\n        this.attackRange = 10; // 10 unit attack range as specified\n        this.attackDamage = 10; // 10 damage per arrow as specified\n        this.attackCooldown = 1.5; // 1.5 seconds between shots\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20; // Speed of tower arrows\n        // Targeting configuration\n        this.currentTarget = null;\n        this.targetSearchRange = this.attackRange + 1; // Search slightly beyond attack range\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n    }\n}\nTower.componentType = \"Tower\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEyQztBQUNMO0FBRS9CLE1BQU1DLGNBQWNELDhDQUFTQTtJQXNEM0JFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLGlCQUF5QjtRQUM5QixPQUFPLFNBQXdDLE9BQS9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEdBQUUsYUFBd0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztJQUM5RDtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNuQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDb0IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZixvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDUyxPQUFPLEdBQUc7SUFDakI7SUFFT0MsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUkzQixNQUFNLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUNELFVBQVU7UUFDckRRLE1BQU1MLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENLLE1BQU1KLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdENJLE1BQU1wQixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDb0IsTUFBTXJCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNxQixNQUFNSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzVDRyxNQUFNdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NCLE1BQU1GLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hERSxNQUFNakIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERpQixNQUFNaEIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERnQixNQUFNeEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUM5QndCLE1BQU12QixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzFCdUIsTUFBTVYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxPQUFPVTtJQUNUO0lBbkdBQyxZQUNFUixVQUFrQixFQUFFLEVBQ3BCRCxhQUFxQixDQUFDLENBQ3RCO1FBQ0EsS0FBSzthQTVCU1UsZ0JBQWdCO1FBOEI5QixJQUFJLENBQUNULE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFFbEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUksb0NBQW9DO1FBQzNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksbUNBQW1DO1FBQzNELElBQUksQ0FBQ2hCLGNBQWMsR0FBRyxLQUFLLDRCQUE0QjtRQUN2RCxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSx3QkFBd0I7UUFFbkQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ25CLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUNILFdBQVcsR0FBRyxHQUFHLHNDQUFzQztRQUNyRixJQUFJLENBQUNaLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSyx1Q0FBdUM7UUFFeEUsUUFBUTtRQUNSLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7SUFDbkI7QUEwRUY7QUE5SGFqQixNQUNZNkIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cz9iNmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIGNvbXBvbmVudCBmb3IgUFZQIGhvbWUgYmFzZSB0b3dlcnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUb3dlcic7XG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Rvd2VyJztcbiAgXG4gIC8vIFRvd2VyIG93bmVyc2hpcCBhbmQgaWRlbnRpZmljYXRpb25cbiAgcHVibGljIG93bmVySWQ6IHN0cmluZzsgLy8gUGxheWVyIElEIHdobyBvd25zIHRoaXMgdG93ZXJcbiAgcHVibGljIHRvd2VySW5kZXg6IG51bWJlcjsgLy8gVG93ZXIgaW5kZXggKDAgZm9yIGZpcnN0IHBsYXllciwgMSBmb3Igc2Vjb25kLCBldGMuKVxuICBcbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcHJvamVjdGlsZVNwZWVkOiBudW1iZXI7XG4gIFxuICAvLyBUYXJnZXRpbmdcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldFxuICBwdWJsaWMgdGFyZ2V0U2VhcmNoUmFuZ2U6IG51bWJlcjsgLy8gUmFuZ2UgdG8gc2VhcmNoIGZvciBuZXcgdGFyZ2V0c1xuICBwdWJsaWMgbGFzdFRhcmdldFNlYXJjaFRpbWU6IG51bWJlcjtcbiAgcHVibGljIHRhcmdldFNlYXJjaENvb2xkb3duOiBudW1iZXI7IC8vIEhvdyBvZnRlbiB0byBzZWFyY2ggZm9yIHRhcmdldHNcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdG93ZXJJbmRleDogbnVtYmVyID0gMFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy50b3dlckluZGV4ID0gdG93ZXJJbmRleDtcbiAgICBcbiAgICAvLyBDb21iYXQgY29uZmlndXJhdGlvblxuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSAxMDsgLy8gMTAgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxMDsgLy8gMTAgZGFtYWdlIHBlciBhcnJvdyBhcyBzcGVjaWZpZWRcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gMS41OyAvLyAxLjUgc2Vjb25kcyBiZXR3ZWVuIHNob3RzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDsgLy8gU3BlZWQgb2YgdG93ZXIgYXJyb3dzXG4gICAgXG4gICAgLy8gVGFyZ2V0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlICsgMTsgLy8gU2VhcmNoIHNsaWdodGx5IGJleW9uZCBhdHRhY2sgcmFuZ2VcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41OyAvLyBTZWFyY2ggZm9yIHRhcmdldHMgZXZlcnkgMC41IHNlY29uZHNcbiAgICBcbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc0RlYWQgfHwgIXRoaXMuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuICBcbiAgcHVibGljIHBlcmZvcm1BdHRhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuICBcbiAgcHVibGljIGNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lKSA+PSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRUYXJnZXQodGFyZ2V0RW50aXR5SWQ6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRFbnRpdHlJZDtcbiAgfVxuICBcbiAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cbiAgXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmNsZWFyVGFyZ2V0KCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVG93ZXIgJHt0aGlzLnRvd2VySW5kZXggKyAxfSAoT3duZXI6ICR7dGhpcy5vd25lcklkfSlgO1xuICB9XG4gIFxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5vd25lcklkID0gJyc7XG4gICAgdGhpcy50b3dlckluZGV4ID0gMDtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gODtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IDEwO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSAxLjU7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSA5O1xuICAgIHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWUgPSAwO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSAwLjU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBcbiAgcHVibGljIGNsb25lKCk6IFRvd2VyIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUb3dlcih0aGlzLm93bmVySWQsIHRoaXMudG93ZXJJbmRleCk7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUucHJvamVjdGlsZVNwZWVkID0gdGhpcy5wcm9qZWN0aWxlU3BlZWQ7XG4gICAgY2xvbmUuY3VycmVudFRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldDtcbiAgICBjbG9uZS50YXJnZXRTZWFyY2hSYW5nZSA9IHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2U7XG4gICAgY2xvbmUubGFzdFRhcmdldFNlYXJjaFRpbWUgPSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lO1xuICAgIGNsb25lLnRhcmdldFNlYXJjaENvb2xkb3duID0gdGhpcy50YXJnZXRTZWFyY2hDb29sZG93bjtcbiAgICBjbG9uZS5pc0FjdGl2ZSA9IHRoaXMuaXNBY3RpdmU7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuZGVhdGhUaW1lID0gdGhpcy5kZWF0aFRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiVG93ZXIiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWN0aXZlIiwiaXNEZWFkIiwiY3VycmVudFRhcmdldCIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsImxhc3RUYXJnZXRTZWFyY2hUaW1lIiwidGFyZ2V0U2VhcmNoQ29vbGRvd24iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJzZXRUYXJnZXQiLCJ0YXJnZXRFbnRpdHlJZCIsImNsZWFyVGFyZ2V0IiwiZGllIiwiZGVhdGhUaW1lIiwiZ2V0RGlzcGxheU5hbWUiLCJ0b3dlckluZGV4Iiwib3duZXJJZCIsInJlc2V0IiwiYXR0YWNrUmFuZ2UiLCJhdHRhY2tEYW1hZ2UiLCJwcm9qZWN0aWxlU3BlZWQiLCJ0YXJnZXRTZWFyY2hSYW5nZSIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Tower.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Transform.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/Transform.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Transform component for position, rotation, and scale\n\n\nclass Transform extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    translate(x, y, z) {\n        this.position.x += x;\n        this.position.y += y;\n        this.position.z += z;\n        this.markMatrixDirty();\n    }\n    rotate(x, y, z) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    lookAt(target) {\n        let up = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.lookAt(this.position, target, up);\n        this.quaternion.setFromRotationMatrix(matrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.markMatrixDirty();\n    }\n    getForward() {\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    getRight() {\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    getUp() {\n        const up = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n    getWorldPosition() {\n        this.updateWorldMatrix();\n        const worldPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldPosition.setFromMatrixPosition(this.worldMatrix);\n        return worldPosition;\n    }\n    getWorldRotation() {\n        this.updateWorldMatrix();\n        const worldQuaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        worldQuaternion.setFromRotationMatrix(this.worldMatrix);\n        return worldQuaternion;\n    }\n    getWorldScale() {\n        this.updateWorldMatrix();\n        const worldScale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldScale.setFromMatrixScale(this.worldMatrix);\n        return worldScale;\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixNeedsUpdate = false;\n    }\n    updateWorldMatrix() {\n        if (this.matrixNeedsUpdate) {\n            this.updateMatrix();\n        }\n        if (this.parent) {\n            this.parent.updateWorldMatrix();\n            this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.matrix);\n        } else {\n            this.worldMatrix.copy(this.matrix);\n        }\n    }\n    addChild(child) {\n        if (child.parent) {\n            child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.children.push(child);\n    }\n    removeChild(child) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n            child.parent = null;\n        }\n    }\n    removeFromParent() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    }\n    updateQuaternion() {\n        this.quaternion.setFromEuler(this.rotation);\n    }\n    markMatrixDirty() {\n        this.matrixNeedsUpdate = true;\n        // Mark all children as dirty too\n        for (const child of this.children){\n            child.markMatrixDirty();\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.position) {\n            this.position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.position.set(0, 0, 0);\n        }\n        if (!this.rotation) {\n            this.rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0);\n        } else {\n            this.rotation.set(0, 0, 0);\n        }\n        if (!this.scale) {\n            this.scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        } else {\n            this.scale.set(1, 1, 1);\n        }\n        if (!this.quaternion) {\n            this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        } else {\n            this.quaternion.set(0, 0, 0, 1);\n        }\n        if (!this.matrix) {\n            this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.matrix.identity();\n        }\n        if (!this.worldMatrix) {\n            this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.worldMatrix.identity();\n        }\n        this.matrixNeedsUpdate = true;\n        // Clear parent-child relationships\n        this.removeFromParent();\n        while(this.children.length > 0){\n            this.removeChild(this.children[0]);\n        }\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Transform(this.position, this.rotation, this.scale);\n        clone.quaternion.copy(this.quaternion);\n        return clone;\n    }\n    constructor(position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0), scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)){\n        super();\n        this.componentType = \"Transform\" // Instance identifier\n        ;\n        this.matrixNeedsUpdate = true;\n        // Parent-child relationships\n        this.parent = null;\n        this.children = [];\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.updateQuaternion();\n    }\n}\nTransform.componentType = \"Transform\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0RBQXdEO0FBQ29CO0FBQ3RDO0FBRS9CLE1BQU1LLGtCQUFrQkQsOENBQVNBO0lBa0MvQkUsWUFBWUMsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT0MsWUFBWU4sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNLLFFBQVEsQ0FBQ0gsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT0ksU0FBU1QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNyRCxJQUFJLENBQUNRLEtBQUssQ0FBQ04sR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUNyQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT00sVUFBVVgsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN0RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0QsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT08sT0FBT1osQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNuRCxJQUFJLENBQUNLLFFBQVEsQ0FBQ1AsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNPLFFBQVEsQ0FBQ04sQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJQTtRQUNuQixJQUFJ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QkFBZ0IsWUFBYSxzQkFBc0I7O2FBUzVEcEIsb0JBQW9CO1FBRTNCLDZCQUE2QjthQUN0QkMsU0FBMkI7YUFDM0JNLFdBQXdCLEVBQUU7UUFTL0IsSUFBSSxDQUFDMUMsUUFBUSxHQUFHQSxTQUFTcUQsS0FBSztRQUM5QixJQUFJLENBQUNqRCxRQUFRLEdBQUdBLFNBQVNpRCxLQUFLO1FBQzlCLElBQUksQ0FBQzlDLEtBQUssR0FBR0EsTUFBTThDLEtBQUs7UUFDeEIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHLElBQUl0Qiw0REFBVUE7UUFDaEMsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlwQix5REFBT0E7UUFDekIsSUFBSSxDQUFDa0MsV0FBVyxHQUFHLElBQUlsQyx5REFBT0E7UUFFOUIsSUFBSSxDQUFDWSxnQkFBZ0I7SUFDdkI7QUE0TEY7QUE1TmFWLFVBQ1k0RCxnQkFBZ0IsWUFBYSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybS50cz9mY2JhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zZm9ybSBjb21wb25lbnQgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5kIHNjYWxlXG5pbXBvcnQgeyBWZWN0b3IzLCBFdWxlciwgUXVhdGVybmlvbiwgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1RyYW5zZm9ybSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUcmFuc2Zvcm0nOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHVibGljIHJvdGF0aW9uOiBFdWxlcjtcbiAgcHVibGljIHNjYWxlOiBWZWN0b3IzO1xuICBwdWJsaWMgcXVhdGVybmlvbjogUXVhdGVybmlvbjtcblxuICAvLyBDYWNoZWQgbWF0cmljZXMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBtYXRyaXg6IE1hdHJpeDQ7XG4gIHB1YmxpYyB3b3JsZE1hdHJpeDogTWF0cml4NDtcbiAgcHVibGljIG1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBQYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICBwdWJsaWMgcGFyZW50OiBUcmFuc2Zvcm0gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBUcmFuc2Zvcm1bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgcm90YXRpb246IEV1bGVyID0gbmV3IEV1bGVyKDAsIDAsIDApLFxuICAgIHNjYWxlOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSlcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUuY2xvbmUoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRSb3RhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy51cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTY2FsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zY2FsZS5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2xhdGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24ueCArPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSArPSB5O1xuICAgIHRoaXMucG9zaXRpb24ueiArPSB6O1xuICAgIHRoaXMubWFya01hdHJpeERpcnR5KCk7XG4gIH1cblxuICBwdWJsaWMgcm90YXRlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJvdGF0aW9uLnggKz0geDtcbiAgICB0aGlzLnJvdGF0aW9uLnkgKz0geTtcbiAgICB0aGlzLnJvdGF0aW9uLnogKz0gejtcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGxvb2tBdCh0YXJnZXQ6IFZlY3RvcjMsIHVwOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCkpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIG1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB1cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGdldEZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldFJpZ2h0KCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgcmlnaHQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldFVwKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgdXAuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHVwO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUG9zaXRpb24oKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUm90YXRpb24oKTogUXVhdGVybmlvbiB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgd29ybGRRdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICByZXR1cm4gd29ybGRRdWF0ZXJuaW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkU2NhbGUoKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFNjYWxlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdHJpeE5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICAgIHRoaXMud29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChjaGlsZDogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVhdGVybmlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMucm90YXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrTWF0cml4RGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gTWFyayBhbGwgY2hpbGRyZW4gYXMgZGlydHkgdG9vXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5tYXJrTWF0cml4RGlydHkoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5yb3RhdGlvbikge1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLndvcmxkTWF0cml4KSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JsZE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogVHJhbnNmb3JtIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbiwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgY2xvbmUucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkV1bGVyIiwiUXVhdGVybmlvbiIsIk1hdHJpeDQiLCJDb21wb25lbnQiLCJUcmFuc2Zvcm0iLCJzZXRQb3NpdGlvbiIsIngiLCJ5IiwieiIsInBvc2l0aW9uIiwic2V0IiwibWFya01hdHJpeERpcnR5Iiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsInVwZGF0ZVF1YXRlcm5pb24iLCJzZXRTY2FsZSIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwibG9va0F0IiwidGFyZ2V0IiwidXAiLCJtYXRyaXgiLCJxdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4Iiwic2V0RnJvbVF1YXRlcm5pb24iLCJnZXRGb3J3YXJkIiwiZm9yd2FyZCIsImFwcGx5UXVhdGVybmlvbiIsImdldFJpZ2h0IiwicmlnaHQiLCJnZXRVcCIsImdldFdvcmxkUG9zaXRpb24iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIndvcmxkUG9zaXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJ3b3JsZE1hdHJpeCIsImdldFdvcmxkUm90YXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJnZXRXb3JsZFNjYWxlIiwid29ybGRTY2FsZSIsInNldEZyb21NYXRyaXhTY2FsZSIsInVwZGF0ZU1hdHJpeCIsImNvbXBvc2UiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInBhcmVudCIsIm11bHRpcGx5TWF0cmljZXMiLCJjb3B5IiwiYWRkQ2hpbGQiLCJjaGlsZCIsInJlbW92ZUNoaWxkIiwiY2hpbGRyZW4iLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRnJvbVBhcmVudCIsInNldEZyb21FdWxlciIsInJlc2V0IiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Transform.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CameraSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CameraSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSystem: function() { return /* binding */ CameraSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/MathUtils */ \"(app-pages-browser)/./src/utils/MathUtils.ts\");\n// Camera system for third-person camera controls\n\n\n\n\nclass CameraSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setTarget(entity) {\n        this.target = entity;\n    }\n    setConfig(config) {\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.spherical.radius = this.config.distance;\n    }\n    update(entities, deltaTime) {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) return;\n        // Handle mouse input for camera rotation\n        this.handleMouseInput();\n        // Update target position\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        // Calculate camera position based on spherical coordinates\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        // Smooth camera movement\n        this.currentPosition.lerp(this.targetPosition, this.config.smoothing);\n        this.currentLookAt.lerp(this.targetLookAt, this.config.smoothing);\n        // Update camera\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    handleMouseInput() {\n        const mouseDelta = this.inputManager.getMouseDelta();\n        // Only rotate camera when right mouse button is held down\n        if ((mouseDelta.x !== 0 || mouseDelta.y !== 0) && this.isRightMouseDown) {\n            // Update spherical coordinates based on mouse movement\n            this.spherical.theta -= mouseDelta.x * this.config.mouseSensitivity;\n            this.spherical.phi -= mouseDelta.y * this.config.mouseSensitivity; // Inverted Y for natural camera feel\n            // Clamp phi to prevent camera flipping\n            this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.phi, this.config.minPolarAngle, this.config.maxPolarAngle);\n            // Normalize theta\n            this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(this.spherical.theta);\n        }\n    }\n    setupEventListeners() {\n        // Mouse button events for camera rotation\n        this.inputManager.on(\"mouseDown\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = true;\n            }\n        });\n        this.inputManager.on(\"mouseUp\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = false;\n            }\n        });\n        // Mouse wheel for zoom - only add listener once\n        if (!this.wheelListenerAdded) {\n            this.inputManager.on(\"wheel\", (param)=>{\n                let { deltaY } = param;\n                this.spherical.radius += deltaY * 0.01;\n                this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.radius, 2, this.config.maxDistance);\n            });\n            this.wheelListenerAdded = true;\n        }\n    }\n    setupInitialPosition() {\n        this.currentPosition.setFromSpherical(this.spherical);\n        this.currentLookAt.set(0, this.config.height, 0);\n        this.targetPosition.copy(this.currentPosition);\n        this.targetLookAt.copy(this.currentLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    // Utility methods\n    getCameraDirection() {\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        return direction;\n    }\n    getCameraRight() {\n        const direction = this.getCameraDirection();\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        right.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n        right.normalize();\n        return right;\n    }\n    getCameraForward() {\n        const right = this.getCameraRight();\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        forward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), right);\n        forward.normalize();\n        return forward;\n    }\n    getDistance() {\n        return this.spherical.radius;\n    }\n    setDistance(distance) {\n        this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(distance, 2, this.config.maxDistance);\n    }\n    getHorizontalAngle() {\n        return this.spherical.theta;\n    }\n    getVerticalAngle() {\n        return this.spherical.phi;\n    }\n    setAngles(horizontal, vertical) {\n        this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(horizontal);\n        this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(vertical, this.config.minPolarAngle, this.config.maxPolarAngle);\n    }\n    resetCamera() {\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3;\n        this.spherical.theta = 0;\n        this.setupInitialPosition();\n    }\n    snapToTarget() {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform || !targetTransform.position) return;\n        // Safety check: ensure position is properly initialized\n        if (targetTransform.position.x === undefined || targetTransform.position.y === undefined || targetTransform.position.z === undefined) {\n            console.warn(\"CameraSystem: Target position is not properly initialized, skipping snapToTarget\");\n            return;\n        }\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        this.currentPosition.copy(this.targetPosition);\n        this.currentLookAt.copy(this.targetLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    getCamera() {\n        return this.camera;\n    }\n    constructor(camera, inputManager, config){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform\n        ];\n        this.target = null;\n        // Camera configuration\n        this.config = {\n            distance: 10,\n            height: 5,\n            mouseSensitivity: 0.005,\n            smoothing: 0.1,\n            minPolarAngle: Math.PI / 3.5,\n            maxPolarAngle: Math.PI / 2.5,\n            maxDistance: 11.5\n        };\n        // Camera state\n        this.spherical = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Spherical(10, Math.PI / 3, 0);\n        this.targetPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.targetLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Mouse state for camera rotation\n        this.isRightMouseDown = false;\n        this.wheelListenerAdded = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.priority = 900; // Run late, after movement\n        if (config) {\n            this.config = {\n                ...this.config,\n                ...config\n            };\n        }\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3; // Start at 60 degrees\n        this.spherical.theta = 0;\n        this.setupEventListeners();\n        this.setupInitialPosition();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NhbWVyYVN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlEQUFpRDtBQUM2QjtBQUN4QztBQUVpQjtBQUVUO0FBWXZDLE1BQU1LLHFCQUFxQkgsK0NBQU1BO0lBOEMvQkksVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNoQjtJQUVPRSxVQUFVQyxNQUE2QixFQUFRO1FBQ3BELElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07WUFBRSxHQUFHQSxNQUFNO1FBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtJQUM5QztJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNSLE1BQU0sRUFBRTtRQUVsQixNQUFNUyxrQkFBa0IsSUFBSSxDQUFDVCxNQUFNLENBQUNVLFlBQVksQ0FBQ2YsZ0VBQVNBO1FBQzFELElBQUksQ0FBQ2MsaUJBQWlCO1FBRXRCLHlDQUF5QztRQUN6QyxJQUFJLENBQUNFLGdCQUFnQjtRQUVyQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksQ0FBQ0osZ0JBQWdCSyxRQUFRO1FBQy9DLElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxDQUFDLElBQUksSUFBSSxDQUFDYixNQUFNLENBQUNjLE1BQU07UUFFekMsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNmLFNBQVM7UUFDbkQsSUFBSSxDQUFDYyxjQUFjLENBQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFlBQVk7UUFFekMseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1EsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDSixjQUFjLEVBQUUsSUFB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R0FBR0E7UUFDcEIsSUFBSSxDQUFDOEMsUUFBUSxHQUFHLEtBQUssMkJBQTJCO1FBRWhELElBQUl2RSxRQUFRO1lBQ1YsSUFBSSxDQUFDQSxNQUFNLEdBQUc7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07Z0JBQUUsR0FBR0EsTUFBTTtZQUFDO1FBQzVDO1FBRUEsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtRQUM1QyxJQUFJLENBQUNGLFNBQVMsQ0FBQzhCLEdBQUcsR0FBRzhCLEtBQUtDLEVBQUUsR0FBRyxHQUFHLHNCQUFzQjtRQUN4RCxJQUFJLENBQUM3RCxTQUFTLENBQUM0QixLQUFLLEdBQUc7UUFFdkIsSUFBSSxDQUFDTyxtQkFBbUI7UUFDeEIsSUFBSSxDQUFDTSxvQkFBb0I7SUFDM0I7QUFpTEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ2FtZXJhU3lzdGVtLnRzP2NkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FtZXJhIHN5c3RlbSBmb3IgdGhpcmQtcGVyc29uIGNhbWVyYSBjb250cm9sc1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEsIFNwaGVyaWNhbCwgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJ0AvY29yZS9JbnB1dE1hbmFnZXInO1xuaW1wb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnQC91dGlscy9NYXRoVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbWVyYUNvbmZpZyB7XG4gIGRpc3RhbmNlOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtb3VzZVNlbnNpdGl2aXR5OiBudW1iZXI7XG4gIHNtb290aGluZzogbnVtYmVyO1xuICBtaW5Qb2xhckFuZ2xlOiBudW1iZXI7XG4gIG1heFBvbGFyQW5nbGU6IG51bWJlcjtcbiAgbWF4RGlzdGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENhbWVyYVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtXTtcbiAgcHJpdmF0ZSBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIHRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBDYW1lcmEgY29uZmlndXJhdGlvblxuICBwcml2YXRlIGNvbmZpZzogQ2FtZXJhQ29uZmlnID0ge1xuICAgIGRpc3RhbmNlOiAxMCxcbiAgICBoZWlnaHQ6IDUsXG4gICAgbW91c2VTZW5zaXRpdml0eTogMC4wMDUsIC8vIEluY3JlYXNlZCBmb3IgYmV0dGVyIHJlc3BvbnNpdmVuZXNzXG4gICAgc21vb3RoaW5nOiAwLjEsXG4gICAgbWluUG9sYXJBbmdsZTogTWF0aC5QSSAvIDMuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBnb2luZyBhYm92ZSBob3Jpem9uXG4gICAgbWF4UG9sYXJBbmdsZTogTWF0aC5QSSAvIDIuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBsb29raW5nIHVuZGVybmVhdGggdGhlIG1hcFxuICAgIG1heERpc3RhbmNlOiAxMS41LFxuICB9O1xuXG4gIC8vIENhbWVyYSBzdGF0ZVxuICBwcml2YXRlIHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoMTAsIE1hdGguUEkgLyAzLCAwKTtcbiAgcHJpdmF0ZSB0YXJnZXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgY3VycmVudFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBjdXJyZW50TG9va0F0ID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0YXJnZXRMb29rQXQgPSBuZXcgVmVjdG9yMygpO1xuICBcbiAgLy8gTW91c2Ugc3RhdGUgZm9yIGNhbWVyYSByb3RhdGlvblxuICBwcml2YXRlIGlzUmlnaHRNb3VzZURvd24gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3aGVlbExpc3RlbmVyQWRkZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhLCBpbnB1dE1hbmFnZXI6IElucHV0TWFuYWdlciwgY29uZmlnPzogUGFydGlhbDxDYW1lcmFDb25maWc+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IGlucHV0TWFuYWdlcjtcbiAgICB0aGlzLnByaW9yaXR5ID0gOTAwOyAvLyBSdW4gbGF0ZSwgYWZ0ZXIgbW92ZW1lbnRcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH07XG4gICAgfVxuXG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7IC8vIFN0YXJ0IGF0IDYwIGRlZ3JlZXNcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IDA7XG5cbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldHVwSW5pdGlhbFBvc2l0aW9uKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0VGFyZ2V0KGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgdGhpcy50YXJnZXQgPSBlbnRpdHk7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29uZmlnKGNvbmZpZzogUGFydGlhbDxDYW1lcmFDb25maWc+KTogdm9pZCB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHJldHVybjtcblxuICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRoaXMudGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICAvLyBIYW5kbGUgbW91c2UgaW5wdXQgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaGFuZGxlTW91c2VJbnB1dCgpO1xuXG4gICAgLy8gVXBkYXRlIHRhcmdldCBwb3NpdGlvblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIC8vIENhbGN1bGF0ZSBjYW1lcmEgcG9zaXRpb24gYmFzZWQgb24gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLmFkZCh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICAvLyBTbW9vdGggY2FtZXJhIG1vdmVtZW50XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24ubGVycCh0aGlzLnRhcmdldFBvc2l0aW9uLCB0aGlzLmNvbmZpZy5zbW9vdGhpbmcpO1xuICAgIHRoaXMuY3VycmVudExvb2tBdC5sZXJwKHRoaXMudGFyZ2V0TG9va0F0LCB0aGlzLmNvbmZpZy5zbW9vdGhpbmcpO1xuXG4gICAgLy8gVXBkYXRlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNb3VzZUlucHV0KCk6IHZvaWQge1xuICAgIGNvbnN0IG1vdXNlRGVsdGEgPSB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gICAgXG4gICAgLy8gT25seSByb3RhdGUgY2FtZXJhIHdoZW4gcmlnaHQgbW91c2UgYnV0dG9uIGlzIGhlbGQgZG93blxuICAgIGlmICgobW91c2VEZWx0YS54ICE9PSAwIHx8IG1vdXNlRGVsdGEueSAhPT0gMCkgJiYgdGhpcy5pc1JpZ2h0TW91c2VEb3duKSB7XG4gICAgICAvLyBVcGRhdGUgc3BoZXJpY2FsIGNvb3JkaW5hdGVzIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50XG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSAtPSBtb3VzZURlbHRhLnggKiB0aGlzLmNvbmZpZy5tb3VzZVNlbnNpdGl2aXR5O1xuICAgICAgdGhpcy5zcGhlcmljYWwucGhpIC09IG1vdXNlRGVsdGEueSAqIHRoaXMuY29uZmlnLm1vdXNlU2Vuc2l0aXZpdHk7IC8vIEludmVydGVkIFkgZm9yIG5hdHVyYWwgY2FtZXJhIGZlZWxcblxuICAgICAgLy8gQ2xhbXAgcGhpIHRvIHByZXZlbnQgY2FtZXJhIGZsaXBwaW5nXG4gICAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSxcbiAgICAgICAgdGhpcy5jb25maWcubWluUG9sYXJBbmdsZSxcbiAgICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICAgKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZXRhXG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IE1hdGhVdGlscy5ub3JtYWxpemVBbmdsZSh0aGlzLnNwaGVyaWNhbC50aGV0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIE1vdXNlIGJ1dHRvbiBldmVudHMgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZURvd24nLCAoeyBidXR0b24gfSkgPT4ge1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMikgeyAvLyBSaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgdGhpcy5pc1JpZ2h0TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZVVwJywgKHsgYnV0dG9uIH0pID0+IHtcbiAgICAgIGlmIChidXR0b24gPT09IDIpIHsgLy8gUmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICAgIHRoaXMuaXNSaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW91c2Ugd2hlZWwgZm9yIHpvb20gLSBvbmx5IGFkZCBsaXN0ZW5lciBvbmNlXG4gICAgaWYgKCF0aGlzLndoZWVsTGlzdGVuZXJBZGRlZCkge1xuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ3doZWVsJywgKHsgZGVsdGFZIH0pID0+IHtcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucmFkaXVzICs9IGRlbHRhWSAqIDAuMDE7XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcCh0aGlzLnNwaGVyaWNhbC5yYWRpdXMsIDIsIHRoaXMuY29uZmlnLm1heERpc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53aGVlbExpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJbml0aWFsUG9zaXRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LnNldCgwLCB0aGlzLmNvbmZpZy5oZWlnaHQsIDApO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICAgIFxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBnZXRDYW1lcmFEaXJlY3Rpb24oKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FtZXJhUmlnaHQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRDYW1lcmFEaXJlY3Rpb24oKTtcbiAgICBjb25zdCByaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgcmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpO1xuICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiByaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmFGb3J3YXJkKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5nZXRDYW1lcmFSaWdodCgpO1xuICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCByaWdodCk7XG4gICAgZm9yd2FyZC5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXN0YW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC5yYWRpdXM7XG4gIH1cblxuICBwdWJsaWMgc2V0RGlzdGFuY2UoZGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcChkaXN0YW5jZSwgMiwgdGhpcy5jb25maWcubWF4RGlzdGFuY2UpO1xuICB9XG5cbiAgcHVibGljIGdldEhvcml6b250YWxBbmdsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC50aGV0YTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRWZXJ0aWNhbEFuZ2xlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnBoaTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRBbmdsZXMoaG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSBNYXRoVXRpbHMubm9ybWFsaXplQW5nbGUoaG9yaXpvbnRhbCk7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aFV0aWxzLmNsYW1wKFxuICAgICAgdmVydGljYWwsXG4gICAgICB0aGlzLmNvbmZpZy5taW5Qb2xhckFuZ2xlLFxuICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXRDYW1lcmEoKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSAwO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzbmFwVG9UYXJnZXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gU2FmZXR5IGNoZWNrOiBlbnN1cmUgcG9zaXRpb24gaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnggPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnkgPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKCdDYW1lcmFTeXN0ZW06IFRhcmdldCBwb3NpdGlvbiBpcyBub3QgcHJvcGVybHkgaW5pdGlhbGl6ZWQsIHNraXBwaW5nIHNuYXBUb1RhcmdldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5hZGQodGhpcy50YXJnZXRMb29rQXQpO1xuXG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uY29weSh0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICB0aGlzLmN1cnJlbnRMb29rQXQuY29weSh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5jb3B5KHRoaXMuY3VycmVudFBvc2l0aW9uKTtcbiAgICB0aGlzLmNhbWVyYS5sb29rQXQodGhpcy5jdXJyZW50TG9va0F0KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogUGVyc3BlY3RpdmVDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlNwaGVyaWNhbCIsIlZlY3RvcjMiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNYXRoVXRpbHMiLCJDYW1lcmFTeXN0ZW0iLCJzZXRUYXJnZXQiLCJlbnRpdHkiLCJ0YXJnZXQiLCJzZXRDb25maWciLCJjb25maWciLCJzcGhlcmljYWwiLCJyYWRpdXMiLCJkaXN0YW5jZSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidGFyZ2V0VHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwiaGFuZGxlTW91c2VJbnB1dCIsInRhcmdldExvb2tBdCIsImNvcHkiLCJwb3NpdGlvbiIsInkiLCJoZWlnaHQiLCJ0YXJnZXRQb3NpdGlvbiIsInNldEZyb21TcGhlcmljYWwiLCJhZGQiLCJjdXJyZW50UG9zaXRpb24iLCJsZXJwIiwic21vb3RoaW5nIiwiY3VycmVudExvb2tBdCIsImNhbWVyYSIsImxvb2tBdCIsIm1vdXNlRGVsdGEiLCJpbnB1dE1hbmFnZXIiLCJnZXRNb3VzZURlbHRhIiwieCIsImlzUmlnaHRNb3VzZURvd24iLCJ0aGV0YSIsIm1vdXNlU2Vuc2l0aXZpdHkiLCJwaGkiLCJjbGFtcCIsIm1pblBvbGFyQW5nbGUiLCJtYXhQb2xhckFuZ2xlIiwibm9ybWFsaXplQW5nbGUiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwib24iLCJidXR0b24iLCJ3aGVlbExpc3RlbmVyQWRkZWQiLCJkZWx0YVkiLCJtYXhEaXN0YW5jZSIsInNldHVwSW5pdGlhbFBvc2l0aW9uIiwic2V0IiwiZ2V0Q2FtZXJhRGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJnZXRDYW1lcmFSaWdodCIsInJpZ2h0IiwiY3Jvc3NWZWN0b3JzIiwibm9ybWFsaXplIiwiZ2V0Q2FtZXJhRm9yd2FyZCIsImZvcndhcmQiLCJnZXREaXN0YW5jZSIsInNldERpc3RhbmNlIiwiZ2V0SG9yaXpvbnRhbEFuZ2xlIiwiZ2V0VmVydGljYWxBbmdsZSIsInNldEFuZ2xlcyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInJlc2V0Q2FtZXJhIiwiTWF0aCIsIlBJIiwic25hcFRvVGFyZ2V0IiwidW5kZWZpbmVkIiwieiIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0Q2FtZXJhIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CameraSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CollisionSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/CollisionSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionSystem: function() { return /* binding */ CollisionSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/SpatialHash */ \"(app-pages-browser)/./src/utils/SpatialHash.ts\");\n// Collision system for efficient collision detection and response\n\n\n\n\n\n\nclass CollisionSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for trigger detection and broad phase\n        this.updateSpatialHash(entities);\n        this.detectCollisions(entities);\n        this.processCollisionCallbacks();\n        // Also resolve collisions in update() to ensure immediate response\n        this.resolveCollisions();\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics collision response\n        this.resolveCollisions();\n    }\n    updateSpatialHash(entities) {\n        // Update spatial hash with current entity positions\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) {\n                this.spatialHash.remove(entity);\n                continue;\n            }\n            // Update collider bounds\n            collider.updateBounds(transform.getWorldPosition());\n            // Update spatial hash\n            this.spatialHash.update(entity, collider.bounds);\n        }\n    }\n    detectCollisions(entities) {\n        this.collisionPairs.length = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        const processedPairs = new Set();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) continue;\n            // Query spatial hash for potential collisions\n            const candidates = this.spatialHash.query(collider.bounds);\n            for (const candidate of candidates){\n                const otherEntity = candidate.entity;\n                // Skip self\n                if (entity.id === otherEntity.id) continue;\n                // Create unique pair key (smaller ID first)\n                const pairKey = entity.id < otherEntity.id ? \"\".concat(entity.id, \"-\").concat(otherEntity.id) : \"\".concat(otherEntity.id, \"-\").concat(entity.id);\n                // Skip if already processed this pair\n                if (processedPairs.has(pairKey)) continue;\n                processedPairs.add(pairKey);\n                const otherTransform = otherEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const otherCollider = otherEntity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n                if (!(otherTransform === null || otherTransform === void 0 ? void 0 : otherTransform.enabled) || !(otherCollider === null || otherCollider === void 0 ? void 0 : otherCollider.enabled)) continue;\n                // Check if colliders can collide\n                if (!collider.canCollideWith(otherCollider)) continue;\n                this.collisionChecks++;\n                // Precise collision detection\n                if (collider.intersects(otherCollider, transform.getWorldPosition(), otherTransform.getWorldPosition())) {\n                    this.actualCollisions++;\n                    // Debug logging for pillar collisions\n                    if (collider.layer === 2 && otherCollider.layer === 16 || collider.layer === 16 && otherCollider.layer === 2) {}\n                    const pair = {\n                        entityA: entity,\n                        entityB: otherEntity,\n                        colliderA: collider,\n                        colliderB: otherCollider\n                    };\n                    this.collisionPairs.push(pair);\n                }\n            }\n        }\n    }\n    processCollisionCallbacks() {\n        const currentCollisions = new Map();\n        // Process current collisions\n        for (const pair of this.collisionPairs){\n            const pairKey = pair.entityA.id < pair.entityB.id ? \"\".concat(pair.entityA.id, \"-\").concat(pair.entityB.id) : \"\".concat(pair.entityB.id, \"-\").concat(pair.entityA.id);\n            currentCollisions.set(pairKey, pair);\n            // Check if this is a new collision\n            if (!this.activeCollisions.has(pairKey)) {\n                // New collision - trigger enter events\n                this.triggerCollisionEnter(pair);\n            } else {\n                // Ongoing collision - trigger stay events\n                this.triggerCollisionStay(pair);\n            }\n        }\n        // Check for collisions that ended\n        this.activeCollisions.forEach((pair, pairKey)=>{\n            if (!currentCollisions.has(pairKey)) {\n                // Collision ended - trigger exit events\n                this.triggerCollisionExit(pair);\n            }\n        });\n        // Update active collisions\n        this.activeCollisions = currentCollisions;\n    }\n    triggerCollisionEnter(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerEnter, _pair_colliderA, _pair_colliderB_onTriggerEnter, _pair_colliderB;\n            (_pair_colliderA_onTriggerEnter = (_pair_colliderA = pair.colliderA).onTriggerEnter) === null || _pair_colliderA_onTriggerEnter === void 0 ? void 0 : _pair_colliderA_onTriggerEnter.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerEnter = (_pair_colliderB = pair.colliderB).onTriggerEnter) === null || _pair_colliderB_onTriggerEnter === void 0 ? void 0 : _pair_colliderB_onTriggerEnter.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionEnter, _pair_colliderA1, _pair_colliderB_onCollisionEnter, _pair_colliderB1;\n            (_pair_colliderA_onCollisionEnter = (_pair_colliderA1 = pair.colliderA).onCollisionEnter) === null || _pair_colliderA_onCollisionEnter === void 0 ? void 0 : _pair_colliderA_onCollisionEnter.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionEnter = (_pair_colliderB1 = pair.colliderB).onCollisionEnter) === null || _pair_colliderB_onCollisionEnter === void 0 ? void 0 : _pair_colliderB_onCollisionEnter.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionStay(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerStay, _pair_colliderA, _pair_colliderB_onTriggerStay, _pair_colliderB;\n            (_pair_colliderA_onTriggerStay = (_pair_colliderA = pair.colliderA).onTriggerStay) === null || _pair_colliderA_onTriggerStay === void 0 ? void 0 : _pair_colliderA_onTriggerStay.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerStay = (_pair_colliderB = pair.colliderB).onTriggerStay) === null || _pair_colliderB_onTriggerStay === void 0 ? void 0 : _pair_colliderB_onTriggerStay.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionStay, _pair_colliderA1, _pair_colliderB_onCollisionStay, _pair_colliderB1;\n            (_pair_colliderA_onCollisionStay = (_pair_colliderA1 = pair.colliderA).onCollisionStay) === null || _pair_colliderA_onCollisionStay === void 0 ? void 0 : _pair_colliderA_onCollisionStay.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionStay = (_pair_colliderB1 = pair.colliderB).onCollisionStay) === null || _pair_colliderB_onCollisionStay === void 0 ? void 0 : _pair_colliderB_onCollisionStay.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionExit(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerExit, _pair_colliderA, _pair_colliderB_onTriggerExit, _pair_colliderB;\n            (_pair_colliderA_onTriggerExit = (_pair_colliderA = pair.colliderA).onTriggerExit) === null || _pair_colliderA_onTriggerExit === void 0 ? void 0 : _pair_colliderA_onTriggerExit.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerExit = (_pair_colliderB = pair.colliderB).onTriggerExit) === null || _pair_colliderB_onTriggerExit === void 0 ? void 0 : _pair_colliderB_onTriggerExit.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionExit, _pair_colliderA1, _pair_colliderB_onCollisionExit, _pair_colliderB1;\n            (_pair_colliderA_onCollisionExit = (_pair_colliderA1 = pair.colliderA).onCollisionExit) === null || _pair_colliderA_onCollisionExit === void 0 ? void 0 : _pair_colliderA_onCollisionExit.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionExit = (_pair_colliderB1 = pair.colliderB).onCollisionExit) === null || _pair_colliderB_onCollisionExit === void 0 ? void 0 : _pair_colliderB_onCollisionExit.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    resolveCollisions() {\n        // Resolve physical collisions (non-trigger)\n        for (const pair of this.collisionPairs){\n            if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n                continue; // Skip triggers\n            }\n            this.resolveCollision(pair);\n        }\n    }\n    resolveCollision(pair) {\n        const transformA = pair.entityA.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const transformB = pair.entityB.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const posA = transformA.getWorldPosition();\n        const posB = transformB.getWorldPosition();\n        // Calculate separation vector with safety checks\n        if (!posA || !posA.clone || !posB || !posB.clone) {\n            return;\n        }\n        const separation = posA.clone().sub(posB);\n        const distance = separation.length();\n        if (distance === 0) {\n            // Objects are at exact same position, separate along Y axis\n            separation.set(0, 1, 0);\n        } else {\n            separation.normalize();\n        }\n        // Calculate required separation distance\n        let requiredSeparation = 0;\n        if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"sphere\") {\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"cylinder\") {\n            // Player (sphere) vs Pillar (cylinder) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"cylinder\" && pair.colliderB.type === \"sphere\") {\n            // Pillar (cylinder) vs Player (sphere) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else {\n            // For other shapes, use a simple approximation\n            const radiusA = this.getApproximateRadius(pair.colliderA);\n            const radiusB = this.getApproximateRadius(pair.colliderB);\n            requiredSeparation = radiusA + radiusB;\n        }\n        const overlap = requiredSeparation - distance;\n        if (overlap > 0) {\n            // Debug logging for pillar collisions\n            if (pair.colliderA.layer === 2 && pair.colliderB.layer === 16 || pair.colliderA.layer === 16 && pair.colliderB.layer === 2) {}\n            // For static objects (like pillars), apply stronger separation to prevent penetration\n            let separationMultiplier = 1.0;\n            if (pair.colliderA.isStatic || pair.colliderB.isStatic) {\n                separationMultiplier = 1.1; // 10% extra separation for static objects\n            }\n            // Separate objects - use enhanced separation for static objects\n            const separationVector = separation.multiplyScalar(overlap * separationMultiplier);\n            // Check if entities have Movement components for intelligent separation distribution\n            const movementA = pair.entityA.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            const movementB = pair.entityB.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Determine separation distribution based on Movement components and static status\n            let separationFactorA = 0.5; // Default: split separation equally\n            let separationFactorB = 0.5;\n            if (pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // A is static, B moves - B takes all separation\n                separationFactorA = 0;\n                separationFactorB = 1;\n            } else if (!pair.colliderA.isStatic && pair.colliderB.isStatic) {\n                // B is static, A moves - A takes all separation\n                separationFactorA = 1;\n                separationFactorB = 0;\n            } else if (!pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // Both non-static - check for PVP scenario (both players)\n                const isPlayerA = pair.colliderA.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER;\n                const isPlayerB = pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER || pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.ENEMY;\n                if (isPlayerA && isPlayerB) {\n                    // PVP collision: check canMove property for fair collision resolution\n                    const canMoveA = movementA ? movementA.canMove : false;\n                    const canMoveB = movementB ? movementB.canMove : false;\n                    if (canMoveA && canMoveB) {\n                        // Both players can move - equal distribution for fair gameplay\n                        separationFactorA = 0.5;\n                        separationFactorB = 0.5;\n                    } else if (canMoveA && !canMoveB) {\n                        // Only A can move (local player), B is position-synced (remote player)\n                        separationFactorA = 1.0;\n                        separationFactorB = 0.0;\n                    } else if (!canMoveA && canMoveB) {\n                        // Only B can move (local player), A is position-synced (remote player)\n                        separationFactorA = 0.0;\n                        separationFactorB = 1.0;\n                    } else {\n                        // Neither can move - no separation (shouldn't happen in PVP)\n                        separationFactorA = 0.0;\n                        separationFactorB = 0.0;\n                    }\n                } else {\n                    // Non-PVP collision - distribute based on Movement components\n                    if (movementA && !movementB) {\n                        // A has Movement, B doesn't\n                        separationFactorA = 0.8;\n                        separationFactorB = 0.2;\n                    } else if (!movementA && movementB) {\n                        // B has Movement, A doesn't\n                        separationFactorA = 0.2;\n                        separationFactorB = 0.8;\n                    }\n                // If both have Movement or neither has Movement, use equal distribution (0.5, 0.5)\n                }\n            }\n            // Apply separation with calculated factors\n            if (separationFactorA > 0 && separationVector && separationVector.clone) {\n                const separationA = separationVector.clone().multiplyScalar(separationFactorA);\n                transformA.translate(separationA.x, separationA.y, separationA.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementA && pair.colliderB.isStatic && movementA.velocity && movementA.velocity.clone && separation && separation.clone) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementA.velocity.clone().projectOnVector(separation.clone().negate());\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementA.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n            if (separationFactorB > 0) {\n                const separationB = separationVector.clone().multiplyScalar(-separationFactorB);\n                transformB.translate(separationB.x, separationB.y, separationB.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementB && pair.colliderA.isStatic) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementB.velocity.clone().projectOnVector(separation);\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementB.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n        }\n    }\n    getApproximateRadius(collider) {\n        switch(collider.type){\n            case \"sphere\":\n                return collider.radius;\n            case \"box\":\n                return Math.max(collider.size.x, collider.size.y, collider.size.z) * 0.5;\n            case \"capsule\":\n            case \"cylinder\":\n                return Math.max(collider.radius, collider.height * 0.5);\n            default:\n                return 0.5;\n        }\n    }\n    // Utility methods for other systems\n    queryColliders(bounds) {\n        const entries = this.spatialHash.query(bounds);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersRadius(center, radius) {\n        const entries = this.spatialHash.queryRadius(center, radius);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersPoint(point) {\n        const entries = this.spatialHash.queryPoint(point);\n        return entries.map((entry)=>entry.entity);\n    }\n    getCollidersInLayer(layer, bounds) {\n        const candidates = bounds ? this.spatialHash.query(bounds) : Array.from(this.spatialHash[\"entityCells\"].keys()).map((id)=>{\n            const entries = this.spatialHash.query(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3().setFromCenterAndSize(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1000, 1000, 1000)));\n            return entries.find((e)=>e.entity.id === id);\n        }).filter(Boolean);\n        return candidates.filter((entry)=>{\n            const collider = entry.entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            return collider && collider.layer === layer;\n        }).map((entry)=>entry.entity);\n    }\n    // Performance and debugging\n    getPerformanceStats() {\n        return {\n            collisionChecks: this.collisionChecks,\n            actualCollisions: this.actualCollisions,\n            activeCollisions: this.activeCollisions.size,\n            spatialHashStats: this.spatialHash.getStats()\n        };\n    }\n    onEntityRemoved(entity) {\n        // Clean up spatial hash when entity is removed\n        this.spatialHash.remove(entity);\n        // Remove from active collisions\n        const keysToRemove = [];\n        this.activeCollisions.forEach((pair, key)=>{\n            if (pair.entityA.id === entity.id || pair.entityB.id === entity.id) {\n                keysToRemove.push(key);\n            }\n        });\n        for (const key of keysToRemove){\n            this.activeCollisions.delete(key);\n        }\n    }\n    onDisable() {\n        this.spatialHash.clear();\n        this.activeCollisions.clear();\n        this.collisionPairs.length = 0;\n    }\n    constructor(cellSize = 5){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider\n        ];\n        this.collisionPairs = [];\n        this.activeCollisions = new Map() // Track ongoing collisions\n        ;\n        // Performance tracking\n        this.lastUpdateTime = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        this.priority = 15; // Run before movement but after input\n        this.spatialHash = new _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__.SpatialHash(cellSize);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBQ1o7QUFDVDtBQUVVO0FBQ0Y7QUFDZ0I7QUFDbkI7QUFTM0MsTUFBTVEsd0JBQXdCTixzREFBYUE7SUFpQnpDTyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDhEQUE4RDtRQUM5RCxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtRQUN2QixJQUFJLENBQUNHLGdCQUFnQixDQUFDSDtRQUN0QixJQUFJLENBQUNJLHlCQUF5QjtRQUM5QixtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDeEI7SUFFT0MsWUFBWU4sUUFBa0IsRUFBRU8sY0FBc0IsRUFBUTtRQUNuRSw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDRixpQkFBaUI7SUFDeEI7SUFFUUgsa0JBQWtCRixRQUFrQixFQUFRO1FBQ2xELG9EQUFvRDtRQUNwRCxLQUFLLE1BQU1RLFVBQVVSLFNBQVU7WUFDN0IsTUFBTVMsWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixXQUFXSCxPQUFPRSxZQUFZLENBQUNmLDhEQUFRQTtZQUU3QyxJQUFJLENBQUNjLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUNOO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCRyxTQUFTSSxZQUFZLENBQUNOLFVBQVVPLGdCQUFnQjtZQUVoRCxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDSCxXQUFXLENBQUNkLE1BQU0sQ0FBQ1MsUUFBUUcsU0FBU00sTUFBTTtRQUNqRDtJQUNGO0lBRVFkLGlCQUFpQkgsUUFBa0IsRUFBUTtRQUNqRCxJQUFJLENBQUNrQixjQUFjLENBQUNDLE1BQU0sR0FBRztRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FB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RixNQUFNLENBQUNEO1FBQy9CO0lBQ0Y7SUFFT0UsWUFBa0I7UUFDdkIsSUFBSSxDQUFDckgsV0FBVyxDQUFDc0gsS0FBSztRQUN0QixJQUFJLENBQUNyRixnQkFBZ0IsQ0FBQ3FGLEtBQUs7UUFDM0IsSUFBSSxDQUFDakgsY0FBYyxDQUFDQyxNQUFNLEdBQUc7SUFDL0I7SUF2WkFpSCxZQUFZQyxXQUFtQixDQUFDLENBQUU7UUFDaEMsS0FBSzthQVhTQyxxQkFBcUI7WUFBQzdJLGdFQUFTQTtZQUFFRSw4REFBUUE7U0FBQzthQUVsRHVCLGlCQUFrQyxFQUFFO2FBQ3BDNEIsbUJBQW1CLElBQUlGLE1BQThCLDJCQUEyQjs7UUFFeEYsdUJBQXVCO2FBQ2YyRixpQkFBaUI7YUFDakJuSCxrQkFBa0I7YUFDbEJDLG1CQUFtQjtRQUl6QixJQUFJLENBQUNtSCxRQUFRLEdBQUcsSUFBSSxzQ0FBc0M7UUFDMUQsSUFBSSxDQUFDM0gsV0FBVyxHQUFHLElBQUloQiwyREFBV0EsQ0FBQ3dJO0lBQ3JDO0FBb1pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cz9jOWVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbGxpc2lvbiBzeXN0ZW0gZm9yIGVmZmljaWVudCBjb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxuaW1wb3J0IHsgVmVjdG9yMywgQm94MyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBTcGF0aWFsSGFzaCB9IGZyb20gJ0AvdXRpbHMvU3BhdGlhbEhhc2gnO1xuXG5pbnRlcmZhY2UgQ29sbGlzaW9uUGFpciB7XG4gIGVudGl0eUE6IEVudGl0eTtcbiAgZW50aXR5QjogRW50aXR5O1xuICBjb2xsaWRlckE6IENvbGxpZGVyO1xuICBjb2xsaWRlckI6IENvbGxpZGVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgUGh5c2ljc1N5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBDb2xsaWRlcl07XG4gIHByaXZhdGUgc3BhdGlhbEhhc2g6IFNwYXRpYWxIYXNoO1xuICBwcml2YXRlIGNvbGxpc2lvblBhaXJzOiBDb2xsaXNpb25QYWlyW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7IC8vIFRyYWNrIG9uZ29pbmcgY29sbGlzaW9uc1xuICBcbiAgLy8gUGVyZm9ybWFuY2UgdHJhY2tpbmdcbiAgcHJpdmF0ZSBsYXN0VXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgY29sbGlzaW9uQ2hlY2tzID0gMDtcbiAgcHJpdmF0ZSBhY3R1YWxDb2xsaXNpb25zID0gMDtcblxuICBjb25zdHJ1Y3RvcihjZWxsU2l6ZTogbnVtYmVyID0gNSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDE1OyAvLyBSdW4gYmVmb3JlIG1vdmVtZW50IGJ1dCBhZnRlciBpbnB1dFxuICAgIHRoaXMuc3BhdGlhbEhhc2ggPSBuZXcgU3BhdGlhbEhhc2goY2VsbFNpemUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGV2ZXJ5IGZyYW1lIGZvciB0cmlnZ2VyIGRldGVjdGlvbiBhbmQgYnJvYWQgcGhhc2VcbiAgICB0aGlzLnVwZGF0ZVNwYXRpYWxIYXNoKGVudGl0aWVzKTtcbiAgICB0aGlzLmRldGVjdENvbGxpc2lvbnMoZW50aXRpZXMpO1xuICAgIHRoaXMucHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcygpO1xuICAgIC8vIEFsc28gcmVzb2x2ZSBjb2xsaXNpb25zIGluIHVwZGF0ZSgpIHRvIGVuc3VyZSBpbW1lZGlhdGUgcmVzcG9uc2VcbiAgICB0aGlzLnJlc29sdmVDb2xsaXNpb25zKCk7XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzIGNvbGxpc2lvbiByZXNwb25zZVxuICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3BhdGlhbEhhc2goZW50aXRpZXM6IEVudGl0eVtdKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaCB3aXRoIGN1cnJlbnQgZW50aXR5IHBvc2l0aW9uc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWNvbGxpZGVyLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xsaWRlciBib3VuZHNcbiAgICAgIGNvbGxpZGVyLnVwZGF0ZUJvdW5kcyh0cmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHNwYXRpYWwgaGFzaFxuICAgICAgdGhpcy5zcGF0aWFsSGFzaC51cGRhdGUoZW50aXR5LCBjb2xsaWRlci5ib3VuZHMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0Q29sbGlzaW9ucyhlbnRpdGllczogRW50aXR5W10pOiB2b2lkIHtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jb2xsaXNpb25DaGVja3MgPSAwO1xuICAgIHRoaXMuYWN0dWFsQ29sbGlzaW9ucyA9IDA7XG5cbiAgICBjb25zdCBwcm9jZXNzZWRQYWlycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhY29sbGlkZXIuZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFF1ZXJ5IHNwYXRpYWwgaGFzaCBmb3IgcG90ZW50aWFsIGNvbGxpc2lvbnNcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KGNvbGxpZGVyLmJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJFbnRpdHkgPSBjYW5kaWRhdGUuZW50aXR5O1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IG90aGVyRW50aXR5LmlkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDcmVhdGUgdW5pcXVlIHBhaXIga2V5IChzbWFsbGVyIElEIGZpcnN0KVxuICAgICAgICBjb25zdCBwYWlyS2V5ID0gZW50aXR5LmlkIDwgb3RoZXJFbnRpdHkuaWQgPyBcbiAgICAgICAgICBgJHtlbnRpdHkuaWR9LSR7b3RoZXJFbnRpdHkuaWR9YCA6IFxuICAgICAgICAgIGAke290aGVyRW50aXR5LmlkfS0ke2VudGl0eS5pZH1gO1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBwYWlyXG4gICAgICAgIGlmIChwcm9jZXNzZWRQYWlycy5oYXMocGFpcktleSkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9jZXNzZWRQYWlycy5hZGQocGFpcktleSk7XG5cbiAgICAgICAgY29uc3Qgb3RoZXJUcmFuc2Zvcm0gPSBvdGhlckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgICAgY29uc3Qgb3RoZXJDb2xsaWRlciA9IG90aGVyRW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG5cbiAgICAgICAgaWYgKCFvdGhlclRyYW5zZm9ybT8uZW5hYmxlZCB8fCAhb3RoZXJDb2xsaWRlcj8uZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgY29sbGlkZXJzIGNhbiBjb2xsaWRlXG4gICAgICAgIGlmICghY29sbGlkZXIuY2FuQ29sbGlkZVdpdGgob3RoZXJDb2xsaWRlcikpIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQ2hlY2tzKys7XG5cbiAgICAgICAgLy8gUHJlY2lzZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIGlmIChjb2xsaWRlci5pbnRlcnNlY3RzKG90aGVyQ29sbGlkZXIsIHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCksIG90aGVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKSkpIHtcbiAgICAgICAgICB0aGlzLmFjdHVhbENvbGxpc2lvbnMrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgICAgIGlmICgoY29sbGlkZXIubGF5ZXIgPT09IDIgJiYgb3RoZXJDb2xsaWRlci5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgICAgICAoY29sbGlkZXIubGF5ZXIgPT09IDE2ICYmIG90aGVyQ29sbGlkZXIubGF5ZXIgPT09IDIpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhaXI6IENvbGxpc2lvblBhaXIgPSB7XG4gICAgICAgICAgICBlbnRpdHlBOiBlbnRpdHksXG4gICAgICAgICAgICBlbnRpdHlCOiBvdGhlckVudGl0eSxcbiAgICAgICAgICAgIGNvbGxpZGVyQTogY29sbGlkZXIsXG4gICAgICAgICAgICBjb2xsaWRlckI6IG90aGVyQ29sbGlkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7XG5cbiAgICAvLyBQcm9jZXNzIGN1cnJlbnQgY29sbGlzaW9uc1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLmNvbGxpc2lvblBhaXJzKSB7XG4gICAgICBjb25zdCBwYWlyS2V5ID0gcGFpci5lbnRpdHlBLmlkIDwgcGFpci5lbnRpdHlCLmlkID8gXG4gICAgICAgIGAke3BhaXIuZW50aXR5QS5pZH0tJHtwYWlyLmVudGl0eUIuaWR9YCA6IFxuICAgICAgICBgJHtwYWlyLmVudGl0eUIuaWR9LSR7cGFpci5lbnRpdHlBLmlkfWA7XG5cbiAgICAgIGN1cnJlbnRDb2xsaXNpb25zLnNldChwYWlyS2V5LCBwYWlyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5hY3RpdmVDb2xsaXNpb25zLmhhcyhwYWlyS2V5KSkge1xuICAgICAgICAvLyBOZXcgY29sbGlzaW9uIC0gdHJpZ2dlciBlbnRlciBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmdvaW5nIGNvbGxpc2lvbiAtIHRyaWdnZXIgc3RheSBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uU3RheShwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB0aGF0IGVuZGVkXG4gICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmZvckVhY2goKHBhaXIsIHBhaXJLZXkpID0+IHtcbiAgICAgIGlmICghY3VycmVudENvbGxpc2lvbnMuaGFzKHBhaXJLZXkpKSB7XG4gICAgICAgIC8vIENvbGxpc2lvbiBlbmRlZCAtIHRyaWdnZXIgZXhpdCBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRXhpdChwYWlyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucyA9IGN1cnJlbnRDb2xsaXNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25UcmlnZ2VyRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckVudGVyPy4ocGFpci5jb2xsaWRlckEsIHBhaXIuZW50aXR5QSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbGxpc2lvbiBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25TdGF5KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25TdGF5Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvblN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25FeGl0KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25FeGl0Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvbkV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb25zKCk6IHZvaWQge1xuICAgIC8vIFJlc29sdmUgcGh5c2ljYWwgY29sbGlzaW9ucyAobm9uLXRyaWdnZXIpXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuY29sbGlzaW9uUGFpcnMpIHtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRyaWdnZXJzXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwYWlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb24ocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybUEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IHRyYW5zZm9ybUIgPSBwYWlyLmVudGl0eUIuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuXG4gICAgY29uc3QgcG9zQSA9IHRyYW5zZm9ybUEuZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBvc0IgPSB0cmFuc2Zvcm1CLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgIC8vIENhbGN1bGF0ZSBzZXBhcmF0aW9uIHZlY3RvciB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICBpZiAoIXBvc0EgfHwgIXBvc0EuY2xvbmUgfHwgIXBvc0IgfHwgIXBvc0IuY2xvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VwYXJhdGlvbiA9IHBvc0EuY2xvbmUoKS5zdWIocG9zQik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBzZXBhcmF0aW9uLmxlbmd0aCgpO1xuXG4gICAgaWYgKGRpc3RhbmNlID09PSAwKSB7XG4gICAgICAvLyBPYmplY3RzIGFyZSBhdCBleGFjdCBzYW1lIHBvc2l0aW9uLCBzZXBhcmF0ZSBhbG9uZyBZIGF4aXNcbiAgICAgIHNlcGFyYXRpb24uc2V0KDAsIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXBhcmF0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSByZXF1aXJlZCBzZXBhcmF0aW9uIGRpc3RhbmNlXG4gICAgbGV0IHJlcXVpcmVkU2VwYXJhdGlvbiA9IDA7XG4gICAgXG4gICAgaWYgKHBhaXIuY29sbGlkZXJBLnR5cGUgPT09ICdzcGhlcmUnICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnc3BoZXJlJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnY3lsaW5kZXInKSB7XG4gICAgICAvLyBQbGF5ZXIgKHNwaGVyZSkgdnMgUGlsbGFyIChjeWxpbmRlcikgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnY3lsaW5kZXInICYmIHBhaXIuY29sbGlkZXJCLnR5cGUgPT09ICdzcGhlcmUnKSB7XG4gICAgICAvLyBQaWxsYXIgKGN5bGluZGVyKSB2cyBQbGF5ZXIgKHNwaGVyZSkgY29sbGlzaW9uXG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSBwYWlyLmNvbGxpZGVyQS5yYWRpdXMgKyBwYWlyLmNvbGxpZGVyQi5yYWRpdXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBvdGhlciBzaGFwZXMsIHVzZSBhIHNpbXBsZSBhcHByb3hpbWF0aW9uXG4gICAgICBjb25zdCByYWRpdXNBID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQSk7XG4gICAgICBjb25zdCByYWRpdXNCID0gdGhpcy5nZXRBcHByb3hpbWF0ZVJhZGl1cyhwYWlyLmNvbGxpZGVyQik7XG4gICAgICByZXF1aXJlZFNlcGFyYXRpb24gPSByYWRpdXNBICsgcmFkaXVzQjtcbiAgICB9XG5cbiAgICBjb25zdCBvdmVybGFwID0gcmVxdWlyZWRTZXBhcmF0aW9uIC0gZGlzdGFuY2U7XG4gICAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBwaWxsYXIgY29sbGlzaW9uc1xuICAgICAgaWYgKChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMiAmJiBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gMTYpIHx8IFxuICAgICAgICAgIChwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gMTYgJiYgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IDIpKSB7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvciBzdGF0aWMgb2JqZWN0cyAobGlrZSBwaWxsYXJzKSwgYXBwbHkgc3Ryb25nZXIgc2VwYXJhdGlvbiB0byBwcmV2ZW50IHBlbmV0cmF0aW9uXG4gICAgICBsZXQgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjA7XG4gICAgICBpZiAocGFpci5jb2xsaWRlckEuaXNTdGF0aWMgfHwgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgc2VwYXJhdGlvbk11bHRpcGxpZXIgPSAxLjE7IC8vIDEwJSBleHRyYSBzZXBhcmF0aW9uIGZvciBzdGF0aWMgb2JqZWN0c1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXBhcmF0ZSBvYmplY3RzIC0gdXNlIGVuaGFuY2VkIHNlcGFyYXRpb24gZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICBjb25zdCBzZXBhcmF0aW9uVmVjdG9yID0gc2VwYXJhdGlvbi5tdWx0aXBseVNjYWxhcihvdmVybGFwICogc2VwYXJhdGlvbk11bHRpcGxpZXIpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdGllcyBoYXZlIE1vdmVtZW50IGNvbXBvbmVudHMgZm9yIGludGVsbGlnZW50IHNlcGFyYXRpb24gZGlzdHJpYnV0aW9uXG4gICAgICBjb25zdCBtb3ZlbWVudEEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgIGNvbnN0IG1vdmVtZW50QiA9IHBhaXIuZW50aXR5Qi5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgc2VwYXJhdGlvbiBkaXN0cmlidXRpb24gYmFzZWQgb24gTW92ZW1lbnQgY29tcG9uZW50cyBhbmQgc3RhdGljIHN0YXR1c1xuICAgICAgbGV0IHNlcGFyYXRpb25GYWN0b3JBID0gMC41OyAvLyBEZWZhdWx0OiBzcGxpdCBzZXBhcmF0aW9uIGVxdWFsbHlcbiAgICAgIGxldCBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuNTtcbiAgICAgIFxuICAgICAgaWYgKHBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmICFwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBBIGlzIHN0YXRpYywgQiBtb3ZlcyAtIEIgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBCIGlzIHN0YXRpYywgQSBtb3ZlcyAtIEEgdGFrZXMgYWxsIHNlcGFyYXRpb25cbiAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAxO1xuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyAmJiAhcGFpci5jb2xsaWRlckIuaXNTdGF0aWMpIHtcbiAgICAgICAgLy8gQm90aCBub24tc3RhdGljIC0gY2hlY2sgZm9yIFBWUCBzY2VuYXJpbyAoYm90aCBwbGF5ZXJzKVxuICAgICAgICBjb25zdCBpc1BsYXllckEgPSBwYWlyLmNvbGxpZGVyQS5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSO1xuICAgICAgICBjb25zdCBpc1BsYXllckIgPSBwYWlyLmNvbGxpZGVyQi5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHx8IHBhaXIuY29sbGlkZXJCLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1BsYXllckEgJiYgaXNQbGF5ZXJCKSB7XG4gICAgICAgICAgLy8gUFZQIGNvbGxpc2lvbjogY2hlY2sgY2FuTW92ZSBwcm9wZXJ0eSBmb3IgZmFpciBjb2xsaXNpb24gcmVzb2x1dGlvblxuICAgICAgICAgIGNvbnN0IGNhbk1vdmVBID0gbW92ZW1lbnRBID8gbW92ZW1lbnRBLmNhbk1vdmUgOiBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjYW5Nb3ZlQiA9IG1vdmVtZW50QiA/IG1vdmVtZW50Qi5jYW5Nb3ZlIDogZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBsYXllcnMgY2FuIG1vdmUgLSBlcXVhbCBkaXN0cmlidXRpb24gZm9yIGZhaXIgZ2FtZXBsYXlcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC41O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5Nb3ZlQSAmJiAhY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgQSBjYW4gbW92ZSAobG9jYWwgcGxheWVyKSwgQiBpcyBwb3NpdGlvbi1zeW5jZWQgKHJlbW90ZSBwbGF5ZXIpXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDEuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC4wO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhbk1vdmVBICYmIGNhbk1vdmVCKSB7XG4gICAgICAgICAgICAvLyBPbmx5IEIgY2FuIG1vdmUgKGxvY2FsIHBsYXllciksIEEgaXMgcG9zaXRpb24tc3luY2VkIChyZW1vdGUgcGxheWVyKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDEuMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTmVpdGhlciBjYW4gbW92ZSAtIG5vIHNlcGFyYXRpb24gKHNob3VsZG4ndCBoYXBwZW4gaW4gUFZQKVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjA7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLVBWUCBjb2xsaXNpb24gLSBkaXN0cmlidXRlIGJhc2VkIG9uIE1vdmVtZW50IGNvbXBvbmVudHNcbiAgICAgICAgICBpZiAobW92ZW1lbnRBICYmICFtb3ZlbWVudEIpIHtcbiAgICAgICAgICAgIC8vIEEgaGFzIE1vdmVtZW50LCBCIGRvZXNuJ3RcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMC44O1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjI7XG4gICAgICAgICAgfSBlbHNlIGlmICghbW92ZW1lbnRBICYmIG1vdmVtZW50Qikge1xuICAgICAgICAgICAgLy8gQiBoYXMgTW92ZW1lbnQsIEEgZG9lc24ndFxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjI7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgYm90aCBoYXZlIE1vdmVtZW50IG9yIG5laXRoZXIgaGFzIE1vdmVtZW50LCB1c2UgZXF1YWwgZGlzdHJpYnV0aW9uICgwLjUsIDAuNSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBzZXBhcmF0aW9uIHdpdGggY2FsY3VsYXRlZCBmYWN0b3JzXG4gICAgICBpZiAoc2VwYXJhdGlvbkZhY3RvckEgPiAwICYmIHNlcGFyYXRpb25WZWN0b3IgJiYgc2VwYXJhdGlvblZlY3Rvci5jbG9uZSkge1xuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQSA9IHNlcGFyYXRpb25WZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzZXBhcmF0aW9uRmFjdG9yQSk7XG4gICAgICAgIHRyYW5zZm9ybUEudHJhbnNsYXRlKHNlcGFyYXRpb25BLngsIHNlcGFyYXRpb25BLnksIHNlcGFyYXRpb25BLnopO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxzbyBzdG9wIG1vdmVtZW50IHZlbG9jaXR5IGZvciBwbGF5ZXIgd2hlbiBoaXR0aW5nIHN0YXRpYyBvYmplY3RzXG4gICAgICAgIGlmIChtb3ZlbWVudEEgJiYgcGFpci5jb2xsaWRlckIuaXNTdGF0aWMgJiYgbW92ZW1lbnRBLnZlbG9jaXR5ICYmIG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSAmJiBzZXBhcmF0aW9uICYmIHNlcGFyYXRpb24uY2xvbmUpIHtcbiAgICAgICAgICAvLyBQcm9qZWN0IHZlbG9jaXR5IHRvIHJlbW92ZSBjb21wb25lbnQgdG93YXJkcyB0aGUgc3RhdGljIG9iamVjdFxuICAgICAgICAgIGNvbnN0IHZlbG9jaXR5VG93YXJkc1N0YXRpYyA9IG1vdmVtZW50QS52ZWxvY2l0eS5jbG9uZSgpLnByb2plY3RPblZlY3RvcihzZXBhcmF0aW9uLmNsb25lKCkubmVnYXRlKCkpO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEEudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzZXBhcmF0aW9uRmFjdG9yQiA+IDApIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbkIgPSBzZXBhcmF0aW9uVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLXNlcGFyYXRpb25GYWN0b3JCKTtcbiAgICAgICAgdHJhbnNmb3JtQi50cmFuc2xhdGUoc2VwYXJhdGlvbkIueCwgc2VwYXJhdGlvbkIueSwgc2VwYXJhdGlvbkIueik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHN0b3AgbW92ZW1lbnQgdmVsb2NpdHkgZm9yIHBsYXllciB3aGVuIGhpdHRpbmcgc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKG1vdmVtZW50QiAmJiBwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYykge1xuICAgICAgICAgIC8vIFByb2plY3QgdmVsb2NpdHkgdG8gcmVtb3ZlIGNvbXBvbmVudCB0b3dhcmRzIHRoZSBzdGF0aWMgb2JqZWN0XG4gICAgICAgICAgY29uc3QgdmVsb2NpdHlUb3dhcmRzU3RhdGljID0gbW92ZW1lbnRCLnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHNlcGFyYXRpb24pO1xuICAgICAgICAgIGlmICh2ZWxvY2l0eVRvd2FyZHNTdGF0aWMubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICBtb3ZlbWVudEIudmVsb2NpdHkuc3ViKHZlbG9jaXR5VG93YXJkc1N0YXRpYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRBcHByb3hpbWF0ZVJhZGl1cyhjb2xsaWRlcjogQ29sbGlkZXIpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoY29sbGlkZXIudHlwZSkge1xuICAgICAgY2FzZSAnc3BoZXJlJzpcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyLnJhZGl1cztcbiAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjb2xsaWRlci5zaXplLngsIGNvbGxpZGVyLnNpemUueSwgY29sbGlkZXIuc2l6ZS56KSAqIDAuNTtcbiAgICAgIGNhc2UgJ2NhcHN1bGUnOlxuICAgICAgY2FzZSAnY3lsaW5kZXInOlxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sbGlkZXIucmFkaXVzLCBjb2xsaWRlci5oZWlnaHQgKiAwLjUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG90aGVyIHN5c3RlbXNcbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzKGJvdW5kczogQm94Myk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShib3VuZHMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUmFkaXVzKGNlbnRlcjogVmVjdG9yMywgcmFkaXVzOiBudW1iZXIpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlSYWRpdXMoY2VudGVyLCByYWRpdXMpO1xuICAgIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgcHVibGljIHF1ZXJ5Q29sbGlkZXJzUG9pbnQocG9pbnQ6IFZlY3RvcjMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50cmllcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnlQb2ludChwb2ludCk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sbGlkZXJzSW5MYXllcihsYXllcjogQ29sbGlzaW9uTGF5ZXIsIGJvdW5kcz86IEJveDMpOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGJvdW5kcyA/IHRoaXMuc3BhdGlhbEhhc2gucXVlcnkoYm91bmRzKSA6IEFycmF5LmZyb20odGhpcy5zcGF0aWFsSGFzaFsnZW50aXR5Q2VsbHMnXS5rZXlzKCkpLm1hcChpZCA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShuZXcgQm94MygpLnNldEZyb21DZW50ZXJBbmRTaXplKG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKDEwMDAsIDEwMDAsIDEwMDApKSk7XG4gICAgICByZXR1cm4gZW50cmllcy5maW5kKGUgPT4gZS5lbnRpdHkuaWQgPT09IGlkKTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikgYXMgYW55W107XG5cbiAgICByZXR1cm4gY2FuZGlkYXRlc1xuICAgICAgLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50cnkuZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIHJldHVybiBjb2xsaWRlciAmJiBjb2xsaWRlci5sYXllciA9PT0gbGF5ZXI7XG4gICAgICB9KVxuICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5lbnRpdHkpO1xuICB9XG5cbiAgLy8gUGVyZm9ybWFuY2UgYW5kIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UGVyZm9ybWFuY2VTdGF0cygpOiB7XG4gICAgY29sbGlzaW9uQ2hlY2tzOiBudW1iZXI7XG4gICAgYWN0dWFsQ29sbGlzaW9uczogbnVtYmVyO1xuICAgIGFjdGl2ZUNvbGxpc2lvbnM6IG51bWJlcjtcbiAgICBzcGF0aWFsSGFzaFN0YXRzOiBhbnk7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xsaXNpb25DaGVja3M6IHRoaXMuY29sbGlzaW9uQ2hlY2tzLFxuICAgICAgYWN0dWFsQ29sbGlzaW9uczogdGhpcy5hY3R1YWxDb2xsaXNpb25zLFxuICAgICAgYWN0aXZlQ29sbGlzaW9uczogdGhpcy5hY3RpdmVDb2xsaXNpb25zLnNpemUsXG4gICAgICBzcGF0aWFsSGFzaFN0YXRzOiB0aGlzLnNwYXRpYWxIYXNoLmdldFN0YXRzKClcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIHNwYXRpYWwgaGFzaCB3aGVuIGVudGl0eSBpcyByZW1vdmVkXG4gICAgdGhpcy5zcGF0aWFsSGFzaC5yZW1vdmUoZW50aXR5KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgZnJvbSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIGNvbnN0IGtleXNUb1JlbW92ZTogc3RyaW5nW10gPSBbXTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuZm9yRWFjaCgocGFpciwga2V5KSA9PiB7XG4gICAgICBpZiAocGFpci5lbnRpdHlBLmlkID09PSBlbnRpdHkuaWQgfHwgcGFpci5lbnRpdHlCLmlkID09PSBlbnRpdHkuaWQpIHtcbiAgICAgICAga2V5c1RvUmVtb3ZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuc3BhdGlhbEhhc2guY2xlYXIoKTtcbiAgICB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuY2xlYXIoKTtcbiAgICB0aGlzLmNvbGxpc2lvblBhaXJzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlBoeXNpY3NTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNb3ZlbWVudCIsIkNvbGxpZGVyIiwiQ29sbGlzaW9uTGF5ZXIiLCJTcGF0aWFsSGFzaCIsIkNvbGxpc2lvblN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidXBkYXRlU3BhdGlhbEhhc2giLCJkZXRlY3RDb2xsaXNpb25zIiwicHJvY2Vzc0NvbGxpc2lvbkNhbGxiYWNrcyIsInJlc29sdmVDb2xsaXNpb25zIiwiZml4ZWRVcGRhdGUiLCJmaXhlZERlbHRhVGltZSIsImVudGl0eSIsInRyYW5zZm9ybSIsImdldENvbXBvbmVudCIsImNvbGxpZGVyIiwiZW5hYmxlZCIsInNwYXRpYWxIYXNoIiwicmVtb3ZlIiwidXBkYXRlQm91bmRzIiwiZ2V0V29ybGRQb3NpdGlvbiIsImJvdW5kcyIsImNvbGxpc2lvblBhaXJzIiwibGVuZ3RoIiwiY29sbGlzaW9uQ2hlY2tzIiwiYWN0dWFsQ29sbGlzaW9ucyIsInByb2Nlc3NlZFBhaXJzIiwiU2V0IiwiY2FuZGlkYXRlcyIsInF1ZXJ5IiwiY2FuZGlkYXRlIiwib3RoZXJFbnRpdHkiLCJpZCIsInBhaXJLZXkiLCJoYXMiLCJhZGQiLCJvdGhlclRyYW5zZm9ybSIsIm90aGVyQ29sbGlkZXIiLCJjYW5Db2xsaWRlV2l0aCIsImludGVyc2VjdHMiLCJsYXllciIsInBhaXIiLCJlbnRpdHlBIiwiZW50aXR5QiIsImNvbGxpZGVyQSIsImNvbGxpZGVyQiIsInB1c2giLCJjdXJyZW50Q29sbGlzaW9ucyIsIk1hcCIsInNldCIsImFjdGl2ZUNvbGxpc2lvbnMiLCJ0cmlnZ2VyQ29sbGlzaW9uRW50ZXIiLCJ0cmlnZ2VyQ29sbGlzaW9uU3RheSIsImZvckVhY2giLCJ0cmlnZ2VyQ29sbGlzaW9uRXhpdCIsImlzVHJpZ2dlciIsIm9uVHJpZ2dlckVudGVyIiwib25Db2xsaXNpb25FbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvbkNvbGxpc2lvblN0YXkiLCJvblRyaWdnZXJFeGl0Iiwib25Db2xsaXNpb25FeGl0IiwicmVzb2x2ZUNvbGxpc2lvbiIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwicG9zQSIsInBvc0IiLCJjbG9uZSIsInNlcGFyYXRpb24iLCJzdWIiLCJkaXN0YW5jZSIsIm5vcm1hbGl6ZSIsInJlcXVpcmVkU2VwYXJhdGlvbiIsInR5cGUiLCJyYWRpdXMiLCJyYWRpdXNBIiwiZ2V0QXBwcm94aW1hdGVSYWRpdXMiLCJyYWRpdXNCIiwib3ZlcmxhcCIsInNlcGFyYXRpb25NdWx0aXBsaWVyIiwiaXNTdGF0aWMiLCJzZXBhcmF0aW9uVmVjdG9yIiwibXVsdGlwbHlTY2FsYXIiLCJtb3ZlbWVudEEiLCJtb3ZlbWVudEIiLCJzZXBhcmF0aW9uRmFjdG9yQSIsInNlcGFyYXRpb25GYWN0b3JCIiwiaXNQbGF5ZXJBIiwiUExBWUVSIiwiaXNQbGF5ZXJCIiwiRU5FTVkiLCJjYW5Nb3ZlQSIsImNhbk1vdmUiLCJjYW5Nb3ZlQiIsInNlcGFyYXRpb25BIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwidmVsb2NpdHkiLCJ2ZWxvY2l0eVRvd2FyZHNTdGF0aWMiLCJwcm9qZWN0T25WZWN0b3IiLCJuZWdhdGUiLCJzZXBhcmF0aW9uQiIsIk1hdGgiLCJtYXgiLCJzaXplIiwiaGVpZ2h0IiwicXVlcnlDb2xsaWRlcnMiLCJlbnRyaWVzIiwibWFwIiwiZW50cnkiLCJxdWVyeUNvbGxpZGVyc1JhZGl1cyIsImNlbnRlciIsInF1ZXJ5UmFkaXVzIiwicXVlcnlDb2xsaWRlcnNQb2ludCIsInBvaW50IiwicXVlcnlQb2ludCIsImdldENvbGxpZGVyc0luTGF5ZXIiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJmaW5kIiwiZSIsImZpbHRlciIsIkJvb2xlYW4iLCJnZXRQZXJmb3JtYW5jZVN0YXRzIiwic3BhdGlhbEhhc2hTdGF0cyIsImdldFN0YXRzIiwib25FbnRpdHlSZW1vdmVkIiwia2V5c1RvUmVtb3ZlIiwia2V5IiwiZGVsZXRlIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsImNlbGxTaXplIiwicmVxdWlyZWRDb21wb25lbnRzIiwibGFzdFVwZGF0ZVRpbWUiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CollisionSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CombatSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CombatSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CombatSystem: function() { return /* binding */ CombatSystem; }\n/* harmony export */ });\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/core/DamageCalculator */ \"(app-pages-browser)/./src/core/DamageCalculator.ts\");\n/* harmony import */ var _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/DamageNumberManager */ \"(app-pages-browser)/./src/utils/DamageNumberManager.ts\");\n// Combat system for handling damage, healing, and combat mechanics\n\n\n\n\n\n\n\n\n\nclass CombatSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_0__.System {\n    // Throttled logging to reduce spam\n    shouldLogDamage() {\n        const now = Date.now();\n        if (now - this.lastDamageLogTime > this.damageLogThrottle) {\n            this.lastDamageLogTime = now;\n            return true;\n        }\n        return false;\n    }\n    // Set callback for routing enemy damage to multiplayer server\n    setEnemyDamageCallback(callback) {\n        this.onEnemyDamageCallback = callback;\n    }\n    // Set callback for routing player damage to multiplayer server (PVP)\n    setPlayerDamageCallback(callback) {\n        this.onPlayerDamageCallback = callback;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000;\n        // Update health components (regeneration, invulnerability timers)\n        this.updateHealthComponents(entities, deltaTime, currentTime);\n        // Process damage queue\n        this.processDamageQueue(currentTime);\n        // Process heal queue\n        this.processHealQueue(currentTime);\n        // Handle death and respawn\n        this.handleDeathAndRespawn(entities, currentTime);\n        // Cleanup old damage numbers\n        this.damageNumberManager.cleanup();\n        // Clear processed queues\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n    }\n    updateHealthComponents(entities, deltaTime, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            // Skip if required Health component is missing\n            if (!health || !health.enabled) continue;\n            // Update health component (handles regeneration and invulnerability)\n            health.update(deltaTime, currentTime);\n            // Update shield component if it exists\n            const shield = entity.getComponent(_ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__.Shield);\n            if (shield) {\n                shield.update(deltaTime);\n            }\n            // Update freeze status for enemies\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (enemy) {\n                enemy.updateFreezeStatus(currentTime);\n            }\n        }\n    }\n    processDamageQueue(currentTime) {\n        for (const damageEvent of this.damageQueue){\n            this.applyDamage(damageEvent, currentTime);\n        }\n    }\n    processHealQueue(currentTime) {\n        for (const healEvent of this.healQueue){\n            this.applyHealing(healEvent, currentTime);\n        }\n    }\n    applyDamage(damageEvent, currentTime) {\n        const { target, damage: baseDamage, source, damageType } = damageEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Debug: Log all damage events for charge damage\n        if (damageType === \"charge\") {\n            const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(target.id, \")\");\n            console.log(\"⚔️ CombatSystem processing charge damage: \".concat(baseDamage, \" to \").concat(entityType, \", source: \").concat(source === null || source === void 0 ? void 0 : source.id, \", hasPlayerCallback: \").concat(!!this.onPlayerDamageCallback));\n        }\n        // Check if target is an enemy - if so, route damage through multiplayer\n        const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy && this.onEnemyDamageCallback) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route enemy damage through multiplayer server instead of applying locally\n            console.log(\"\\uD83C\\uDF10 Routing \".concat(actualDamage, \" damage to enemy \").concat(target.id, \" through multiplayer server\"));\n            this.onEnemyDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            // Log for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            console.log(\"\\uD83D\\uDCA5 \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (routed to server)\"));\n            return; // Don't apply damage locally for enemies\n        }\n        // Check if target is a player in PVP mode - if so, route damage through multiplayer\n        // Also prevent self-damage in PVP (source hitting themselves)\n        if (!enemy && this.onPlayerDamageCallback && source && source.id !== target.id) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            // Route player damage through multiplayer server for PVP (let receiver handle shields)\n            if (this.shouldLogDamage()) {\n                console.log(\"⚔️ Routing \".concat(damageResult.damage, \" PVP \").concat(damageType || \"damage\", \" to player \").concat(target.id, \" through multiplayer server\"));\n            }\n            this.onPlayerDamageCallback(target.id.toString(), damageResult.damage, damageType); // Send damage, let receiver handle shields\n            // Create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    position.y += 1.5;\n                    // Add slight position offset for delayed damage (like sabres right hit) to prevent overlap\n                    if (damageType === \"sabres_right\") {\n                        position.x += 0.3; // Slight offset to the right for the right sabre\n                    }\n                    this.damageNumberManager.addDamageNumber(damageResult.damage, damageResult.isCritical, position, damageType || \"pvp\");\n                } else {\n                    console.warn(\"⚠️ Skipping PVP damage number creation - invalid position:\", position);\n                }\n            }\n            // Log for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Player \".concat(source.id) : \"Unknown\";\n                const targetName = \"Player \".concat(target.id);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                console.log(\"⚔️ \".concat(sourceName, \" dealt \").concat(damageResult.damage).concat(critText, \" PVP \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (routed to server)\"));\n            }\n            return; // Don't apply damage locally for PVP players\n        }\n        // For non-enemies (like players in non-PVP mode), apply damage locally as before\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n        const actualDamage = damageResult.damage;\n        // Apply damage (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    // Offset slightly above the target\n                    position.y += 3;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                } else {\n                    console.warn(\"⚠️ Skipping damage number creation - invalid position:\", position);\n                }\n            }\n            // Log damage for debugging (throttled to reduce spam)\n            if (this.shouldLogDamage()) {\n                const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n                const targetName = this.getEntityDisplayName(target);\n                const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n                console.log(\"\\uD83D\\uDCA5 \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            }\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n    }\n    applyHealing(healEvent, currentTime) {\n        const { target, amount, source } = healEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Apply healing\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            // Log healing for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            console.log(\"\\uD83D\\uDC9A \".concat(sourceName, \" healed \").concat(targetName, \" for \").concat(amount, \" HP (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            // Trigger healing effects\n            this.triggerHealingEffects(target, amount, source);\n        }\n    }\n    handleEntityDeath(entity, killer, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            enemy.die(currentTime || Date.now() / 1000);\n            this.enemiesKilled++;\n            console.log(\"\\uD83D\\uDC80 \".concat(enemy.getDisplayName(), \" has been defeated!\"));\n            // Award experience to killer if it's a player\n            if (killer) {\n                this.awardExperience(killer, enemy.experienceReward);\n            }\n            // Trigger death effects\n            this.triggerDeathEffects(entity, killer);\n        }\n        this.deadEntities.push(entity);\n    }\n    handleDeathAndRespawn(entities, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (!health || !enemy) continue;\n            // Handle respawn for enemies\n            if (enemy.isDead && enemy.canRespawnNow(currentTime)) {\n                this.respawnEnemy(entity, enemy, health);\n            }\n        }\n    }\n    respawnEnemy(entity, enemy, health) {\n        // Respawn the enemy\n        enemy.respawn();\n        health.revive();\n        console.log(\"\\uD83D\\uDD04 \".concat(enemy.getDisplayName(), \" has respawned!\"));\n        // Trigger respawn effects\n        this.triggerRespawnEffects(entity);\n    }\n    triggerDamageEffects(target, damage, source, damageType, isCritical) {\n        // This can be extended to trigger particle effects, screen shake, etc.\n        // For now, we'll just handle basic effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            // Could trigger damage number popup, blood effects, etc.\n            // For now, just log the position where damage occurred\n            const critText = isCritical ? \" (CRITICAL)\" : \"\";\n            console.log(\"\\uD83C\\uDFAF Damage effect\".concat(critText, \" at position:\"), transform.position);\n        }\n        // Handle special projectile effects\n        if (damageType === \"projectile\" && source) {\n            var _sourceRenderer_mesh_userData, _sourceRenderer_mesh;\n            const sourceRenderer = source.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            if (sourceRenderer === null || sourceRenderer === void 0 ? void 0 : (_sourceRenderer_mesh = sourceRenderer.mesh) === null || _sourceRenderer_mesh === void 0 ? void 0 : (_sourceRenderer_mesh_userData = _sourceRenderer_mesh.userData) === null || _sourceRenderer_mesh_userData === void 0 ? void 0 : _sourceRenderer_mesh_userData.isBarrageArrow) {\n                console.log(\"\\uD83C\\uDFF9 Barrage arrow hit detected, applying slow effect to target \".concat(target.id));\n                const targetMovement = target.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n                if (targetMovement) {\n                    targetMovement.slow(5000, 0.5); // 5 seconds, 50% speed\n                    console.log(\"\\uD83D\\uDC0C Applied 50% slow for 5 seconds to target \".concat(target.id));\n                }\n            }\n        }\n    }\n    triggerHealingEffects(target, amount, source) {\n        // This can be extended to trigger healing particle effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"✨ Healing effect at position:\", transform.position);\n        }\n    }\n    triggerDeathEffects(entity, killer) {\n        // This can be extended to trigger death animations, loot drops, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"\\uD83D\\uDC80 Death effect at position:\", transform.position);\n        }\n    }\n    triggerRespawnEffects(entity) {\n        // This can be extended to trigger respawn animations, effects, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"\\uD83C\\uDF1F Respawn effect at position:\", transform.position);\n        }\n    }\n    awardExperience(entity, experience) {\n        // This would integrate with a progression system\n        console.log(\"⭐ Entity \".concat(entity.id, \" gained \").concat(experience, \" experience!\"));\n    }\n    getEntityDisplayName(entity) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            return enemy.getDisplayName();\n        }\n        // Could check for other components that provide names\n        return \"Entity \".concat(entity.id);\n    }\n    // Public API for other systems to queue damage and healing\n    queueDamage(target, damage, source, damageType) {\n        this.damageQueue.push({\n            target,\n            damage,\n            source,\n            damageType,\n            timestamp: Date.now() / 1000\n        });\n    }\n    queueHealing(target, amount, source) {\n        this.healQueue.push({\n            target,\n            amount,\n            source,\n            timestamp: Date.now() / 1000\n        });\n    }\n    // Immediate damage/healing (bypasses queue)\n    dealDamageImmediate(target, damage, source, damageType) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        // Calculate actual damage with critical hit mechanics\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n        const actualDamage = damageResult.damage;\n        const currentTime = Date.now() / 1000;\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Offset slightly above the target\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n        return damageDealt;\n    }\n    healImmediate(target, amount, source) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            this.triggerHealingEffects(target, amount, source);\n        }\n        return healingDone;\n    }\n    // Utility methods\n    isEntityDead(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.isDead : false;\n    }\n    getEntityHealthRatio(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.getHealthRatio() : 0;\n    }\n    canEntityTakeDamage(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? !health.isDead && !health.isInvulnerable : false;\n    }\n    // Statistics and debugging\n    getCombatStats() {\n        return {\n            totalDamageDealt: this.totalDamageDealt,\n            totalHealingDone: this.totalHealingDone,\n            enemiesKilled: this.enemiesKilled,\n            queuedDamageEvents: this.damageQueue.length,\n            queuedHealEvents: this.healQueue.length\n        };\n    }\n    resetStats() {\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n    }\n    // Damage numbers management\n    getDamageNumbers() {\n        return this.damageNumberManager.getDamageNumbers();\n    }\n    removeDamageNumber(id) {\n        this.damageNumberManager.removeDamageNumber(id);\n    }\n    onDisable() {\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n        this.damageNumberManager.clear();\n        this.resetStats();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health\n        ];\n        this.damageQueue = [];\n        this.healQueue = [];\n        this.deadEntities = [];\n        // Combat statistics\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n        // Log throttling to reduce spam\n        this.lastDamageLogTime = 0;\n        this.damageLogThrottle = 100 // Only log every 100ms\n        ;\n        this.world = world;\n        this.damageNumberManager = new _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__.DamageNumberManager();\n        this.priority = 25; // Run after collision detection\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQW1FO0FBQzdCO0FBRVc7QUFDQTtBQUNGO0FBQ1E7QUFDRjtBQUNBO0FBRW1CO0FBQ047QUFpQjNELE1BQU1TLHFCQUFxQlQsK0NBQU1BO0lBOEJ0QyxtQ0FBbUM7SUFDM0JVLGtCQUEyQjtRQUNqQyxNQUFNQyxNQUFNQyxLQUFLRCxHQUFHO1FBQ3BCLElBQUlBLE1BQU0sSUFBSSxDQUFDRSxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQixFQUFFO1lBQ3pELElBQUksQ0FBQ0QsaUJBQWlCLEdBQUdGO1lBQ3pCLE9BQU87UUFDVDtRQUNBLE9BQU87SUFDVDtJQUVBLDhEQUE4RDtJQUN2REksdUJBQXVCQyxRQUFtRCxFQUFRO1FBQ3ZGLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdEO0lBQy9CO0lBRUEscUVBQXFFO0lBQzlERSx3QkFBd0JGLFFBQXlFLEVBQVE7UUFDOUcsSUFBSSxDQUFDRyxzQkFBc0IsR0FBR0g7SUFDaEM7SUFFT0ksT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCxNQUFNQyxjQUFjWCxLQUFLRCxHQUFHLEtBQUs7UUFFakMsa0VBQWtFO1FBQ2xFLElBQUksQ0FBQ2Esc0JBQXNCLENBQUNILFVBQVVDLFdBQVdDO1FBRWpELHVCQUF1QjtRQUN2QixJQUFJLENBQUNFLGtCQUFrQixDQUFDRjtRQUV4QixxQkFBcUI7UUFDckIsSUFBSSxDQUFDRyxnQkFBZ0IsQ0FBQ0g7UUFFdEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ0kscUJBQXFCLENBQUNOLFVBQVVFO1FBRXJDLDZCQUE2QjtRQUM3QixJQUFJLENBQUNLLG1CQUFtQixDQUFDQyxPQUFPO1FBRWhDLHlCQUF5QjtRQUN6QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxN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QUs7YUF2QlNDLHFCQUFxQjtZQUFDM0gsMERBQU1BO1NBQUM7YUFFckM2QixjQUE2QixFQUFFO2FBQy9CRSxZQUF5QixFQUFFO2FBQzNCQyxlQUF5QixFQUFFO1FBR25DLG9CQUFvQjthQUNaeUMsbUJBQW1CO2FBQ25CUyxtQkFBbUI7YUFDbkJJLGdCQUFnQjtRQVF4QixnQ0FBZ0M7YUFDeEIxRSxvQkFBb0I7YUFDcEJDLG9CQUFvQixJQUFLLHVCQUF1Qjs7UUFJdEQsSUFBSSxDQUFDNkcsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQy9GLG1CQUFtQixHQUFHLElBQUlwQiwyRUFBbUJBO1FBQ2xELElBQUksQ0FBQ3FILFFBQVEsR0FBRyxJQUFJLGdDQUFnQztJQUN0RDtBQXFmRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Db21iYXRTeXN0ZW0udHM/YTYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21iYXQgc3lzdGVtIGZvciBoYW5kbGluZyBkYW1hZ2UsIGhlYWxpbmcsIGFuZCBjb21iYXQgbWVjaGFuaWNzXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFNoaWVsZCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvU2hpZWxkJztcbmltcG9ydCB7IEVuZW15IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9FbmVteSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgTW92ZW1lbnQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL01vdmVtZW50JztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGFtYWdlLCBEYW1hZ2VSZXN1bHQgfSBmcm9tICdAL2NvcmUvRGFtYWdlQ2FsY3VsYXRvcic7XG5pbXBvcnQgeyBEYW1hZ2VOdW1iZXJNYW5hZ2VyIH0gZnJvbSAnQC91dGlscy9EYW1hZ2VOdW1iZXJNYW5hZ2VyJztcblxuaW50ZXJmYWNlIERhbWFnZUV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGRhbWFnZTogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIGRhbWFnZVR5cGU/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgSGVhbEV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGFtb3VudDogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29tYmF0U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtIZWFsdGhdO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBkYW1hZ2VRdWV1ZTogRGFtYWdlRXZlbnRbXSA9IFtdO1xuICBwcml2YXRlIGhlYWxRdWV1ZTogSGVhbEV2ZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBkZWFkRW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gIHByaXZhdGUgZGFtYWdlTnVtYmVyTWFuYWdlcjogRGFtYWdlTnVtYmVyTWFuYWdlcjtcbiAgXG4gIC8vIENvbWJhdCBzdGF0aXN0aWNzXG4gIHByaXZhdGUgdG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gIHByaXZhdGUgdG90YWxIZWFsaW5nRG9uZSA9IDA7XG4gIHByaXZhdGUgZW5lbWllc0tpbGxlZCA9IDA7XG5cbiAgLy8gTXVsdGlwbGF5ZXIgZGFtYWdlIGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvbkVuZW15RGFtYWdlQ2FsbGJhY2s/OiAoZW5lbXlJZDogc3RyaW5nLCBkYW1hZ2U6IG51bWJlcikgPT4gdm9pZDtcbiAgXG4gIC8vIFBWUCBkYW1hZ2UgY2FsbGJhY2sgZm9yIHJvdXRpbmcgcGxheWVyIGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvblBsYXllckRhbWFnZUNhbGxiYWNrPzogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8vIExvZyB0aHJvdHRsaW5nIHRvIHJlZHVjZSBzcGFtXG4gIHByaXZhdGUgbGFzdERhbWFnZUxvZ1RpbWUgPSAwO1xuICBwcml2YXRlIGRhbWFnZUxvZ1Rocm90dGxlID0gMTAwOyAvLyBPbmx5IGxvZyBldmVyeSAxMDBtc1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlciA9IG5ldyBEYW1hZ2VOdW1iZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgY29sbGlzaW9uIGRldGVjdGlvblxuICB9XG5cbiAgLy8gVGhyb3R0bGVkIGxvZ2dpbmcgdG8gcmVkdWNlIHNwYW1cbiAgcHJpdmF0ZSBzaG91bGRMb2dEYW1hZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gdGhpcy5sYXN0RGFtYWdlTG9nVGltZSA+IHRoaXMuZGFtYWdlTG9nVGhyb3R0bGUpIHtcbiAgICAgIHRoaXMubGFzdERhbWFnZUxvZ1RpbWUgPSBub3c7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBtdWx0aXBsYXllciBzZXJ2ZXJcbiAgcHVibGljIHNldEVuZW15RGFtYWdlQ2FsbGJhY2soY2FsbGJhY2s6IChlbmVteUlkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIHBsYXllciBkYW1hZ2UgdG8gbXVsdGlwbGF5ZXIgc2VydmVyIChQVlApXG4gIHB1YmxpYyBzZXRQbGF5ZXJEYW1hZ2VDYWxsYmFjayhjYWxsYmFjazogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyLCBkYW1hZ2VUeXBlPzogc3RyaW5nKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBjb21wb25lbnRzIChyZWdlbmVyYXRpb24sIGludnVsbmVyYWJpbGl0eSB0aW1lcnMpXG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb21wb25lbnRzKGVudGl0aWVzLCBkZWx0YVRpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIFByb2Nlc3MgZGFtYWdlIHF1ZXVlXG4gICAgdGhpcy5wcm9jZXNzRGFtYWdlUXVldWUoY3VycmVudFRpbWUpO1xuXG4gICAgLy8gUHJvY2VzcyBoZWFsIHF1ZXVlXG4gICAgdGhpcy5wcm9jZXNzSGVhbFF1ZXVlKGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIEhhbmRsZSBkZWF0aCBhbmQgcmVzcGF3blxuICAgIHRoaXMuaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzLCBjdXJyZW50VGltZSk7XG5cbiAgICAvLyBDbGVhbnVwIG9sZCBkYW1hZ2UgbnVtYmVyc1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhbnVwKCk7XG5cbiAgICAvLyBDbGVhciBwcm9jZXNzZWQgcXVldWVzXG4gICAgdGhpcy5kYW1hZ2VRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhbFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZWFkRW50aXRpZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoQ29tcG9uZW50cyhlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBIZWFsdGggY29tcG9uZW50IGlzIG1pc3NpbmdcbiAgICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFVwZGF0ZSBoZWFsdGggY29tcG9uZW50IChoYW5kbGVzIHJlZ2VuZXJhdGlvbiBhbmQgaW52dWxuZXJhYmlsaXR5KVxuICAgICAgaGVhbHRoLnVwZGF0ZShkZWx0YVRpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgLy8gVXBkYXRlIHNoaWVsZCBjb21wb25lbnQgaWYgaXQgZXhpc3RzXG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIHNoaWVsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGZyZWV6ZSBzdGF0dXMgZm9yIGVuZW1pZXNcbiAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBpZiAoZW5lbXkpIHtcbiAgICAgICAgZW5lbXkudXBkYXRlRnJlZXplU3RhdHVzKGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NEYW1hZ2VRdWV1ZShjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBkYW1hZ2VFdmVudCBvZiB0aGlzLmRhbWFnZVF1ZXVlKSB7XG4gICAgICB0aGlzLmFwcGx5RGFtYWdlKGRhbWFnZUV2ZW50LCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzSGVhbFF1ZXVlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGhlYWxFdmVudCBvZiB0aGlzLmhlYWxRdWV1ZSkge1xuICAgICAgdGhpcy5hcHBseUhlYWxpbmcoaGVhbEV2ZW50LCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBseURhbWFnZShkYW1hZ2VFdmVudDogRGFtYWdlRXZlbnQsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRhcmdldCwgZGFtYWdlOiBiYXNlRGFtYWdlLCBzb3VyY2UsIGRhbWFnZVR5cGUgfSA9IGRhbWFnZUV2ZW50O1xuICAgIFxuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybjtcblxuICAgIC8vIERlYnVnOiBMb2cgYWxsIGRhbWFnZSBldmVudHMgZm9yIGNoYXJnZSBkYW1hZ2VcbiAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ2NoYXJnZScpIHtcbiAgICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBjb25zdCBlbnRpdHlUeXBlID0gZW5lbXkgPyBgRW5lbXkoJHtlbmVteS5nZXREaXNwbGF5TmFtZSgpfSlgIDogYFBsYXllcigke3RhcmdldC5pZH0pYDtcbiAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gQ29tYmF0U3lzdGVtIHByb2Nlc3NpbmcgY2hhcmdlIGRhbWFnZTogJHtiYXNlRGFtYWdlfSB0byAke2VudGl0eVR5cGV9LCBzb3VyY2U6ICR7c291cmNlPy5pZH0sIGhhc1BsYXllckNhbGxiYWNrOiAkeyEhdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrfWApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbiBlbmVteSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15ICYmIHRoaXMub25FbmVteURhbWFnZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcbiAgICAgIFxuICAgICAgLy8gUm91dGUgZW5lbXkgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyIGluc3RlYWQgb2YgYXBwbHlpbmcgbG9jYWxseVxuICAgICAgY29uc29sZS5sb2coYPCfjJAgUm91dGluZyAke2FjdHVhbERhbWFnZX0gZGFtYWdlIHRvIGVuZW15ICR7dGFyZ2V0LmlkfSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlcmApO1xuICAgICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGFjdHVhbERhbWFnZSk7XG4gICAgICBcbiAgICAgIC8vIFN0aWxsIGNyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgY29uc29sZS5sb2coYPCfkqUgJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKHJvdXRlZCB0byBzZXJ2ZXIpYCk7XG4gICAgICBcbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgYXBwbHkgZGFtYWdlIGxvY2FsbHkgZm9yIGVuZW1pZXNcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBwbGF5ZXIgaW4gUFZQIG1vZGUgLSBpZiBzbywgcm91dGUgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXJcbiAgICAvLyBBbHNvIHByZXZlbnQgc2VsZi1kYW1hZ2UgaW4gUFZQIChzb3VyY2UgaGl0dGluZyB0aGVtc2VsdmVzKVxuICAgIGlmICghZW5lbXkgJiYgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrICYmIHNvdXJjZSAmJiBzb3VyY2UuaWQgIT09IHRhcmdldC5pZCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkYW1hZ2Ugd2l0aCBjcml0aWNhbCBoaXQgbWVjaGFuaWNzXG4gICAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICAgIFxuICAgICAgLy8gUm91dGUgcGxheWVyIGRhbWFnZSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlciBmb3IgUFZQIChsZXQgcmVjZWl2ZXIgaGFuZGxlIHNoaWVsZHMpXG4gICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqU77iPIFJvdXRpbmcgJHtkYW1hZ2VSZXN1bHQuZGFtYWdlfSBQVlAgJHtkYW1hZ2VUeXBlIHx8ICdkYW1hZ2UnfSB0byBwbGF5ZXIgJHt0YXJnZXQuaWR9IHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyYCk7XG4gICAgICB9XG4gICAgICB0aGlzLm9uUGxheWVyRGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGRhbWFnZVJlc3VsdC5kYW1hZ2UsIGRhbWFnZVR5cGUpOyAvLyBTZW5kIGRhbWFnZSwgbGV0IHJlY2VpdmVyIGhhbmRsZSBzaGllbGRzXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9zaXRpb24ueSArPSAxLjU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRkIHNsaWdodCBwb3NpdGlvbiBvZmZzZXQgZm9yIGRlbGF5ZWQgZGFtYWdlIChsaWtlIHNhYnJlcyByaWdodCBoaXQpIHRvIHByZXZlbnQgb3ZlcmxhcFxuICAgICAgICAgIGlmIChkYW1hZ2VUeXBlID09PSAnc2FicmVzX3JpZ2h0Jykge1xuICAgICAgICAgICAgcG9zaXRpb24ueCArPSAwLjM7IC8vIFNsaWdodCBvZmZzZXQgdG8gdGhlIHJpZ2h0IGZvciB0aGUgcmlnaHQgc2FicmVcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5kYW1hZ2UsIC8vIFNob3cgdGhlIGZ1bGwgZGFtYWdlIGluIGRhbWFnZSBudW1iZXJzXG4gICAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZGFtYWdlVHlwZSB8fCAncHZwJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gU2tpcHBpbmcgUFZQIGRhbWFnZSBudW1iZXIgY3JlYXRpb24gLSBpbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZyAodGhyb3R0bGVkIHRvIHJlZHVjZSBzcGFtKVxuICAgICAgaWYgKHRoaXMuc2hvdWxkTG9nRGFtYWdlKCkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHNvdXJjZSA/IGBQbGF5ZXIgJHtzb3VyY2UuaWR9YCA6ICdVbmtub3duJztcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IGBQbGF5ZXIgJHt0YXJnZXQuaWR9YDtcbiAgICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gJHtzb3VyY2VOYW1lfSBkZWFsdCAke2RhbWFnZVJlc3VsdC5kYW1hZ2V9JHtjcml0VGV4dH0gUFZQICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAocm91dGVkIHRvIHNlcnZlcilgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuOyAvLyBEb24ndCBhcHBseSBkYW1hZ2UgbG9jYWxseSBmb3IgUFZQIHBsYXllcnNcbiAgICB9XG5cbiAgICAvLyBGb3Igbm9uLWVuZW1pZXMgKGxpa2UgcGxheWVycyBpbiBub24tUFZQIG1vZGUpLCBhcHBseSBkYW1hZ2UgbG9jYWxseSBhcyBiZWZvcmVcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgLy8gQXBwbHkgZGFtYWdlIChwYXNzIGVudGl0eSBzbyBIZWFsdGggY2FuIHVzZSBTaGllbGQgY29tcG9uZW50KVxuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gT2Zmc2V0IHNsaWdodGx5IGFib3ZlIHRoZSB0YXJnZXRcbiAgICAgICAgICBwb3NpdGlvbi55ICs9IDM7XG4gICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBTa2lwcGluZyBkYW1hZ2UgbnVtYmVyIGNyZWF0aW9uIC0gaW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTG9nIGRhbWFnZSBmb3IgZGVidWdnaW5nICh0aHJvdHRsZWQgdG8gcmVkdWNlIHNwYW0pXG4gICAgICBpZiAodGhpcy5zaG91bGRMb2dEYW1hZ2UoKSkge1xuICAgICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgICBjb25zdCB0YXJnZXROYW1lID0gdGhpcy5nZXRFbnRpdHlEaXNwbGF5TmFtZSh0YXJnZXQpO1xuICAgICAgICBjb25zdCBjcml0VGV4dCA9IGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsID8gJyBDUklUSUNBTCcgOiAnJztcbiAgICAgICAgY29uc29sZS5sb2coYPCfkqUgJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBkaWVkXG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUVudGl0eURlYXRoKHRhcmdldCwgc291cmNlLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgZGFtYWdlIGVmZmVjdHNcbiAgICAgIHRoaXMudHJpZ2dlckRhbWFnZUVmZmVjdHModGFyZ2V0LCBhY3R1YWxEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSwgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlIZWFsaW5nKGhlYWxFdmVudDogSGVhbEV2ZW50LCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgeyB0YXJnZXQsIGFtb3VudCwgc291cmNlIH0gPSBoZWFsRXZlbnQ7XG4gICAgXG4gICAgY29uc3QgaGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgaGVhbGluZ1xuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICBcbiAgICAgIC8vIExvZyBoZWFsaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gdGhpcy5nZXRFbnRpdHlEaXNwbGF5TmFtZSh0YXJnZXQpO1xuICAgICAgY29uc29sZS5sb2coYPCfkpogJHtzb3VyY2VOYW1lfSBoZWFsZWQgJHt0YXJnZXROYW1lfSBmb3IgJHthbW91bnR9IEhQICgke2hlYWx0aC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aC5tYXhIZWFsdGh9IEhQKWApO1xuXG4gICAgICAvLyBUcmlnZ2VyIGhlYWxpbmcgZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VySGVhbGluZ0VmZmVjdHModGFyZ2V0LCBhbW91bnQsIHNvdXJjZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFbnRpdHlEZWF0aChlbnRpdHk6IEVudGl0eSwga2lsbGVyPzogRW50aXR5LCBjdXJyZW50VGltZT86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgXG4gICAgaWYgKGVuZW15KSB7XG4gICAgICBlbmVteS5kaWUoY3VycmVudFRpbWUgfHwgRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgdGhpcy5lbmVtaWVzS2lsbGVkKys7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KAICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIGJlZW4gZGVmZWF0ZWQhYCk7XG4gICAgICBcbiAgICAgIC8vIEF3YXJkIGV4cGVyaWVuY2UgdG8ga2lsbGVyIGlmIGl0J3MgYSBwbGF5ZXJcbiAgICAgIGlmIChraWxsZXIpIHtcbiAgICAgICAgdGhpcy5hd2FyZEV4cGVyaWVuY2Uoa2lsbGVyLCBlbmVteS5leHBlcmllbmNlUmV3YXJkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBkZWF0aCBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5LCBraWxsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZGVhZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzOiBFbnRpdHlbXSwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgXG4gICAgICBpZiAoIWhlYWx0aCB8fCAhZW5lbXkpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBIYW5kbGUgcmVzcGF3biBmb3IgZW5lbWllc1xuICAgICAgaWYgKGVuZW15LmlzRGVhZCAmJiBlbmVteS5jYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLnJlc3Bhd25FbmVteShlbnRpdHksIGVuZW15LCBoZWFsdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzcGF3bkVuZW15KGVudGl0eTogRW50aXR5LCBlbmVteTogRW5lbXksIGhlYWx0aDogSGVhbHRoKTogdm9pZCB7XG4gICAgLy8gUmVzcGF3biB0aGUgZW5lbXlcbiAgICBlbmVteS5yZXNwYXduKCk7XG4gICAgaGVhbHRoLnJldml2ZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SEICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIHJlc3Bhd25lZCFgKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIHJlc3Bhd24gZWZmZWN0c1xuICAgIHRoaXMudHJpZ2dlclJlc3Bhd25FZmZlY3RzKGVudGl0eSk7XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldDogRW50aXR5LCBkYW1hZ2U6IG51bWJlciwgc291cmNlPzogRW50aXR5LCBkYW1hZ2VUeXBlPzogc3RyaW5nLCBpc0NyaXRpY2FsPzogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcGFydGljbGUgZWZmZWN0cywgc2NyZWVuIHNoYWtlLCBldGMuXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBoYW5kbGUgYmFzaWMgZWZmZWN0c1xuICAgIFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb3VsZCB0cmlnZ2VyIGRhbWFnZSBudW1iZXIgcG9wdXAsIGJsb29kIGVmZmVjdHMsIGV0Yy5cbiAgICAgIC8vIEZvciBub3csIGp1c3QgbG9nIHRoZSBwb3NpdGlvbiB3aGVyZSBkYW1hZ2Ugb2NjdXJyZWRcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gaXNDcml0aWNhbCA/ICcgKENSSVRJQ0FMKScgOiAnJztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIERhbWFnZSBlZmZlY3Qke2NyaXRUZXh0fSBhdCBwb3NpdGlvbjpgLCB0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGVjaWFsIHByb2plY3RpbGUgZWZmZWN0c1xuICAgIGlmIChkYW1hZ2VUeXBlID09PSAncHJvamVjdGlsZScgJiYgc291cmNlKSB7XG4gICAgICBjb25zdCBzb3VyY2VSZW5kZXJlciA9IHNvdXJjZS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgaWYgKHNvdXJjZVJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNCYXJyYWdlQXJyb3cpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfj7kgQmFycmFnZSBhcnJvdyBoaXQgZGV0ZWN0ZWQsIGFwcGx5aW5nIHNsb3cgZWZmZWN0IHRvIHRhcmdldCAke3RhcmdldC5pZH1gKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TW92ZW1lbnQgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgaWYgKHRhcmdldE1vdmVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0TW92ZW1lbnQuc2xvdyg1MDAwLCAwLjUpOyAvLyA1IHNlY29uZHMsIDUwJSBzcGVlZFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5CMIEFwcGxpZWQgNTAlIHNsb3cgZm9yIDUgc2Vjb25kcyB0byB0YXJnZXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQ6IEVudGl0eSwgYW1vdW50OiBudW1iZXIsIHNvdXJjZT86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgaGVhbGluZyBwYXJ0aWNsZSBlZmZlY3RzXG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinKggSGVhbGluZyBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5OiBFbnRpdHksIGtpbGxlcj86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgZGVhdGggYW5pbWF0aW9ucywgbG9vdCBkcm9wcywgZXRjLlxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+SgCBEZWF0aCBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZXNwYXduRWZmZWN0cyhlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcmVzcGF3biBhbmltYXRpb25zLCBlZmZlY3RzLCBldGMuXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yfIFJlc3Bhd24gZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhd2FyZEV4cGVyaWVuY2UoZW50aXR5OiBFbnRpdHksIGV4cGVyaWVuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggYSBwcm9ncmVzc2lvbiBzeXN0ZW1cbiAgICBjb25zb2xlLmxvZyhg4q2QIEVudGl0eSAke2VudGl0eS5pZH0gZ2FpbmVkICR7ZXhwZXJpZW5jZX0gZXhwZXJpZW5jZSFgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RW50aXR5RGlzcGxheU5hbWUoZW50aXR5OiBFbnRpdHkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15KSB7XG4gICAgICByZXR1cm4gZW5lbXkuZ2V0RGlzcGxheU5hbWUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ291bGQgY2hlY2sgZm9yIG90aGVyIGNvbXBvbmVudHMgdGhhdCBwcm92aWRlIG5hbWVzXG4gICAgcmV0dXJuIGBFbnRpdHkgJHtlbnRpdHkuaWR9YDtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIG90aGVyIHN5c3RlbXMgdG8gcXVldWUgZGFtYWdlIGFuZCBoZWFsaW5nXG4gIHB1YmxpYyBxdWV1ZURhbWFnZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLnB1c2goe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGFtYWdlLFxuICAgICAgc291cmNlLFxuICAgICAgZGFtYWdlVHlwZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBxdWV1ZUhlYWxpbmcoXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIGFtb3VudDogbnVtYmVyLCBcbiAgICBzb3VyY2U/OiBFbnRpdHlcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5oZWFsUXVldWUucHVzaCh7XG4gICAgICB0YXJnZXQsXG4gICAgICBhbW91bnQsXG4gICAgICBzb3VyY2UsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCkgLyAxMDAwXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbW1lZGlhdGUgZGFtYWdlL2hlYWxpbmcgKGJ5cGFzc2VzIHF1ZXVlKVxuICBwdWJsaWMgZGVhbERhbWFnZUltbWVkaWF0ZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShkYW1hZ2UpO1xuICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYW1hZ2VEZWFsdDtcbiAgfVxuXG4gIHB1YmxpYyBoZWFsSW1tZWRpYXRlKFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBhbW91bnQ6IG51bWJlciwgXG4gICAgc291cmNlPzogRW50aXR5XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWxpbmdEb25lO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBpc0VudGl0eURlYWQoZW50aXR5OiBFbnRpdHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgcmV0dXJuIGhlYWx0aCA/IGhlYWx0aC5pc0RlYWQgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFbnRpdHlIZWFsdGhSYXRpbyhlbnRpdHk6IEVudGl0eSk6IG51bWJlciB7XG4gICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIHJldHVybiBoZWFsdGggPyBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSA6IDA7XG4gIH1cblxuICBwdWJsaWMgY2FuRW50aXR5VGFrZURhbWFnZShlbnRpdHk6IEVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICByZXR1cm4gaGVhbHRoID8gKCFoZWFsdGguaXNEZWFkICYmICFoZWFsdGguaXNJbnZ1bG5lcmFibGUpIDogZmFsc2U7XG4gIH1cblxuICAvLyBTdGF0aXN0aWNzIGFuZCBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldENvbWJhdFN0YXRzKCk6IHtcbiAgICB0b3RhbERhbWFnZURlYWx0OiBudW1iZXI7XG4gICAgdG90YWxIZWFsaW5nRG9uZTogbnVtYmVyO1xuICAgIGVuZW1pZXNLaWxsZWQ6IG51bWJlcjtcbiAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IG51bWJlcjtcbiAgICBxdWV1ZWRIZWFsRXZlbnRzOiBudW1iZXI7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbERhbWFnZURlYWx0OiB0aGlzLnRvdGFsRGFtYWdlRGVhbHQsXG4gICAgICB0b3RhbEhlYWxpbmdEb25lOiB0aGlzLnRvdGFsSGVhbGluZ0RvbmUsXG4gICAgICBlbmVtaWVzS2lsbGVkOiB0aGlzLmVuZW1pZXNLaWxsZWQsXG4gICAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IHRoaXMuZGFtYWdlUXVldWUubGVuZ3RoLFxuICAgICAgcXVldWVkSGVhbEV2ZW50czogdGhpcy5oZWFsUXVldWUubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gICAgdGhpcy50b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgICB0aGlzLmVuZW1pZXNLaWxsZWQgPSAwO1xuICB9XG5cbiAgLy8gRGFtYWdlIG51bWJlcnMgbWFuYWdlbWVudFxuICBwdWJsaWMgZ2V0RGFtYWdlTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmdldERhbWFnZU51bWJlcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVEYW1hZ2VOdW1iZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5yZW1vdmVEYW1hZ2VOdW1iZXIoaWQpO1xuICB9XG5cbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRTdGF0cygpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU3lzdGVtIiwiSGVhbHRoIiwiU2hpZWxkIiwiRW5lbXkiLCJUcmFuc2Zvcm0iLCJSZW5kZXJlciIsIk1vdmVtZW50IiwiY2FsY3VsYXRlRGFtYWdlIiwiRGFtYWdlTnVtYmVyTWFuYWdlciIsIkNvbWJhdFN5c3RlbSIsInNob3VsZExvZ0RhbWFnZSIsIm5vdyIsIkRhdGUiLCJsYXN0RGFtYWdlTG9nVGltZSIsImRhbWFnZUxvZ1Rocm90dGxlIiwic2V0RW5lbXlEYW1hZ2VDYWxsYmFjayIsImNhbGxiYWNrIiwib25FbmVteURhbWFnZUNhbGxiYWNrIiwic2V0UGxheWVyRGFtYWdlQ2FsbGJhY2siLCJvblBsYXllckRhbWFnZUNhbGxiYWNrIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsInVwZGF0ZUhlYWx0aENvbXBvbmVudHMiLCJwcm9jZXNzRGFtYWdlUXVldWUiLCJwcm9jZXNzSGVhbFF1ZXVlIiwiaGFuZGxlRGVhdGhBbmRSZXNwYXduIiwiZGFtYWdlTnVtYmVyTWFuYWdlciIsImNsZWFudXAiLCJkYW1hZ2VRdWV1ZSIsImxlbmd0aCIsImhlYWxRdWV1ZSIsImRlYWRFbnRpdGllcyIsImVudGl0eSIsImhlYWx0aCIsImdldENvbXBvbmVudCIsImVuYWJsZWQiLCJzaGllbGQiLCJlbmVteSIsInVwZGF0ZUZyZWV6ZVN0YXR1cyIsImRhbWFnZUV2ZW50IiwiYXBwbHlEYW1hZ2UiLCJoZWFsRXZlbnQiLCJhcHBseUhlYWxpbmciLCJ0YXJnZXQiLCJkYW1hZ2UiLCJiYXNlRGFtYWdlIiwic291cmNlIiwiZGFtYWdlVHlwZSIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImlkIiwiY29uc29sZSIsImxvZyIsImRhbWFnZVJlc3VsdCIsImFjdHVhbERhbWFnZSIsInRvU3RyaW5nIiwidHJhbnNmb3JtIiwicG9zaXRpb24iLCJnZXRXb3JsZFBvc2l0aW9uIiwieSIsImFkZERhbWFnZU51bWJlciIsImlzQ3JpdGljYWwiLCJzb3VyY2VOYW1lIiwidGFyZ2V0TmFtZSIsImdldEVudGl0eURpc3BsYXlOYW1lIiwiY3JpdFRleHQiLCJ4IiwidW5kZWZpbmVkIiwieiIsIndhcm4iLCJkYW1hZ2VEZWFsdCIsInRha2VEYW1hZ2UiLCJ0b3RhbERhbWFnZURlYWx0IiwiY3VycmVudEhlYWx0aCIsIm1heEhlYWx0aCIsImlzRGVhZCIsImhhbmRsZUVudGl0eURlYXRoIiwidHJpZ2dlckRhbWFnZUVmZmVjdHMiLCJhbW91bnQiLCJoZWFsaW5nRG9uZSIsImhlYWwiLCJ0b3RhbEhlYWxpbmdEb25lIiwidHJpZ2dlckhlYWxpbmdFZmZlY3RzIiwia2lsbGVyIiwiZGllIiwiZW5lbWllc0tpbGxlZCIsImF3YXJkRXhwZXJpZW5jZSIsImV4cGVyaWVuY2VSZXdhcmQiLCJ0cmlnZ2VyRGVhdGhFZmZlY3RzIiwicHVzaCIsImNhblJlc3Bhd25Ob3ciLCJyZXNwYXduRW5lbXkiLCJyZXNwYXduIiwicmV2aXZlIiwidHJpZ2dlclJlc3Bhd25FZmZlY3RzIiwic291cmNlUmVuZGVyZXIiLCJtZXNoIiwidXNlckRhdGEiLCJpc0JhcnJhZ2VBcnJvdyIsInRhcmdldE1vdmVtZW50Iiwic2xvdyIsImV4cGVyaWVuY2UiLCJxdWV1ZURhbWFnZSIsInRpbWVzdGFtcCIsInF1ZXVlSGVhbGluZyIsImRlYWxEYW1hZ2VJbW1lZGlhdGUiLCJoZWFsSW1tZWRpYXRlIiwiaXNFbnRpdHlEZWFkIiwiZ2V0RW50aXR5SGVhbHRoUmF0aW8iLCJnZXRIZWFsdGhSYXRpbyIsImNhbkVudGl0eVRha2VEYW1hZ2UiLCJpc0ludnVsbmVyYWJsZSIsImdldENvbWJhdFN0YXRzIiwicXVldWVkRGFtYWdlRXZlbnRzIiwicXVldWVkSGVhbEV2ZW50cyIsInJlc2V0U3RhdHMiLCJnZXREYW1hZ2VOdW1iZXJzIiwicmVtb3ZlRGFtYWdlTnVtYmVyIiwib25EaXNhYmxlIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsIndvcmxkIiwicmVxdWlyZWRDb21wb25lbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CombatSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ControlSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/ControlSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlSystem: function() { return /* binding */ ControlSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _CombatSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CombatSystem */ \"(app-pages-browser)/./src/systems/CombatSystem.ts\");\n/* harmony import */ var _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/dragon/weapons */ \"(app-pages-browser)/./src/components/dragon/weapons.ts\");\n/* harmony import */ var _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/weapons/DeflectBarrier */ \"(app-pages-browser)/./src/components/weapons/DeflectBarrier.ts\");\n/* harmony import */ var _components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/weapons/FrostNovaManager */ \"(app-pages-browser)/./src/components/weapons/FrostNovaManager.tsx\");\n/* harmony import */ var _components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/projectiles/CobraShotManager */ \"(app-pages-browser)/./src/components/projectiles/CobraShotManager.tsx\");\n/* harmony import */ var _components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/projectiles/ViperStingManager */ \"(app-pages-browser)/./src/components/projectiles/ViperStingManager.tsx\");\n// Control system for player input handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ControlSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setPlayer(entity) {\n        this.playerEntity = entity;\n    }\n    update(entities, deltaTime) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerTransform || !playerMovement) return;\n        // Update debuff states first\n        if (typeof playerMovement.updateDebuffs === \"function\") {\n            playerMovement.updateDebuffs();\n        }\n        // Handle weapon switching\n        this.handleWeaponSwitching();\n        // Handle dash movement first (overrides regular movement)\n        this.handleDashMovement(playerMovement, playerTransform);\n        // Handle charge movement (overrides regular movement)\n        this.handleChargeMovement(playerMovement, playerTransform);\n        // Handle player movement input (only if not dashing, charging, frozen, or skyfalling)\n        if (!playerMovement.isDashing && !playerMovement.isCharging && !playerMovement.isFrozen && !this.isSkyfalling) {\n            this.handleMovementInput(playerMovement);\n        }\n        // Handle combat input\n        this.handleCombatInput(playerTransform);\n        // Update deflect barrier position if active\n        this.updateDeflectBarrier(playerTransform);\n    }\n    handleMovementInput(movement) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!playerTransform) return;\n        // Check for double-tap dashes first (before processing regular movement)\n        this.checkForDashInput(movement, playerTransform);\n        // Get input direction\n        const inputDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let hasInput = false;\n        // WASD movement\n        if (this.inputManager.isKeyPressed(\"w\")) {\n            inputDirection.z -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"s\")) {\n            inputDirection.z += 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"a\")) {\n            inputDirection.x -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"d\")) {\n            inputDirection.x += 1;\n            hasInput = true;\n        }\n        // Normalize diagonal movement\n        if (inputDirection.length() > 0) {\n            inputDirection.normalize();\n        }\n        // Convert input to world space based on camera orientation\n        if (hasInput) {\n            const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(cameraDirection);\n            // Get camera's right vector\n            const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n            // Get camera's forward vector (projected on XZ plane)\n            const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n            // Transform input direction to world space\n            const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            worldDirection.addScaledVector(cameraRight, inputDirection.x);\n            worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n            worldDirection.normalize();\n            movement.setMoveDirection(worldDirection, 1.0);\n        } else {\n            movement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n        }\n        // Handle jumping\n        if (this.inputManager.isKeyPressed(\" \")) {\n            movement.jump();\n        }\n    }\n    handleWeaponSwitching() {\n        const currentTime = Date.now() / 1000;\n        // Prevent rapid weapon switching\n        if (currentTime - this.lastWeaponSwitchTime < this.weaponSwitchCooldown) {\n            return;\n        }\n        // Handle weapon switching with number keys\n        if (this.inputManager.isKeyPressed(\"1\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.DIVINITY; // Default sword subclass\n                this.fireRate = this.swordFireRate; // Use sword-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to sword\n            }\n        } else if (this.inputManager.isKeyPressed(\"2\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL; // Default bow subclass\n                this.fireRate = 0.225; // Bow fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"3\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.CHAOS; // Default scythe subclass\n                this.fireRate = this.scytheFireRate; // Use scythe fire rate (0.5s)\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        } else if (this.inputManager.isKeyPressed(\"4\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n                this.resetAllAbilityStates(); // Reset all ability states when switching weapons\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.FROST; // Default sabres subclass\n                this.fireRate = this.sabresFireRate; // Use sabres-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n            }\n        }\n    }\n    handleCombatInput(playerTransform) {\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            this.handleBowInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            this.handleScytheInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            this.handleSwordInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            this.handleSabresInput(playerTransform);\n        }\n    }\n    handleBowInput(playerTransform) {\n        // Handle Viper Sting ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isViperStingCharging && !this.isCharging) {\n            this.performViperSting(playerTransform);\n        }\n        // Handle Barrage ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\")) {\n            if (!this.isBarrageCharging && !this.isCharging && !this.isViperStingCharging) {\n                this.performBarrage(playerTransform);\n            }\n        }\n        // Handle Cobra Shot ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\")) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.performCobraShot(playerTransform);\n            }\n        }\n        // Handle bow charging and firing\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n            }\n            // Increase charge progress (could be time-based)\n            if (!this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.chargeProgress = Math.min(this.chargeProgress + 0.0125, 1.0); // BOW CHARGE SPEED\n            }\n        } else if (this.isCharging) {\n            // Check if any ability is charging - if so, cancel the regular bow shot\n            if (this.isViperStingCharging || this.isBarrageCharging || this.isCobraShotCharging) {\n                this.isCharging = false;\n                this.chargeProgress = 0;\n                return;\n            }\n            // Store charge progress before resetting for visual effects\n            const finalChargeProgress = this.chargeProgress;\n            // Release the bow\n            this.fireProjectile(playerTransform);\n            this.isCharging = false;\n            this.chargeProgress = 0;\n            // Trigger visual effects callback with the stored charge progress\n            this.triggerBowReleaseEffects(finalChargeProgress);\n        }\n    }\n    handleScytheInput(playerTransform) {\n        // Handle scythe left click for EntropicBolt\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\"⚡ Started charging scythe (spinning)\");\n            }\n            // Increase charge progress continuously for spinning animation (no cap)\n            this.chargeProgress += 0.03; // Continuously increase for spinning\n            // Fire EntropicBolt projectiles continuously while spinning\n            this.fireEntropicBoltProjectile(playerTransform);\n        } else if (this.isCharging) {\n            // Stop spinning when mouse is released\n            this.isCharging = false;\n            this.chargeProgress = 0;\n        }\n        // Handle CrossentropyBolt ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isCharging) {\n            this.fireCrossentropyBoltAbility(playerTransform);\n        }\n        // Handle Reanimate ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isCharging) {\n            this.performReanimateAbility(playerTransform);\n        }\n        // Handle Frost Nova ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isCharging) {\n            this.performFrostNovaAbility(playerTransform);\n        }\n    }\n    fireProjectile(playerTransform) {\n        // Rate limiting - prevent spam clicking\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.fireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction (same as camera direction since dragon faces camera)\n        // This ensures arrows fire outward from where the dragon is facing\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation to account for restricted camera bounds\n        // Since camera can't look down much due to bounds, we add a fixed downward angle\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        // Create a rotation matrix to apply the downward angle around the camera's right axis\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Perfect shot timing constants\n        const perfectShotMinThreshold = 0.7; // 85% charge\n        const perfectShotMaxThreshold = 0.98; // 95% charge\n        const isPerfectShot = this.chargeProgress >= perfectShotMinThreshold && this.chargeProgress <= perfectShotMaxThreshold;\n        // Check if bow is fully charged for special projectile\n        if (this.chargeProgress >= 1.0) {\n            this.createChargedArrowProjectile(playerTransform.position.clone(), direction);\n        } else if (isPerfectShot) {\n            this.createPerfectShotProjectile(playerTransform.position.clone(), direction);\n        } else {\n            // Debug: Log the firing angle to verify it's changing with camera rotation\n            const angle = Math.atan2(direction.x, direction.z);\n            this.createProjectile(playerTransform.position.clone(), direction);\n        }\n    }\n    fireEntropicBoltProjectile(playerTransform) {\n        // Rate limiting - use new scythe rate (0.35 seconds)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.scytheFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        const spinStatus = this.isCharging ? \" (SPINNING)\" : \"\";\n        this.createEntropicBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    fireCrossentropyBoltAbility(playerTransform) {\n        // Rate limiting - use CrossentropyBolt rate (1 per second)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCrossentropyTime < this.crossentropyFireRate) {\n            return;\n        }\n        this.lastCrossentropyTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        this.createCrossentropyBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    createProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create projectile using the ProjectileSystem with current weapon config\n        const projectileConfig = {\n            speed: 25,\n            damage: 10,\n            lifetime: 3,\n            maxDistance: 25,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createProjectile(this.world, spawnPosition, direction, this.playerEntity.id, projectileConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"regular_arrow\", spawnPosition, direction, projectileConfig);\n        }\n    }\n    createEntropicBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            return;\n        }\n        // Check if player has enough mana (15 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastEntropicBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(10);\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create EntropicBolt projectile using the new method\n        const entropicConfig = {\n            speed: 20,\n            damage: 20,\n            lifetime: 2,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createEntropicBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, entropicConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"entropic_bolt\", spawnPosition, direction, entropicConfig);\n        }\n    }\n    createCrossentropyBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(40);\n            console.log(\"⚔️ Consumed 40 mana for Crossentropy Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 1; // Slightly higher\n        // Create CrossentropyBolt projectile using the existing method\n        const crossentropyConfig = {\n            speed: 15,\n            damage: 90,\n            lifetime: 2.5,\n            piercing: false,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createCrossentropyBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, crossentropyConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"crossentropy_bolt\", spawnPosition, direction, crossentropyConfig);\n        }\n    }\n    performReanimateAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Rate limiting - prevent spam casting (1 second cooldown)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastReanimateTime < 1.0) {\n            return;\n        }\n        this.lastReanimateTime = currentTime;\n        // Check if player has enough mana (20 mana cost - doubled from 10)\n        const gameUI = window.gameUI;\n        const currentMana = gameUI ? gameUI.getCurrentMana() : 0;\n        if (gameUI && !gameUI.canCastReanimate()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(20);\n            const manaAfter = gameUI.getCurrentMana();\n        }\n        // Always trigger the visual effect first, regardless of healing success\n        this.triggerReanimateEffect(playerTransform);\n        // Get player's health component and heal for 30 HP \n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const didHeal = healthComponent.heal(30); // REANIMATE HEAL AMOUNT\n            if (didHeal) {\n            // console.log(`🩸 Reanimate healed player for 30 HP. Current health: ${healthComponent.currentHealth}/${healthComponent.maxHealth}`);\n            } else {\n            // console.log('🩸 Reanimate cast successfully but player already at full health');\n            }\n        }\n    }\n    triggerReanimateEffect(playerTransform) {\n        // Trigger the visual healing effect\n        if (this.onReanimateCallback) {\n            this.onReanimateCallback();\n        }\n        const playerPosition = playerTransform.position;\n    }\n    performFrostNovaAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFrostNovaTime < this.frostNovaFireRate) {\n            return;\n        }\n        // Check if player has enough mana (50 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastFrostNova()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(50);\n        }\n        this.lastFrostNovaTime = currentTime;\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger Frost Nova callback for visual effects\n        if (this.onFrostNovaCallback) {\n            this.onFrostNovaCallback(playerPosition, direction);\n        }\n        // Find all enemies within 5 unit radius and freeze them\n        this.freezeEnemiesInRadius(playerPosition, 6.0, currentTime);\n        // Trigger global frost nova visual effect\n        (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.triggerGlobalFrostNova)(playerPosition);\n    }\n    performCobraShot(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCobraShotTime < this.cobraShotFireRate) {\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCobraShot()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isCobraShotCharging = true;\n        this.cobraShotChargeProgress = 0;\n        this.lastCobraShotTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 750; // 0.75 second charge time (between Viper Sting and Barrage)\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.cobraShotChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.cobraShotChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCobraShot(playerTransform);\n                this.isCobraShotCharging = false;\n                this.cobraShotChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCobraShot(playerTransform) {\n        // Get player position and direction (same as other projectiles)\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level like Viper Sting\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Cobra Shot damage is handled by CobraShotManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage (similar to Viper Sting)\n        // Trigger Cobra Shot callback for visual effects\n        if (this.onCobraShotCallback) {\n            this.onCobraShotCallback(spawnPosition, direction);\n        }\n        // Trigger global cobra shot with proper positioning (handles local visual effects and damage)\n        (0,_components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_12__.triggerGlobalCobraShot)(spawnPosition, direction);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"cobra_shot_projectile\", spawnPosition, direction, {\n                speed: 20,\n                damage: 29,\n                lifetime: 8,\n                venomDuration: 6\n            });\n        }\n    }\n    freezeEnemiesInRadius(centerPosition, radius, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        let frozenCount = 0;\n        let damagedPlayers = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            // Skip self\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const entityPosition = entityTransform.position;\n            const distance = centerPosition.distanceTo(entityPosition);\n            // Check if entity is within freeze radius\n            if (distance <= radius) {\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                if (enemy) {\n                    // This is an enemy - freeze it (single player mode)\n                    enemy.freeze(6.0, currentTime);\n                    frozenCount++;\n                    // Add frozen visual effect for this enemy\n                    (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.addGlobalFrozenEnemy)(entity.id.toString(), entityPosition);\n                } else {\n                    // This is likely another player in PVP mode - deal damage and freeze\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        const frostNovaDamage = 50; // Frost Nova damage\n                        combatSystem.queueDamage(entity, frostNovaDamage, this.playerEntity, \"frost_nova\");\n                        damagedPlayers++;\n                        // Broadcast freeze effect to the target player so they get frozen on their end\n                        if (this.onDebuffCallback) {\n                            this.onDebuffCallback(entity.id, \"frozen\", 6000, entityPosition);\n                        }\n                    }\n                }\n            }\n        });\n        if (frozenCount > 0) {\n        // console.log(`❄️ Frost Nova froze ${frozenCount} enemies within ${radius} unit radius`);\n        }\n        if (damagedPlayers > 0) {\n        // console.log(`❄️ Frost Nova damaged ${damagedPlayers} players within ${radius} unit radius`);\n        }\n    }\n    createChargedArrowProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create charged arrow projectile - more powerful than regular arrows\n        const chargedArrowConfig = {\n            speed: 35,\n            damage: 50,\n            lifetime: 2,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, chargedArrowConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"charged_arrow\", spawnPosition, direction, chargedArrowConfig);\n        }\n    }\n    createPerfectShotProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create perfect shot projectile - enhanced charged arrow with special effects\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, {\n            speed: 40,\n            damage: 75,\n            lifetime: 6,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        });\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"perfect_shot\", spawnPosition, direction, {\n                speed: 40,\n                damage: 75,\n                lifetime: 6,\n                piercing: true,\n                subclass: this.currentSubclass,\n                level: this.currentLevel,\n                opacity: 1.0\n            });\n        }\n    }\n    // Methods to configure weapon for testing\n    setWeaponSubclass(subclass) {\n        this.currentSubclass = subclass;\n    }\n    // Method to set bow release callback\n    setBowReleaseCallback(callback) {\n        this.onBowReleaseCallback = callback;\n    }\n    setDivineStormCallback(callback) {\n        this.onDivineStormCallback = callback;\n    }\n    setProjectileCreatedCallback(callback) {\n        this.onProjectileCreatedCallback = callback;\n    }\n    setViperStingCallback(callback) {\n        this.onViperStingCallback = callback;\n    }\n    setBarrageCallback(callback) {\n        this.onBarrageCallback = callback;\n    }\n    setReanimateCallback(callback) {\n        this.onReanimateCallback = callback;\n    }\n    setFrostNovaCallback(callback) {\n        this.onFrostNovaCallback = callback;\n    }\n    setCobraShotCallback(callback) {\n        this.onCobraShotCallback = callback;\n    }\n    setChargeCallback(callback) {\n        this.onChargeCallback = callback;\n    }\n    setDeflectCallback(callback) {\n        this.onDeflectCallback = callback;\n    }\n    setSkyfallCallback(callback) {\n        this.onSkyfallCallback = callback;\n    }\n    setBackstabCallback(callback) {\n        this.onBackstabCallback = callback;\n    }\n    setDebuffCallback(callback) {\n        this.onDebuffCallback = callback;\n    }\n    // Method to trigger bow release effects\n    triggerBowReleaseEffects(finalChargeProgress) {\n        if (this.onBowReleaseCallback) {\n            // Check if this was a perfect shot\n            const perfectShotMinThreshold = 0.75; // 85% charge\n            const perfectShotMaxThreshold = 0.98; // 95% charge\n            const isPerfectShot = finalChargeProgress >= perfectShotMinThreshold && finalChargeProgress <= perfectShotMaxThreshold;\n            this.onBowReleaseCallback(finalChargeProgress, isPerfectShot);\n        }\n    }\n    setWeaponLevel(level) {\n        this.currentLevel = level;\n    }\n    getCurrentWeaponConfig() {\n        return {\n            weapon: this.currentWeapon,\n            subclass: this.currentSubclass,\n            level: this.currentLevel\n        };\n    }\n    // Getters for weapon state (for UI/rendering)\n    getCurrentWeapon() {\n        return this.currentWeapon;\n    }\n    getCurrentSubclass() {\n        return this.currentSubclass;\n    }\n    isWeaponCharging() {\n        return this.isCharging;\n    }\n    getChargeProgress() {\n        return this.chargeProgress;\n    }\n    isViperStingChargingActive() {\n        return this.isViperStingCharging;\n    }\n    getViperStingChargeProgress() {\n        return this.viperStingChargeProgress;\n    }\n    isBarrageChargingActive() {\n        return this.isBarrageCharging;\n    }\n    getBarrageChargeProgress() {\n        return this.barrageChargeProgress;\n    }\n    isCobraShotChargingActive() {\n        return this.isCobraShotCharging;\n    }\n    getCobraShotChargeProgress() {\n        return this.cobraShotChargeProgress;\n    }\n    isWeaponSwinging() {\n        return this.isSwinging;\n    }\n    // Sword-specific getters\n    getSwordComboStep() {\n        return this.swordComboStep;\n    }\n    isDivineStormActive() {\n        return this.isDivineStorming;\n    }\n    isChargeActive() {\n        return this.isSwordCharging;\n    }\n    isDeflectActive() {\n        return this.isDeflecting;\n    }\n    isSkyfallActive() {\n        return this.isSkyfalling;\n    }\n    isBackstabActive() {\n        return this.isBackstabbing;\n    }\n    handleSwordInput(playerTransform) {\n        // Handle sword melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isDivineStorming && !this.isSwordCharging && !this.isDeflecting) {\n            this.performSwordMeleeAttack(playerTransform);\n        }\n        // Handle Divine Storm ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting) {\n            this.performDivineStorm(playerTransform);\n        }\n        // Handle Charge ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwordCharging && !this.isDivineStorming && !this.isSwinging && !this.isDeflecting) {\n            this.performCharge(playerTransform);\n        }\n        // Handle Deflect ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeflecting && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging) {\n            this.performDeflect(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    performSwordMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sword-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.swordFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        // Set swinging state - completion will be handled by sword component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    // Called by sword component when swing animation completes\n    onSwordSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        // Reset swinging state\n        this.isSwinging = false;\n        // Advance combo step for next attack\n        this.swordComboStep = this.swordComboStep % 3 + 1;\n    }\n    handleSabresInput(playerTransform) {\n        // Handle left click for dual sabre attack\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isSkyfalling) {\n            this.performSabresMeleeAttack(playerTransform);\n        }\n        // Handle Q key for Backstab ability\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isSwinging && !this.isSkyfalling) {\n            this.performBackstab(playerTransform);\n        }\n        // Handle E key for Skyfall ability\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSkyfalling) {\n            this.performSkyfall(playerTransform);\n        }\n        // Update Skyfall state if active\n        if (this.isSkyfalling) {\n            this.updateSkyfallMovement(playerTransform);\n        }\n        // Update Backstab state if active\n        if (this.isBackstabbing) {\n            this.updateBackstabState(playerTransform);\n        }\n    }\n    performSabresMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sabres-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.sabresFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        console.log(\"⚔️ Sabres dual attack initiated\");\n        // Set swinging state - completion will be handled by sabres component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (dual attack)\n        this.performSabresMeleeDamage(playerTransform);\n    }\n    // Called by sabres component when swing animation completes\n    onSabresSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\"⚔️ Sabres dual swing completed\");\n        // Reset swinging state\n        this.isSwinging = false;\n    }\n    performSabresMeleeDamage(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Get all entities that could be damaged\n        const allEntities = this.world.getAllEntities();\n        const potentialTargets = allEntities.filter((entity)=>entity.hasComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health) && entity.hasComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform) && entity !== this.playerEntity);\n        // SABRES DAMAGE\n        const attackRange = 3.8; // Slightly longer range than sword\n        const attackAngle = Math.PI / 2; // 60 degree cone (wider than sword)\n        const leftSabreDamage = 19;\n        const rightSabreDamage = 23;\n        // Get camera direction for attack direction\n        const attackDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(attackDirection);\n        attackDirection.normalize();\n        let hitCount = 0;\n        for (const target of potentialTargets){\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!targetTransform || !targetHealth || targetHealth.isDead) continue;\n            // Calculate direction to target\n            const directionToTarget = targetTransform.position.clone().sub(playerTransform.position);\n            const distanceToTarget = directionToTarget.length();\n            // Check if target is within range\n            if (distanceToTarget > attackRange) continue;\n            // Check if target is within attack cone\n            directionToTarget.normalize();\n            const dotProduct = attackDirection.dot(directionToTarget);\n            const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dotProduct)));\n            if (angleToTarget > attackAngle / 2) continue;\n            // Target is within range and cone - apply damage from both sabres\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                // Left sabre hit (immediate)\n                combatSystem.queueDamage(target, leftSabreDamage, this.playerEntity || undefined);\n                // Right sabre hit (with small delay)\n                setTimeout(()=>{\n                    if (!targetHealth.isDead) {\n                        combatSystem.queueDamage(target, rightSabreDamage, this.playerEntity || undefined);\n                    }\n                }, 100); // 100ms delay between sabre hits\n                hitCount++;\n            }\n        }\n    }\n    // Skyfall ability implementation\n    performSkyfall(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastSkyfallTime < this.skyfallCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastSkyfall()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(40);\n        // Start Skyfall\n        this.isSkyfalling = true;\n        this.skyfallPhase = \"ascending\";\n        this.skyfallStartTime = currentTime;\n        this.lastSkyfallTime = currentTime;\n        this.skyfallStartPosition.copy(playerTransform.position);\n        // Set target height (double jump height)\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            this.skyfallOriginalGravity = playerMovement.gravity;\n            this.skyfallTargetHeight = playerTransform.position.y + playerMovement.jumpForce * 1.4; // Reduced height by 30% (was 2x, now 1.4x)\n            // Apply upward velocity\n            playerMovement.velocity.y = playerMovement.jumpForce * 2; // Stronger initial velocity\n            playerMovement.gravity = 0; // Disable gravity during ascent\n        // Don't disable canMove as it prevents all physics updates including gravity\n        // Instead we'll control horizontal movement in the ControlSystem\n        }\n        // Trigger callback for multiplayer/visual effects\n        if (this.onSkyfallCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onSkyfallCallback(playerTransform.position, direction);\n        }\n    }\n    updateSkyfallMovement(playerTransform) {\n        var _this_playerEntity;\n        const currentTime = Date.now() / 1000;\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerMovement) return;\n        const elapsedTime = currentTime - this.skyfallStartTime;\n        switch(this.skyfallPhase){\n            case \"ascending\":\n                // Check if we've reached target height or started falling\n                if (playerTransform.position.y >= this.skyfallTargetHeight || playerMovement.velocity.y <= 0) {\n                    this.skyfallPhase = \"descending\";\n                    playerMovement.velocity.y = 0; // Stop at peak\n                    playerMovement.gravity = this.skyfallOriginalGravity * 30; // Faster descent\n                }\n                break;\n            case \"descending\":\n                // Check if we've landed (close to original height or on ground)\n                if (playerTransform.position.y <= this.skyfallStartPosition.y + 0.5) {\n                    this.skyfallPhase = \"landing\";\n                    this.performSkyfallLanding(playerTransform);\n                }\n                break;\n            case \"landing\":\n                // Landing phase complete\n                this.completeSkyfallAbility(playerTransform);\n                break;\n        }\n        // Safety timeout (if something goes wrong, end after 5 seconds)\n        if (elapsedTime > 4.0) {\n            this.completeSkyfallAbility(playerTransform);\n        }\n    }\n    performSkyfallLanding(playerTransform) {\n        // Deal damage to enemies in landing area\n        const allEntities = this.world.getAllEntities();\n        const landingPosition = playerTransform.position;\n        const damageRadius = 4.0; // 4 unit radius\n        const skyfallDamage = 125; // 125 damage as requested\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check distance to landing position\n            const distanceToLanding = landingPosition.distanceTo(targetTransform.position);\n            if (distanceToLanding <= damageRadius) {\n                // Apply Skyfall damage\n                const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                if (combatSystem) {\n                    combatSystem.queueDamage(entity, skyfallDamage, this.playerEntity || undefined);\n                    hitCount++;\n                }\n            }\n        }\n    }\n    completeSkyfallAbility(playerTransform) {\n        var _this_playerEntity;\n        // Reset all Skyfall states\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        // Restore player movement\n        const playerMovement = (_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (playerMovement) {\n            playerMovement.gravity = this.skyfallOriginalGravity;\n            playerMovement.velocity.y = 0; // Stop any remaining vertical movement\n        }\n    }\n    updateBackstabState(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        const elapsedTime = currentTime - this.backstabStartTime;\n        // Check if backstab animation duration has elapsed\n        if (elapsedTime >= this.backstabDuration) {\n            this.isBackstabbing = false;\n        }\n    }\n    resetAllAbilityStates() {\n        // Reset all ability states when switching weapons\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.isBackstabbing = false;\n        this.isDivineStorming = false;\n        this.isSwordCharging = false;\n        this.isDeflecting = false;\n    }\n    // Backstab ability implementation\n    performBackstab(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Check cooldown\n        if (currentTime - this.lastBackstabTime < this.backstabCooldown) {\n            return;\n        }\n        // Check energy cost\n        const gameUI = window.gameUI;\n        if (!gameUI || !gameUI.canCastBackstab()) {\n            return;\n        }\n        // Consume energy\n        gameUI.consumeEnergy(60);\n        // Set cooldown\n        this.lastBackstabTime = currentTime;\n        // Start backstab animation\n        this.isBackstabbing = true;\n        this.backstabStartTime = currentTime;\n        // Trigger callback for multiplayer/visual effects\n        if (this.onBackstabCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            this.onBackstabCallback(playerTransform.position, direction, 75, false); // Base damage, not backstab by default\n        }\n        // Perform backstab damage\n        this.performBackstabDamage(playerTransform);\n    }\n    performBackstabDamage(playerTransform) {\n        // Get all entities in the world to check for enemies/players\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const playerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(playerDirection);\n        playerDirection.normalize();\n        const backstabRange = 2.5; // Sabre melee range\n        let hitCount = 0;\n        for (const entity of allEntities){\n            if (entity === this.playerEntity) continue;\n            const targetHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetHealth || !targetTransform || targetHealth.isDead) continue;\n            // Check if target is in range\n            const distance = playerPosition.distanceTo(targetTransform.position);\n            if (distance > backstabRange) continue;\n            // Check if target is in front of player (cone attack)\n            const directionToTarget = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(targetTransform.position, playerPosition).normalize();\n            const dotProduct = playerDirection.dot(directionToTarget);\n            const angleThreshold = Math.cos(Math.PI / 3); // 60 degree cone\n            if (dotProduct < angleThreshold) continue;\n            // Determine if this is a backstab (attacking from behind the target)\n            let isBackstab = false;\n            let damage = 75; // Base damage\n            // For PVP players, check if we're behind them\n            const pvpPlayers = window.pvpPlayers;\n            const localSocketId = window.localSocketId;\n            if (pvpPlayers && localSocketId) {\n                // Find the target player in PVP players map\n                let targetPlayer = null;\n                for (const [playerId, player] of pvpPlayers){\n                    if (playerId !== localSocketId) {\n                        const playerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(player.position.x, player.position.y, player.position.z);\n                        if (playerPos.distanceTo(targetTransform.position) < 0.5) {\n                            targetPlayer = player;\n                            break;\n                        }\n                    }\n                }\n                if (targetPlayer) {\n                    // Calculate target's facing direction from their rotation\n                    const targetFacingDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(targetPlayer.rotation.y), 0, Math.cos(targetPlayer.rotation.y)).normalize();\n                    // Vector from target to attacker\n                    const attackerDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().subVectors(playerPosition, targetTransform.position).normalize();\n                    // Check if attacker is behind target (dot product < 0 means opposite direction)\n                    const behindDotProduct = targetFacingDirection.dot(attackerDirection);\n                    isBackstab = behindDotProduct < -0.3; // 70 degree cone behind target\n                    if (isBackstab) {\n                        damage = 175; // Backstab damage\n                    }\n                }\n            }\n            // Apply damage\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                combatSystem.queueDamage(entity, damage, this.playerEntity, \"backstab\");\n                hitCount++;\n            }\n        }\n    }\n    performMeleeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Melee attack parameters - increased for PVP combat\n        const meleeRange = 4.5; // Increased attack range for PVP\n        const meleeAngle = Math.PI / 2; // 120 degree cone (60 degrees each side)\n        // Base damage values based on combo step - works for all subclasses\n        let baseDamage = 45; // Base sword damage\n        // Combo damage scaling\n        switch(this.swordComboStep){\n            case 1:\n                baseDamage = 40;\n                break;\n            case 2:\n                baseDamage = 45;\n                break;\n            case 3:\n                baseDamage = 55;\n                break; // Finisher does more damage\n        }\n        // Get combat system to apply damage\n        const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n        // Track enemies hit for rage generation\n        let enemiesHit = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            // Check if entity has enemy component and health\n            const enemyTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const enemyHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!enemyTransform || !enemyHealth || entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const enemyPosition = enemyTransform.position;\n            const toEnemy = enemyPosition.clone().sub(playerPosition);\n            const distance = toEnemy.length();\n            // Debug logging for PVP hit detection\n            // Check if enemy is within range\n            if (distance <= meleeRange) {\n                // Check if enemy is within attack cone\n                toEnemy.normalize();\n                const angle = direction.angleTo(toEnemy);\n                const angleDegrees = angle * 180 / Math.PI;\n                const maxAngleDegrees = meleeAngle / 2 * 180 / Math.PI;\n                if (angle <= meleeAngle / 2) {\n                    // Enemy is within attack cone - deal damage through combat system\n                    if (combatSystem && this.playerEntity) {\n                        // Queue damage through combat system (which will route to multiplayer for enemies)\n                        combatSystem.queueDamage(entity, baseDamage, this.playerEntity, \"melee\");\n                        enemiesHit++;\n                    }\n                }\n            }\n        });\n        // Generate rage only if we hit enemies (5 rage per hit, max 5 per swing)\n        if (enemiesHit > 0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const rageToGain = Math.min(enemiesHit * 5, 5); // 5 rage per hit, max 5 per swing\n                gameUI.gainRage(rageToGain);\n            }\n        }\n    }\n    checkForDashInput(movement, transform) {\n        // Check for double-tap on movement keys\n        const dashDirections = [\n            {\n                key: \"w\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)\n            },\n            {\n                key: \"s\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n            },\n            {\n                key: \"a\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0)\n            },\n            {\n                key: \"d\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0)\n            } // Right\n        ];\n        for (const { key, direction } of dashDirections){\n            if (this.inputManager.checkDoubleTap(key)) {\n                // Debug: Log the double tap detection\n                const debugInfo = this.inputManager.getDoubleTapDebugInfo(key);\n                // Convert input direction to world space based on camera orientation\n                const worldDirection = this.getWorldSpaceDirection(direction);\n                // Attempt to start dash\n                const currentTime = Date.now() / 1000; // Convert to seconds\n                const dashStarted = movement.startDash(worldDirection, transform.position, currentTime);\n                if (dashStarted) {\n                    // Reset the double-tap state to prevent multiple dashes\n                    this.inputManager.resetDoubleTap(key);\n                }\n                break; // Only process one dash per frame\n            }\n        }\n    }\n    handleDashMovement(movement, transform) {\n        if (!movement.isDashing) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        const dashResult = movement.updateDash(currentTime);\n        if (dashResult.newPosition) {\n            // Apply bounds checking (similar to old implementation)\n            const MAX_DASH_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = dashResult.newPosition.length();\n            if (distanceFromOrigin <= MAX_DASH_BOUNDS) {\n                transform.position.copy(dashResult.newPosition);\n            } else {\n                // Cancel dash if it would move too far from origin\n                // console.warn(`Dash cancelled: would move too far from origin (${distanceFromOrigin.toFixed(2)} > ${MAX_DASH_BOUNDS})`);\n                movement.cancelDash();\n            }\n        }\n    }\n    handleChargeMovement(movement, transform) {\n        if (!movement.isCharging) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        // Check if charge was stopped by collision\n        if (this.chargeStoppedByCollision) {\n            movement.cancelCharge();\n            return;\n        }\n        const chargeResult = movement.updateCharge(currentTime);\n        if (chargeResult.newPosition) {\n            // Apply bounds checking\n            const MAX_CHARGE_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = chargeResult.newPosition.length();\n            // Check for pillar collision\n            const pillarCollision = this.checkPillarCollision(chargeResult.newPosition);\n            if (distanceFromOrigin > MAX_CHARGE_BOUNDS) {\n                // Cancel charge if it would move too far from origin\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (pillarCollision.hasCollision) {\n                // Cancel charge if it would collide with a pillar\n                console.warn(\"Charge cancelled: would collide with pillar at [\".concat(pillarCollision.pillarCenter.toArray().join(\", \"), \"]\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (!this.chargeStoppedByCollision) {\n                // Only update position if not stopped by collision\n                transform.position.copy(chargeResult.newPosition);\n            }\n        }\n        if (chargeResult.isComplete || this.chargeStoppedByCollision) {\n            console.log(\"⚔️ Charge movement completed\");\n            // Notify sword component that charge is complete\n            this.onChargeComplete();\n        }\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    getWorldSpaceDirection(inputDirection) {\n        // Get camera direction vectors\n        const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(cameraDirection);\n        // Get camera's right vector\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Get camera's forward vector (projected on XZ plane)\n        const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n        // Transform input direction to world space\n        const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldDirection.addScaledVector(cameraRight, inputDirection.x);\n        worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n        worldDirection.normalize();\n        return worldDirection;\n    }\n    performDivineStorm(playerTransform) {\n        // Check if player has enough rage (minimum 20 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDivineStorm()) {\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDivineStormTime < this.divineStormCooldown) {\n            return;\n        }\n        // Get current rage amount and consume ALL rage\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40; // Fallback to 40 if gameUI not available\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 20\n        }\n        // Calculate extended duration: base 4 seconds + 1 second per 10 rage consumed\n        const baseStormDuration = 1000; // 4 seconds base\n        const bonusDuration = Math.floor(currentRage / 10) * 500; // 1 second per 10 rage\n        const totalDivineStormDuration = baseStormDuration + bonusDuration;\n        this.isDivineStorming = true;\n        this.lastDivineStormTime = currentTime;\n        // Trigger Divine Storm callback for multiplayer\n        if (this.onDivineStormCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDivineStormCallback(playerTransform.position.clone(), direction, totalDivineStormDuration);\n        }\n        // Divine Storm lasts for calculated duration\n        setTimeout(()=>{\n            this.isDivineStorming = false;\n        }, totalDivineStormDuration);\n    }\n    performCharge(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastChargeTime < this.chargeCooldown) {\n            return;\n        }\n        this.isSwordCharging = true;\n        this.lastChargeTime = currentTime;\n        // Reset collision tracking for new charge\n        this.chargeStoppedByCollision = false;\n        // Trigger Charge callback for multiplayer\n        if (this.onChargeCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onChargeCallback(playerTransform.position.clone(), direction);\n        }\n        // Gain rage for using charge ability (+20 rage)\n        const gameUI = window.gameUI;\n        if (gameUI) {\n            gameUI.gainRage(20);\n        }\n        // Start the charge movement using the separate charge system\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                // Get charge direction from camera\n                const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(direction);\n                direction.y = 0; // Keep movement horizontal\n                direction.normalize();\n                // Start charge with 10.5 distance (separate from dash system)\n                const chargeStarted = playerMovement.startCharge(direction, playerTransform.position, currentTime);\n                if (chargeStarted) {\n                    // Schedule charge damage detection during movement\n                    this.scheduleChargeDamage(playerTransform, direction, currentTime);\n                }\n            }\n        }\n    }\n    // Schedule damage detection during charge movement\n    scheduleChargeDamage(playerTransform, chargeDirection, startTime) {\n        const chargeDuration = 0.6;\n        const damageCheckInterval = 50; // Check for damage every 50ms for better collision detection\n        const chargeDamage = 40; // High damage for charge ability\n        const chargeRadius = 2.5; // Damage radius around player during charge\n        // Reset charge hit tracking\n        this.chargeHitEntities.clear();\n        this.chargeStoppedByCollision = false;\n        const damageInterval = setInterval(()=>{\n            const currentTime = Date.now() / 1000;\n            // Stop if charge is complete, cancelled, or stopped by collision\n            if (!this.isSwordCharging || currentTime - startTime > chargeDuration || this.chargeStoppedByCollision) {\n                clearInterval(damageInterval);\n                return;\n            }\n            // Get all entities in the world to check for damage\n            const allEntities = this.world.getAllEntities();\n            const playerPosition = playerTransform.position;\n            let hitSomething = false;\n            // Debug: Log all entities in the world during charge\n            // ENHANCED: Also check against server player positions directly as a fallback\n            // This ensures we don't miss collisions due to entity sync issues\n            const serverPlayers = window.pvpPlayers || new Map();\n            const localSocketId = window.localSocketId;\n            serverPlayers.forEach((serverPlayer, playerId)=>{\n                // Skip self\n                if (playerId === localSocketId) return;\n                // Skip already hit players (use hash of player ID for tracking)\n                const playerIdHash = playerId.length * 1000 + playerId.charCodeAt(0);\n                if (this.chargeHitEntities.has(playerIdHash)) return;\n                const serverPlayerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(serverPlayer.position.x, serverPlayer.position.y, serverPlayer.position.z);\n                const distance = playerPosition.distanceTo(serverPlayerPos);\n                const stopDistance = 0.9 + 1.0; // Player collision radius + buffer\n                if (distance <= stopDistance && serverPlayer.health > 0) {\n                    this.chargeHitEntities.add(playerIdHash);\n                    hitSomething = true;\n                    // Apply damage through PVP system if available\n                    if (this.onProjectileCreatedCallback) {\n                        this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                            damage: chargeDamage,\n                            targetId: playerId,\n                            hitPosition: {\n                                x: serverPlayerPos.x,\n                                y: serverPlayerPos.y,\n                                z: serverPlayerPos.z\n                            }\n                        });\n                    }\n                }\n            });\n            allEntities.forEach((entity)=>{\n                var _this_playerEntity;\n                // Skip self\n                if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n                // Skip already hit entities\n                if (this.chargeHitEntities.has(entity.id)) return;\n                // Check if entity has transform and health (could be enemy or player)\n                const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n                const entityCollider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n                // Debug: Log entity details\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n                const entityPosition = entityTransform.position;\n                const distance = playerPosition.distanceTo(entityPosition);\n                // Check if entity is within charge damage radius\n                // In PVP, we want to stop just before hitting the enemy, not overlap with them\n                const stopDistance = entityCollider ? entityCollider.radius + 1.0 : chargeRadius; // Stop 1 unit away from enemy edge\n                // Debug: Log position and distance information\n                if (distance <= stopDistance) {\n                    // Mark as hit to prevent multiple hits\n                    this.chargeHitEntities.add(entity.id);\n                    hitSomething = true;\n                    // Apply damage through combat system\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        combatSystem.queueDamage(entity, chargeDamage, this.playerEntity, \"charge\");\n                        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                        const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                        // Broadcast charge attack for PVP (includes damage and animation)\n                        if (this.onProjectileCreatedCallback) {\n                            this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                                damage: chargeDamage,\n                                targetId: entity.id,\n                                hitPosition: {\n                                    x: entityPosition.x,\n                                    y: entityPosition.y,\n                                    z: entityPosition.z\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            // In PVP mode, stop charge when hitting something\n            if (hitSomething) {\n                this.chargeStoppedByCollision = true;\n                // Stop the charge movement immediately\n                if (this.playerEntity) {\n                    const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                    if (playerMovement) {\n                        playerMovement.cancelCharge();\n                    }\n                }\n                // Clear the damage interval immediately to prevent further hits\n                clearInterval(damageInterval);\n                // Trigger charge completion\n                this.onChargeComplete();\n            }\n        }, damageCheckInterval);\n    }\n    // Called by sword component when Charge completes\n    onChargeComplete() {\n        this.isSwordCharging = false;\n    }\n    performDeflect(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeflectTime < this.deflectCooldown) {\n            return;\n        }\n        this.isDeflecting = true;\n        this.lastDeflectTime = currentTime;\n        // Trigger Deflect callback for multiplayer\n        if (this.onDeflectCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDeflectCallback(playerTransform.position.clone(), direction);\n        }\n        // Set up deflect barrier that blocks damage and reflects projectiles\n        this.setupDeflectBarrier(playerTransform);\n        // Auto-complete deflect after duration\n        setTimeout(()=>{\n            this.onDeflectComplete();\n        }, this.deflectDuration * 1000);\n    }\n    performViperSting(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastViperStingTime < this.viperStingFireRate) {\n            return;\n        }\n        // Check if player has enough energy (60 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastViperSting()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(60);\n        }\n        this.isViperStingCharging = true;\n        this.viperStingChargeProgress = 0;\n        this.lastViperStingTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.viperStingChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.viperStingChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireViperSting(playerTransform);\n                this.isViperStingCharging = false;\n                this.viperStingChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireViperSting(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Viper Sting damage is handled by ViperStingManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage\n        // Trigger Viper Sting callback for visual effects\n        if (this.onViperStingCallback) {\n            this.onViperStingCallback(playerPosition, direction);\n        }\n        // Trigger the global Viper Sting manager for visual effects\n        const success = (0,_components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_13__.triggerGlobalViperSting)();\n        if (success) {\n        // console.log('🐍 Viper Sting visual effects successfully triggered!');\n        }\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"viper_sting_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 61,\n                lifetime: 5,\n                isReturning: false\n            });\n        }\n    }\n    performBarrage(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastBarrageTime < this.barrageFireRate) {\n            console.log(\"⏰ Barrage on cooldown for \".concat((this.barrageFireRate - (currentTime - this.lastBarrageTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastBarrage()) {\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n        }\n        this.isBarrageCharging = true;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 500; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.barrageChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.barrageChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireBarrage(playerTransform);\n                this.isBarrageCharging = false;\n                this.barrageChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireBarrage(playerTransform) {\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.825; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        // Apply same downward compensation as projectile system\n        const compensationAngle = Math.PI / 6; // 30 degrees\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Create 5 arrows: center (0°), left (15°, 30°), right (-15°, -30°) using proper ECS projectiles\n        const angles = [\n            0,\n            Math.PI / 12,\n            -Math.PI / 12,\n            Math.PI / 6,\n            -Math.PI / 6\n        ]; // 0°, 15°, -15°, 30°, -30°\n        angles.forEach((angle)=>{\n            // Rotate the base direction by the specified angle around the Y axis\n            const projectileDirection = direction.clone();\n            const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationY(angle);\n            projectileDirection.applyMatrix4(rotationMatrix);\n            projectileDirection.normalize();\n            // Offset spawn position slightly forward to avoid collision with player\n            const spawnPosition = playerPosition.clone();\n            spawnPosition.add(projectileDirection.clone().multiplyScalar(1)); // 1 unit forward\n            // Create proper ECS projectile entity\n            const projectileConfig = {\n                speed: 22,\n                damage: 30,\n                lifetime: 8,\n                maxDistance: 25,\n                piercing: false,\n                subclass: this.currentSubclass,\n                level: 1,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, spawnPosition, projectileDirection, this.playerEntity.id, projectileConfig);\n            // Mark as barrage arrow for visual identification\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__.Renderer);\n            if (renderer === null || renderer === void 0 ? void 0 : renderer.mesh) {\n                renderer.mesh.userData.isBarrageArrow = true;\n                renderer.mesh.userData.isRegularArrow = false; // Override regular arrow marking\n            }\n            // Broadcast projectile creation to other players\n            if (this.onProjectileCreatedCallback) {\n                this.onProjectileCreatedCallback(\"barrage_projectile\", spawnPosition, projectileDirection, projectileConfig);\n            }\n        });\n        // Trigger Barrage callback for additional visual effects if needed\n        if (this.onBarrageCallback) {\n            this.onBarrageCallback(playerPosition, direction);\n        }\n    }\n    setupDeflectBarrier(playerTransform) {\n        // Activate the deflect barrier\n        const playerPosition = playerTransform.getWorldPosition();\n        const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n        if (this.playerEntity) {\n            const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (movement && movement.inputStrength > 0.1) {\n                // Player is actively moving - use movement direction (same as DragonRenderer)\n                const moveDir = movement.moveDirection;\n                if (moveDir.length() > 0.1) {\n                    const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                    playerRotation.y = moveAngle;\n                }\n            } else {\n                // Not moving - use camera direction (same as DragonRenderer fallback)\n                const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(cameraDirection);\n                playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n            }\n        }\n        this.deflectBarrier.activate(playerPosition, playerRotation, this.playerEntity || undefined);\n    }\n    updateDeflectBarrier(playerTransform) {\n        // Update deflect barrier position if it's active\n        if (this.deflectBarrier.isBarrierActive()) {\n            const playerPosition = playerTransform.getWorldPosition();\n            const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n            if (this.playerEntity) {\n                const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                if (movement && movement.inputStrength > 0.1) {\n                    // Player is actively moving - use movement direction (same as DragonRenderer)\n                    const moveDir = movement.moveDirection;\n                    if (moveDir.length() > 0.1) {\n                        const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                        playerRotation.y = moveAngle;\n                    }\n                } else {\n                    // Not moving - use camera direction (same as DragonRenderer fallback)\n                    const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    this.camera.getWorldDirection(cameraDirection);\n                    playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n                }\n            }\n            // Update barrier position to follow player\n            this.deflectBarrier.updatePosition(playerPosition, playerRotation);\n        }\n    }\n    // Called by sword component when Deflect completes\n    onDeflectComplete() {\n        this.isDeflecting = false;\n        this.deflectBarrier.deactivate();\n    }\n    // Public methods to get cooldown information for UI\n    getWeaponSwitchCooldown() {\n        const currentTime = Date.now() / 1000;\n        return {\n            current: Math.max(0, this.weaponSwitchCooldown - (currentTime - this.lastWeaponSwitchTime)),\n            max: this.weaponSwitchCooldown\n        };\n    }\n    getAbilityCooldowns() {\n        const currentTime = Date.now() / 1000;\n        const cooldowns = {};\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deflectCooldown - (currentTime - this.lastDeflectTime)),\n                max: this.deflectCooldown,\n                isActive: this.isDeflecting\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.chargeCooldown - (currentTime - this.lastChargeTime)),\n                max: this.chargeCooldown,\n                isActive: this.isSwordCharging\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.divineStormCooldown - (currentTime - this.lastDivineStormTime)),\n                max: this.divineStormCooldown,\n                isActive: this.isDivineStorming\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.barrageFireRate - (currentTime - this.lastBarrageTime)),\n                max: this.barrageFireRate,\n                isActive: this.isBarrageCharging\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)),\n                max: this.cobraShotFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.viperStingFireRate - (currentTime - this.lastViperStingTime)),\n                max: this.viperStingFireRate,\n                isActive: this.isViperStingCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, 1.0 - (currentTime - this.lastReanimateTime)),\n                max: 1.0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)),\n                max: this.frostNovaFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.crossentropyFireRate - (currentTime - this.lastCrossentropyTime)),\n                max: this.crossentropyFireRate,\n                isActive: false\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.backstabCooldown - (currentTime - this.lastBackstabTime)),\n                max: this.backstabCooldown,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.skyfallCooldown - (currentTime - this.lastSkyfallTime)),\n                max: this.skyfallCooldown,\n                isActive: this.isSkyfalling\n            };\n            cooldowns[\"R\"] = {\n                current: 0,\n                max: 0,\n                isActive: false\n            };\n        }\n        return cooldowns;\n    }\n    constructor(camera, inputManager, world, projectileSystem){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        this.playerEntity = null;\n        // Rate limiting for projectile firing\n        this.lastFireTime = 0;\n        this.lastCrossentropyTime = 0 // Separate tracking for CrossentropyBolt\n        ;\n        this.lastReanimateTime = 0 // Separate tracking for Reanimate ability\n        ;\n        this.lastViperStingTime = 0;\n        this.lastFrostNovaTime = 0 // Separate tracking for Frost Nova ability\n        ;\n        this.lastCobraShotTime = 0 // Separate tracking for Cobra Shot ability\n        ;\n        this.fireRate = 0.225 // Default for bow\n        ;\n        this.swordFireRate = 0.9 // Rate for sword attacks\n        ;\n        this.sabresFireRate = 0.6 // Sabres dual attack rate (600ms between attacks)\n        ;\n        this.scytheFireRate = 0.33 // EntropicBolt rate (0.33s cooldown)\n        ;\n        this.crossentropyFireRate = 2 // CrossentropyBolt rate (1 per second)\n        ;\n        this.viperStingFireRate = 2.5 // Viper Sting rate (2 seconds cooldown)\n        ;\n        this.frostNovaFireRate = 12.0 // Frost Nova rate (12 seconds cooldown)\n        ;\n        this.cobraShotFireRate = 2.5 // Cobra Shot rate (2 seconds cooldown)\n        ;\n        // Current weapon configuration\n        this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW // Default weapon\n        ;\n        this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL // Default for bow\n        ;\n        this.currentLevel = 1;\n        // Weapon-specific states\n        this.isCharging = false;\n        this.chargeProgress = 0;\n        this.isSwinging = false;\n        // Viper Sting charging state\n        this.isViperStingCharging = false;\n        this.viperStingChargeProgress = 0;\n        // Barrage charging state\n        this.isBarrageCharging = false;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = 0;\n        this.barrageFireRate = 5.0 // 5 second cooldown (keeping as requested)\n        ;\n        // Cobra Shot charging state\n        this.isCobraShotCharging = false;\n        this.cobraShotChargeProgress = 0;\n        // Sword-specific states\n        this.swordComboStep = 1;\n        this.lastSwordAttackTime = 0;\n        this.swordComboResetTime = 1 // Reset combo after 1 seconds\n        ;\n        // Divine Storm ability state\n        this.isDivineStorming = false;\n        this.lastDivineStormTime = 0;\n        this.divineStormCooldown = 8.0 // 8 second cooldown\n        ;\n        // Charge ability state\n        this.isSwordCharging = false;\n        this.lastChargeTime = 0;\n        this.chargeCooldown = 8.0 // 8 second cooldown\n        ;\n        // Deflect ability state\n        this.isDeflecting = false;\n        this.lastDeflectTime = 0;\n        this.deflectCooldown = 6.0 // 8 second cooldown\n        ;\n        this.deflectDuration = 3.0 // 3 second duration\n        ;\n        // Skyfall ability state (Sabres)\n        this.isSkyfalling = false;\n        this.skyfallPhase = \"none\";\n        this.lastSkyfallTime = 0;\n        this.skyfallCooldown = 5.0 // 4 second cooldown\n        ;\n        this.skyfallStartTime = 0;\n        this.skyfallStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.skyfallTargetHeight = 0;\n        this.skyfallOriginalGravity = 0;\n        // Backstab ability state (Sabres)\n        this.lastBackstabTime = 0;\n        this.backstabCooldown = 2.0 // 2 second cooldown\n        ;\n        this.isBackstabbing = false;\n        this.backstabStartTime = 0;\n        this.backstabDuration = 1.0 // Total animation duration (0.3 + 0.4 + 0.3 seconds)\n        ;\n        this.lastWeaponSwitchTime = 0;\n        this.weaponSwitchCooldown = 1.5 // 200ms cooldown to prevent rapid switching\n        ;\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Track charge hit entities to prevent multiple hits and enable collision stopping\n        this.chargeHitEntities = new Set();\n        this.chargeStoppedByCollision = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.world = world;\n        this.projectileSystem = projectileSystem;\n        this.deflectBarrier = new _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__.DeflectBarrier(world);\n        this.priority = 5; // Run early for input handling\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBQ2M7QUFHbkI7QUFFaUI7QUFDRjtBQUNKO0FBQ0Y7QUFDTTtBQUNBO0FBSVA7QUFDMkI7QUFDSjtBQUNnQztBQUNsQjtBQUNFO0FBRTlFLE1BQU1pQixzQkFBc0JmLCtDQUFNQTtJQTRJaENnQixVQUFVQyxNQUFjLEVBQVE7UUFDckMsSUFBSSxDQUFDQyxZQUFZLEdBQUdEO0lBQ3RCO0lBRU9FLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQ0gsWUFBWSxFQUFFO1FBRXhCLE1BQU1JLGtCQUFrQixJQUFJLENBQUNKLFlBQVksQ0FBQ0ssWUFBWSxDQUFDdEIsZ0VBQVNBO1FBQ2hFLE1BQU11QixpQkFBaUIsSUFBSSxDQUFDTixZQUFZLENBQUNLLFlBQVksQ0FBQ3JCLDhEQUFRQTtRQUU5RCxJQUFJLENBQUNvQixtQkFBbUIsQ0FBQ0UsZ0JBQWdCO1FBRXpDLDZCQUE2QjtRQUM3QixJQUFJLE9BQU9BLGVBQWVDLGFBQWEsS0FBSyxZQUFZO1lBQ3RERCxlQUFlQyxhQUFhO1FBQzlCO1FBRUEsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ0MscUJBQXFCO1FBRTFCLDBEQUEwRDtRQUMxRCxJQUFJLENBQUNDLGtCQUFrQixDQUFDSCxnQkFBZ0JGO1FBRXhDLHNEQUFzRDtRQUN0RCxJQUFJLENBQUNNLG9CQUFvQixDQUFDSixnQkFBZ0JGO1FBRTFDLHNGQUFzRjtRQUN0RixJQUFJLENBQUNFLGVBQWVLLFNBQVMsSUFBSSxDQUFDTCxlQUFlTSxVQUFVLElBQUksQ0FBQ04sZUFBZU8sUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDQyxZQUFZLEVBQUU7WUFDN0csSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ1Q7UUFDM0I7UUFFQSxzQkFBc0I7UUFDdEIsSUFBSSxDQUFD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SyxxREFBcUQ7O2FBd0g3RS9QLHVCQUF1QjthQUN2QkMsdUJBQXVCLElBQUssNENBQTRDOztRQWc5Q2hGLHVEQUF1RDthQUN0Q2dVLG1CQUFtQjtZQUNsQyxJQUFJOVgseURBQU9BLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDbkIsSUFBSUEseURBQU9BLENBQUMsQ0FBQyxNQUFNLEdBQUc7WUFDdEIsSUFBSUEseURBQU9BLENBQUMsTUFBTSxHQUFHLEtBQVMsZUFBZTtTQUM5QzthQUNnQmlZLGdCQUFnQixJQUFLLDhCQUE4Qjs7UUEwSXBFLG1GQUFtRjthQUMzRXVCLG9CQUFvQixJQUFJNEQ7YUFDeEJyRywyQkFBMkI7UUFudERqQyxJQUFJLENBQUM5VCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUCxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ21GLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN3QixnQkFBZ0IsR0FBR0E7UUFDeEIsSUFBSSxDQUFDbVQsY0FBYyxHQUFHLElBQUk1YiwrRUFBY0EsQ0FBQ2lIO1FBQ3pDLElBQUksQ0FBQ3dWLFFBQVEsR0FBRyxHQUFHLCtCQUErQjtJQUNwRDtBQXF0RUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ29udHJvbFN5c3RlbS50cz8yYzI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnRyb2wgc3lzdGVtIGZvciBwbGF5ZXIgaW5wdXQgaGFuZGxpbmdcbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDQgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcbmltcG9ydCB7IENvbGxpZGVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBJbnB1dE1hbmFnZXIgfSBmcm9tICdAL2NvcmUvSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5pbXBvcnQgeyBDb21iYXRTeXN0ZW0gfSBmcm9tICcuL0NvbWJhdFN5c3RlbSc7XG5pbXBvcnQgeyBXZWFwb25TdWJjbGFzcywgV2VhcG9uVHlwZSB9IGZyb20gJ0AvY29tcG9uZW50cy9kcmFnb24vd2VhcG9ucyc7XG5pbXBvcnQgeyBEZWZsZWN0QmFycmllciB9IGZyb20gJ0AvY29tcG9uZW50cy93ZWFwb25zL0RlZmxlY3RCYXJyaWVyJztcbmltcG9ydCB7IHRyaWdnZXJHbG9iYWxGcm9zdE5vdmEsIGFkZEdsb2JhbEZyb3plbkVuZW15IH0gZnJvbSAnQC9jb21wb25lbnRzL3dlYXBvbnMvRnJvc3ROb3ZhTWFuYWdlcic7XG5pbXBvcnQgeyB0cmlnZ2VyR2xvYmFsQ29icmFTaG90IH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0NvYnJhU2hvdE1hbmFnZXInO1xuaW1wb3J0IHsgdHJpZ2dlckdsb2JhbFZpcGVyU3RpbmcgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvVmlwZXJTdGluZ01hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgQ29udHJvbFN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBNb3ZlbWVudF07XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FtZXJhOiBQZXJzcGVjdGl2ZUNhbWVyYTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbTtcbiAgcHJpdmF0ZSBwbGF5ZXJFbnRpdHk6IEVudGl0eSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJvdyByZWxlYXNlIGVmZmVjdHNcbiAgcHJpdmF0ZSBvbkJvd1JlbGVhc2VDYWxsYmFjaz86IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIERpdmluZSBTdG9ybSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EaXZpbmVTdG9ybUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgcHJvamVjdGlsZSBjcmVhdGlvblxuICBwcml2YXRlIG9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaz86IChwcm9qZWN0aWxlVHlwZTogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBjb25maWc6IGFueSkgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBWaXBlciBTdGluZyBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25WaXBlclN0aW5nQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBCYXJyYWdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkJhcnJhZ2VDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIFJlYW5pbWF0ZSBoZWFsaW5nIGVmZmVjdFxuICBwcml2YXRlIG9uUmVhbmltYXRlQ2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEZyb3N0IE5vdmEgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uRnJvc3ROb3ZhQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBDb2JyYSBTaG90IGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNvYnJhU2hvdENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgQ2hhcmdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNoYXJnZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgRGVmbGVjdCBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EZWZsZWN0Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgZGVidWZmIGVmZmVjdHMgaW4gUFZQXG4gIHByaXZhdGUgb25EZWJ1ZmZDYWxsYmFjaz86ICh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBTa3lmYWxsIGFiaWxpdHlcbiAgcHJpdmF0ZSBvblNreWZhbGxDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEJhY2tzdGFiIGFiaWxpdHlcbiAgcHJpdmF0ZSBvbkJhY2tzdGFiQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZGFtYWdlOiBudW1iZXIsIGlzQmFja3N0YWI6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIFxuICAvLyBSYXRlIGxpbWl0aW5nIGZvciBwcm9qZWN0aWxlIGZpcmluZ1xuICBwcml2YXRlIGxhc3RGaXJlVGltZSA9IDA7XG4gIHByaXZhdGUgbGFzdENyb3NzZW50cm9weVRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICBwcml2YXRlIGxhc3RSZWFuaW1hdGVUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIFJlYW5pbWF0ZSBhYmlsaXR5XG4gIHByaXZhdGUgbGFzdFZpcGVyU3RpbmdUaW1lID0gMDtcbiAgcHJpdmF0ZSBsYXN0RnJvc3ROb3ZhVGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBGcm9zdCBOb3ZhIGFiaWxpdHlcbiAgcHJpdmF0ZSBsYXN0Q29icmFTaG90VGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBDb2JyYSBTaG90IGFiaWxpdHlcbiAgcHJpdmF0ZSBmaXJlUmF0ZSA9IDAuMjI1OyAvLyBEZWZhdWx0IGZvciBib3dcbiAgcHJpdmF0ZSBzd29yZEZpcmVSYXRlID0gMC45OyAvLyBSYXRlIGZvciBzd29yZCBhdHRhY2tzXG4gIHByaXZhdGUgc2FicmVzRmlyZVJhdGUgPSAwLjY7IC8vIFNhYnJlcyBkdWFsIGF0dGFjayByYXRlICg2MDBtcyBiZXR3ZWVuIGF0dGFja3MpXG4gIHByaXZhdGUgc2N5dGhlRmlyZVJhdGUgPSAwLjMzOyAvLyBFbnRyb3BpY0JvbHQgcmF0ZSAoMC4zM3MgY29vbGRvd24pXG4gIHByaXZhdGUgY3Jvc3NlbnRyb3B5RmlyZVJhdGUgPSAyOyAvLyBDcm9zc2VudHJvcHlCb2x0IHJhdGUgKDEgcGVyIHNlY29uZClcbiAgcHJpdmF0ZSB2aXBlclN0aW5nRmlyZVJhdGUgPSAyLjU7IC8vIFZpcGVyIFN0aW5nIHJhdGUgKDIgc2Vjb25kcyBjb29sZG93bilcbiAgcHJpdmF0ZSBmcm9zdE5vdmFGaXJlUmF0ZSA9IDEyLjA7IC8vIEZyb3N0IE5vdmEgcmF0ZSAoMTIgc2Vjb25kcyBjb29sZG93bilcbiAgcHJpdmF0ZSBjb2JyYVNob3RGaXJlUmF0ZSA9IDIuNTsgLy8gQ29icmEgU2hvdCByYXRlICgyIHNlY29uZHMgY29vbGRvd24pXG4gIFxuICAvLyBDdXJyZW50IHdlYXBvbiBjb25maWd1cmF0aW9uXG4gIHByaXZhdGUgY3VycmVudFdlYXBvbjogV2VhcG9uVHlwZSA9IFdlYXBvblR5cGUuQk9XOyAvLyBEZWZhdWx0IHdlYXBvblxuICBwcml2YXRlIGN1cnJlbnRTdWJjbGFzczogV2VhcG9uU3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5FTEVNRU5UQUw7IC8vIERlZmF1bHQgZm9yIGJvd1xuICBwcml2YXRlIGN1cnJlbnRMZXZlbCA9IDE7XG4gIFxuICAvLyBXZWFwb24tc3BlY2lmaWMgc3RhdGVzXG4gIHByaXZhdGUgaXNDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGNoYXJnZVByb2dyZXNzID0gMDtcbiAgcHJpdmF0ZSBpc1N3aW5naW5nID0gZmFsc2U7XG4gIFxuICAvLyBWaXBlciBTdGluZyBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzVmlwZXJTdGluZ0NoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgdmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gMDtcbiAgXG4gIC8vIEJhcnJhZ2UgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc0JhcnJhZ2VDaGFyZ2luZyA9IGZhbHNlO1xuICBwcml2YXRlIGJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIHByaXZhdGUgbGFzdEJhcnJhZ2VUaW1lID0gMDtcbiAgcHJpdmF0ZSBiYXJyYWdlRmlyZVJhdGUgPSA1LjA7IC8vIDUgc2Vjb25kIGNvb2xkb3duIChrZWVwaW5nIGFzIHJlcXVlc3RlZClcbiAgXG4gIC8vIENvYnJhIFNob3QgY2hhcmdpbmcgc3RhdGVcbiAgcHJpdmF0ZSBpc0NvYnJhU2hvdENoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBcbiAgLy8gU3dvcmQtc3BlY2lmaWMgc3RhdGVzXG4gIHByaXZhdGUgc3dvcmRDb21ib1N0ZXA6IDEgfCAyIHwgMyA9IDE7XG4gIHByaXZhdGUgbGFzdFN3b3JkQXR0YWNrVGltZSA9IDA7XG4gIHByaXZhdGUgc3dvcmRDb21ib1Jlc2V0VGltZSA9IDE7IC8vIFJlc2V0IGNvbWJvIGFmdGVyIDEgc2Vjb25kc1xuICBcbiAgLy8gRGl2aW5lIFN0b3JtIGFiaWxpdHkgc3RhdGVcbiAgcHJpdmF0ZSBpc0RpdmluZVN0b3JtaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdERpdmluZVN0b3JtVGltZSA9IDA7XG4gIHByaXZhdGUgZGl2aW5lU3Rvcm1Db29sZG93biA9IDguMDsgLy8gOCBzZWNvbmQgY29vbGRvd25cbiAgXG4gIC8vIENoYXJnZSBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNTd29yZENoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdENoYXJnZVRpbWUgPSAwO1xuICBwcml2YXRlIGNoYXJnZUNvb2xkb3duID0gOC4wOyAvLyA4IHNlY29uZCBjb29sZG93blxuICBcbiAgLy8gRGVmbGVjdCBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gIHByaXZhdGUgbGFzdERlZmxlY3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBkZWZsZWN0Q29vbGRvd24gPSA2LjA7IC8vIDggc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgZGVmbGVjdER1cmF0aW9uID0gMy4wOyAvLyAzIHNlY29uZCBkdXJhdGlvblxuICBwcml2YXRlIGRlZmxlY3RCYXJyaWVyOiBEZWZsZWN0QmFycmllcjtcbiAgXG4gIC8vIFNreWZhbGwgYWJpbGl0eSBzdGF0ZSAoU2FicmVzKVxuICBwcml2YXRlIGlzU2t5ZmFsbGluZyA9IGZhbHNlO1xuICBwcml2YXRlIHNreWZhbGxQaGFzZTogJ25vbmUnIHwgJ2FzY2VuZGluZycgfCAnZGVzY2VuZGluZycgfCAnbGFuZGluZycgPSAnbm9uZSc7XG4gIHByaXZhdGUgbGFzdFNreWZhbGxUaW1lID0gMDtcbiAgcHJpdmF0ZSBza3lmYWxsQ29vbGRvd24gPSA1LjA7IC8vIDQgc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgc2t5ZmFsbFN0YXJ0VGltZSA9IDA7XG4gIHByaXZhdGUgc2t5ZmFsbFN0YXJ0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIHNreWZhbGxUYXJnZXRIZWlnaHQgPSAwO1xuICBwcml2YXRlIHNreWZhbGxPcmlnaW5hbEdyYXZpdHkgPSAwO1xuICBcbiAgLy8gQmFja3N0YWIgYWJpbGl0eSBzdGF0ZSAoU2FicmVzKVxuICBwcml2YXRlIGxhc3RCYWNrc3RhYlRpbWUgPSAwO1xuICBwcml2YXRlIGJhY2tzdGFiQ29vbGRvd24gPSAyLjA7IC8vIDIgc2Vjb25kIGNvb2xkb3duXG4gIHByaXZhdGUgaXNCYWNrc3RhYmJpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBiYWNrc3RhYlN0YXJ0VGltZSA9IDA7XG4gIHByaXZhdGUgYmFja3N0YWJEdXJhdGlvbiA9IDEuMDsgLy8gVG90YWwgYW5pbWF0aW9uIGR1cmF0aW9uICgwLjMgKyAwLjQgKyAwLjMgc2Vjb25kcylcbiAgY29uc3RydWN0b3IoXG4gICAgY2FtZXJhOiBQZXJzcGVjdGl2ZUNhbWVyYSwgXG4gICAgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXIsIFxuICAgIHdvcmxkOiBXb3JsZCxcbiAgICBwcm9qZWN0aWxlU3lzdGVtOiBQcm9qZWN0aWxlU3lzdGVtXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIgPSBpbnB1dE1hbmFnZXI7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbSA9IHByb2plY3RpbGVTeXN0ZW07XG4gICAgdGhpcy5kZWZsZWN0QmFycmllciA9IG5ldyBEZWZsZWN0QmFycmllcih3b3JsZCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDU7IC8vIFJ1biBlYXJseSBmb3IgaW5wdXQgaGFuZGxpbmdcbiAgfVxuXG4gIHB1YmxpYyBzZXRQbGF5ZXIoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICB0aGlzLnBsYXllckVudGl0eSA9IGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcblxuICAgIGNvbnN0IHBsYXllclRyYW5zZm9ybSA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBcbiAgICBpZiAoIXBsYXllclRyYW5zZm9ybSB8fCAhcGxheWVyTW92ZW1lbnQpIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSBkZWJ1ZmYgc3RhdGVzIGZpcnN0XG4gICAgaWYgKHR5cGVvZiBwbGF5ZXJNb3ZlbWVudC51cGRhdGVEZWJ1ZmZzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC51cGRhdGVEZWJ1ZmZzKCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHdlYXBvbiBzd2l0Y2hpbmdcbiAgICB0aGlzLmhhbmRsZVdlYXBvblN3aXRjaGluZygpO1xuXG4gICAgLy8gSGFuZGxlIGRhc2ggbW92ZW1lbnQgZmlyc3QgKG92ZXJyaWRlcyByZWd1bGFyIG1vdmVtZW50KVxuICAgIHRoaXMuaGFuZGxlRGFzaE1vdmVtZW50KHBsYXllck1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gSGFuZGxlIGNoYXJnZSBtb3ZlbWVudCAob3ZlcnJpZGVzIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5oYW5kbGVDaGFyZ2VNb3ZlbWVudChwbGF5ZXJNb3ZlbWVudCwgcGxheWVyVHJhbnNmb3JtKTtcblxuICAgIC8vIEhhbmRsZSBwbGF5ZXIgbW92ZW1lbnQgaW5wdXQgKG9ubHkgaWYgbm90IGRhc2hpbmcsIGNoYXJnaW5nLCBmcm96ZW4sIG9yIHNreWZhbGxpbmcpXG4gICAgaWYgKCFwbGF5ZXJNb3ZlbWVudC5pc0Rhc2hpbmcgJiYgIXBsYXllck1vdmVtZW50LmlzQ2hhcmdpbmcgJiYgIXBsYXllck1vdmVtZW50LmlzRnJvemVuICYmICF0aGlzLmlzU2t5ZmFsbGluZykge1xuICAgICAgdGhpcy5oYW5kbGVNb3ZlbWVudElucHV0KHBsYXllck1vdmVtZW50KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGNvbWJhdCBpbnB1dFxuICAgIHRoaXMuaGFuZGxlQ29tYmF0SW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgZGVmbGVjdCBiYXJyaWVyIHBvc2l0aW9uIGlmIGFjdGl2ZVxuICAgIHRoaXMudXBkYXRlRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlTW92ZW1lbnRJbnB1dChtb3ZlbWVudDogTW92ZW1lbnQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG5cbiAgICBjb25zdCBwbGF5ZXJUcmFuc2Zvcm0gPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAoIXBsYXllclRyYW5zZm9ybSkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGRvdWJsZS10YXAgZGFzaGVzIGZpcnN0IChiZWZvcmUgcHJvY2Vzc2luZyByZWd1bGFyIG1vdmVtZW50KVxuICAgIHRoaXMuY2hlY2tGb3JEYXNoSW5wdXQobW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBHZXQgaW5wdXQgZGlyZWN0aW9uXG4gICAgY29uc3QgaW5wdXREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICBsZXQgaGFzSW5wdXQgPSBmYWxzZTtcblxuICAgIC8vIFdBU0QgbW92ZW1lbnRcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCd3JykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnogLT0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncycpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi56ICs9IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2EnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueCAtPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdkJykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnggKz0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgZGlhZ29uYWwgbW92ZW1lbnRcbiAgICBpZiAoaW5wdXREaXJlY3Rpb24ubGVuZ3RoKCkgPiAwKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGlucHV0IHRvIHdvcmxkIHNwYWNlIGJhc2VkIG9uIGNhbWVyYSBvcmllbnRhdGlvblxuICAgIGlmIChoYXNJbnB1dCkge1xuICAgICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW1lcmEncyByaWdodCB2ZWN0b3JcbiAgICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhjYW1lcmFEaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbWVyYSdzIGZvcndhcmQgdmVjdG9yIChwcm9qZWN0ZWQgb24gWFogcGxhbmUpXG4gICAgICBjb25zdCBjYW1lcmFGb3J3YXJkID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYUZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCBjYW1lcmFSaWdodCkubm9ybWFsaXplKCk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSBpbnB1dCBkaXJlY3Rpb24gdG8gd29ybGQgc3BhY2VcbiAgICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFSaWdodCwgaW5wdXREaXJlY3Rpb24ueCk7XG4gICAgICB3b3JsZERpcmVjdGlvbi5hZGRTY2FsZWRWZWN0b3IoY2FtZXJhRm9yd2FyZCwgLWlucHV0RGlyZWN0aW9uLnopO1xuICAgICAgd29ybGREaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgIG1vdmVtZW50LnNldE1vdmVEaXJlY3Rpb24od29ybGREaXJlY3Rpb24sIDEuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vdmVtZW50LnNldE1vdmVEaXJlY3Rpb24obmV3IFZlY3RvcjMoMCwgMCwgMCksIDApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBqdW1waW5nXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnICcpKSB7IC8vIFNwYWNlYmFyXG4gICAgICBtb3ZlbWVudC5qdW1wKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsYXN0V2VhcG9uU3dpdGNoVGltZSA9IDA7XG4gIHByaXZhdGUgd2VhcG9uU3dpdGNoQ29vbGRvd24gPSAxLjU7IC8vIDIwMG1zIGNvb2xkb3duIHRvIHByZXZlbnQgcmFwaWQgc3dpdGNoaW5nXG5cbiAgcHJpdmF0ZSBoYW5kbGVXZWFwb25Td2l0Y2hpbmcoKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBQcmV2ZW50IHJhcGlkIHdlYXBvbiBzd2l0Y2hpbmdcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lIDwgdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB3ZWFwb24gc3dpdGNoaW5nIHdpdGggbnVtYmVyIGtleXNcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCcxJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5TV09SRDtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5ESVZJTklUWTsgLy8gRGVmYXVsdCBzd29yZCBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zd29yZEZpcmVSYXRlOyAvLyBVc2Ugc3dvcmQtc3BlY2lmaWMgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5zd29yZENvbWJvU3RlcCA9IDE7IC8vIFJlc2V0IGNvbWJvIHdoZW4gc3dpdGNoaW5nIHRvIHN3b3JkXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzInKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgICAgdGhpcy5yZXNldEFsbEFiaWxpdHlTdGF0ZXMoKTsgLy8gUmVzZXQgYWxsIGFiaWxpdHkgc3RhdGVzIHdoZW4gc3dpdGNoaW5nIHdlYXBvbnNcbiAgICAgICAgdGhpcy5jdXJyZW50V2VhcG9uID0gV2VhcG9uVHlwZS5CT1c7XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gV2VhcG9uU3ViY2xhc3MuRUxFTUVOVEFMOyAvLyBEZWZhdWx0IGJvdyBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gMC4yMjU7IC8vIEJvdyBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCczJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxBYmlsaXR5U3RhdGVzKCk7IC8vIFJlc2V0IGFsbCBhYmlsaXR5IHN0YXRlcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgICAgIHRoaXMuY3VycmVudFdlYXBvbiA9IFdlYXBvblR5cGUuU0NZVEhFO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkNIQU9TOyAvLyBEZWZhdWx0IHNjeXRoZSBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zY3l0aGVGaXJlUmF0ZTsgLy8gVXNlIHNjeXRoZSBmaXJlIHJhdGUgKDAuNXMpXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnNCcpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlNBQlJFUykge1xuICAgICAgICB0aGlzLnJlc2V0QWxsQWJpbGl0eVN0YXRlcygpOyAvLyBSZXNldCBhbGwgYWJpbGl0eSBzdGF0ZXMgd2hlbiBzd2l0Y2hpbmcgd2VhcG9uc1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNBQlJFUztcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5GUk9TVDsgLy8gRGVmYXVsdCBzYWJyZXMgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IHRoaXMuc2FicmVzRmlyZVJhdGU7IC8vIFVzZSBzYWJyZXMtc3BlY2lmaWMgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUNvbWJhdElucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgIHRoaXMuaGFuZGxlQm93SW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQ1lUSEUpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2N5dGhlSW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgdGhpcy5oYW5kbGVTd29yZElucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0FCUkVTKSB7XG4gICAgICB0aGlzLmhhbmRsZVNhYnJlc0lucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVCb3dJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBWaXBlciBTdGluZyBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1WaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBCYXJyYWdlIGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpKSB7XG5cbiAgICAgIGlmICghdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENvYnJhIFNob3QgYWJpbGl0eSB3aXRoICdFJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdlJykpIHtcblxuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLnBlcmZvcm1Db2JyYVNob3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIGJvdyBjaGFyZ2luZyBhbmQgZmlyaW5nXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uIGhlbGRcbiAgICAgIGlmICghdGhpcy5pc0NoYXJnaW5nICYmICF0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nICYmICF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG5cbiAgICAgIH1cbiAgICAgIC8vIEluY3JlYXNlIGNoYXJnZSBwcm9ncmVzcyAoY291bGQgYmUgdGltZS1iYXNlZClcbiAgICAgIGlmICghdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLmNoYXJnZVByb2dyZXNzICsgMC4wMTI1LCAxLjApOyAvLyBCT1cgQ0hBUkdFIFNQRUVEXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIC8vIENoZWNrIGlmIGFueSBhYmlsaXR5IGlzIGNoYXJnaW5nIC0gaWYgc28sIGNhbmNlbCB0aGUgcmVndWxhciBib3cgc2hvdFxuICAgICAgaWYgKHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgfHwgdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyB8fCB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIGNoYXJnZSBwcm9ncmVzcyBiZWZvcmUgcmVzZXR0aW5nIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgICAgY29uc3QgZmluYWxDaGFyZ2VQcm9ncmVzcyA9IHRoaXMuY2hhcmdlUHJvZ3Jlc3M7XG4gICAgICBcbiAgICAgIC8vIFJlbGVhc2UgdGhlIGJvd1xuICAgICAgdGhpcy5maXJlUHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciB2aXN1YWwgZWZmZWN0cyBjYWxsYmFjayB3aXRoIHRoZSBzdG9yZWQgY2hhcmdlIHByb2dyZXNzXG4gICAgICB0aGlzLnRyaWdnZXJCb3dSZWxlYXNlRWZmZWN0cyhmaW5hbENoYXJnZVByb2dyZXNzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNjeXRoZUlucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIHNjeXRoZSBsZWZ0IGNsaWNrIGZvciBFbnRyb3BpY0JvbHRcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkpIHsgLy8gTGVmdCBtb3VzZSBidXR0b24gaGVsZFxuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5pc0NoYXJnaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICAgIGNvbnNvbGUubG9nKCfimqEgU3RhcnRlZCBjaGFyZ2luZyBzY3l0aGUgKHNwaW5uaW5nKScpO1xuICAgICAgfVxuICAgICAgLy8gSW5jcmVhc2UgY2hhcmdlIHByb2dyZXNzIGNvbnRpbnVvdXNseSBmb3Igc3Bpbm5pbmcgYW5pbWF0aW9uIChubyBjYXApXG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzICs9IDAuMDM7IC8vIENvbnRpbnVvdXNseSBpbmNyZWFzZSBmb3Igc3Bpbm5pbmdcbiAgICAgIFxuICAgICAgLy8gRmlyZSBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZXMgY29udGludW91c2x5IHdoaWxlIHNwaW5uaW5nXG4gICAgICB0aGlzLmZpcmVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIC8vIFN0b3Agc3Bpbm5pbmcgd2hlbiBtb3VzZSBpcyByZWxlYXNlZFxuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENyb3NzZW50cm9weUJvbHQgYWJpbGl0eSB3aXRoICdSJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5maXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFJlYW5pbWF0ZSBhYmlsaXR5IHdpdGggJ1EnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3EnKSAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1SZWFuaW1hdGVBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBGcm9zdCBOb3ZhIGFiaWxpdHkgd2l0aCAnRScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybUZyb3N0Tm92YUFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZpcmVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZ1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLmZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb24gKHNhbWUgYXMgY2FtZXJhIGRpcmVjdGlvbiBzaW5jZSBkcmFnb24gZmFjZXMgY2FtZXJhKVxuICAgIC8vIFRoaXMgZW5zdXJlcyBhcnJvd3MgZmlyZSBvdXR3YXJkIGZyb20gd2hlcmUgdGhlIGRyYWdvbiBpcyBmYWNpbmdcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiB0byBhY2NvdW50IGZvciByZXN0cmljdGVkIGNhbWVyYSBib3VuZHNcbiAgICAvLyBTaW5jZSBjYW1lcmEgY2FuJ3QgbG9vayBkb3duIG11Y2ggZHVlIHRvIGJvdW5kcywgd2UgYWRkIGEgZml4ZWQgZG93bndhcmQgYW5nbGVcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIFxuICAgIC8vIENyZWF0ZSBhIHJvdGF0aW9uIG1hdHJpeCB0byBhcHBseSB0aGUgZG93bndhcmQgYW5nbGUgYXJvdW5kIHRoZSBjYW1lcmEncyByaWdodCBheGlzXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSByb3RhdGlvbiBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgdG8gdGlsdCB0aGUgZGlyZWN0aW9uIGRvd253YXJkXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gUGVyZmVjdCBzaG90IHRpbWluZyBjb25zdGFudHNcbiAgICBjb25zdCBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCA9IDAuNzsgLy8gODUlIGNoYXJnZVxuICAgIGNvbnN0IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkID0gMC45ODsgLy8gOTUlIGNoYXJnZVxuICAgIGNvbnN0IGlzUGVyZmVjdFNob3QgPSB0aGlzLmNoYXJnZVByb2dyZXNzID49IHBlcmZlY3RTaG90TWluVGhyZXNob2xkICYmIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPD0gcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQ7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYm93IGlzIGZ1bGx5IGNoYXJnZWQgZm9yIHNwZWNpYWwgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLmNoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgdGhpcy5jcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNQZXJmZWN0U2hvdCkge1xuICAgICAgdGhpcy5jcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlYnVnOiBMb2cgdGhlIGZpcmluZyBhbmdsZSB0byB2ZXJpZnkgaXQncyBjaGFuZ2luZyB3aXRoIGNhbWVyYSByb3RhdGlvblxuICAgICAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueik7XG4gICAgICB0aGlzLmNyZWF0ZVByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaXJlRW50cm9waWNCb2x0UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSB1c2UgbmV3IHNjeXRoZSByYXRlICgwLjM1IHNlY29uZHMpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc2N5dGhlRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBHZXQgZHJhZ29uJ3MgZmFjaW5nIGRpcmVjdGlvblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIChzYW1lIGFzIGJvdyBwcm9qZWN0aWxlcylcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgc3BpblN0YXR1cyA9IHRoaXMuaXNDaGFyZ2luZyA/ICcgKFNQSU5OSU5HKScgOiAnJztcbiAgICBcbiAgICB0aGlzLmNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGZpcmVDcm9zc2VudHJvcHlCb2x0QWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIFJhdGUgbGltaXRpbmcgLSB1c2UgQ3Jvc3NlbnRyb3B5Qm9sdCByYXRlICgxIHBlciBzZWNvbmQpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lIDwgdGhpcy5jcm9zc2VudHJvcHlGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDcm9zc2VudHJvcHlUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb25cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGFuZ2xlIGNvbXBlbnNhdGlvbiAoc2FtZSBhcyBib3cgcHJvamVjdGlsZXMpXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgXG4gICAgdGhpcy5jcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgdmFsaWQgdGFyZ2V0cyBpbiB0aGUgd29ybGQgYmVmb3JlIGNyZWF0aW5nIHByb2plY3RpbGVzXG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBIZWFsdGgsIENvbGxpZGVyXSk7XG4gICAgY29uc3QgdmFsaWRUYXJnZXRzID0gcG90ZW50aWFsVGFyZ2V0cy5maWx0ZXIodGFyZ2V0ID0+IFxuICAgICAgdGFyZ2V0LmlkICE9PSB0aGlzLnBsYXllckVudGl0eSEuaWQgJiYgLy8gTm90IHRoZSBwbGF5ZXIgaXRzZWxmXG4gICAgICAhdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpPy5pc0RlYWQgLy8gTm90IGRlYWRcbiAgICApO1xuICAgIFxuICAgIC8vIEluIG11bHRpcGxheWVyIG1vZGUsIG9ubHkgY3JlYXRlIHByb2plY3RpbGVzIGlmIHRoZXJlIGFyZSB2YWxpZCB0YXJnZXRzIG9yIGlmIHdlIG5lZWQgdG8gYnJvYWRjYXN0IHRvIG90aGVyIHBsYXllcnNcbiAgICBjb25zdCBoYXNWYWxpZFRhcmdldHMgPSB2YWxpZFRhcmdldHMubGVuZ3RoID4gMDtcbiAgICBjb25zdCBzaG91bGRCcm9hZGNhc3QgPSB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayAhPT0gdW5kZWZpbmVkO1xuICAgIFxuICAgIGlmICghaGFzVmFsaWRUYXJnZXRzICYmICFzaG91bGRCcm9hZGNhc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDAuNzU7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBwcm9qZWN0aWxlIHVzaW5nIHRoZSBQcm9qZWN0aWxlU3lzdGVtIHdpdGggY3VycmVudCB3ZWFwb24gY29uZmlnXG4gICAgY29uc3QgcHJvamVjdGlsZUNvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAyNSxcbiAgICAgIGRhbWFnZTogMTAsIC8vIEFycm93IGRhbWFnZSBzaG91bGQgYmUgMTBcbiAgICAgIGxpZmV0aW1lOiAzLFxuICAgICAgbWF4RGlzdGFuY2U6IDI1LCAvLyBMaW1pdCBib3cgYXJyb3dzIHRvIDI1IHVuaXRzIGRpc3RhbmNlXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIHByb2plY3RpbGVDb25maWdcbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdyZWd1bGFyX2Fycm93Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBwcm9qZWN0aWxlQ29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHZhbGlkIHRhcmdldHMgaW4gdGhlIHdvcmxkIGJlZm9yZSBjcmVhdGluZyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuICAgIGNvbnN0IHZhbGlkVGFyZ2V0cyA9IHBvdGVudGlhbFRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiBcbiAgICAgIHRhcmdldC5pZCAhPT0gdGhpcy5wbGF5ZXJFbnRpdHkhLmlkICYmIC8vIE5vdCB0aGUgcGxheWVyIGl0c2VsZlxuICAgICAgIXRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKT8uaXNEZWFkIC8vIE5vdCBkZWFkXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbiBtdWx0aXBsYXllciBtb2RlLCBvbmx5IGNyZWF0ZSBwcm9qZWN0aWxlcyBpZiB0aGVyZSBhcmUgdmFsaWQgdGFyZ2V0cyBvciBpZiB3ZSBuZWVkIHRvIGJyb2FkY2FzdCB0byBvdGhlciBwbGF5ZXJzXG4gICAgY29uc3QgaGFzVmFsaWRUYXJnZXRzID0gdmFsaWRUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc2hvdWxkQnJvYWRjYXN0ID0gdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgIT09IHVuZGVmaW5lZDtcbiAgICBcbiAgICBpZiAoIWhhc1ZhbGlkVGFyZ2V0cyAmJiAhc2hvdWxkQnJvYWRjYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDE1IG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0RW50cm9waWNCb2x0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDEwKTtcbiAgICB9XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDE7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZSB1c2luZyB0aGUgbmV3IG1ldGhvZFxuICAgIGNvbnN0IGVudHJvcGljQ29uZmlnID0ge1xuICAgICAgc3BlZWQ6IDIwLCAvLyBGYXN0ZXIgdGhhbiBDcm9zc2VudHJvcHlCb2x0XG4gICAgICBkYW1hZ2U6IDIwLCAvLyBFbnRyb3BpY0JvbHQgZGFtYWdlXG4gICAgICBsaWZldGltZTogMiwgLy8gU2hvcnRlciBsaWZldGltZVxuICAgICAgcGllcmNpbmc6IGZhbHNlLCAvLyBOb24tcGllcmNpbmcgc28gcHJvamVjdGlsZSBnZXRzIGRlc3Ryb3llZCBvbiBoaXRcbiAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIE5vIGV4cGxvc2lvbiBlZmZlY3RcbiAgICAgIGV4cGxvc2lvblJhZGl1czogMCwgLy8gTm8gZXhwbG9zaW9uIHJhZGl1c1xuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICBlbnRyb3BpY0NvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2VudHJvcGljX2JvbHQnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGVudHJvcGljQ29uZmlnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoNDAgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RDcm9zc2VudHJvcHlCb2x0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDQwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ29uc3VtZWQgNDAgbWFuYSBmb3IgQ3Jvc3NlbnRyb3B5IEJvbHQnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDE7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBDcm9zc2VudHJvcHlCb2x0IHByb2plY3RpbGUgdXNpbmcgdGhlIGV4aXN0aW5nIG1ldGhvZFxuICAgIGNvbnN0IGNyb3NzZW50cm9weUNvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAxNSwgLy8gU2xvd2VyIHRoYW4gRW50cm9waWNCb2x0XG4gICAgICBkYW1hZ2U6IDkwLCAvLyBIaWdoZXIgZGFtYWdlIGZvciBSIGFiaWxpdHlcbiAgICAgIGxpZmV0aW1lOiAyLjUsIC8vIExvbmdlciBsaWZldGltZVxuICAgICAgcGllcmNpbmc6IGZhbHNlLCAvLyBcbiAgICAgIGV4cGxvc2l2ZTogZmFsc2UsIC8vIERpc2FibGVkIGV4cGxvc2lvbiBlZmZlY3QgZm9yIHBlcmZvcm1hbmNlXG4gICAgICBleHBsb3Npb25SYWRpdXM6IDAsIC8vIE5vIGV4cGxvc2lvbiByYWRpdXNcbiAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgIG9wYWNpdHk6IDEuMFxuICAgIH07XG4gICAgXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGNyb3NzZW50cm9weUNvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2Nyb3NzZW50cm9weV9ib2x0Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBjcm9zc2VudHJvcHlDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVJlYW5pbWF0ZUFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjYXN0aW5nICgxIHNlY29uZCBjb29sZG93bilcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUgPCAxLjApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVhbmltYXRlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDIwIG1hbmEgY29zdCAtIGRvdWJsZWQgZnJvbSAxMClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGNvbnN0IGN1cnJlbnRNYW5hID0gZ2FtZVVJID8gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCkgOiAwO1xuICAgIFxuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0UmVhbmltYXRlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDIwKTtcbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHdheXMgdHJpZ2dlciB0aGUgdmlzdWFsIGVmZmVjdCBmaXJzdCwgcmVnYXJkbGVzcyBvZiBoZWFsaW5nIHN1Y2Nlc3NcbiAgICB0aGlzLnRyaWdnZXJSZWFuaW1hdGVFZmZlY3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyJ3MgaGVhbHRoIGNvbXBvbmVudCBhbmQgaGVhbCBmb3IgMzAgSFAgXG4gICAgY29uc3QgaGVhbHRoQ29tcG9uZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKGhlYWx0aENvbXBvbmVudCkge1xuICAgICAgY29uc3QgZGlkSGVhbCA9IGhlYWx0aENvbXBvbmVudC5oZWFsKDMwKTsgLy8gUkVBTklNQVRFIEhFQUwgQU1PVU5UXG4gICAgICBpZiAoZGlkSGVhbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+puCBSZWFuaW1hdGUgaGVhbGVkIHBsYXllciBmb3IgMzAgSFAuIEN1cnJlbnQgaGVhbHRoOiAke2hlYWx0aENvbXBvbmVudC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aENvbXBvbmVudC5tYXhIZWFsdGh9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygn8J+puCBSZWFuaW1hdGUgY2FzdCBzdWNjZXNzZnVsbHkgYnV0IHBsYXllciBhbHJlYWR5IGF0IGZ1bGwgaGVhbHRoJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyUmVhbmltYXRlRWZmZWN0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gVHJpZ2dlciB0aGUgdmlzdWFsIGhlYWxpbmcgZWZmZWN0XG4gICAgXG4gICAgaWYgKHRoaXMub25SZWFuaW1hdGVDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblJlYW5pbWF0ZUNhbGxiYWNrKCk7XG4gICAgfSBcbiAgICBcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUZyb3N0Tm92YUFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUgPCB0aGlzLmZyb3N0Tm92YUZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDUwIG1hbmEgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0RnJvc3ROb3ZhKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDUwKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgRnJvc3QgTm92YSBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uRnJvc3ROb3ZhQ2FsbGJhY2socGxheWVyUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIGVuZW1pZXMgd2l0aGluIDUgdW5pdCByYWRpdXMgYW5kIGZyZWV6ZSB0aGVtXG4gICAgdGhpcy5mcmVlemVFbmVtaWVzSW5SYWRpdXMocGxheWVyUG9zaXRpb24sIDYuMCwgY3VycmVudFRpbWUpO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgZ2xvYmFsIGZyb3N0IG5vdmEgdmlzdWFsIGVmZmVjdFxuICAgIHRyaWdnZXJHbG9iYWxGcm9zdE5vdmEocGxheWVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQ29icmFTaG90KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2JyYVNob3RUaW1lIDwgdGhpcy5jb2JyYVNob3RGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIGVuZXJneSAoNDAgZW5lcmd5IGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdENvYnJhU2hvdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg0MCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RDb2JyYVNob3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gU3RhcnQgY2hhcmdpbmcgYW5pbWF0aW9uXG4gICAgY29uc3QgY2hhcmdlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjaGFyZ2VEdXJhdGlvbiA9IDc1MDsgLy8gMC43NSBzZWNvbmQgY2hhcmdlIHRpbWUgKGJldHdlZW4gVmlwZXIgU3RpbmcgYW5kIEJhcnJhZ2UpXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGNoYXJnZUludGVydmFsKTtcbiAgICAgICAgdGhpcy5maXJlQ29icmFTaG90KHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9LCAxNik7IC8vIH42MGZwcyB1cGRhdGVzXG4gIH1cblxuICBwcml2YXRlIGZpcmVDb2JyYVNob3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb24gKHNhbWUgYXMgb3RoZXIgcHJvamVjdGlsZXMpXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIHBsYXllclBvc2l0aW9uLnkgKz0gMC44MjU7IC8vIFNob290IGZyb20gY2hlc3QgbGV2ZWwgbGlrZSBWaXBlciBTdGluZ1xuICAgIFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgc2FtZSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gYXMgb3RoZXIgcHJvamVjdGlsZXNcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIE9mZnNldCBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBcbiAgICAvLyBOb3RlOiBDb2JyYSBTaG90IGRhbWFnZSBpcyBoYW5kbGVkIGJ5IENvYnJhU2hvdE1hbmFnZXIsIG5vdCBFQ1MgcHJvamVjdGlsZXNcbiAgICAvLyBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZSBwcm9qZWN0aWxlcyBhbmQgZGFtYWdlIChzaW1pbGFyIHRvIFZpcGVyIFN0aW5nKVxuICAgIFxuICAgIC8vIFRyaWdnZXIgQ29icmEgU2hvdCBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vbkNvYnJhU2hvdENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQ29icmFTaG90Q2FsbGJhY2soc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJpZ2dlciBnbG9iYWwgY29icmEgc2hvdCB3aXRoIHByb3BlciBwb3NpdGlvbmluZyAoaGFuZGxlcyBsb2NhbCB2aXN1YWwgZWZmZWN0cyBhbmQgZGFtYWdlKVxuICAgIHRyaWdnZXJHbG9iYWxDb2JyYVNob3Qoc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY29icmFfc2hvdF9wcm9qZWN0aWxlJywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiAyMCwgLy8gQ29uc2lzdGVudCBzcGVlZCBmb3IgUFZQXG4gICAgICAgIGRhbWFnZTogMjksIC8vIFVzZSBjb25zaXN0ZW50IGRhbWFnZSB2YWx1ZVxuICAgICAgICBsaWZldGltZTogOCxcbiAgICAgICAgdmVub21EdXJhdGlvbjogNlxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmcmVlemVFbmVtaWVzSW5SYWRpdXMoY2VudGVyUG9zaXRpb246IFZlY3RvcjMsIHJhZGl1czogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGRcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBsZXQgZnJvemVuQ291bnQgPSAwO1xuICAgIGxldCBkYW1hZ2VkUGxheWVycyA9IDA7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgY29uc3QgZW50aXR5VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgZW50aXR5SGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIWVudGl0eVRyYW5zZm9ybSB8fCAhZW50aXR5SGVhbHRoIHx8IGVudGl0eUhlYWx0aC5pc0RlYWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgZW50aXR5UG9zaXRpb24gPSBlbnRpdHlUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNlbnRlclBvc2l0aW9uLmRpc3RhbmNlVG8oZW50aXR5UG9zaXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbnRpdHkgaXMgd2l0aGluIGZyZWV6ZSByYWRpdXNcbiAgICAgIGlmIChkaXN0YW5jZSA8PSByYWRpdXMpIHtcbiAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlbmVteSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZW5lbXkgLSBmcmVlemUgaXQgKHNpbmdsZSBwbGF5ZXIgbW9kZSlcbiAgICAgICAgICBlbmVteS5mcmVlemUoNi4wLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgZnJvemVuQ291bnQrKztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgZnJvemVuIHZpc3VhbCBlZmZlY3QgZm9yIHRoaXMgZW5lbXlcbiAgICAgICAgICBhZGRHbG9iYWxGcm96ZW5FbmVteShlbnRpdHkuaWQudG9TdHJpbmcoKSwgZW50aXR5UG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGFub3RoZXIgcGxheWVyIGluIFBWUCBtb2RlIC0gZGVhbCBkYW1hZ2UgYW5kIGZyZWV6ZVxuICAgICAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSAmJiB0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgICAgY29uc3QgZnJvc3ROb3ZhRGFtYWdlID0gNTA7IC8vIEZyb3N0IE5vdmEgZGFtYWdlXG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCBmcm9zdE5vdmFEYW1hZ2UsIHRoaXMucGxheWVyRW50aXR5LCAnZnJvc3Rfbm92YScpO1xuICAgICAgICAgICAgZGFtYWdlZFBsYXllcnMrKztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQnJvYWRjYXN0IGZyZWV6ZSBlZmZlY3QgdG8gdGhlIHRhcmdldCBwbGF5ZXIgc28gdGhleSBnZXQgZnJvemVuIG9uIHRoZWlyIGVuZFxuICAgICAgICAgICAgaWYgKHRoaXMub25EZWJ1ZmZDYWxsYmFjaykge1xuICAgICAgICAgICAgICB0aGlzLm9uRGVidWZmQ2FsbGJhY2soZW50aXR5LmlkLCAnZnJvemVuJywgNjAwMCwgZW50aXR5UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChmcm96ZW5Db3VudCA+IDApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDinYTvuI8gRnJvc3QgTm92YSBmcm96ZSAke2Zyb3plbkNvdW50fSBlbmVtaWVzIHdpdGhpbiAke3JhZGl1c30gdW5pdCByYWRpdXNgKTtcbiAgICB9XG4gICAgaWYgKGRhbWFnZWRQbGF5ZXJzID4gMCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYOKdhO+4jyBGcm9zdCBOb3ZhIGRhbWFnZWQgJHtkYW1hZ2VkUGxheWVyc30gcGxheWVycyB3aXRoaW4gJHtyYWRpdXN9IHVuaXQgcmFkaXVzYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDAuNTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIGNoYXJnZWQgYXJyb3cgcHJvamVjdGlsZSAtIG1vcmUgcG93ZXJmdWwgdGhhbiByZWd1bGFyIGFycm93c1xuICAgIGNvbnN0IGNoYXJnZWRBcnJvd0NvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAzNSwgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3MgKDI1KVxuICAgICAgZGFtYWdlOiA1MCwgLy8gTXVjaCBoaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3MgKDEwKVxuICAgICAgbGlmZXRpbWU6IDIsIC8vIExvbmdlciBsaWZldGltZSB0aGFuIHJlZ3VsYXIgYXJyb3dzICgzKVxuICAgICAgcGllcmNpbmc6IHRydWUsIC8vIENoYXJnZWQgYXJyb3dzIGNhbiBwaWVyY2UgdGhyb3VnaCBlbmVtaWVzXG4gICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24sIGJ1dCBjb3VsZCBhZGQgc3BlY2lhbCBlZmZlY3RzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGNoYXJnZWRBcnJvd0NvbmZpZ1xuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2NoYXJnZWRfYXJyb3cnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGNoYXJnZWRBcnJvd0NvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVQZXJmZWN0U2hvdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBPZmZzZXQgcHJvamVjdGlsZSBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBzcGF3blBvc2l0aW9uLnkgKz0gMC41OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgcGVyZmVjdCBzaG90IHByb2plY3RpbGUgLSBlbmhhbmNlZCBjaGFyZ2VkIGFycm93IHdpdGggc3BlY2lhbCBlZmZlY3RzXG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAge1xuICAgICAgICBzcGVlZDogNDAsIC8vIEZhc3RlciB0aGFuIHJlZ3VsYXIgY2hhcmdlZCBhcnJvd3MgKDM1KVxuICAgICAgICBkYW1hZ2U6IDc1LCAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBjaGFyZ2VkIGFycm93cyAoNTApXG4gICAgICAgIGxpZmV0aW1lOiA2LCAvLyBMb25nZXIgbGlmZXRpbWUgdGhhbiByZWd1bGFyIGNoYXJnZWQgYXJyb3dzICg1KVxuICAgICAgICBwaWVyY2luZzogdHJ1ZSwgLy8gUGVyZmVjdCBzaG90cyBjYW4gcGllcmNlIHRocm91Z2ggZW5lbWllc1xuICAgICAgICBleHBsb3NpdmU6IGZhbHNlLCAvLyBObyBleHBsb3Npb24sIGJ1dCBoYXMgc3BlY2lhbCB2aXN1YWwgZWZmZWN0c1xuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygncGVyZmVjdF9zaG90Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiA0MCxcbiAgICAgICAgZGFtYWdlOiA3NSxcbiAgICAgICAgbGlmZXRpbWU6IDYsXG4gICAgICAgIHBpZXJjaW5nOiB0cnVlLFxuICAgICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICAgIGxldmVsOiB0aGlzLmN1cnJlbnRMZXZlbCxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2RzIHRvIGNvbmZpZ3VyZSB3ZWFwb24gZm9yIHRlc3RpbmdcbiAgcHVibGljIHNldFdlYXBvblN1YmNsYXNzKHN1YmNsYXNzOiBXZWFwb25TdWJjbGFzcyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFN1YmNsYXNzID0gc3ViY2xhc3M7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gc2V0IGJvdyByZWxlYXNlIGNhbGxiYWNrXG4gIHB1YmxpYyBzZXRCb3dSZWxlYXNlQ2FsbGJhY2soY2FsbGJhY2s6IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkJvd1JlbGVhc2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGl2aW5lU3Rvcm1DYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0UHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjazogKHByb2plY3RpbGVUeXBlOiBzdHJpbmcsIHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGNvbmZpZzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFZpcGVyU3RpbmdDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0QmFycmFnZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25CYXJyYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIHB1YmxpYyBzZXRSZWFuaW1hdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25SZWFuaW1hdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RnJvc3ROb3ZhQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkZyb3N0Tm92YUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRDb2JyYVNob3RDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29icmFTaG90Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldENoYXJnZUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFyZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGVmbGVjdENhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EZWZsZWN0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFNreWZhbGxDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uU2t5ZmFsbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRCYWNrc3RhYkNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMywgZGFtYWdlOiBudW1iZXIsIGlzQmFja3N0YWI6IGJvb2xlYW4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQmFja3N0YWJDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0RGVidWZmQ2FsbGJhY2soY2FsbGJhY2s6ICh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25EZWJ1ZmZDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgLy8gTWV0aG9kIHRvIHRyaWdnZXIgYm93IHJlbGVhc2UgZWZmZWN0c1xuICBwcml2YXRlIHRyaWdnZXJCb3dSZWxlYXNlRWZmZWN0cyhmaW5hbENoYXJnZVByb2dyZXNzOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vbkJvd1JlbGVhc2VDYWxsYmFjaykge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB3YXMgYSBwZXJmZWN0IHNob3RcbiAgICAgIGNvbnN0IHBlcmZlY3RTaG90TWluVGhyZXNob2xkID0gMC43NTsgLy8gODUlIGNoYXJnZVxuICAgICAgY29uc3QgcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQgPSAwLjk4OyAvLyA5NSUgY2hhcmdlXG4gICAgICBjb25zdCBpc1BlcmZlY3RTaG90ID0gZmluYWxDaGFyZ2VQcm9ncmVzcyA+PSBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCAmJiBmaW5hbENoYXJnZVByb2dyZXNzIDw9IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkO1xuICAgICAgXG4gICAgICB0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrKGZpbmFsQ2hhcmdlUHJvZ3Jlc3MsIGlzUGVyZmVjdFNob3QpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRXZWFwb25MZXZlbChsZXZlbDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDdXJyZW50V2VhcG9uQ29uZmlnKCk6IHsgd2VhcG9uOiBXZWFwb25UeXBlOyBzdWJjbGFzczogV2VhcG9uU3ViY2xhc3M7IGxldmVsOiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlYXBvbjogdGhpcy5jdXJyZW50V2VhcG9uLFxuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEdldHRlcnMgZm9yIHdlYXBvbiBzdGF0ZSAoZm9yIFVJL3JlbmRlcmluZylcbiAgcHVibGljIGdldEN1cnJlbnRXZWFwb24oKTogV2VhcG9uVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFdlYXBvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDdXJyZW50U3ViY2xhc3MoKTogV2VhcG9uU3ViY2xhc3Mge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdWJjbGFzcztcbiAgfVxuXG4gIHB1YmxpYyBpc1dlYXBvbkNoYXJnaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc1ZpcGVyU3RpbmdDaGFyZ2luZ0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRWaXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNCYXJyYWdlQ2hhcmdpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0QmFycmFnZUNoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzQ29icmFTaG90Q2hhcmdpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb2JyYVNob3RDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzV2VhcG9uU3dpbmdpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTd2luZ2luZztcbiAgfVxuXG4gIC8vIFN3b3JkLXNwZWNpZmljIGdldHRlcnNcbiAgcHVibGljIGdldFN3b3JkQ29tYm9TdGVwKCk6IDEgfCAyIHwgMyB7XG4gICAgcmV0dXJuIHRoaXMuc3dvcmRDb21ib1N0ZXA7XG4gIH1cblxuICBwdWJsaWMgaXNEaXZpbmVTdG9ybUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RpdmluZVN0b3JtaW5nO1xuICB9XG5cbiAgcHVibGljIGlzQ2hhcmdlQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU3dvcmRDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBpc0RlZmxlY3RBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZsZWN0aW5nO1xuICB9XG4gIFxuICBwdWJsaWMgaXNTa3lmYWxsQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU2t5ZmFsbGluZztcbiAgfVxuICBcbiAgcHVibGljIGlzQmFja3N0YWJBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNCYWNrc3RhYmJpbmc7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVN3b3JkSW5wdXQocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgc3dvcmQgbWVsZWUgYXR0YWNrc1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykgeyAvLyBMZWZ0IG1vdXNlIGJ1dHRvblxuICAgICAgdGhpcy5wZXJmb3JtU3dvcmRNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgRGl2aW5lIFN0b3JtIGFiaWxpdHkgd2l0aCAnUicga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncicpICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEZWZsZWN0aW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1EaXZpbmVTdG9ybShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQ2hhcmdlIGFiaWxpdHkgd2l0aCAnRScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU3dvcmRDaGFyZ2luZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNEZWZsZWN0aW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1DaGFyZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIERlZmxlY3QgYWJpbGl0eSB3aXRoICdRJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNEZWZsZWN0aW5nICYmICF0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybURlZmxlY3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbWJvIHJlc2V0XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTd29yZEF0dGFja1RpbWUgPiB0aGlzLnN3b3JkQ29tYm9SZXNldFRpbWUpIHtcbiAgICAgIHRoaXMuc3dvcmRDb21ib1N0ZXAgPSAxO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVN3b3JkTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNsaWNraW5nICh1c2Ugc3dvcmQtc3BlY2lmaWMgZmlyZSByYXRlKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLnN3b3JkRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmxhc3RTd29yZEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTZXQgc3dpbmdpbmcgc3RhdGUgLSBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieSBzd29yZCBjb21wb25lbnQgY2FsbGJhY2tcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSB0cnVlO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gbWVsZWUgZGFtYWdlIGluIGEgY29uZSBpbiBmcm9udCBvZiBwbGF5ZXJcbiAgICB0aGlzLnBlcmZvcm1NZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIFxuICAgIC8vIE5vdGU6IFN3aW5nIGNvbXBsZXRpb24gYW5kIGNvbWJvIGFkdmFuY2VtZW50IGlzIG5vdyBoYW5kbGVkIGJ5IG9uU3dvcmRTd2luZ0NvbXBsZXRlIGNhbGxiYWNrXG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gc3dpbmcgYW5pbWF0aW9uIGNvbXBsZXRlc1xuICBwdWJsaWMgb25Td29yZFN3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgIFxuICAgIC8vIFJlc2V0IHN3aW5naW5nIHN0YXRlXG4gICAgdGhpcy5pc1N3aW5naW5nID0gZmFsc2U7XG4gICAgXG4gICAgLy8gQWR2YW5jZSBjb21ibyBzdGVwIGZvciBuZXh0IGF0dGFja1xuICAgIHRoaXMuc3dvcmRDb21ib1N0ZXAgPSAodGhpcy5zd29yZENvbWJvU3RlcCAlIDMgKyAxKSBhcyAxIHwgMiB8IDM7XG4gICAgXG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNhYnJlc0lucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIGxlZnQgY2xpY2sgZm9yIGR1YWwgc2FicmUgYXR0YWNrXG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTa3lmYWxsaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgUSBrZXkgZm9yIEJhY2tzdGFiIGFiaWxpdHlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdxJykgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc1NreWZhbGxpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybUJhY2tzdGFiKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBFIGtleSBmb3IgU2t5ZmFsbCBhYmlsaXR5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzU2t5ZmFsbGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtU2t5ZmFsbChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgU2t5ZmFsbCBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc1NreWZhbGxpbmcpIHtcbiAgICAgIHRoaXMudXBkYXRlU2t5ZmFsbE1vdmVtZW50KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBCYWNrc3RhYiBzdGF0ZSBpZiBhY3RpdmVcbiAgICBpZiAodGhpcy5pc0JhY2tzdGFiYmluZykge1xuICAgICAgdGhpcy51cGRhdGVCYWNrc3RhYlN0YXRlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtU2FicmVzTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNsaWNraW5nICh1c2Ugc2FicmVzLXNwZWNpZmljIGZpcmUgcmF0ZSlcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5zYWJyZXNGaXJlUmF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RGaXJlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGR1YWwgYXR0YWNrIGluaXRpYXRlZCcpO1xuICAgIFxuICAgIC8vIFNldCBzd2luZ2luZyBzdGF0ZSAtIGNvbXBsZXRpb24gd2lsbCBiZSBoYW5kbGVkIGJ5IHNhYnJlcyBjb21wb25lbnQgY2FsbGJhY2tcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSB0cnVlO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gbWVsZWUgZGFtYWdlIGluIGEgY29uZSBpbiBmcm9udCBvZiBwbGF5ZXIgKGR1YWwgYXR0YWNrKVxuICAgIHRoaXMucGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc2FicmVzIGNvbXBvbmVudCB3aGVuIHN3aW5nIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uU2FicmVzU3dpbmdDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTd2luZ2luZykgcmV0dXJuOyAvLyBQcmV2ZW50IG11bHRpcGxlIGNhbGxzXG4gICAgXG4gICAgY29uc29sZS5sb2coJ+KalO+4jyBTYWJyZXMgZHVhbCBzd2luZyBjb21wbGV0ZWQnKTtcbiAgICBcbiAgICAvLyBSZXNldCBzd2luZ2luZyBzdGF0ZVxuICAgIHRoaXMuaXNTd2luZ2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtU2FicmVzTWVsZWVEYW1hZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgdGhhdCBjb3VsZCBiZSBkYW1hZ2VkXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IGFsbEVudGl0aWVzLmZpbHRlcihlbnRpdHkgPT4gXG4gICAgICBlbnRpdHkuaGFzQ29tcG9uZW50KEhlYWx0aCkgJiYgXG4gICAgICBlbnRpdHkuaGFzQ29tcG9uZW50KFRyYW5zZm9ybSkgJiZcbiAgICAgIGVudGl0eSAhPT0gdGhpcy5wbGF5ZXJFbnRpdHlcbiAgICApO1xuICAgIFxuICAgIC8vIFNBQlJFUyBEQU1BR0VcbiAgICBjb25zdCBhdHRhY2tSYW5nZSA9IDMuODsgLy8gU2xpZ2h0bHkgbG9uZ2VyIHJhbmdlIHRoYW4gc3dvcmRcbiAgICBjb25zdCBhdHRhY2tBbmdsZSA9IE1hdGguUEkgLyAyOyAvLyA2MCBkZWdyZWUgY29uZSAod2lkZXIgdGhhbiBzd29yZClcbiAgICBjb25zdCBsZWZ0U2FicmVEYW1hZ2UgPSAxOTtcbiAgICBjb25zdCByaWdodFNhYnJlRGFtYWdlID0gMjM7XG4gICAgXG4gICAgLy8gR2V0IGNhbWVyYSBkaXJlY3Rpb24gZm9yIGF0dGFjayBkaXJlY3Rpb25cbiAgICBjb25zdCBhdHRhY2tEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGF0dGFja0RpcmVjdGlvbik7XG4gICAgYXR0YWNrRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGxldCBoaXRDb3VudCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcG90ZW50aWFsVGFyZ2V0cykge1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIXRhcmdldFRyYW5zZm9ybSB8fCAhdGFyZ2V0SGVhbHRoIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgICAgY29uc3QgZGlyZWN0aW9uVG9UYXJnZXQgPSB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKS5zdWIocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9UYXJnZXQgPSBkaXJlY3Rpb25Ub1RhcmdldC5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRpc3RhbmNlVG9UYXJnZXQgPiBhdHRhY2tSYW5nZSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyB3aXRoaW4gYXR0YWNrIGNvbmVcbiAgICAgIGRpcmVjdGlvblRvVGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuICAgICAgY29uc3QgZG90UHJvZHVjdCA9IGF0dGFja0RpcmVjdGlvbi5kb3QoZGlyZWN0aW9uVG9UYXJnZXQpO1xuICAgICAgY29uc3QgYW5nbGVUb1RhcmdldCA9IE1hdGguYWNvcyhNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZG90UHJvZHVjdCkpKTtcbiAgICAgIFxuICAgICAgaWYgKGFuZ2xlVG9UYXJnZXQgPiBhdHRhY2tBbmdsZSAvIDIpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBUYXJnZXQgaXMgd2l0aGluIHJhbmdlIGFuZCBjb25lIC0gYXBwbHkgZGFtYWdlIGZyb20gYm90aCBzYWJyZXNcbiAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgIC8vIExlZnQgc2FicmUgaGl0IChpbW1lZGlhdGUpXG4gICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZSh0YXJnZXQsIGxlZnRTYWJyZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJpZ2h0IHNhYnJlIGhpdCAod2l0aCBzbWFsbCBkZWxheSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCByaWdodFNhYnJlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTsgLy8gMTAwbXMgZGVsYXkgYmV0d2VlbiBzYWJyZSBoaXRzXG4gICAgICAgIFxuICAgICAgICBoaXRDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNreWZhbGwgYWJpbGl0eSBpbXBsZW1lbnRhdGlvblxuICBwcml2YXRlIHBlcmZvcm1Ta3lmYWxsKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFNreWZhbGxUaW1lIDwgdGhpcy5za3lmYWxsQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZW5lcmd5IGNvc3RcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmICghZ2FtZVVJIHx8ICFnYW1lVUkuY2FuQ2FzdFNreWZhbGwoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDQwKTtcbiAgICBcbiAgICAvLyBTdGFydCBTa3lmYWxsXG4gICAgdGhpcy5pc1NreWZhbGxpbmcgPSB0cnVlO1xuICAgIHRoaXMuc2t5ZmFsbFBoYXNlID0gJ2FzY2VuZGluZyc7XG4gICAgdGhpcy5za3lmYWxsU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5sYXN0U2t5ZmFsbFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLnNreWZhbGxTdGFydFBvc2l0aW9uLmNvcHkocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBTZXQgdGFyZ2V0IGhlaWdodCAoZG91YmxlIGp1bXAgaGVpZ2h0KVxuICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHk/LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHkgPSBwbGF5ZXJNb3ZlbWVudC5ncmF2aXR5O1xuICAgICAgdGhpcy5za3lmYWxsVGFyZ2V0SGVpZ2h0ID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLnkgKyAocGxheWVyTW92ZW1lbnQuanVtcEZvcmNlICogMS40KTsgLy8gUmVkdWNlZCBoZWlnaHQgYnkgMzAlICh3YXMgMngsIG5vdyAxLjR4KVxuICAgICAgICAgICAgXG4gICAgICAvLyBBcHBseSB1cHdhcmQgdmVsb2NpdHlcbiAgICAgIHBsYXllck1vdmVtZW50LnZlbG9jaXR5LnkgPSBwbGF5ZXJNb3ZlbWVudC5qdW1wRm9yY2UgKiAyOyAvLyBTdHJvbmdlciBpbml0aWFsIHZlbG9jaXR5XG4gICAgICBwbGF5ZXJNb3ZlbWVudC5ncmF2aXR5ID0gMDsgLy8gRGlzYWJsZSBncmF2aXR5IGR1cmluZyBhc2NlbnRcbiAgICAgIC8vIERvbid0IGRpc2FibGUgY2FuTW92ZSBhcyBpdCBwcmV2ZW50cyBhbGwgcGh5c2ljcyB1cGRhdGVzIGluY2x1ZGluZyBncmF2aXR5XG4gICAgICAvLyBJbnN0ZWFkIHdlJ2xsIGNvbnRyb2wgaG9yaXpvbnRhbCBtb3ZlbWVudCBpbiB0aGUgQ29udHJvbFN5c3RlbVxuICAgIH1cblxuICAgIFxuICAgIC8vIFRyaWdnZXIgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyL3Zpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Ta3lmYWxsQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgdGhpcy5vblNreWZhbGxDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHVwZGF0ZVNreWZhbGxNb3ZlbWVudChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eT8uZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAoIXBsYXllck1vdmVtZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuc2t5ZmFsbFN0YXJ0VGltZTtcbiAgICBcblxuICAgIFxuICAgIHN3aXRjaCAodGhpcy5za3lmYWxsUGhhc2UpIHtcbiAgICAgIGNhc2UgJ2FzY2VuZGluZyc6XG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGFyZ2V0IGhlaWdodCBvciBzdGFydGVkIGZhbGxpbmdcbiAgICAgICAgaWYgKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi55ID49IHRoaXMuc2t5ZmFsbFRhcmdldEhlaWdodCB8fCBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55IDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdkZXNjZW5kaW5nJztcbiAgICAgICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gMDsgLy8gU3RvcCBhdCBwZWFrXG4gICAgICAgICAgcGxheWVyTW92ZW1lbnQuZ3Jhdml0eSA9IHRoaXMuc2t5ZmFsbE9yaWdpbmFsR3Jhdml0eSAqIDMwOyAvLyBGYXN0ZXIgZGVzY2VudFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ2Rlc2NlbmRpbmcnOlxuICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSBsYW5kZWQgKGNsb3NlIHRvIG9yaWdpbmFsIGhlaWdodCBvciBvbiBncm91bmQpXG4gICAgICAgIGlmIChwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24ueSA8PSB0aGlzLnNreWZhbGxTdGFydFBvc2l0aW9uLnkgKyAwLjUpIHtcbiAgICAgICAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdsYW5kaW5nJztcbiAgICAgICAgICB0aGlzLnBlcmZvcm1Ta3lmYWxsTGFuZGluZyhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ2xhbmRpbmcnOlxuICAgICAgICAvLyBMYW5kaW5nIHBoYXNlIGNvbXBsZXRlXG4gICAgICAgIHRoaXMuY29tcGxldGVTa3lmYWxsQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgLy8gU2FmZXR5IHRpbWVvdXQgKGlmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBlbmQgYWZ0ZXIgNSBzZWNvbmRzKVxuICAgIGlmIChlbGFwc2VkVGltZSA+IDQuMCkge1xuICAgICAgdGhpcy5jb21wbGV0ZVNreWZhbGxBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHBlcmZvcm1Ta3lmYWxsTGFuZGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIFxuICAgIC8vIERlYWwgZGFtYWdlIHRvIGVuZW1pZXMgaW4gbGFuZGluZyBhcmVhXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgY29uc3QgbGFuZGluZ1Bvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IGRhbWFnZVJhZGl1cyA9IDQuMDsgLy8gNCB1bml0IHJhZGl1c1xuICAgIGNvbnN0IHNreWZhbGxEYW1hZ2UgPSAxMjU7IC8vIDEyNSBkYW1hZ2UgYXMgcmVxdWVzdGVkXG4gICAgXG4gICAgbGV0IGhpdENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBhbGxFbnRpdGllcykge1xuICAgICAgaWYgKGVudGl0eSA9PT0gdGhpcy5wbGF5ZXJFbnRpdHkpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBcbiAgICAgIGlmICghdGFyZ2V0SGVhbHRoIHx8ICF0YXJnZXRUcmFuc2Zvcm0gfHwgdGFyZ2V0SGVhbHRoLmlzRGVhZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGRpc3RhbmNlIHRvIGxhbmRpbmcgcG9zaXRpb25cbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9MYW5kaW5nID0gbGFuZGluZ1Bvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlVG9MYW5kaW5nIDw9IGRhbWFnZVJhZGl1cykge1xuICAgICAgICAvLyBBcHBseSBTa3lmYWxsIGRhbWFnZVxuICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgc2t5ZmFsbERhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICBoaXRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGNvbXBsZXRlU2t5ZmFsbEFiaWxpdHkocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSZXNldCBhbGwgU2t5ZmFsbCBzdGF0ZXNcbiAgICB0aGlzLmlzU2t5ZmFsbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2t5ZmFsbFBoYXNlID0gJ25vbmUnO1xuICAgIFxuICAgIC8vIFJlc3RvcmUgcGxheWVyIG1vdmVtZW50XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eT8uZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgIHBsYXllck1vdmVtZW50LmdyYXZpdHkgPSB0aGlzLnNreWZhbGxPcmlnaW5hbEdyYXZpdHk7XG4gICAgICBwbGF5ZXJNb3ZlbWVudC52ZWxvY2l0eS55ID0gMDsgLy8gU3RvcCBhbnkgcmVtYWluaW5nIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHVwZGF0ZUJhY2tzdGFiU3RhdGUocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSB0aGlzLmJhY2tzdGFiU3RhcnRUaW1lO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGJhY2tzdGFiIGFuaW1hdGlvbiBkdXJhdGlvbiBoYXMgZWxhcHNlZFxuICAgIGlmIChlbGFwc2VkVGltZSA+PSB0aGlzLmJhY2tzdGFiRHVyYXRpb24pIHtcbiAgICAgIHRoaXMuaXNCYWNrc3RhYmJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgcmVzZXRBbGxBYmlsaXR5U3RhdGVzKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IGFsbCBhYmlsaXR5IHN0YXRlcyB3aGVuIHN3aXRjaGluZyB3ZWFwb25zXG4gICAgdGhpcy5pc1NreWZhbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNreWZhbGxQaGFzZSA9ICdub25lJztcbiAgICB0aGlzLmlzQmFja3N0YWJiaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0RpdmluZVN0b3JtaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1N3b3JkQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGVmbGVjdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQmFja3N0YWIgYWJpbGl0eSBpbXBsZW1lbnRhdGlvblxuICBwcml2YXRlIHBlcmZvcm1CYWNrc3RhYihwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYWNrc3RhYlRpbWUgPCB0aGlzLmJhY2tzdGFiQ29vbGRvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZW5lcmd5IGNvc3RcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmICghZ2FtZVVJIHx8ICFnYW1lVUkuY2FuQ2FzdEJhY2tzdGFiKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg2MCk7XG4gICAgXG4gICAgLy8gU2V0IGNvb2xkb3duXG4gICAgdGhpcy5sYXN0QmFja3N0YWJUaW1lID0gY3VycmVudFRpbWU7XG4gIFxuICAgIFxuICAgIC8vIFN0YXJ0IGJhY2tzdGFiIGFuaW1hdGlvblxuICAgIHRoaXMuaXNCYWNrc3RhYmJpbmcgPSB0cnVlO1xuICAgIHRoaXMuYmFja3N0YWJTdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllci92aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uQmFja3N0YWJDYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICB0aGlzLm9uQmFja3N0YWJDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24sIGRpcmVjdGlvbiwgNzUsIGZhbHNlKTsgLy8gQmFzZSBkYW1hZ2UsIG5vdCBiYWNrc3RhYiBieSBkZWZhdWx0XG4gICAgfVxuICAgIFxuICAgIC8vIFBlcmZvcm0gYmFja3N0YWIgZGFtYWdlXG4gICAgdGhpcy5wZXJmb3JtQmFja3N0YWJEYW1hZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUJhY2tzdGFiRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGVuZW1pZXMvcGxheWVyc1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgZmFjaW5nIGRpcmVjdGlvbiAoY2FtZXJhIGRpcmVjdGlvbilcbiAgICBjb25zdCBwbGF5ZXJEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKHBsYXllckRpcmVjdGlvbik7XG4gICAgcGxheWVyRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGNvbnN0IGJhY2tzdGFiUmFuZ2UgPSAyLjU7IC8vIFNhYnJlIG1lbGVlIHJhbmdlXG4gICAgbGV0IGhpdENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBhbGxFbnRpdGllcykge1xuICAgICAgaWYgKGVudGl0eSA9PT0gdGhpcy5wbGF5ZXJFbnRpdHkpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBcbiAgICAgIGlmICghdGFyZ2V0SGVhbHRoIHx8ICF0YXJnZXRUcmFuc2Zvcm0gfHwgdGFyZ2V0SGVhbHRoLmlzRGVhZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBpbiByYW5nZVxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgICBpZiAoZGlzdGFuY2UgPiBiYWNrc3RhYlJhbmdlKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGluIGZyb250IG9mIHBsYXllciAoY29uZSBhdHRhY2spXG4gICAgICBjb25zdCBkaXJlY3Rpb25Ub1RhcmdldCA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgLnN1YlZlY3RvcnModGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLCBwbGF5ZXJQb3NpdGlvbilcbiAgICAgICAgLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICBjb25zdCBkb3RQcm9kdWN0ID0gcGxheWVyRGlyZWN0aW9uLmRvdChkaXJlY3Rpb25Ub1RhcmdldCk7XG4gICAgICBjb25zdCBhbmdsZVRocmVzaG9sZCA9IE1hdGguY29zKE1hdGguUEkgLyAzKTsgLy8gNjAgZGVncmVlIGNvbmVcbiAgICAgIFxuICAgICAgaWYgKGRvdFByb2R1Y3QgPCBhbmdsZVRocmVzaG9sZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBpZiB0aGlzIGlzIGEgYmFja3N0YWIgKGF0dGFja2luZyBmcm9tIGJlaGluZCB0aGUgdGFyZ2V0KVxuICAgICAgbGV0IGlzQmFja3N0YWIgPSBmYWxzZTtcbiAgICAgIGxldCBkYW1hZ2UgPSA3NTsgLy8gQmFzZSBkYW1hZ2VcbiAgICAgIFxuICAgICAgLy8gRm9yIFBWUCBwbGF5ZXJzLCBjaGVjayBpZiB3ZSdyZSBiZWhpbmQgdGhlbVxuICAgICAgY29uc3QgcHZwUGxheWVycyA9ICh3aW5kb3cgYXMgYW55KS5wdnBQbGF5ZXJzO1xuICAgICAgY29uc3QgbG9jYWxTb2NrZXRJZCA9ICh3aW5kb3cgYXMgYW55KS5sb2NhbFNvY2tldElkO1xuICAgICAgXG4gICAgICBpZiAocHZwUGxheWVycyAmJiBsb2NhbFNvY2tldElkKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHRhcmdldCBwbGF5ZXIgaW4gUFZQIHBsYXllcnMgbWFwXG4gICAgICAgIGxldCB0YXJnZXRQbGF5ZXIgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IFtwbGF5ZXJJZCwgcGxheWVyXSBvZiBwdnBQbGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKHBsYXllcklkICE9PSBsb2NhbFNvY2tldElkKSB7XG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJQb3MgPSBuZXcgVmVjdG9yMyhwbGF5ZXIucG9zaXRpb24ueCwgcGxheWVyLnBvc2l0aW9uLnksIHBsYXllci5wb3NpdGlvbi56KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJQb3MuZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pIDwgMC41KSB7XG4gICAgICAgICAgICAgIHRhcmdldFBsYXllciA9IHBsYXllcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGFyZ2V0UGxheWVyKSB7XG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIHRhcmdldCdzIGZhY2luZyBkaXJlY3Rpb24gZnJvbSB0aGVpciByb3RhdGlvblxuICAgICAgICAgIGNvbnN0IHRhcmdldEZhY2luZ0RpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKFxuICAgICAgICAgICAgTWF0aC5zaW4odGFyZ2V0UGxheWVyLnJvdGF0aW9uLnkpLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIE1hdGguY29zKHRhcmdldFBsYXllci5yb3RhdGlvbi55KVxuICAgICAgICAgICkubm9ybWFsaXplKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVjdG9yIGZyb20gdGFyZ2V0IHRvIGF0dGFja2VyXG4gICAgICAgICAgY29uc3QgYXR0YWNrZXJEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpXG4gICAgICAgICAgICAuc3ViVmVjdG9ycyhwbGF5ZXJQb3NpdGlvbiwgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKVxuICAgICAgICAgICAgLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGF0dGFja2VyIGlzIGJlaGluZCB0YXJnZXQgKGRvdCBwcm9kdWN0IDwgMCBtZWFucyBvcHBvc2l0ZSBkaXJlY3Rpb24pXG4gICAgICAgICAgY29uc3QgYmVoaW5kRG90UHJvZHVjdCA9IHRhcmdldEZhY2luZ0RpcmVjdGlvbi5kb3QoYXR0YWNrZXJEaXJlY3Rpb24pO1xuICAgICAgICAgIGlzQmFja3N0YWIgPSBiZWhpbmREb3RQcm9kdWN0IDwgLTAuMzsgLy8gNzAgZGVncmVlIGNvbmUgYmVoaW5kIHRhcmdldFxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChpc0JhY2tzdGFiKSB7XG4gICAgICAgICAgICBkYW1hZ2UgPSAxNzU7IC8vIEJhY2tzdGFiIGRhbWFnZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBseSBkYW1hZ2VcbiAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgZGFtYWdlLFxuICAgICAgICAgIHRoaXMucGxheWVyRW50aXR5ISxcbiAgICAgICAgICAnYmFja3N0YWInXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBoaXRDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybU1lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGVuZW1pZXNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIGZhY2luZyBkaXJlY3Rpb24gKGNhbWVyYSBkaXJlY3Rpb24pXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBNZWxlZSBhdHRhY2sgcGFyYW1ldGVycyAtIGluY3JlYXNlZCBmb3IgUFZQIGNvbWJhdFxuICAgIGNvbnN0IG1lbGVlUmFuZ2UgPSA0LjU7IC8vIEluY3JlYXNlZCBhdHRhY2sgcmFuZ2UgZm9yIFBWUFxuICAgIGNvbnN0IG1lbGVlQW5nbGUgPSBNYXRoLlBJIC8gMjsgLy8gMTIwIGRlZ3JlZSBjb25lICg2MCBkZWdyZWVzIGVhY2ggc2lkZSlcbiAgICBcbiAgICAvLyBCYXNlIGRhbWFnZSB2YWx1ZXMgYmFzZWQgb24gY29tYm8gc3RlcCAtIHdvcmtzIGZvciBhbGwgc3ViY2xhc3Nlc1xuICAgIGxldCBiYXNlRGFtYWdlID0gNDU7IC8vIEJhc2Ugc3dvcmQgZGFtYWdlXG4gICAgLy8gQ29tYm8gZGFtYWdlIHNjYWxpbmdcbiAgICBzd2l0Y2ggKHRoaXMuc3dvcmRDb21ib1N0ZXApIHtcbiAgICAgIGNhc2UgMTogYmFzZURhbWFnZSA9IDQwOyBicmVhaztcbiAgICAgIGNhc2UgMjogYmFzZURhbWFnZSA9IDQ1OyBicmVhaztcbiAgICAgIGNhc2UgMzogYmFzZURhbWFnZSA9IDU1OyBicmVhazsgLy8gRmluaXNoZXIgZG9lcyBtb3JlIGRhbWFnZVxuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgY29tYmF0IHN5c3RlbSB0byBhcHBseSBkYW1hZ2VcbiAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgIFxuICAgIC8vIFRyYWNrIGVuZW1pZXMgaGl0IGZvciByYWdlIGdlbmVyYXRpb25cbiAgICBsZXQgZW5lbWllc0hpdCA9IDA7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGhhcyBlbmVteSBjb21wb25lbnQgYW5kIGhlYWx0aFxuICAgICAgY29uc3QgZW5lbXlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbmVteUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGlmICghZW5lbXlUcmFuc2Zvcm0gfHwgIWVuZW15SGVhbHRoIHx8IGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZW15UG9zaXRpb24gPSBlbmVteVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgIGNvbnN0IHRvRW5lbXkgPSBlbmVteVBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG9FbmVteS5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3IgUFZQIGhpdCBkZXRlY3Rpb25cbiAgICAgIFxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiBlbmVteSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgIGlmIChkaXN0YW5jZSA8PSBtZWxlZVJhbmdlKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGVuZW15IGlzIHdpdGhpbiBhdHRhY2sgY29uZVxuICAgICAgICB0b0VuZW15Lm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IGRpcmVjdGlvbi5hbmdsZVRvKHRvRW5lbXkpO1xuICAgICAgICBjb25zdCBhbmdsZURlZ3JlZXMgPSBhbmdsZSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IG1heEFuZ2xlRGVncmVlcyA9IChtZWxlZUFuZ2xlIC8gMikgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmIChhbmdsZSA8PSBtZWxlZUFuZ2xlIC8gMikge1xuICAgICAgICAgIC8vIEVuZW15IGlzIHdpdGhpbiBhdHRhY2sgY29uZSAtIGRlYWwgZGFtYWdlIHRocm91Z2ggY29tYmF0IHN5c3RlbVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIC8vIFF1ZXVlIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gKHdoaWNoIHdpbGwgcm91dGUgdG8gbXVsdGlwbGF5ZXIgZm9yIGVuZW1pZXMpXG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCBiYXNlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ21lbGVlJyk7XG4gICAgICAgICAgICBlbmVtaWVzSGl0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgcmFnZSBvbmx5IGlmIHdlIGhpdCBlbmVtaWVzICg1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nKVxuICAgIGlmIChlbmVtaWVzSGl0ID4gMCkge1xuICAgICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICAgIGlmIChnYW1lVUkpIHtcbiAgICAgICAgY29uc3QgcmFnZVRvR2FpbiA9IE1hdGgubWluKGVuZW1pZXNIaXQgKiA1LCA1KTsgLy8gNSByYWdlIHBlciBoaXQsIG1heCA1IHBlciBzd2luZ1xuICAgICAgICBnYW1lVUkuZ2FpblJhZ2UocmFnZVRvR2Fpbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ZvckRhc2hJbnB1dChtb3ZlbWVudDogTW92ZW1lbnQsIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgZm9yIGRvdWJsZS10YXAgb24gbW92ZW1lbnQga2V5c1xuICAgIGNvbnN0IGRhc2hEaXJlY3Rpb25zID0gW1xuICAgICAgeyBrZXk6ICd3JywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAtMSkgfSwgLy8gRm9yd2FyZFxuICAgICAgeyBrZXk6ICdzJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygwLCAwLCAxKSB9LCAgLy8gQmFja3dhcmRcbiAgICAgIHsga2V5OiAnYScsIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoLTEsIDAsIDApIH0sIC8vIExlZnRcbiAgICAgIHsga2V5OiAnZCcsIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoMSwgMCwgMCkgfSAgIC8vIFJpZ2h0XG4gICAgXTtcblxuICAgIGZvciAoY29uc3QgeyBrZXksIGRpcmVjdGlvbiB9IG9mIGRhc2hEaXJlY3Rpb25zKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuY2hlY2tEb3VibGVUYXAoa2V5KSkge1xuICAgICAgICAvLyBEZWJ1ZzogTG9nIHRoZSBkb3VibGUgdGFwIGRldGVjdGlvblxuICAgICAgICBjb25zdCBkZWJ1Z0luZm8gPSB0aGlzLmlucHV0TWFuYWdlci5nZXREb3VibGVUYXBEZWJ1Z0luZm8oa2V5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlIGJhc2VkIG9uIGNhbWVyYSBvcmllbnRhdGlvblxuICAgICAgICBjb25zdCB3b3JsZERpcmVjdGlvbiA9IHRoaXMuZ2V0V29ybGRTcGFjZURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdGFydCBkYXNoXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgICAgICBjb25zdCBkYXNoU3RhcnRlZCA9IG1vdmVtZW50LnN0YXJ0RGFzaCh3b3JsZERpcmVjdGlvbiwgdHJhbnNmb3JtLnBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGFzaFN0YXJ0ZWQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgZG91YmxlLXRhcCBzdGF0ZSB0byBwcmV2ZW50IG11bHRpcGxlIGRhc2hlc1xuICAgICAgICAgIHRoaXMuaW5wdXRNYW5hZ2VyLnJlc2V0RG91YmxlVGFwKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGJyZWFrOyAvLyBPbmx5IHByb2Nlc3Mgb25lIGRhc2ggcGVyIGZyYW1lXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVEYXNoTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNEYXNoaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcbiAgICBjb25zdCBkYXNoUmVzdWx0ID0gbW92ZW1lbnQudXBkYXRlRGFzaChjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoZGFzaFJlc3VsdC5uZXdQb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgYm91bmRzIGNoZWNraW5nIChzaW1pbGFyIHRvIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICAgIGNvbnN0IE1BWF9EQVNIX0JPVU5EUyA9IDI5OyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luIChtYXRjaGVzIG1hcCBib3VuZGFyeSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IGRhc2hSZXN1bHQubmV3UG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZUZyb21PcmlnaW4gPD0gTUFYX0RBU0hfQk9VTkRTKSB7XG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGRhc2hSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FuY2VsIGRhc2ggaWYgaXQgd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luXG4gICAgICAgIC8vIGNvbnNvbGUud2FybihgRGFzaCBjYW5jZWxsZWQ6IHdvdWxkIG1vdmUgdG9vIGZhciBmcm9tIG9yaWdpbiAoJHtkaXN0YW5jZUZyb21PcmlnaW4udG9GaXhlZCgyKX0gPiAke01BWF9EQVNIX0JPVU5EU30pYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbERhc2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUNoYXJnZU1vdmVtZW50KG1vdmVtZW50OiBNb3ZlbWVudCwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBpZiAoIW1vdmVtZW50LmlzQ2hhcmdpbmcpIHJldHVybjtcblxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGNoYXJnZSB3YXMgc3RvcHBlZCBieSBjb2xsaXNpb25cbiAgICBpZiAodGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjaGFyZ2VSZXN1bHQgPSBtb3ZlbWVudC51cGRhdGVDaGFyZ2UoY3VycmVudFRpbWUpO1xuXG4gICAgaWYgKGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgYm91bmRzIGNoZWNraW5nXG4gICAgICBjb25zdCBNQVhfQ0hBUkdFX0JPVU5EUyA9IDI5OyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luIChtYXRjaGVzIG1hcCBib3VuZGFyeSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbi5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIHBpbGxhciBjb2xsaXNpb25cbiAgICAgIGNvbnN0IHBpbGxhckNvbGxpc2lvbiA9IHRoaXMuY2hlY2tQaWxsYXJDb2xsaXNpb24oY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlRnJvbU9yaWdpbiA+IE1BWF9DSEFSR0VfQk9VTkRTKSB7XG4gICAgICAgIC8vIENhbmNlbCBjaGFyZ2UgaWYgaXQgd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luXG4gICAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAvLyBOb3RpZnkgc3dvcmQgY29tcG9uZW50IHRoYXQgY2hhcmdlIHdhcyBjYW5jZWxsZWRcbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBjb2xsaWRlIHdpdGggYSBwaWxsYXJcbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFyZ2UgY2FuY2VsbGVkOiB3b3VsZCBjb2xsaWRlIHdpdGggcGlsbGFyIGF0IFske3BpbGxhckNvbGxpc2lvbi5waWxsYXJDZW50ZXIudG9BcnJheSgpLmpvaW4oJywgJyl9XWApO1xuICAgICAgICBtb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgLy8gTm90aWZ5IHN3b3JkIGNvbXBvbmVudCB0aGF0IGNoYXJnZSB3YXMgY2FuY2VsbGVkXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgcG9zaXRpb24gaWYgbm90IHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYXJnZVJlc3VsdC5pc0NvbXBsZXRlIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIENoYXJnZSBtb3ZlbWVudCBjb21wbGV0ZWQnKTtcbiAgICAgIC8vIE5vdGlmeSBzd29yZCBjb21wb25lbnQgdGhhdCBjaGFyZ2UgaXMgY29tcGxldGVcbiAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGdldFdvcmxkU3BhY2VEaXJlY3Rpb24oaW5wdXREaXJlY3Rpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICAvLyBHZXQgY2FtZXJhIGRpcmVjdGlvbiB2ZWN0b3JzXG4gICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyByaWdodCB2ZWN0b3JcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGNhbWVyYURpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyBmb3J3YXJkIHZlY3RvciAocHJvamVjdGVkIG9uIFhaIHBsYW5lKVxuICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYUZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCBjYW1lcmFSaWdodCkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlXG4gICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFSaWdodCwgaW5wdXREaXJlY3Rpb24ueCk7XG4gICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYUZvcndhcmQsIC1pbnB1dERpcmVjdGlvbi56KTtcbiAgICB3b3JsZERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB3b3JsZERpcmVjdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybURpdmluZVN0b3JtKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggcmFnZSAobWluaW11bSAyMCByYWdlIHJlcXVpcmVkKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3REaXZpbmVTdG9ybSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERpdmluZVN0b3JtVGltZSA8IHRoaXMuZGl2aW5lU3Rvcm1Db29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IHJhZ2UgYW1vdW50IGFuZCBjb25zdW1lIEFMTCByYWdlXG4gICAgY29uc3QgY3VycmVudFJhZ2UgPSBnYW1lVUkgPyBnYW1lVUkuZ2V0Q3VycmVudFJhZ2UoKSA6IDQwOyAvLyBGYWxsYmFjayB0byA0MCBpZiBnYW1lVUkgbm90IGF2YWlsYWJsZVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lQWxsUmFnZSgpOyAvLyBDb25zdW1lIGFsbCByYWdlIGluc3RlYWQgb2YganVzdCAyMFxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBleHRlbmRlZCBkdXJhdGlvbjogYmFzZSA0IHNlY29uZHMgKyAxIHNlY29uZCBwZXIgMTAgcmFnZSBjb25zdW1lZFxuICAgIGNvbnN0IGJhc2VTdG9ybUR1cmF0aW9uID0gMTAwMDsgLy8gNCBzZWNvbmRzIGJhc2VcbiAgICBjb25zdCBib251c0R1cmF0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50UmFnZSAvIDEwKSAqIDUwMDsgLy8gMSBzZWNvbmQgcGVyIDEwIHJhZ2VcbiAgICBjb25zdCB0b3RhbERpdmluZVN0b3JtRHVyYXRpb24gPSBiYXNlU3Rvcm1EdXJhdGlvbiArIGJvbnVzRHVyYXRpb247XG5cbiAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMubGFzdERpdmluZVN0b3JtVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgRGl2aW5lIFN0b3JtIGNhbGxiYWNrIGZvciBtdWx0aXBsYXllclxuICAgIGlmICh0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uRGl2aW5lU3Rvcm1DYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uLCB0b3RhbERpdmluZVN0b3JtRHVyYXRpb24pO1xuICAgIH1cblxuICAgIC8vIERpdmluZSBTdG9ybSBsYXN0cyBmb3IgY2FsY3VsYXRlZCBkdXJhdGlvblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5pc0RpdmluZVN0b3JtaW5nID0gZmFsc2U7XG4gICAgfSwgdG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUNoYXJnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDaGFyZ2VUaW1lIDwgdGhpcy5jaGFyZ2VDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNTd29yZENoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3RDaGFyZ2VUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gUmVzZXQgY29sbGlzaW9uIHRyYWNraW5nIGZvciBuZXcgY2hhcmdlXG4gICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIENoYXJnZSBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXJcbiAgICBpZiAodGhpcy5vbkNoYXJnZUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIHRoaXMub25DaGFyZ2VDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2FpbiByYWdlIGZvciB1c2luZyBjaGFyZ2UgYWJpbGl0eSAoKzIwIHJhZ2UpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuZ2FpblJhZ2UoMjApO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCB0aGUgY2hhcmdlIG1vdmVtZW50IHVzaW5nIHRoZSBzZXBhcmF0ZSBjaGFyZ2Ugc3lzdGVtXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgLy8gR2V0IGNoYXJnZSBkaXJlY3Rpb24gZnJvbSBjYW1lcmFcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSAwOyAvLyBLZWVwIG1vdmVtZW50IGhvcml6b250YWxcbiAgICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgY2hhcmdlIHdpdGggMTAuNSBkaXN0YW5jZSAoc2VwYXJhdGUgZnJvbSBkYXNoIHN5c3RlbSlcbiAgICAgICAgY29uc3QgY2hhcmdlU3RhcnRlZCA9IHBsYXllck1vdmVtZW50LnN0YXJ0Q2hhcmdlKGRpcmVjdGlvbiwgcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhcmdlU3RhcnRlZCkge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGNoYXJnZSBkYW1hZ2UgZGV0ZWN0aW9uIGR1cmluZyBtb3ZlbWVudFxuICAgICAgICAgIHRoaXMuc2NoZWR1bGVDaGFyZ2VEYW1hZ2UocGxheWVyVHJhbnNmb3JtLCBkaXJlY3Rpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNrIGNoYXJnZSBoaXQgZW50aXRpZXMgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzIGFuZCBlbmFibGUgY29sbGlzaW9uIHN0b3BwaW5nXG4gIHByaXZhdGUgY2hhcmdlSGl0RW50aXRpZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcblxuICAvLyBTY2hlZHVsZSBkYW1hZ2UgZGV0ZWN0aW9uIGR1cmluZyBjaGFyZ2UgbW92ZW1lbnRcbiAgcHJpdmF0ZSBzY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSwgY2hhcmdlRGlyZWN0aW9uOiBWZWN0b3IzLCBzdGFydFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMC42OyBcbiAgICBjb25zdCBkYW1hZ2VDaGVja0ludGVydmFsID0gNTA7IC8vIENoZWNrIGZvciBkYW1hZ2UgZXZlcnkgNTBtcyBmb3IgYmV0dGVyIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICBjb25zdCBjaGFyZ2VEYW1hZ2UgPSA0MDsgLy8gSGlnaCBkYW1hZ2UgZm9yIGNoYXJnZSBhYmlsaXR5XG4gICAgY29uc3QgY2hhcmdlUmFkaXVzID0gMi41OyAvLyBEYW1hZ2UgcmFkaXVzIGFyb3VuZCBwbGF5ZXIgZHVyaW5nIGNoYXJnZVxuICAgIFxuICAgIC8vIFJlc2V0IGNoYXJnZSBoaXQgdHJhY2tpbmdcbiAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmNsZWFyKCk7XG4gICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcbiAgICBcbiAgICBjb25zdCBkYW1hZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBcbiAgICAgIC8vIFN0b3AgaWYgY2hhcmdlIGlzIGNvbXBsZXRlLCBjYW5jZWxsZWQsIG9yIHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgICBpZiAoIXRoaXMuaXNTd29yZENoYXJnaW5nIHx8IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lID4gY2hhcmdlRHVyYXRpb24gfHwgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkYW1hZ2VJbnRlcnZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGRhbWFnZVxuICAgICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgIFxuICAgICAgbGV0IGhpdFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgXG4gICAgICAvLyBEZWJ1ZzogTG9nIGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgZHVyaW5nIGNoYXJnZVxuICAgICAgXG4gICAgICAvLyBFTkhBTkNFRDogQWxzbyBjaGVjayBhZ2FpbnN0IHNlcnZlciBwbGF5ZXIgcG9zaXRpb25zIGRpcmVjdGx5IGFzIGEgZmFsbGJhY2tcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBkb24ndCBtaXNzIGNvbGxpc2lvbnMgZHVlIHRvIGVudGl0eSBzeW5jIGlzc3Vlc1xuICAgICAgY29uc3Qgc2VydmVyUGxheWVycyA9ICh3aW5kb3cgYXMgYW55KS5wdnBQbGF5ZXJzIHx8IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGxvY2FsU29ja2V0SWQgPSAod2luZG93IGFzIGFueSkubG9jYWxTb2NrZXRJZDtcbiAgICAgICAgICAgIFxuICAgICAgc2VydmVyUGxheWVycy5mb3JFYWNoKChzZXJ2ZXJQbGF5ZXI6IGFueSwgcGxheWVySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAvLyBTa2lwIHNlbGZcbiAgICAgICAgaWYgKHBsYXllcklkID09PSBsb2NhbFNvY2tldElkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIGFscmVhZHkgaGl0IHBsYXllcnMgKHVzZSBoYXNoIG9mIHBsYXllciBJRCBmb3IgdHJhY2tpbmcpXG4gICAgICAgIGNvbnN0IHBsYXllcklkSGFzaCA9IHBsYXllcklkLmxlbmd0aCAqIDEwMDAgKyBwbGF5ZXJJZC5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAodGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5oYXMocGxheWVySWRIYXNoKSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2VydmVyUGxheWVyUG9zID0gbmV3IFZlY3RvcjMoc2VydmVyUGxheWVyLnBvc2l0aW9uLngsIHNlcnZlclBsYXllci5wb3NpdGlvbi55LCBzZXJ2ZXJQbGF5ZXIucG9zaXRpb24ueik7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcGxheWVyUG9zaXRpb24uZGlzdGFuY2VUbyhzZXJ2ZXJQbGF5ZXJQb3MpO1xuICAgICAgICBjb25zdCBzdG9wRGlzdGFuY2UgPSAwLjkgKyAxLjA7IC8vIFBsYXllciBjb2xsaXNpb24gcmFkaXVzICsgYnVmZmVyXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHN0b3BEaXN0YW5jZSAmJiBzZXJ2ZXJQbGF5ZXIuaGVhbHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuYWRkKHBsYXllcklkSGFzaCk7XG4gICAgICAgICAgaGl0U29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcHBseSBkYW1hZ2UgdGhyb3VnaCBQVlAgc3lzdGVtIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3N3b3JkX2NoYXJnZV9oaXQnLCBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpLCBjaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKSwge1xuICAgICAgICAgICAgICBkYW1hZ2U6IGNoYXJnZURhbWFnZSxcbiAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHBsYXllcklkLFxuICAgICAgICAgICAgICBoaXRQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IHNlcnZlclBsYXllclBvcy54LFxuICAgICAgICAgICAgICAgIHk6IHNlcnZlclBsYXllclBvcy55LFxuICAgICAgICAgICAgICAgIHo6IHNlcnZlclBsYXllclBvcy56XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGFsbEVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChlbnRpdHkuaWQgPT09IHRoaXMucGxheWVyRW50aXR5Py5pZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBhbHJlYWR5IGhpdCBlbnRpdGllc1xuICAgICAgICBpZiAodGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5oYXMoZW50aXR5LmlkKSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGhhcyB0cmFuc2Zvcm0gYW5kIGhlYWx0aCAoY291bGQgYmUgZW5lbXkgb3IgcGxheWVyKVxuICAgICAgICBjb25zdCBlbnRpdHlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICAgIGNvbnN0IGVudGl0eUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgICAgY29uc3QgZW50aXR5Q29sbGlkZXIgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERlYnVnOiBMb2cgZW50aXR5IGRldGFpbHNcbiAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgY29uc3QgZW50aXR5VHlwZSA9IGVuZW15ID8gYEVuZW15KCR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0pYCA6IGBQbGF5ZXIoJHtlbnRpdHkuaWR9KWA7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWVudGl0eVRyYW5zZm9ybSB8fCAhZW50aXR5SGVhbHRoIHx8IGVudGl0eUhlYWx0aC5pc0RlYWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVudGl0eVBvc2l0aW9uID0gZW50aXR5VHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8oZW50aXR5UG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGlzIHdpdGhpbiBjaGFyZ2UgZGFtYWdlIHJhZGl1c1xuICAgICAgICAvLyBJbiBQVlAsIHdlIHdhbnQgdG8gc3RvcCBqdXN0IGJlZm9yZSBoaXR0aW5nIHRoZSBlbmVteSwgbm90IG92ZXJsYXAgd2l0aCB0aGVtXG4gICAgICAgIGNvbnN0IHN0b3BEaXN0YW5jZSA9IGVudGl0eUNvbGxpZGVyID8gZW50aXR5Q29sbGlkZXIucmFkaXVzICsgMS4wIDogY2hhcmdlUmFkaXVzOyAvLyBTdG9wIDEgdW5pdCBhd2F5IGZyb20gZW5lbXkgZWRnZVxuICAgICAgICBcbiAgICAgICAgLy8gRGVidWc6IExvZyBwb3NpdGlvbiBhbmQgZGlzdGFuY2UgaW5mb3JtYXRpb25cbiAgICAgICAgXG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSBzdG9wRGlzdGFuY2UpIHtcbiAgICAgICAgICAvLyBNYXJrIGFzIGhpdCB0byBwcmV2ZW50IG11bHRpcGxlIGhpdHNcbiAgICAgICAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmFkZChlbnRpdHkuaWQpO1xuICAgICAgICAgIGhpdFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwbHkgZGFtYWdlIHRocm91Z2ggY29tYmF0IHN5c3RlbVxuICAgICAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICAgICAgaWYgKGNvbWJhdFN5c3RlbSAmJiB0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgICAgY29tYmF0U3lzdGVtLnF1ZXVlRGFtYWdlKGVudGl0eSwgY2hhcmdlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ2NoYXJnZScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgICAgICAgY29uc3QgZW50aXR5VHlwZSA9IGVuZW15ID8gYEVuZW15KCR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0pYCA6IGBQbGF5ZXIoJHtlbnRpdHkuaWR9KWA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBjaGFyZ2UgYXR0YWNrIGZvciBQVlAgKGluY2x1ZGVzIGRhbWFnZSBhbmQgYW5pbWF0aW9uKVxuICAgICAgICAgICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdzd29yZF9jaGFyZ2VfaGl0JywgcGxheWVyUG9zaXRpb24uY2xvbmUoKSwgY2hhcmdlRGlyZWN0aW9uLmNsb25lKCksIHtcbiAgICAgICAgICAgICAgICBkYW1hZ2U6IGNoYXJnZURhbWFnZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogZW50aXR5LmlkLFxuICAgICAgICAgICAgICAgIGhpdFBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBlbnRpdHlQb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgeTogZW50aXR5UG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgIHo6IGVudGl0eVBvc2l0aW9uLnpcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEluIFBWUCBtb2RlLCBzdG9wIGNoYXJnZSB3aGVuIGhpdHRpbmcgc29tZXRoaW5nXG4gICAgICBpZiAoaGl0U29tZXRoaW5nKSB7XG4gICAgICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3AgdGhlIGNoYXJnZSBtb3ZlbWVudCBpbW1lZGlhdGVseVxuICAgICAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICAgICAgaWYgKHBsYXllck1vdmVtZW50KSB7XG4gICAgICAgICAgICBwbGF5ZXJNb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIHRoZSBkYW1hZ2UgaW50ZXJ2YWwgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBmdXJ0aGVyIGhpdHNcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkYW1hZ2VJbnRlcnZhbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIGNoYXJnZSBjb21wbGV0aW9uXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0sIGRhbWFnZUNoZWNrSW50ZXJ2YWwpO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIENoYXJnZSBjb21wbGV0ZXNcbiAgcHVibGljIG9uQ2hhcmdlQ29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5pc1N3b3JkQ2hhcmdpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybURlZmxlY3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVmbGVjdFRpbWUgPCB0aGlzLmRlZmxlY3RDb29sZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxhc3REZWZsZWN0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgRGVmbGVjdCBjYWxsYmFjayBmb3IgbXVsdGlwbGF5ZXJcbiAgICBpZiAodGhpcy5vbkRlZmxlY3RDYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uRGVmbGVjdENhbGxiYWNrKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgdXAgZGVmbGVjdCBiYXJyaWVyIHRoYXQgYmxvY2tzIGRhbWFnZSBhbmQgcmVmbGVjdHMgcHJvamVjdGlsZXNcbiAgICB0aGlzLnNldHVwRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBBdXRvLWNvbXBsZXRlIGRlZmxlY3QgYWZ0ZXIgZHVyYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMub25EZWZsZWN0Q29tcGxldGUoKTtcbiAgICB9LCB0aGlzLmRlZmxlY3REdXJhdGlvbiAqIDEwMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWaXBlclN0aW5nVGltZSA8IHRoaXMudmlwZXJTdGluZ0ZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg2MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0VmlwZXJTdGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZSBlbmVyZ3lcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUVuZXJneSg2MCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdFZpcGVyU3RpbmdUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gU3RhcnQgY2hhcmdpbmcgYW5pbWF0aW9uXG4gICAgY29uc3QgY2hhcmdlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjaGFyZ2VEdXJhdGlvbiA9IDEwMDA7IC8vIDEgc2Vjb25kIGNoYXJnZSB0aW1lXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMudmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVWaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAwLjgyNTsgLy8gU2hvb3QgZnJvbSBjaGVzdCBsZXZlbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgc2FtZSBkb3dud2FyZCBhbmdsZSBjb21wZW5zYXRpb24gYXMgb3RoZXIgcHJvamVjdGlsZXNcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgcm90YXRpb24gYXJvdW5kIHRoZSByaWdodCBheGlzIHRvIHRpbHQgdGhlIGRpcmVjdGlvbiBkb3dud2FyZFxuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIE9mZnNldCBzcGF3biBwb3NpdGlvbiBzbGlnaHRseSBmb3J3YXJkIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIHBsYXllclxuICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgIHNwYXduUG9zaXRpb24uYWRkKGRpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICBcbiAgICAvLyBOb3RlOiBWaXBlciBTdGluZyBkYW1hZ2UgaXMgaGFuZGxlZCBieSBWaXBlclN0aW5nTWFuYWdlciwgbm90IEVDUyBwcm9qZWN0aWxlc1xuICAgIC8vIFRoaXMgcHJldmVudHMgZHVwbGljYXRlIHByb2plY3RpbGVzIGFuZCBkYW1hZ2VcbiAgICBcbiAgICAvLyBUcmlnZ2VyIFZpcGVyIFN0aW5nIGNhbGxiYWNrIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uVmlwZXJTdGluZ0NhbGxiYWNrKHBsYXllclBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcmlnZ2VyIHRoZSBnbG9iYWwgVmlwZXIgU3RpbmcgbWFuYWdlciBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBjb25zdCBzdWNjZXNzID0gdHJpZ2dlckdsb2JhbFZpcGVyU3RpbmcoKTtcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ/CfkI0gVmlwZXIgU3RpbmcgdmlzdWFsIGVmZmVjdHMgc3VjY2Vzc2Z1bGx5IHRyaWdnZXJlZCEnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3ZpcGVyX3N0aW5nX3Byb2plY3RpbGUnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIHtcbiAgICAgICAgc3BlZWQ6IDE2LFxuICAgICAgICBkYW1hZ2U6IDYxLFxuICAgICAgICBsaWZldGltZTogNSxcbiAgICAgICAgaXNSZXR1cm5pbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1CYXJyYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgXG4gICAgLy8gQ2hlY2sgY29vbGRvd25cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lIDwgdGhpcy5iYXJyYWdlRmlyZVJhdGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgQmFycmFnZSBvbiBjb29sZG93biBmb3IgJHsodGhpcy5iYXJyYWdlRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYXJyYWdlVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIGVuZXJneSAoNDAgZW5lcmd5IGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdEJhcnJhZ2UoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNDApO1xuICAgIH1cblxuICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RCYXJyYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSA1MDA7IC8vIDEgc2Vjb25kIGNoYXJnZSB0aW1lXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVCYXJyYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAwLjgyNTsgLy8gU2hvb3QgZnJvbSBjaGVzdCBsZXZlbFxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICAvLyBBcHBseSBzYW1lIGRvd253YXJkIGNvbXBlbnNhdGlvbiBhcyBwcm9qZWN0aWxlIHN5c3RlbVxuICAgIGNvbnN0IGNvbXBlbnNhdGlvbkFuZ2xlID0gTWF0aC5QSSAvIDY7IC8vIDMwIGRlZ3JlZXNcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICByb3RhdGlvbk1hdHJpeC5tYWtlUm90YXRpb25BeGlzKGNhbWVyYVJpZ2h0LCBjb21wZW5zYXRpb25BbmdsZSk7XG4gICAgZGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSA1IGFycm93czogY2VudGVyICgwwrApLCBsZWZ0ICgxNcKwLCAzMMKwKSwgcmlnaHQgKC0xNcKwLCAtMzDCsCkgdXNpbmcgcHJvcGVyIEVDUyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IGFuZ2xlcyA9IFswLCBNYXRoLlBJIC8gMTIsIC1NYXRoLlBJIC8gMTIsIE1hdGguUEkgLyA2LCAtTWF0aC5QSSAvIDZdOyAvLyAwwrAsIDE1wrAsIC0xNcKwLCAzMMKwLCAtMzDCsFxuICAgIFxuICAgIGFuZ2xlcy5mb3JFYWNoKGFuZ2xlID0+IHtcbiAgICAgIC8vIFJvdGF0ZSB0aGUgYmFzZSBkaXJlY3Rpb24gYnkgdGhlIHNwZWNpZmllZCBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICAgICAgY29uc3QgcHJvamVjdGlsZURpcmVjdGlvbiA9IGRpcmVjdGlvbi5jbG9uZSgpO1xuICAgICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpLm1ha2VSb3RhdGlvblkoYW5nbGUpO1xuICAgICAgcHJvamVjdGlsZURpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgICAgcHJvamVjdGlsZURpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gT2Zmc2V0IHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICAgIHNwYXduUG9zaXRpb24uYWRkKHByb2plY3RpbGVEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBwcm9wZXIgRUNTIHByb2plY3RpbGUgZW50aXR5XG4gICAgICBjb25zdCBwcm9qZWN0aWxlQ29uZmlnID0ge1xuICAgICAgICBzcGVlZDogMjIsIC8vIFNsaWdodGx5IGZhc3RlciB0aGFuIHJlZ3VsYXIgYXJyb3dzICgyMClcbiAgICAgICAgZGFtYWdlOiAzMCwgLy8gSGlnaCBkYW1hZ2UgZm9yIGJhcnJhZ2UgYXJyb3dzXG4gICAgICAgIGxpZmV0aW1lOiA4LFxuICAgICAgICBtYXhEaXN0YW5jZTogMjUsIC8vIExpbWl0IGJhcnJhZ2UgYXJyb3dzIHRvIDI1IHVuaXRzIGRpc3RhbmNlIChzYW1lIGFzIHJlZ3VsYXIgYXJyb3dzKVxuICAgICAgICBwaWVyY2luZzogZmFsc2UsXG4gICAgICAgIHN1YmNsYXNzOiB0aGlzLmN1cnJlbnRTdWJjbGFzcyxcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcHJvamVjdGlsZUVudGl0eSA9IHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVQcm9qZWN0aWxlKFxuICAgICAgICB0aGlzLndvcmxkLFxuICAgICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLFxuICAgICAgICB0aGlzLnBsYXllckVudGl0eSEuaWQsXG4gICAgICAgIHByb2plY3RpbGVDb25maWdcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIE1hcmsgYXMgYmFycmFnZSBhcnJvdyBmb3IgdmlzdWFsIGlkZW50aWZpY2F0aW9uXG4gICAgICBjb25zdCByZW5kZXJlciA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSBhcyBSZW5kZXJlcjtcbiAgICAgIGlmIChyZW5kZXJlcj8ubWVzaCkge1xuICAgICAgICByZW5kZXJlci5tZXNoLnVzZXJEYXRhLmlzQmFycmFnZUFycm93ID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyZXIubWVzaC51c2VyRGF0YS5pc1JlZ3VsYXJBcnJvdyA9IGZhbHNlOyAvLyBPdmVycmlkZSByZWd1bGFyIGFycm93IG1hcmtpbmdcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdiYXJyYWdlX3Byb2plY3RpbGUnLCBzcGF3blBvc2l0aW9uLCBwcm9qZWN0aWxlRGlyZWN0aW9uLCBwcm9qZWN0aWxlQ29uZmlnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFRyaWdnZXIgQmFycmFnZSBjYWxsYmFjayBmb3IgYWRkaXRpb25hbCB2aXN1YWwgZWZmZWN0cyBpZiBuZWVkZWRcbiAgICBpZiAodGhpcy5vbkJhcnJhZ2VDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkJhcnJhZ2VDYWxsYmFjayhwbGF5ZXJQb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gIH1cblxuICBwcml2YXRlIHNldHVwRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBBY3RpdmF0ZSB0aGUgZGVmbGVjdCBiYXJyaWVyXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBsYXllclJvdGF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgXG4gICAgLy8gVXNlIFNBTUUgcm90YXRpb24gbG9naWMgYXMgRHJhZ29uUmVuZGVyZXIgZm9yIGNvbnNpc3RlbmN5IHdpdGggdmlzdWFsIHNoaWVsZFxuICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgaWYgKG1vdmVtZW50ICYmIG1vdmVtZW50LmlucHV0U3RyZW5ndGggPiAwLjEpIHtcbiAgICAgICAgLy8gUGxheWVyIGlzIGFjdGl2ZWx5IG1vdmluZyAtIHVzZSBtb3ZlbWVudCBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIpXG4gICAgICAgIGNvbnN0IG1vdmVEaXIgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uO1xuICAgICAgICBpZiAobW92ZURpci5sZW5ndGgoKSA+IDAuMSkge1xuICAgICAgICAgIGNvbnN0IG1vdmVBbmdsZSA9IE1hdGguYXRhbjIobW92ZURpci54LCBtb3ZlRGlyLnopO1xuICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBtb3ZlQW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBtb3ZpbmcgLSB1c2UgY2FtZXJhIGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlciBmYWxsYmFjaylcbiAgICAgICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IE1hdGguYXRhbjIoY2FtZXJhRGlyZWN0aW9uLngsIGNhbWVyYURpcmVjdGlvbi56KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5hY3RpdmF0ZShwbGF5ZXJQb3NpdGlvbiwgcGxheWVyUm90YXRpb24sIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZURlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGRlZmxlY3QgYmFycmllciBwb3NpdGlvbiBpZiBpdCdzIGFjdGl2ZVxuICAgIGlmICh0aGlzLmRlZmxlY3RCYXJyaWVyLmlzQmFycmllckFjdGl2ZSgpKSB7XG4gICAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBwbGF5ZXJSb3RhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgICAgXG4gICAgICAvLyBVc2UgU0FNRSByb3RhdGlvbiBsb2dpYyBhcyBEcmFnb25SZW5kZXJlciBmb3IgY29uc2lzdGVuY3kgd2l0aCB2aXN1YWwgc2hpZWxkXG4gICAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgY29uc3QgbW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDAuMSkge1xuICAgICAgICAgIC8vIFBsYXllciBpcyBhY3RpdmVseSBtb3ZpbmcgLSB1c2UgbW92ZW1lbnQgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyKVxuICAgICAgICAgIGNvbnN0IG1vdmVEaXIgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uO1xuICAgICAgICAgIGlmIChtb3ZlRGlyLmxlbmd0aCgpID4gMC4xKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlQW5nbGUgPSBNYXRoLmF0YW4yKG1vdmVEaXIueCwgbW92ZURpci56KTtcbiAgICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBtb3ZlQW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBtb3ZpbmcgLSB1c2UgY2FtZXJhIGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlciBmYWxsYmFjaylcbiAgICAgICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IE1hdGguYXRhbjIoY2FtZXJhRGlyZWN0aW9uLngsIGNhbWVyYURpcmVjdGlvbi56KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYmFycmllciBwb3NpdGlvbiB0byBmb2xsb3cgcGxheWVyXG4gICAgICB0aGlzLmRlZmxlY3RCYXJyaWVyLnVwZGF0ZVBvc2l0aW9uKHBsYXllclBvc2l0aW9uLCBwbGF5ZXJSb3RhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIERlZmxlY3QgY29tcGxldGVzXG4gIHB1YmxpYyBvbkRlZmxlY3RDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVmbGVjdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZGVmbGVjdEJhcnJpZXIuZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgLy8gUHVibGljIG1ldGhvZHMgdG8gZ2V0IGNvb2xkb3duIGluZm9ybWF0aW9uIGZvciBVSVxuICBwdWJsaWMgZ2V0V2VhcG9uU3dpdGNoQ29vbGRvd24oKTogeyBjdXJyZW50OiBudW1iZXI7IG1heDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMud2VhcG9uU3dpdGNoQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lKSksXG4gICAgICBtYXg6IHRoaXMud2VhcG9uU3dpdGNoQ29vbGRvd25cbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGdldEFiaWxpdHlDb29sZG93bnMoKTogUmVjb3JkPHN0cmluZywgeyBjdXJyZW50OiBudW1iZXI7IG1heDogbnVtYmVyOyBpc0FjdGl2ZTogYm9vbGVhbiB9PiB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICBjb25zdCBjb29sZG93bnM6IFJlY29yZDxzdHJpbmcsIHsgY3VycmVudDogbnVtYmVyOyBtYXg6IG51bWJlcjsgaXNBY3RpdmU6IGJvb2xlYW4gfT4gPSB7fTtcbiAgICBcbiAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNXT1JEKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5kZWZsZWN0Q29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REZWZsZWN0VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZGVmbGVjdENvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc0RlZmxlY3RpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0UnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5jaGFyZ2VDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENoYXJnZVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmNoYXJnZUNvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1N3b3JkQ2hhcmdpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5kaXZpbmVTdG9ybUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGl2aW5lU3Rvcm1UaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5kaXZpbmVTdG9ybUNvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc0RpdmluZVN0b3JtaW5nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLkJPVykge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIHRoaXMuYmFycmFnZUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFycmFnZVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmJhcnJhZ2VGaXJlUmF0ZSxcbiAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0UnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5jb2JyYVNob3RGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENvYnJhU2hvdFRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmNvYnJhU2hvdEZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy52aXBlclN0aW5nRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWaXBlclN0aW5nVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMudmlwZXJTdGluZ0ZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQ1lUSEUpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCAxLjAgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RSZWFuaW1hdGVUaW1lKSksXG4gICAgICAgIG1heDogMS4wLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0UnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5mcm9zdE5vdmFGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmZyb3N0Tm92YUZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5jcm9zc2VudHJvcHlGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENyb3NzZW50cm9weVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0FCUkVTKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5iYWNrc3RhYkNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFja3N0YWJUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5iYWNrc3RhYkNvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ0UnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5za3lmYWxsQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RTa3lmYWxsVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuc2t5ZmFsbENvb2xkb3duLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc1NreWZhbGxpbmdcbiAgICAgIH07XG4gICAgICBjb29sZG93bnNbJ1InXSA9IHtcbiAgICAgICAgY3VycmVudDogMCwgLy8gTm8gUiBhYmlsaXR5IHlldFxuICAgICAgICBtYXg6IDAsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvb2xkb3ducztcbiAgfVxufSJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiTWF0cml4NCIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwiSGVhbHRoIiwiRW5lbXkiLCJSZW5kZXJlciIsIkNvbGxpZGVyIiwiQ29tYmF0U3lzdGVtIiwiV2VhcG9uU3ViY2xhc3MiLCJXZWFwb25UeXBlIiwiRGVmbGVjdEJhcnJpZXIiLCJ0cmlnZ2VyR2xvYmFsRnJvc3ROb3ZhIiwiYWRkR2xvYmFsRnJvemVuRW5lbXkiLCJ0cmlnZ2VyR2xvYmFsQ29icmFTaG90IiwidHJpZ2dlckdsb2JhbFZpcGVyU3RpbmciLCJDb250cm9sU3lzdGVtIiwic2V0UGxheWVyIiwiZW50aXR5IiwicGxheWVyRW50aXR5IiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJwbGF5ZXJUcmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJwbGF5ZXJNb3ZlbWVudCIsInVwZGF0ZURlYnVmZnMiLCJoYW5kbGVXZWFwb25Td2l0Y2hpbmciLCJoYW5kbGVEYXNoTW92ZW1lbnQiLCJoYW5kbGVDaGFyZ2VNb3ZlbWVudCIsImlzRGFzaGluZyIsImlzQ2hhcmdpbmciLCJpc0Zyb3plbiIsImlzU2t5ZmFsbGluZyIsImhhbmRsZU1vdmVtZW50SW5wdXQiLCJoYW5kbGVDb21iYXRJbnB1dCIsInVwZGF0ZURlZmxlY3RCYXJyaWVyIiwibW92ZW1lbnQiLCJjaGVja0ZvckRhc2hJbnB1dCIsImlucHV0RGlyZWN0aW9uIiwiaGFzSW5wdXQiLCJpbnB1dE1hbmFnZXIiLCJpc0tleVByZXNzZWQiLCJ6IiwieCIsImxlbmd0aCIsIm5vcm1hbGl6ZSIsImNhbWVyYURpcmVjdGlvbiIsImNhbWVyYSIsImdldFdvcmxkRGlyZWN0aW9uIiwiY2FtZXJhUmlnaHQiLCJjcm9zc1ZlY3RvcnMiLCJjYW1lcmFGb3J3YXJkIiwid29ybGREaXJlY3Rpb24iLCJhZGRTY2FsZWRWZWN0b3IiLCJzZXRNb3ZlRGlyZWN0aW9uIiwianVtcCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImxhc3RXZWFwb25Td2l0Y2hUaW1lIiwid2VhcG9uU3dpdGNoQ29vbGRvd24iLCJjdXJyZW50V2VhcG9uIiwiU1dPUkQiLCJyZXNldEFsbEFiaWxpdHlTdGF0ZXMiLCJjdXJyZW50U3ViY2xhc3MiLCJESVZJTklUWSIsImZpcmVSYXRlIiwic3dvcmRGaXJlUmF0ZSIsInN3b3JkQ29tYm9TdGVwIiwiQk9XIiwiRUxFTUVOVEFMIiwiU0NZVEhFIiwiQ0hBT1MiLCJzY3l0aGVGaXJlUmF0ZSIsIlNBQlJFUyIsIkZST1NUIiwic2FicmVzRmlyZVJhdGUiLCJoYW5kbGVCb3dJbnB1dCIsImhhbmRsZVNjeXRoZUlucHV0IiwiaGFuZGxlU3dvcmRJbnB1dCIsImhhbmRsZVNhYnJlc0lucHV0IiwiaXNWaXBlclN0aW5nQ2hhcmdpbmciLCJwZXJmb3JtVmlwZXJTdGluZyIsImlzQmFycmFnZUNoYXJnaW5nIiwicGVyZm9ybUJhcnJhZ2UiLCJpc0NvYnJhU2hvdENoYXJnaW5nIiwicGVyZm9ybUNvYnJhU2hvdCIsImlzTW91c2VCdXR0b25QcmVzc2VkIiwiY2hhcmdlUHJvZ3Jlc3MiLCJNYXRoIiwibWluIiwiZmluYWxDaGFyZ2VQcm9ncmVzcyIsImZpcmVQcm9qZWN0aWxlIiwidHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzIiwiY29uc29sZSIsImxvZyIsImZpcmVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlIiwiZmlyZUNyb3NzZW50cm9weUJvbHRBYmlsaXR5IiwicGVyZm9ybVJlYW5pbWF0ZUFiaWxpdHkiLCJwZXJmb3JtRnJvc3ROb3ZhQWJpbGl0eSIsImxhc3RGaXJlVGltZSIsImRpcmVjdGlvbiIsImNvbXBlbnNhdGlvbkFuZ2xlIiwiUEkiLCJyb3RhdGlvbk1hdHJpeCIsIm1ha2VSb3RhdGlvbkF4aXMiLCJhcHBseU1hdHJpeDQiLCJwZXJmZWN0U2hvdE1pblRocmVzaG9sZCIsInBlcmZlY3RTaG90TWF4VGhyZXNob2xkIiwiaXNQZXJmZWN0U2hvdCIsImNyZWF0ZUNoYXJnZWRBcnJvd1Byb2plY3RpbGUiLCJwb3NpdGlvbiIsImNsb25lIiwiY3JlYXRlUGVyZmVjdFNob3RQcm9qZWN0aWxlIiwiYW5nbGUiLCJhdGFuMiIsImNyZWF0ZVByb2plY3RpbGUiLCJzcGluU3RhdHVzIiwiY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZSIsImxhc3RDcm9zc2VudHJvcHlUaW1lIiwiY3Jvc3NlbnRyb3B5RmlyZVJhdGUiLCJjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZSIsInBvdGVudGlhbFRhcmdldHMiLCJ3b3JsZCIsInF1ZXJ5RW50aXRpZXMiLCJ2YWxpZFRhcmdldHMiLCJmaWx0ZXIiLCJ0YXJnZXQiLCJpZCIsImlzRGVhZCIsImhhc1ZhbGlkVGFyZ2V0cyIsInNob3VsZEJyb2FkY2FzdCIsIm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjayIsInVuZGVmaW5lZCIsInNwYXduUG9zaXRpb24iLCJhZGQiLCJtdWx0aXBseVNjYWxhciIsInkiLCJwcm9qZWN0aWxlQ29uZmlnIiwic3BlZWQiLCJkYW1hZ2UiLCJsaWZldGltZSIsIm1heERpc3RhbmNlIiwic3ViY2xhc3MiLCJsZXZlbCIsImN1cnJlbnRMZXZlbCIsIm9wYWNpdHkiLCJwcm9qZWN0aWxlU3lzdGVtIiwiZ2FtZVVJIiwid2luZG93IiwiY2FuQ2FzdEVudHJvcGljQm9sdCIsImNvbnN1bWVNYW5hIiwiZW50cm9waWNDb25maWciLCJwaWVyY2luZyIsImV4cGxvc2l2ZSIsImV4cGxvc2lvblJhZGl1cyIsImNhbkNhc3RDcm9zc2VudHJvcHlCb2x0IiwiY3Jvc3NlbnRyb3B5Q29uZmlnIiwibGFzdFJlYW5pbWF0ZVRpbWUiLCJjdXJyZW50TWFuYSIsImdldEN1cnJlbnRNYW5hIiwiY2FuQ2FzdFJlYW5pbWF0ZSIsIm1hbmFCZWZvcmUiLCJtYW5hQWZ0ZXIiLCJ0cmlnZ2VyUmVhbmltYXRlRWZmZWN0IiwiaGVhbHRoQ29tcG9uZW50IiwiZGlkSGVhbCIsImhlYWwiLCJvblJlYW5pbWF0ZUNhbGxiYWNrIiwicGxheWVyUG9zaXRpb24iLCJsYXN0RnJvc3ROb3ZhVGltZSIsImZyb3N0Tm92YUZpcmVSYXRlIiwiY2FuQ2FzdEZyb3N0Tm92YSIsImdldFdvcmxkUG9zaXRpb24iLCJvbkZyb3N0Tm92YUNhbGxiYWNrIiwiZnJlZXplRW5lbWllc0luUmFkaXVzIiwibGFzdENvYnJhU2hvdFRpbWUiLCJjb2JyYVNob3RGaXJlUmF0ZSIsImNhbkNhc3RDb2JyYVNob3QiLCJjb25zdW1lRW5lcmd5IiwiY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MiLCJjaGFyZ2VTdGFydFRpbWUiLCJjaGFyZ2VEdXJhdGlvbiIsImNoYXJnZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJlbGFwc2VkIiwiY2xlYXJJbnRlcnZhbCIsImZpcmVDb2JyYVNob3QiLCJvbkNvYnJhU2hvdENhbGxiYWNrIiwidmVub21EdXJhdGlvbiIsImNlbnRlclBvc2l0aW9uIiwicmFkaXVzIiwiYWxsRW50aXRpZXMiLCJnZXRBbGxFbnRpdGllcyIsImZyb3plbkNvdW50IiwiZGFtYWdlZFBsYXllcnMiLCJmb3JFYWNoIiwiZW50aXR5VHJhbnNmb3JtIiwiZW50aXR5SGVhbHRoIiwiZW50aXR5UG9zaXRpb24iLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJlbmVteSIsImZyZWV6ZSIsInRvU3RyaW5nIiwiY29tYmF0U3lzdGVtIiwiZ2V0U3lzdGVtIiwiZnJvc3ROb3ZhRGFtYWdlIiwicXVldWVEYW1hZ2UiLCJvbkRlYnVmZkNhbGxiYWNrIiwiY2hhcmdlZEFycm93Q29uZmlnIiwic2V0V2VhcG9uU3ViY2xhc3MiLCJzZXRCb3dSZWxlYXNlQ2FsbGJhY2siLCJjYWxsYmFjayIsIm9uQm93UmVsZWFzZUNhbGxiYWNrIiwic2V0RGl2aW5lU3Rvcm1DYWxsYmFjayIsIm9uRGl2aW5lU3Rvcm1DYWxsYmFjayIsInNldFByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2siLCJzZXRWaXBlclN0aW5nQ2FsbGJhY2siLCJvblZpcGVyU3RpbmdDYWxsYmFjayIsInNldEJhcnJhZ2VDYWxsYmFjayIsIm9uQmFycmFnZUNhbGxiYWNrIiwic2V0UmVhbmltYXRlQ2FsbGJhY2siLCJzZXRGcm9zdE5vdmFDYWxsYmFjayIsInNldENvYnJhU2hvdENhbGxiYWNrIiwic2V0Q2hhcmdlQ2FsbGJhY2siLCJvbkNoYXJnZUNhbGxiYWNrIiwic2V0RGVmbGVjdENhbGxiYWNrIiwib25EZWZsZWN0Q2FsbGJhY2siLCJzZXRTa3lmYWxsQ2FsbGJhY2siLCJvblNreWZhbGxDYWxsYmFjayIsInNldEJhY2tzdGFiQ2FsbGJhY2siLCJvbkJhY2tzdGFiQ2FsbGJhY2siLCJzZXREZWJ1ZmZDYWxsYmFjayIsInNldFdlYXBvbkxldmVsIiwiZ2V0Q3VycmVudFdlYXBvbkNvbmZpZyIsIndlYXBvbiIsImdldEN1cnJlbnRXZWFwb24iLCJnZXRDdXJyZW50U3ViY2xhc3MiLCJpc1dlYXBvbkNoYXJnaW5nIiwiZ2V0Q2hhcmdlUHJvZ3Jlc3MiLCJpc1ZpcGVyU3RpbmdDaGFyZ2luZ0FjdGl2ZSIsImdldFZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyIsInZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyIsImlzQmFycmFnZUNoYXJnaW5nQWN0aXZlIiwiZ2V0QmFycmFnZUNoYXJnZVByb2dyZXNzIiwiYmFycmFnZUNoYXJnZVByb2dyZXNzIiwiaXNDb2JyYVNob3RDaGFyZ2luZ0FjdGl2ZSIsImdldENvYnJhU2hvdENoYXJnZVByb2dyZXNzIiwiaXNXZWFwb25Td2luZ2luZyIsImlzU3dpbmdpbmciLCJnZXRTd29yZENvbWJvU3RlcCIsImlzRGl2aW5lU3Rvcm1BY3RpdmUiLCJpc0RpdmluZVN0b3JtaW5nIiwiaXNDaGFyZ2VBY3RpdmUiLCJpc1N3b3JkQ2hhcmdpbmciLCJpc0RlZmxlY3RBY3RpdmUiLCJpc0RlZmxlY3RpbmciLCJpc1NreWZhbGxBY3RpdmUiLCJpc0JhY2tzdGFiQWN0aXZlIiwiaXNCYWNrc3RhYmJpbmciLCJwZXJmb3JtU3dvcmRNZWxlZUF0dGFjayIsInBlcmZvcm1EaXZpbmVTdG9ybSIsInBlcmZvcm1DaGFyZ2UiLCJwZXJmb3JtRGVmbGVjdCIsImxhc3RTd29yZEF0dGFja1RpbWUiLCJzd29yZENvbWJvUmVzZXRUaW1lIiwicGVyZm9ybU1lbGVlRGFtYWdlIiwib25Td29yZFN3aW5nQ29tcGxldGUiLCJwZXJmb3JtU2FicmVzTWVsZWVBdHRhY2siLCJwZXJmb3JtQmFja3N0YWIiLCJwZXJmb3JtU2t5ZmFsbCIsInVwZGF0ZVNreWZhbGxNb3ZlbWVudCIsInVwZGF0ZUJhY2tzdGFiU3RhdGUiLCJwZXJmb3JtU2FicmVzTWVsZWVEYW1hZ2UiLCJvblNhYnJlc1N3aW5nQ29tcGxldGUiLCJoYXNDb21wb25lbnQiLCJhdHRhY2tSYW5nZSIsImF0dGFja0FuZ2xlIiwibGVmdFNhYnJlRGFtYWdlIiwicmlnaHRTYWJyZURhbWFnZSIsImF0dGFja0RpcmVjdGlvbiIsImhpdENvdW50IiwidGFyZ2V0VHJhbnNmb3JtIiwidGFyZ2V0SGVhbHRoIiwiZGlyZWN0aW9uVG9UYXJnZXQiLCJzdWIiLCJkaXN0YW5jZVRvVGFyZ2V0IiwiZG90UHJvZHVjdCIsImRvdCIsImFuZ2xlVG9UYXJnZXQiLCJhY29zIiwibWF4Iiwic2V0VGltZW91dCIsImxhc3RTa3lmYWxsVGltZSIsInNreWZhbGxDb29sZG93biIsImNhbkNhc3RTa3lmYWxsIiwic2t5ZmFsbFBoYXNlIiwic2t5ZmFsbFN0YXJ0VGltZSIsInNreWZhbGxTdGFydFBvc2l0aW9uIiwiY29weSIsInNreWZhbGxPcmlnaW5hbEdyYXZpdHkiLCJncmF2aXR5Iiwic2t5ZmFsbFRhcmdldEhlaWdodCIsImp1bXBGb3JjZSIsInZlbG9jaXR5IiwiZWxhcHNlZFRpbWUiLCJwZXJmb3JtU2t5ZmFsbExhbmRpbmciLCJjb21wbGV0ZVNreWZhbGxBYmlsaXR5IiwibGFuZGluZ1Bvc2l0aW9uIiwiZGFtYWdlUmFkaXVzIiwic2t5ZmFsbERhbWFnZSIsImRpc3RhbmNlVG9MYW5kaW5nIiwiYmFja3N0YWJTdGFydFRpbWUiLCJiYWNrc3RhYkR1cmF0aW9uIiwibGFzdEJhY2tzdGFiVGltZSIsImJhY2tzdGFiQ29vbGRvd24iLCJjYW5DYXN0QmFja3N0YWIiLCJwZXJmb3JtQmFja3N0YWJEYW1hZ2UiLCJwbGF5ZXJEaXJlY3Rpb24iLCJiYWNrc3RhYlJhbmdlIiwic3ViVmVjdG9ycyIsImFuZ2xlVGhyZXNob2xkIiwiY29zIiwiaXNCYWNrc3RhYiIsInB2cFBsYXllcnMiLCJsb2NhbFNvY2tldElkIiwidGFyZ2V0UGxheWVyIiwicGxheWVySWQiLCJwbGF5ZXIiLCJwbGF5ZXJQb3MiLCJ0YXJnZXRGYWNpbmdEaXJlY3Rpb24iLCJzaW4iLCJyb3RhdGlvbiIsImF0dGFja2VyRGlyZWN0aW9uIiwiYmVoaW5kRG90UHJvZHVjdCIsIm1lbGVlUmFuZ2UiLCJtZWxlZUFuZ2xlIiwiYmFzZURhbWFnZSIsImVuZW1pZXNIaXQiLCJlbmVteVRyYW5zZm9ybSIsImVuZW15SGVhbHRoIiwiZW5lbXlQb3NpdGlvbiIsInRvRW5lbXkiLCJhbmdsZVRvIiwiYW5nbGVEZWdyZWVzIiwibWF4QW5nbGVEZWdyZWVzIiwicmFnZVRvR2FpbiIsImdhaW5SYWdlIiwidHJhbnNmb3JtIiwiZGFzaERpcmVjdGlvbnMiLCJrZXkiLCJjaGVja0RvdWJsZVRhcCIsImRlYnVnSW5mbyIsImdldERvdWJsZVRhcERlYnVnSW5mbyIsImdldFdvcmxkU3BhY2VEaXJlY3Rpb24iLCJkYXNoU3RhcnRlZCIsInN0YXJ0RGFzaCIsInJlc2V0RG91YmxlVGFwIiwiZGFzaFJlc3VsdCIsInVwZGF0ZURhc2giLCJuZXdQb3NpdGlvbiIsIk1BWF9EQVNIX0JPVU5EUyIsImRpc3RhbmNlRnJvbU9yaWdpbiIsImNhbmNlbERhc2giLCJjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24iLCJjYW5jZWxDaGFyZ2UiLCJjaGFyZ2VSZXN1bHQiLCJ1cGRhdGVDaGFyZ2UiLCJNQVhfQ0hBUkdFX0JPVU5EUyIsInBpbGxhckNvbGxpc2lvbiIsImNoZWNrUGlsbGFyQ29sbGlzaW9uIiwib25DaGFyZ2VDb21wbGV0ZSIsImhhc0NvbGxpc2lvbiIsIndhcm4iLCJwaWxsYXJDZW50ZXIiLCJ0b0FycmF5Iiwiam9pbiIsImlzQ29tcGxldGUiLCJwaWxsYXJQb3MiLCJQSUxMQVJfUE9TSVRJT05TIiwiaG9yaXpvbnRhbFBvcyIsInBpbGxhckhvcml6b250YWwiLCJQSUxMQVJfUkFESVVTIiwibm9ybWFsIiwic2V0IiwiY2FuQ2FzdERpdmluZVN0b3JtIiwibGFzdERpdmluZVN0b3JtVGltZSIsImRpdmluZVN0b3JtQ29vbGRvd24iLCJjdXJyZW50UmFnZSIsImdldEN1cnJlbnRSYWdlIiwiY29uc3VtZUFsbFJhZ2UiLCJiYXNlU3Rvcm1EdXJhdGlvbiIsImJvbnVzRHVyYXRpb24iLCJmbG9vciIsInRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbiIsImxhc3RDaGFyZ2VUaW1lIiwiY2hhcmdlQ29vbGRvd24iLCJjaGFyZ2VTdGFydGVkIiwic3RhcnRDaGFyZ2UiLCJzY2hlZHVsZUNoYXJnZURhbWFnZSIsImNoYXJnZURpcmVjdGlvbiIsInN0YXJ0VGltZSIsImRhbWFnZUNoZWNrSW50ZXJ2YWwiLCJjaGFyZ2VEYW1hZ2UiLCJjaGFyZ2VSYWRpdXMiLCJjaGFyZ2VIaXRFbnRpdGllcyIsImNsZWFyIiwiZGFtYWdlSW50ZXJ2YWwiLCJoaXRTb21ldGhpbmciLCJzZXJ2ZXJQbGF5ZXJzIiwiTWFwIiwic2VydmVyUGxheWVyIiwicGxheWVySWRIYXNoIiwiY2hhckNvZGVBdCIsImhhcyIsInNlcnZlclBsYXllclBvcyIsInN0b3BEaXN0YW5jZSIsImhlYWx0aCIsInRhcmdldElkIiwiaGl0UG9zaXRpb24iLCJlbnRpdHlDb2xsaWRlciIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImxhc3REZWZsZWN0VGltZSIsImRlZmxlY3RDb29sZG93biIsInNldHVwRGVmbGVjdEJhcnJpZXIiLCJvbkRlZmxlY3RDb21wbGV0ZSIsImRlZmxlY3REdXJhdGlvbiIsImxhc3RWaXBlclN0aW5nVGltZSIsInZpcGVyU3RpbmdGaXJlUmF0ZSIsImNhbkNhc3RWaXBlclN0aW5nIiwiZmlyZVZpcGVyU3RpbmciLCJzdWNjZXNzIiwiaXNSZXR1cm5pbmciLCJsYXN0QmFycmFnZVRpbWUiLCJiYXJyYWdlRmlyZVJhdGUiLCJ0b0ZpeGVkIiwiY2FuQ2FzdEJhcnJhZ2UiLCJmaXJlQmFycmFnZSIsImFuZ2xlcyIsInByb2plY3RpbGVEaXJlY3Rpb24iLCJtYWtlUm90YXRpb25ZIiwicHJvamVjdGlsZUVudGl0eSIsInJlbmRlcmVyIiwibWVzaCIsInVzZXJEYXRhIiwiaXNCYXJyYWdlQXJyb3ciLCJpc1JlZ3VsYXJBcnJvdyIsInBsYXllclJvdGF0aW9uIiwiaW5wdXRTdHJlbmd0aCIsIm1vdmVEaXIiLCJtb3ZlRGlyZWN0aW9uIiwibW92ZUFuZ2xlIiwiZGVmbGVjdEJhcnJpZXIiLCJhY3RpdmF0ZSIsImlzQmFycmllckFjdGl2ZSIsInVwZGF0ZVBvc2l0aW9uIiwiZGVhY3RpdmF0ZSIsImdldFdlYXBvblN3aXRjaENvb2xkb3duIiwiY3VycmVudCIsImdldEFiaWxpdHlDb29sZG93bnMiLCJjb29sZG93bnMiLCJpc0FjdGl2ZSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwiU2V0IiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ControlSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/HealthBarSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/HealthBarSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBarSystem: function() { return /* binding */ HealthBarSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/HealthBar */ \"(app-pages-browser)/./src/ecs/components/HealthBar.ts\");\n// Health bar system for rendering health bars above entities\n\n\n\n\n\nclass HealthBarSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update health bar logic\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n            if (!transform.enabled || !health.enabled || !healthBar.enabled) {\n                continue;\n            }\n            // Update health bar with current health ratio\n            const worldPosition = transform.getWorldPosition();\n            const cameraPosition = this.camera.position;\n            healthBar.updateHealthBar(health.getHealthRatio(), cameraPosition, worldPosition, deltaTime);\n        }\n    }\n    render(entities, deltaTime) {\n    // Health bars are automatically rendered as part of the scene\n    // This method can be used for any additional rendering logic\n    }\n    onEntityAdded(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Add health bar group to scene\n            this.scene.add(healthBar.getGroup());\n        }\n    }\n    onEntityRemoved(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Remove health bar group from scene and dispose resources\n            this.scene.remove(healthBar.getGroup());\n            healthBar.dispose();\n        }\n    }\n    onDisable() {\n        // Clean up all health bars from scene\n        const healthBarGroups = [];\n        this.scene.traverse((object)=>{\n            if (object instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group && object.userData.isHealthBar) {\n                healthBarGroups.push(object);\n            }\n        });\n        for (const group of healthBarGroups){\n            this.scene.remove(group);\n        }\n    }\n    constructor(scene, camera){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar\n        ];\n        this.scene = scene;\n        this.camera = camera;\n        this.priority = 100; // Render after main objects\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0hlYWx0aEJhclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDQTtBQUNqQjtBQUVXO0FBQ047QUFDTTtBQUVoRCxNQUFNSyx3QkFBd0JKLHFEQUFZQTtJQVl4Q0ssT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQkFBMEI7UUFDMUIsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1QsZ0VBQVNBO1lBQy9DLE1BQU1VLFNBQVNILE9BQU9FLFlBQVksQ0FBQ1IsMERBQU1BO1lBQ3pDLE1BQU1VLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBRS9DLElBQUksQ0FBQ00sVUFBVUksT0FBTyxJQUFJLENBQUNGLE9BQU9FLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCTCxVQUFVTSxnQkFBZ0I7WUFDaEQsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1lBRTNDTixVQUFVTyxlQUFlLENBQ3ZCUixPQUFPUyxjQUFjLElBQ3JCSixnQkFDQUYsZUFDQVA7UUFFSjtJQUNGO0lBRU9jLE9BQU9mLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7SUFDekQsOERBQThEO0lBQzlELDZEQUE2RDtJQUMvRDtJQUVPZSxjQUFjZCxNQUFjLEVBQVE7UUFDekMsTUFBTUksWUFBWUosT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7UUFDL0MsSUFBSVMsV0FBVztZQUNiLGdDQUFnQztZQUNoQyxJQUFJLENBQUNXLEtBQUssQ0FBQ0MsR0FBRyxDQUFDWixVQUFVYSxRQUFRO1FBQ25DO0lBQ0Y7SUFFT0MsZ0JBQWdCbEIsTUFBYyxFQUFRO1FBQzNDLE1BQU1JLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1FBQy9DLElBQUlTLFdBQVc7WUFDYiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDVyxLQUFLLENBQUNJLE1BQU0sQ0FBQ2YsVUFBVWEsUUFBUTtZQUNwQ2IsVUFBVWdCLE9BQU87UUFDbkI7SUFDRjtJQUVPQyxZQUFrQjtRQUN2QixzQ0FBc0M7UUFDdEMsTUFBTUMsa0JBQTJCLEVBQUU7UUFFbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDQztZQUNuQixJQUFJQSxrQkFBa0JqQyx1REFBS0EsSUFBSWlDLE9BQU9DLFFBQVEsQ0FBQ0MsV0FBVyxFQUFFO2dCQUMxREosZ0JBQWdCSyxJQUFJLENBQUNIO1lBQ3ZCO1FBQ0Y7UUFFQSxLQUFLLE1BQU1JLFNBQVNOLGdCQUFpQjtZQUNuQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUztRQUNwQjtJQUNGO0lBbEVBQyxZQUFZZCxLQUFZLEVBQUVOLE1BQWMsQ0FBRTtRQUN4QyxLQUFLO2FBTFNxQixxQkFBcUI7WUFBQ3JDLGdFQUFTQTtZQUFFQywwREFBTUE7WUFBRUMsZ0VBQVNBO1NBQUM7UUFNakUsSUFBSSxDQUFDb0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRyxLQUFLLDRCQUE0QjtJQUNuRDtBQThERiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9IZWFsdGhCYXJTeXN0ZW0udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIHN5c3RlbSBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBHcm91cCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEhlYWx0aEJhciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoQmFyJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhclN5c3RlbSBleHRlbmRzIFJlbmRlclN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBIZWFsdGgsIEhlYWx0aEJhcl07XG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwOyAvLyBSZW5kZXIgYWZ0ZXIgbWFpbiBvYmplY3RzXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBsb2dpY1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWhlYWx0aC5lbmFibGVkIHx8ICFoZWFsdGhCYXIuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2l0aCBjdXJyZW50IGhlYWx0aCByYXRpb1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBoZWFsdGhCYXIudXBkYXRlSGVhbHRoQmFyKFxuICAgICAgICBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSxcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgIGRlbHRhVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBIZWFsdGggYmFycyBhcmUgYXV0b21hdGljYWxseSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzY2VuZVxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBhbnkgYWRkaXRpb25hbCByZW5kZXJpbmcgbG9naWNcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgaGVhbHRoQmFyID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGhCYXIpO1xuICAgIGlmIChoZWFsdGhCYXIpIHtcbiAgICAgIC8vIEFkZCBoZWFsdGggYmFyIGdyb3VwIHRvIHNjZW5lXG4gICAgICB0aGlzLnNjZW5lLmFkZChoZWFsdGhCYXIuZ2V0R3JvdXAoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKTtcbiAgICBpZiAoaGVhbHRoQmFyKSB7XG4gICAgICAvLyBSZW1vdmUgaGVhbHRoIGJhciBncm91cCBmcm9tIHNjZW5lIGFuZCBkaXNwb3NlIHJlc291cmNlc1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoaGVhbHRoQmFyLmdldEdyb3VwKCkpO1xuICAgICAgaGVhbHRoQmFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBoZWFsdGggYmFycyBmcm9tIHNjZW5lXG4gICAgY29uc3QgaGVhbHRoQmFyR3JvdXBzOiBHcm91cFtdID0gW107XG4gICAgXG4gICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgR3JvdXAgJiYgb2JqZWN0LnVzZXJEYXRhLmlzSGVhbHRoQmFyKSB7XG4gICAgICAgIGhlYWx0aEJhckdyb3Vwcy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGhlYWx0aEJhckdyb3Vwcykge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoZ3JvdXApO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdyb3VwIiwiUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiSGVhbHRoQmFyIiwiSGVhbHRoQmFyU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoZWFsdGgiLCJoZWFsdGhCYXIiLCJlbmFibGVkIiwid29ybGRQb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYSIsInBvc2l0aW9uIiwidXBkYXRlSGVhbHRoQmFyIiwiZ2V0SGVhbHRoUmF0aW8iLCJyZW5kZXIiLCJvbkVudGl0eUFkZGVkIiwic2NlbmUiLCJhZGQiLCJnZXRHcm91cCIsIm9uRW50aXR5UmVtb3ZlZCIsInJlbW92ZSIsImRpc3Bvc2UiLCJvbkRpc2FibGUiLCJoZWFsdGhCYXJHcm91cHMiLCJ0cmF2ZXJzZSIsIm9iamVjdCIsInVzZXJEYXRhIiwiaXNIZWFsdGhCYXIiLCJwdXNoIiwiZ3JvdXAiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/HealthBarSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/PhysicsSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/PhysicsSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Physics system for handling movement physics\n\n\n\n\nclass PhysicsSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for variable timestep updates\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            // Update debuff states (frozen, slowed, etc.)\n            if (typeof movement.updateDebuffs === \"function\") {\n                movement.updateDebuffs();\n            } else {\n                console.warn(\"⚠️ Movement component missing updateDebuffs method:\", movement);\n            }\n            this.updateMovement(transform, movement, deltaTime);\n        }\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            this.applyPhysics(transform, movement, fixedDeltaTime);\n        }\n    }\n    updateMovement(transform, movement, deltaTime) {\n        // Update position based on velocity\n        const deltaPosition = movement.velocity.clone().multiplyScalar(deltaTime);\n        // Calculate potential new position\n        const currentPosition = transform.position.clone();\n        const potentialPosition = currentPosition.clone().add(deltaPosition);\n        // Apply map boundary constraints with smooth sliding (radius of 29 units from origin)\n        const MAP_RADIUS = 29;\n        // Only check horizontal distance (ignore Y for boundary)\n        const horizontalPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(potentialPosition.x, 0, potentialPosition.z);\n        const distanceFromCenter = horizontalPosition.length();\n        // Check for pillar collisions first\n        const pillarCollision = this.checkPillarCollision(potentialPosition);\n        if (distanceFromCenter >= MAP_RADIUS) {\n            // If we hit the boundary, calculate tangent movement for smooth sliding\n            const currentHorizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(currentPosition.x, 0, currentPosition.z);\n            const toCenter = currentHorizontalPos.clone().normalize();\n            // Create tangent vector (perpendicular to radius)\n            const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-toCenter.z, 0, toCenter.x);\n            // Project our horizontal movement onto the tangent\n            const horizontalMovement = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(deltaPosition.x, 0, deltaPosition.z);\n            const tangentMovement = tangent.multiplyScalar(horizontalMovement.dot(tangent));\n            // Apply the tangential movement while keeping distance to center constant\n            const newHorizontalPosition = currentHorizontalPos.add(tangentMovement);\n            newHorizontalPosition.normalize().multiplyScalar(MAP_RADIUS);\n            // Update position with tangent movement and preserve Y movement\n            transform.setPosition(newHorizontalPosition.x, currentPosition.y + deltaPosition.y, newHorizontalPosition.z);\n        } else if (pillarCollision.hasCollision) {\n            // Handle pillar collision with smooth sliding\n            const slidePosition = this.calculatePillarSliding(currentPosition, deltaPosition, pillarCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the pillar to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(pillarCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else {\n            // If within bounds and no pillar collision, move normally\n            transform.translate(deltaPosition.x, deltaPosition.y, deltaPosition.z);\n        }\n        // Mark transform matrix as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    calculatePillarSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from pillar center\n        const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.pillarCenter.x, 0, collision.pillarCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(pillarHorizontal);\n        if (distanceAfterSlide < this.PILLAR_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(pillarHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = pillarHorizontal.clone().add(pushDirection.multiplyScalar(this.PILLAR_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    applyPhysics(transform, movement, deltaTime) {\n        // Apply gravity (only affects Y velocity)\n        movement.applyGravity(deltaTime);\n        // Handle horizontal movement directly for immediate response\n        if (movement.inputStrength > 0) {\n            // Use effective max speed which accounts for frozen/slowed states\n            const effectiveMaxSpeed = movement.getEffectiveMaxSpeed();\n            // Direct velocity setting for responsive movement\n            const targetVelocity = movement.moveDirection.clone();\n            targetVelocity.multiplyScalar(effectiveMaxSpeed * movement.inputStrength);\n            // Set horizontal velocity directly (preserve Y velocity for gravity/jumping)\n            movement.velocity.x = targetVelocity.x;\n            movement.velocity.z = targetVelocity.z;\n        } else {\n            // No input - stop horizontal movement immediately for responsive controls\n            movement.velocity.x = 0;\n            movement.velocity.z = 0;\n        }\n        // Apply any additional forces (like knockback, wind, etc.)\n        movement.velocity.add(movement.acceleration.clone().multiplyScalar(deltaTime));\n        // Reset acceleration for next frame\n        movement.acceleration.set(0, 0, 0);\n        // Simple ground check (Y = 0 is ground level, account for sphere radius)\n        const sphereRadius = 0.5; // Player sphere radius\n        const groundLevel = sphereRadius; // Sphere center should be at radius height above ground\n        if (transform.position.y <= groundLevel && movement.velocity.y <= 0) {\n            transform.position.y = groundLevel;\n            movement.velocity.y = 0;\n            movement.isGrounded = true;\n        } else {\n            movement.isGrounded = false;\n        }\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        this.priority = 15; // Run after control system but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrQ0FBK0M7QUFDQztBQUNrQjtBQUVYO0FBQ0Y7QUFFOUMsTUFBTUMsc0JBQXNCQyxzREFBaUJBO0lBUTNDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELHNEQUFzRDtRQUN0RCxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsV0FBV0gsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ0ssYUFBYSxDQUFDRSxVQUFVO2dCQUMzQjtZQUNGO1lBRUEsSUFBSSxDQUFDRixVQUFVRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxJQUFJLENBQUNELFNBQVNFLE9BQU8sRUFBRTtnQkFDaEU7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLE9BQU9GLFNBQVNHLGFBQWEsS0FBSyxZQUFZO2dCQUNoREgsU0FBU0csYUFBYTtZQUN4QixPQUFPO2dCQUNMQyxRQUFRQyxJQUFJLENBQUMsdURBQXVETDtZQUN0RTtZQUVBLElBQUksQ0FBQ00sY0FBYyxDQUFDUixXQUFXRSxVQUFVSjtRQUMzQztJQUNGO0lBRU9XLFlBQVlaLFFBQWtCLEVBQUVhLGNBQXNCLEVBQVE7UUFDbkUsMENBQTBDO1FBQzFDLEtBQUssTUFBTVgsVUFBVUYsU0FBVTtZQUM3QixNQUFNRyxZQUFZRCxPQUFPRSxZQUFZLENBQUNQLGdFQUFTQTtZQUMvQyxNQUFNUSxXQUFXSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUU3QywwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDSyxhQUFhLENBQUNFLFVBQVU7Z0JBQzNCO1lBQ0Y7WUFFQSxJQUFJLENBQUNGLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLElBQUks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Q0FBQ1MsQ0FBQyxHQUFHO1lBQ3RCcEIsU0FBU1csUUFBUSxDQUFDVSxDQUFDLEdBQUc7UUFDeEI7UUFFQSwyREFBMkQ7UUFDM0RyQixTQUFTVyxRQUFRLENBQUNNLEdBQUcsQ0FBQ2pCLFNBQVNpRSxZQUFZLENBQUNyRCxLQUFLLEdBQUdDLGNBQWMsQ0FBQ2pCO1FBRW5FLG9DQUFvQztRQUNwQ0ksU0FBU2lFLFlBQVksQ0FBQ2IsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUVoQyx5RUFBeUU7UUFDekUsTUFBTWMsZUFBZSxLQUFLLHVCQUF1QjtRQUNqRCxNQUFNQyxjQUFjRCxjQUFjLHdEQUF3RDtRQUUxRixJQUFJcEUsVUFBVWlCLFFBQVEsQ0FBQ29CLENBQUMsSUFBSWdDLGVBQWVuRSxTQUFTVyxRQUFRLENBQUN3QixDQUFDLElBQUksR0FBRztZQUNuRXJDLFVBQVVpQixRQUFRLENBQUNvQixDQUFDLEdBQUdnQztZQUN2Qm5FLFNBQVNXLFFBQVEsQ0FBQ3dCLENBQUMsR0FBRztZQUN0Qm5DLFNBQVNvRSxVQUFVLEdBQUc7UUFDeEIsT0FBTztZQUNMcEUsU0FBU29FLFVBQVUsR0FBRztRQUN4QjtJQUNGO0lBaE5BQyxhQUFjO1FBQ1osS0FBSzthQUhTQyxxQkFBcUI7WUFBQzlFLGdFQUFTQTtZQUFFQyw4REFBUUE7U0FBQztRQTZHMUQsdURBQXVEO2FBQ3RDcUQsbUJBQW1CO1lBQ2xDLElBQUl6RCx5REFBT0EsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNuQixJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLE1BQU0sR0FBRztZQUN0QixJQUFJQSx5REFBT0EsQ0FBQyxNQUFNLEdBQUcsS0FBUyxlQUFlO1NBQzlDO2FBQ2dCOEQsZ0JBQWdCLElBQUssOEJBQThCOztRQS9HbEUsSUFBSSxDQUFDb0IsUUFBUSxHQUFHLElBQUksZ0RBQWdEO0lBQ3RFO0FBOE1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHM/MGNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQaHlzaWNzIHN5c3RlbSBmb3IgaGFuZGxpbmcgbW92ZW1lbnQgcGh5c2ljc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIGFzIEJhc2VQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuXG5leHBvcnQgY2xhc3MgUGh5c2ljc1N5c3RlbSBleHRlbmRzIEJhc2VQaHlzaWNzU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIE1vdmVtZW50XTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxNTsgLy8gUnVuIGFmdGVyIGNvbnRyb2wgc3lzdGVtIGJ1dCBiZWZvcmUgcmVuZGVyaW5nXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHJ1bnMgZXZlcnkgZnJhbWUgZm9yIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXNcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcblxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBjb21wb25lbnRzIGFyZSBtaXNzaW5nXG4gICAgICBpZiAoIXRyYW5zZm9ybSB8fCAhbW92ZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIW1vdmVtZW50LmVuYWJsZWQgfHwgIW1vdmVtZW50LmNhbk1vdmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBkZWJ1ZmYgc3RhdGVzIChmcm96ZW4sIHNsb3dlZCwgZXRjLilcbiAgICAgIGlmICh0eXBlb2YgbW92ZW1lbnQudXBkYXRlRGVidWZmcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb3ZlbWVudC51cGRhdGVEZWJ1ZmZzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBNb3ZlbWVudCBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVEZWJ1ZmZzIG1ldGhvZDonLCBtb3ZlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlTW92ZW1lbnQodHJhbnNmb3JtLCBtb3ZlbWVudCwgZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG5cbiAgICAgIC8vIFNraXAgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbWlzc2luZ1xuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIW1vdmVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFtb3ZlbWVudC5lbmFibGVkIHx8ICFtb3ZlbWVudC5jYW5Nb3ZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGx5UGh5c2ljcyh0cmFuc2Zvcm0sIG1vdmVtZW50LCBmaXhlZERlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNb3ZlbWVudCh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB2ZWxvY2l0eVxuICAgIGNvbnN0IGRlbHRhUG9zaXRpb24gPSBtb3ZlbWVudC52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHBvdGVudGlhbCBuZXcgcG9zaXRpb25cbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0cmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICBjb25zdCBwb3RlbnRpYWxQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpLmFkZChkZWx0YVBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBBcHBseSBtYXAgYm91bmRhcnkgY29uc3RyYWludHMgd2l0aCBzbW9vdGggc2xpZGluZyAocmFkaXVzIG9mIDI5IHVuaXRzIGZyb20gb3JpZ2luKVxuICAgIGNvbnN0IE1BUF9SQURJVVMgPSAyOTtcbiAgICBcbiAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZIGZvciBib3VuZGFyeSlcbiAgICBjb25zdCBob3Jpem9udGFsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhwb3RlbnRpYWxQb3NpdGlvbi54LCAwLCBwb3RlbnRpYWxQb3NpdGlvbi56KTtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBob3Jpem9udGFsUG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHBpbGxhciBjb2xsaXNpb25zIGZpcnN0XG4gICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihwb3RlbnRpYWxQb3NpdGlvbik7XG4gICAgXG4gICAgaWYgKGRpc3RhbmNlRnJvbUNlbnRlciA+PSBNQVBfUkFESVVTKSB7XG4gICAgICAvLyBJZiB3ZSBoaXQgdGhlIGJvdW5kYXJ5LCBjYWxjdWxhdGUgdGFuZ2VudCBtb3ZlbWVudCBmb3Igc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IGN1cnJlbnRIb3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMoY3VycmVudFBvc2l0aW9uLngsIDAsIGN1cnJlbnRQb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHRvQ2VudGVyID0gY3VycmVudEhvcml6b250YWxQb3MuY2xvbmUoKS5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIHJhZGl1cylcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgVmVjdG9yMygtdG9DZW50ZXIueiwgMCwgdG9DZW50ZXIueCk7XG4gICAgICBcbiAgICAgIC8vIFByb2plY3Qgb3VyIGhvcml6b250YWwgbW92ZW1lbnQgb250byB0aGUgdGFuZ2VudFxuICAgICAgY29uc3QgaG9yaXpvbnRhbE1vdmVtZW50ID0gbmV3IFZlY3RvcjMoZGVsdGFQb3NpdGlvbi54LCAwLCBkZWx0YVBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcihob3Jpem9udGFsTW92ZW1lbnQuZG90KHRhbmdlbnQpKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgdGhlIHRhbmdlbnRpYWwgbW92ZW1lbnQgd2hpbGUga2VlcGluZyBkaXN0YW5jZSB0byBjZW50ZXIgY29uc3RhbnRcbiAgICAgIGNvbnN0IG5ld0hvcml6b250YWxQb3NpdGlvbiA9IGN1cnJlbnRIb3Jpem9udGFsUG9zLmFkZCh0YW5nZW50TW92ZW1lbnQpO1xuICAgICAgbmV3SG9yaXpvbnRhbFBvc2l0aW9uLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKE1BUF9SQURJVVMpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcG9zaXRpb24gd2l0aCB0YW5nZW50IG1vdmVtZW50IGFuZCBwcmVzZXJ2ZSBZIG1vdmVtZW50XG4gICAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24oXG4gICAgICAgIG5ld0hvcml6b250YWxQb3NpdGlvbi54LCBcbiAgICAgICAgY3VycmVudFBvc2l0aW9uLnkgKyBkZWx0YVBvc2l0aW9uLnksIC8vIEFsbG93IHZlcnRpY2FsIG1vdmVtZW50IChqdW1waW5nLCBmYWxsaW5nKVxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24uelxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgIC8vIEhhbmRsZSBwaWxsYXIgY29sbGlzaW9uIHdpdGggc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uLCBkZWx0YVBvc2l0aW9uLCBwaWxsYXJDb2xsaXNpb24pO1xuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKHNsaWRlUG9zaXRpb24ueCwgc2xpZGVQb3NpdGlvbi55LCBzbGlkZVBvc2l0aW9uLnopO1xuICAgICAgXG4gICAgICAvLyBSZWR1Y2UgdmVsb2NpdHkgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGlsbGFyIHRvIHByZXZlbnQgYm91bmNpbmdcbiAgICAgIGNvbnN0IHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50ID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IocGlsbGFyQ29sbGlzaW9uLm5vcm1hbCk7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS5zdWIodmVsb2NpdHlOb3JtYWxDb21wb25lbnQubXVsdGlwbHlTY2FsYXIoMC41KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdpdGhpbiBib3VuZHMgYW5kIG5vIHBpbGxhciBjb2xsaXNpb24sIG1vdmUgbm9ybWFsbHlcbiAgICAgIHRyYW5zZm9ybS50cmFuc2xhdGUoZGVsdGFQb3NpdGlvbi54LCBkZWx0YVBvc2l0aW9uLnksIGRlbHRhUG9zaXRpb24ueik7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0cmFuc2Zvcm0gbWF0cml4IGFzIG5lZWRpbmcgdXBkYXRlXG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uOiBWZWN0b3IzLCBkZWx0YVBvc2l0aW9uOiBWZWN0b3IzLCBjb2xsaXNpb246IHsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSk6IFZlY3RvcjMge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFuZ2VudCB2ZWN0b3IgKHBlcnBlbmRpY3VsYXIgdG8gbm9ybWFsIGluIFhaIHBsYW5lKVxuICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgVmVjdG9yMygtY29sbGlzaW9uLm5vcm1hbC56LCAwLCBjb2xsaXNpb24ubm9ybWFsLngpO1xuICAgIFxuICAgIC8vIFByb2plY3QgdGhlIG1vdmVtZW50IHZlY3RvciBvbnRvIHRoZSB0YW5nZW50IGZvciBzbGlkaW5nXG4gICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gZGVsdGFQb3NpdGlvbi5jbG9uZSgpLnByb2plY3RPblZlY3Rvcih0YW5nZW50KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwb3NpdGlvbiB3aXRoIHNsaWRpbmcgbW92ZW1lbnRcbiAgICBjb25zdCBzbGlkZVBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uLmNsb25lKCkuYWRkKHRhbmdlbnRNb3ZlbWVudCk7XG4gICAgXG4gICAgLy8gRW5zdXJlIHdlIG1haW50YWluIG1pbmltdW0gZGlzdGFuY2UgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKGNvbGxpc2lvbi5waWxsYXJDZW50ZXIueCwgMCwgY29sbGlzaW9uLnBpbGxhckNlbnRlci56KTtcbiAgICBjb25zdCBzbGlkZUhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhzbGlkZVBvc2l0aW9uLngsIDAsIHNsaWRlUG9zaXRpb24ueik7XG4gICAgY29uc3QgZGlzdGFuY2VBZnRlclNsaWRlID0gc2xpZGVIb3Jpem9udGFsLmRpc3RhbmNlVG8ocGlsbGFySG9yaXpvbnRhbCk7XG4gICAgXG4gICAgaWYgKGRpc3RhbmNlQWZ0ZXJTbGlkZSA8IHRoaXMuUElMTEFSX1JBRElVUykge1xuICAgICAgLy8gUHVzaCB0aGUgcG9zaXRpb24gdG8gbWFpbnRhaW4gbWluaW11bSBkaXN0YW5jZVxuICAgICAgY29uc3QgcHVzaERpcmVjdGlvbiA9IHNsaWRlSG9yaXpvbnRhbC5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgIGlmIChwdXNoRGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHB1c2hEaXJlY3Rpb24uc2V0KDEsIDAsIDApOyAvLyBEZWZhdWx0IGRpcmVjdGlvblxuICAgICAgfVxuICAgICAgY29uc3QgY29ycmVjdGVkSG9yaXpvbnRhbCA9IHBpbGxhckhvcml6b250YWwuY2xvbmUoKS5hZGQocHVzaERpcmVjdGlvbi5tdWx0aXBseVNjYWxhcih0aGlzLlBJTExBUl9SQURJVVMpKTtcbiAgICAgIHNsaWRlUG9zaXRpb24ueCA9IGNvcnJlY3RlZEhvcml6b250YWwueDtcbiAgICAgIHNsaWRlUG9zaXRpb24ueiA9IGNvcnJlY3RlZEhvcml6b250YWwuejtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNsaWRlUG9zaXRpb247XG4gIH1cblxuICBwcml2YXRlIGFwcGx5UGh5c2ljcyh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEFwcGx5IGdyYXZpdHkgKG9ubHkgYWZmZWN0cyBZIHZlbG9jaXR5KVxuICAgIG1vdmVtZW50LmFwcGx5R3Jhdml0eShkZWx0YVRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIGhvcml6b250YWwgbW92ZW1lbnQgZGlyZWN0bHkgZm9yIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIGlmIChtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoID4gMCkge1xuICAgICAgLy8gVXNlIGVmZmVjdGl2ZSBtYXggc3BlZWQgd2hpY2ggYWNjb3VudHMgZm9yIGZyb3plbi9zbG93ZWQgc3RhdGVzXG4gICAgICBjb25zdCBlZmZlY3RpdmVNYXhTcGVlZCA9IG1vdmVtZW50LmdldEVmZmVjdGl2ZU1heFNwZWVkKCk7XG4gICAgICBcbiAgICAgIC8vIERpcmVjdCB2ZWxvY2l0eSBzZXR0aW5nIGZvciByZXNwb25zaXZlIG1vdmVtZW50XG4gICAgICBjb25zdCB0YXJnZXRWZWxvY2l0eSA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb24uY2xvbmUoKTtcbiAgICAgIHRhcmdldFZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKGVmZmVjdGl2ZU1heFNwZWVkICogbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCk7XG4gICAgICBcbiAgICAgIC8vIFNldCBob3Jpem9udGFsIHZlbG9jaXR5IGRpcmVjdGx5IChwcmVzZXJ2ZSBZIHZlbG9jaXR5IGZvciBncmF2aXR5L2p1bXBpbmcpXG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS54ID0gdGFyZ2V0VmVsb2NpdHkueDtcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnogPSB0YXJnZXRWZWxvY2l0eS56O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBpbnB1dCAtIHN0b3AgaG9yaXpvbnRhbCBtb3ZlbWVudCBpbW1lZGlhdGVseSBmb3IgcmVzcG9uc2l2ZSBjb250cm9sc1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueCA9IDA7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS56ID0gMDtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhbnkgYWRkaXRpb25hbCBmb3JjZXMgKGxpa2Uga25vY2tiYWNrLCB3aW5kLCBldGMuKVxuICAgIG1vdmVtZW50LnZlbG9jaXR5LmFkZChtb3ZlbWVudC5hY2NlbGVyYXRpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpKTtcblxuICAgIC8vIFJlc2V0IGFjY2VsZXJhdGlvbiBmb3IgbmV4dCBmcmFtZVxuICAgIG1vdmVtZW50LmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG5cbiAgICAvLyBTaW1wbGUgZ3JvdW5kIGNoZWNrIChZID0gMCBpcyBncm91bmQgbGV2ZWwsIGFjY291bnQgZm9yIHNwaGVyZSByYWRpdXMpXG4gICAgY29uc3Qgc3BoZXJlUmFkaXVzID0gMC41OyAvLyBQbGF5ZXIgc3BoZXJlIHJhZGl1c1xuICAgIGNvbnN0IGdyb3VuZExldmVsID0gc3BoZXJlUmFkaXVzOyAvLyBTcGhlcmUgY2VudGVyIHNob3VsZCBiZSBhdCByYWRpdXMgaGVpZ2h0IGFib3ZlIGdyb3VuZFxuICAgIFxuICAgIGlmICh0cmFuc2Zvcm0ucG9zaXRpb24ueSA8PSBncm91bmRMZXZlbCAmJiBtb3ZlbWVudC52ZWxvY2l0eS55IDw9IDApIHtcbiAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gZ3JvdW5kTGV2ZWw7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS55ID0gMDtcbiAgICAgIG1vdmVtZW50LmlzR3JvdW5kZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlbWVudC5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlBoeXNpY3NTeXN0ZW0iLCJCYXNlUGh5c2ljc1N5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJtb3ZlbWVudCIsImVuYWJsZWQiLCJjYW5Nb3ZlIiwidXBkYXRlRGVidWZmcyIsImNvbnNvbGUiLCJ3YXJuIiwidXBkYXRlTW92ZW1lbnQiLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwiYXBwbHlQaHlzaWNzIiwiZGVsdGFQb3NpdGlvbiIsInZlbG9jaXR5IiwiY2xvbmUiLCJtdWx0aXBseVNjYWxhciIsImN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwicG90ZW50aWFsUG9zaXRpb24iLCJhZGQiLCJNQVBfUkFESVVTIiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwieCIsInoiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJsZW5ndGgiLCJwaWxsYXJDb2xsaXNpb24iLCJjaGVja1BpbGxhckNvbGxpc2lvbiIsImN1cnJlbnRIb3Jpem9udGFsUG9zIiwidG9DZW50ZXIiLCJub3JtYWxpemUiLCJ0YW5nZW50IiwiaG9yaXpvbnRhbE1vdmVtZW50IiwidGFuZ2VudE1vdmVtZW50IiwiZG90IiwibmV3SG9yaXpvbnRhbFBvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJ5IiwiaGFzQ29sbGlzaW9uIiwic2xpZGVQb3NpdGlvbiIsImNhbGN1bGF0ZVBpbGxhclNsaWRpbmciLCJ2ZWxvY2l0eU5vcm1hbENvbXBvbmVudCIsInByb2plY3RPblZlY3RvciIsIm5vcm1hbCIsInN1YiIsInRyYW5zbGF0ZSIsIm1hdHJpeE5lZWRzVXBkYXRlIiwicGlsbGFyUG9zIiwiUElMTEFSX1BPU0lUSU9OUyIsImhvcml6b250YWxQb3MiLCJwaWxsYXJIb3Jpem9udGFsIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiUElMTEFSX1JBRElVUyIsInNldCIsInBpbGxhckNlbnRlciIsImNvbGxpc2lvbiIsInNsaWRlSG9yaXpvbnRhbCIsImRpc3RhbmNlQWZ0ZXJTbGlkZSIsInB1c2hEaXJlY3Rpb24iLCJjb3JyZWN0ZWRIb3Jpem9udGFsIiwiYXBwbHlHcmF2aXR5IiwiaW5wdXRTdHJlbmd0aCIsImVmZmVjdGl2ZU1heFNwZWVkIiwiZ2V0RWZmZWN0aXZlTWF4U3BlZWQiLCJ0YXJnZXRWZWxvY2l0eSIsIm1vdmVEaXJlY3Rpb24iLCJhY2NlbGVyYXRpb24iLCJzcGhlcmVSYWRpdXMiLCJncm91bmRMZXZlbCIsImlzR3JvdW5kZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/PhysicsSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ProjectileSystem.ts":
/*!*****************************************!*\
  !*** ./src/systems/ProjectileSystem.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectileSystem: function() { return /* binding */ ProjectileSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Projectile system for handling projectile movement and collisions\n\n\n\n\n\n\n\n\nclass ProjectileSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    update(entities, deltaTime) {\n        this.projectilesToDestroy.length = 0;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n            if (!transform.enabled || !projectile.enabled) {\n                continue;\n            }\n            // Update projectile\n            projectile.update(deltaTime);\n            // Check if projectile has expired\n            if (projectile.isExpired()) {\n                this.projectilesToDestroy.push(entity.id);\n                continue;\n            }\n            // Move projectile\n            this.moveProjectile(transform, projectile, deltaTime);\n            // Arrow orientation is set once at creation - no need to update every frame\n            // this.updateArrowOrientation(entity, projectile);\n            // Check collisions\n            this.checkCollisions(entity, transform, projectile);\n            // Check world boundaries\n            this.checkWorldBounds(entity, transform);\n        }\n        // Destroy expired projectiles\n        for (const entityId of this.projectilesToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    moveProjectile(transform, projectile, deltaTime) {\n        // Use temp vector to avoid allocations\n        this.tempVector.copy(projectile.velocity).multiplyScalar(deltaTime);\n        // Update position\n        transform.translate(this.tempVector.x, this.tempVector.y, this.tempVector.z);\n        transform.matrixNeedsUpdate = true;\n    }\n    checkCollisions(projectileEntity, transform, projectile) {\n        const projectilePos = transform.position;\n        // Get all entities that could be hit - specifically look for enemies with colliders\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        // Early exit if no targets\n        if (potentialTargets.length === 0) return;\n        for (const target of potentialTargets){\n            // Skip self and owner\n            if (target.id === projectileEntity.id || target.id === projectile.owner) {\n                // Debug logging for owner collision prevention\n                if (target.id === projectile.owner) {\n                // console.log(`🚫 Projectile ${projectileEntity.id} skipping owner ${projectile.owner} (target ${target.id})`);\n                }\n                continue;\n            }\n            // Skip if already hit and not piercing\n            if (!projectile.canHitTarget(target.id)) {\n                continue;\n            }\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            // Skip if target is dead\n            if (targetHealth.isDead) {\n                continue;\n            }\n            // Check if projectile can hit this target (layer-based collision)\n            // In PVP mode, projectiles can hit both ENEMY (remote players) and PLAYER (local player) layers\n            if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER) {\n                continue;\n            }\n            // Additional safety check: prevent projectiles from hitting their owner in PVP mode\n            // This is a backup check in case the owner comparison above fails\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && target.id === projectile.owner) {\n                continue;\n            }\n            const targetPos = targetTransform.getWorldPosition();\n            // Use collider radius for more accurate collision detection\n            const projectileRadius = 0.2; // Increased from 0.1 for more forgiving collision detection\n            const targetRadius = targetCollider.radius;\n            // Use squared distance for performance (avoid sqrt)\n            const distanceSquared = projectilePos.distanceToSquared(targetPos);\n            const collisionRadiusSquared = (projectileRadius + targetRadius) ** 2;\n            if (distanceSquared <= collisionRadiusSquared) {\n                this.handleHit(projectileEntity, target, projectile, targetHealth);\n                // If not piercing, destroy projectile\n                if (!projectile.piercing) {\n                    this.projectilesToDestroy.push(projectileEntity.id);\n                    break;\n                }\n            }\n        }\n    }\n    handleHit(projectileEntity, target, projectile, targetHealth) {\n        // Mark target as hit\n        projectile.addHitTarget(target.id);\n        // Deal damage through combat system if available, otherwise directly\n        if (this.combatSystem) {\n            var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n            // Check projectile type for special damage handling\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            const isCrossentropyBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isCrossentropyBolt;\n            const isEntropicBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.isEntropicBolt;\n            let damageType = \"projectile\";\n            if (isCrossentropyBolt) {\n                damageType = \"crossentropy\";\n            } else if (isEntropicBolt) {\n                damageType = \"entropic\";\n            }\n            this.combatSystem.queueDamage(target, projectile.damage, projectileEntity, damageType);\n        } else {\n            // Fallback to direct damage (pass entity for shield absorption)\n            const currentTime = Date.now() / 1000;\n            const damageDealt = targetHealth.takeDamage(projectile.damage, currentTime, target);\n        }\n        // Handle explosion if explosive\n        if (projectile.explosionRadius > 0) {\n            this.handleExplosion(projectileEntity, projectile);\n        }\n    }\n    handleExplosion(projectileEntity, projectile) {\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const explosionCenter = projectileTransform.position;\n        // Emit explosion event for visual effects\n        this.world.emitEvent(\"explosion\", {\n            position: explosionCenter.clone(),\n            color: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(\"#00ff44\"),\n            size: projectile.explosionRadius,\n            duration: 0.5\n        });\n        // Find all entities within explosion radius\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const target of potentialTargets){\n            if (target.id === projectile.owner) continue; // Don't damage owner\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const distance = explosionCenter.distanceTo(targetTransform.position);\n            if (distance <= projectile.explosionRadius) {\n                // Calculate damage falloff based on distance\n                const damageFalloff = 1 - distance / projectile.explosionRadius;\n                const explosionDamage = Math.floor(projectile.damage * damageFalloff);\n                if (explosionDamage > 0) {\n                    const currentTime = Date.now() / 1000;\n                    targetHealth.takeDamage(explosionDamage, currentTime, target);\n                }\n            }\n        }\n    }\n    checkWorldBounds(entity, transform) {\n        const pos = transform.position;\n        const maxDistance = 40; // Maximum distance from origin\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Check if projectile is too far from origin (using squared distance)\n        if (pos.lengthSq() > maxDistanceSquared) {\n            this.projectilesToDestroy.push(entity.id);\n            return; // Early exit\n        }\n        // Check if projectile is below ground (simple ground check)\n        if (pos.y < -10) {\n            this.projectilesToDestroy.push(entity.id);\n        }\n    }\n    // Utility method to create a ChargedArrow projectile for fully charged bow\n    createChargedArrowProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with charged arrow-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 35; // Faster than regular arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 25; // Higher damage than regular arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for ChargedArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a ChargedArrow for special handling\n        placeholderMesh.userData.isChargedArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        return projectileEntity;\n    }\n    // Utility method to create a CrossentropyBolt projectile for scythe\n    createCrossentropyBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with scythe-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Slower than arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 30; // Higher damage than arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for CrossentropyBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.28, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a CrossentropyBolt for special handling\n        placeholderMesh.userData.isCrossentropyBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n            console.warn(\"⚠️ Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create an EntropicBolt projectile for scythe left click\n    createEntropicBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with EntropicBolt-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Faster than CrossentropyBolt\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 20; // EntropicBolt damage\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 1.75; // Shorter lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for EntropicBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 6, 6);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 0,\n            transparent: true,\n            opacity: 0 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as an EntropicBolt for special handling\n        placeholderMesh.userData.isEntropicBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n            console.warn(\"⚠️ Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create a projectile\n    createProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20;\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 5; // Set default damage to 5 as requested\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 2;\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        projectile.setStartPosition(position);\n        // Set max distance if specified (for bow arrows)\n        if ((config === null || config === void 0 ? void 0 : config.maxDistance) !== undefined) {\n            projectile.setMaxDistance(config.maxDistance);\n        }\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for RegularArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a RegularArrow for special handling\n        placeholderMesh.userData.isRegularArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false); // Projectiles don't need to cast shadows\n        } else {\n            console.warn(\"⚠️ Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        // Notify systems that the entity is ready (this will trigger RenderSystem.onEntityAdded)\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Get pool statistics for debugging\n    getPoolStats() {\n        return {\n            vector3: this.vector3Pool.getPoolSize()\n        };\n    }\n    // Dispose of all pools when system is destroyed\n    onDisable() {\n        console.log(\"\\uD83E\\uDDF9 Cleaning up ProjectileSystem pools:\", this.getPoolStats());\n        this.vector3Pool.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ];\n        this.combatSystem = null;\n        this.projectilesToDestroy = [];\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 20; // Run after movement\n        // Initialize vector pool for calculations\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_7__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 100);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FO0FBQytCO0FBQzdEO0FBRWlCO0FBQ0U7QUFDUjtBQUNJO0FBQ2dCO0FBR3JCO0FBTXpDLE1BQU1hLHlCQUF5QlIsK0NBQU1BO0lBOEJuQ1MsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQ0Msb0JBQW9CLENBQUNDLE1BQU0sR0FBRztRQUVuQyxLQUFLLE1BQU1DLFVBQVVKLFNBQVU7WUFDN0IsTUFBTUssWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixhQUFhSCxPQUFPRSxZQUFZLENBQUNoQixrRUFBVUE7WUFFakQsSUFBSSxDQUFDZSxVQUFVRyxPQUFPLElBQUksQ0FBQ0QsV0FBV0MsT0FBTyxFQUFFO2dCQUM3QztZQUNGO1lBRUEsb0JBQW9CO1lBQ3BCRCxXQUFXUixNQUFNLENBQUNFO1lBRWxCLGtDQUFrQztZQUNsQyxJQUFJTSxXQUFXRSxTQUFTLElBQUk7Z0JBQzFCLElBQUksQ0FBQ1Asb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtnQkFDeEM7WUFDRjtZQUVBLGtCQUFrQjtZQUNsQixJQUFJLENBQUNDLGNBQWMsQ0FBQ1AsV0FBV0UsWUFBWU47WUFFM0MsNEVBQTRFO1lBQzVFLG1EQUFtRDtZQUVuRCxtQkFBbUI7WUFDbkIsSUFBSSxDQUFDWSxlQUFlLENBQUNULFFBQVFDLFdBQVdFO1lBRXhDLHlCQUF5QjtZQUN6QixJQUFJLENBQUNPLGdCQUFnQixDQUFDVixRQUFRQztRQUNoQztRQUVBLDhCQUE4QjtRQUM5QixLQUFLLE1BQU1VLFlBQVksSUFBSSxDQUFDYixvQkFBb0IsQ0FBRTtZQUNoRCxJQUFJLENB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QkFBcUI7UUFJekMsMENBQTBDO1FBQzFDLElBQUksQ0FBQ1IsV0FBVyxHQUFHLElBQUlqSSx5REFBVUEsQ0FDL0IsSUFBTSxJQUFJWix5REFBT0EsSUFDakIsQ0FBQ3NKLFNBQVdBLE9BQU9DLEdBQUcsQ0FBQyxHQUFHLEdBQUcsSUFDN0I7SUFFSjtBQXFpQkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvUHJvamVjdGlsZVN5c3RlbS50cz8wMGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2plY3RpbGUgc3lzdGVtIGZvciBoYW5kbGluZyBwcm9qZWN0aWxlIG1vdmVtZW50IGFuZCBjb2xsaXNpb25zXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgU3BoZXJlR2VvbWV0cnksIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJ0AvZWNzL1N5c3RlbSc7XG5pbXBvcnQgeyBFbnRpdHkgfSBmcm9tICdAL2Vjcy9FbnRpdHknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0nO1xuaW1wb3J0IHsgUHJvamVjdGlsZSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUHJvamVjdGlsZSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgV29ybGQgfSBmcm9tICdAL2Vjcy9Xb3JsZCc7XG5pbXBvcnQgeyBPYmplY3RQb29sIH0gZnJvbSAnQC91dGlscy9PYmplY3RQb29sJztcblxuaW1wb3J0IHsgV2VhcG9uU3ViY2xhc3MgfSBmcm9tICdAL2NvbXBvbmVudHMvZHJhZ29uL3dlYXBvbnMnO1xuaW1wb3J0IHsgQ29tYmF0U3lzdGVtIH0gZnJvbSAnLi9Db21iYXRTeXN0ZW0nO1xuaW1wb3J0IENyb3NzZW50cm9weUJvbHQgZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0Nyb3NzZW50cm9weUJvbHQnO1xuXG5leHBvcnQgY2xhc3MgUHJvamVjdGlsZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBQcm9qZWN0aWxlXTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgY29tYmF0U3lzdGVtOiBDb21iYXRTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBwcm9qZWN0aWxlc1RvRGVzdHJveTogbnVtYmVyW10gPSBbXTtcbiAgXG5cbiAgXG4gIC8vIE9iamVjdCBwb29scyBmb3IgcGVyZm9ybWFuY2UgKGtlZXBpbmcgdmVjdG9yIHBvb2wgZm9yIGNhbGN1bGF0aW9ucylcbiAgcHJpdmF0ZSB2ZWN0b3IzUG9vbDogT2JqZWN0UG9vbDxWZWN0b3IzPjtcbiAgXG4gIC8vIFJldXNhYmxlIG9iamVjdHMgdG8gcmVkdWNlIGFsbG9jYXRpb25zXG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyMDsgLy8gUnVuIGFmdGVyIG1vdmVtZW50XG4gICAgXG5cbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHZlY3RvciBwb29sIGZvciBjYWxjdWxhdGlvbnNcbiAgICB0aGlzLnZlY3RvcjNQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiBuZXcgVmVjdG9yMygpLFxuICAgICAgKHZlY3RvcikgPT4gdmVjdG9yLnNldCgwLCAwLCAwKSxcbiAgICAgIDEwMFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29tYmF0U3lzdGVtKGNvbWJhdFN5c3RlbTogQ29tYmF0U3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5jb21iYXRTeXN0ZW0gPSBjb21iYXRTeXN0ZW07XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVzVG9EZXN0cm95Lmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICAgIGNvbnN0IHByb2plY3RpbGUgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhcHJvamVjdGlsZS5lbmFibGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcHJvamVjdGlsZVxuICAgICAgcHJvamVjdGlsZS51cGRhdGUoZGVsdGFUaW1lKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBoYXMgZXhwaXJlZFxuICAgICAgaWYgKHByb2plY3RpbGUuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIHByb2plY3RpbGVcbiAgICAgIHRoaXMubW92ZVByb2plY3RpbGUodHJhbnNmb3JtLCBwcm9qZWN0aWxlLCBkZWx0YVRpbWUpO1xuXG4gICAgICAvLyBBcnJvdyBvcmllbnRhdGlvbiBpcyBzZXQgb25jZSBhdCBjcmVhdGlvbiAtIG5vIG5lZWQgdG8gdXBkYXRlIGV2ZXJ5IGZyYW1lXG4gICAgICAvLyB0aGlzLnVwZGF0ZUFycm93T3JpZW50YXRpb24oZW50aXR5LCBwcm9qZWN0aWxlKTtcblxuICAgICAgLy8gQ2hlY2sgY29sbGlzaW9uc1xuICAgICAgdGhpcy5jaGVja0NvbGxpc2lvbnMoZW50aXR5LCB0cmFuc2Zvcm0sIHByb2plY3RpbGUpO1xuXG4gICAgICAvLyBDaGVjayB3b3JsZCBib3VuZGFyaWVzXG4gICAgICB0aGlzLmNoZWNrV29ybGRCb3VuZHMoZW50aXR5LCB0cmFuc2Zvcm0pO1xuICAgIH1cblxuICAgIC8vIERlc3Ryb3kgZXhwaXJlZCBwcm9qZWN0aWxlc1xuICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveSkge1xuICAgICAgdGhpcy53b3JsZC5kZXN0cm95RW50aXR5KGVudGl0eUlkKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1vdmVQcm9qZWN0aWxlKHRyYW5zZm9ybTogVHJhbnNmb3JtLCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVzZSB0ZW1wIHZlY3RvciB0byBhdm9pZCBhbGxvY2F0aW9uc1xuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHByb2plY3RpbGUudmVsb2NpdHkpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHBvc2l0aW9uXG4gICAgdHJhbnNmb3JtLnRyYW5zbGF0ZSh0aGlzLnRlbXBWZWN0b3IueCwgdGhpcy50ZW1wVmVjdG9yLnksIHRoaXMudGVtcFZlY3Rvci56KTtcbiAgICB0cmFuc2Zvcm0ubWF0cml4TmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cblxuXG4gIHByaXZhdGUgY2hlY2tDb2xsaXNpb25zKHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHByb2plY3RpbGU6IFByb2plY3RpbGUpOiB2b2lkIHtcbiAgICBjb25zdCBwcm9qZWN0aWxlUG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuXG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyB0aGF0IGNvdWxkIGJlIGhpdCAtIHNwZWNpZmljYWxseSBsb29rIGZvciBlbmVtaWVzIHdpdGggY29sbGlkZXJzXG4gICAgY29uc3QgcG90ZW50aWFsVGFyZ2V0cyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBIZWFsdGgsIENvbGxpZGVyXSk7XG5cbiAgICAvLyBFYXJseSBleGl0IGlmIG5vIHRhcmdldHNcbiAgICBpZiAocG90ZW50aWFsVGFyZ2V0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHBvdGVudGlhbFRhcmdldHMpIHtcbiAgICAgIC8vIFNraXAgc2VsZiBhbmQgb3duZXJcbiAgICAgIGlmICh0YXJnZXQuaWQgPT09IHByb2plY3RpbGVFbnRpdHkuaWQgfHwgdGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIG93bmVyIGNvbGxpc2lvbiBwcmV2ZW50aW9uXG4gICAgICAgIGlmICh0YXJnZXQuaWQgPT09IHByb2plY3RpbGUub3duZXIpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+aqyBQcm9qZWN0aWxlICR7cHJvamVjdGlsZUVudGl0eS5pZH0gc2tpcHBpbmcgb3duZXIgJHtwcm9qZWN0aWxlLm93bmVyfSAodGFyZ2V0ICR7dGFyZ2V0LmlkfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGhpdCBhbmQgbm90IHBpZXJjaW5nXG4gICAgICBpZiAoIXByb2plY3RpbGUuY2FuSGl0VGFyZ2V0KHRhcmdldC5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKSE7XG4gICAgICBcbiAgICAgIC8vIFNraXAgaWYgdGFyZ2V0IGlzIGRlYWRcbiAgICAgIGlmICh0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGNhbiBoaXQgdGhpcyB0YXJnZXQgKGxheWVyLWJhc2VkIGNvbGxpc2lvbilcbiAgICAgIC8vIEluIFBWUCBtb2RlLCBwcm9qZWN0aWxlcyBjYW4gaGl0IGJvdGggRU5FTVkgKHJlbW90ZSBwbGF5ZXJzKSBhbmQgUExBWUVSIChsb2NhbCBwbGF5ZXIpIGxheWVyc1xuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyICE9PSBDb2xsaXNpb25MYXllci5FTkVNWSAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRpdGlvbmFsIHNhZmV0eSBjaGVjazogcHJldmVudCBwcm9qZWN0aWxlcyBmcm9tIGhpdHRpbmcgdGhlaXIgb3duZXIgaW4gUFZQIG1vZGVcbiAgICAgIC8vIFRoaXMgaXMgYSBiYWNrdXAgY2hlY2sgaW4gY2FzZSB0aGUgb3duZXIgY29tcGFyaXNvbiBhYm92ZSBmYWlsc1xuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVIgJiYgdGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYPCfmqsgRXh0cmEgc2FmZXR5OiBQcm9qZWN0aWxlICR7cHJvamVjdGlsZUVudGl0eS5pZH0gcHJldmVudGVkIGZyb20gaGl0dGluZyBvd25lciAke3Byb2plY3RpbGUub3duZXJ9IChQVlAgbW9kZSlgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRhcmdldFRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG5cbiAgICAgIC8vIFVzZSBjb2xsaWRlciByYWRpdXMgZm9yIG1vcmUgYWNjdXJhdGUgY29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgY29uc3QgcHJvamVjdGlsZVJhZGl1cyA9IDAuMjsgLy8gSW5jcmVhc2VkIGZyb20gMC4xIGZvciBtb3JlIGZvcmdpdmluZyBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICBjb25zdCB0YXJnZXRSYWRpdXMgPSB0YXJnZXRDb2xsaWRlci5yYWRpdXM7XG5cbiAgICAgIC8vIFVzZSBzcXVhcmVkIGRpc3RhbmNlIGZvciBwZXJmb3JtYW5jZSAoYXZvaWQgc3FydClcbiAgICAgIGNvbnN0IGRpc3RhbmNlU3F1YXJlZCA9IHByb2plY3RpbGVQb3MuZGlzdGFuY2VUb1NxdWFyZWQodGFyZ2V0UG9zKTtcbiAgICAgIGNvbnN0IGNvbGxpc2lvblJhZGl1c1NxdWFyZWQgPSAocHJvamVjdGlsZVJhZGl1cyArIHRhcmdldFJhZGl1cykgKiogMjtcbiAgICAgIFxuICAgICAgaWYgKGRpc3RhbmNlU3F1YXJlZCA8PSBjb2xsaXNpb25SYWRpdXNTcXVhcmVkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSGl0KHByb2plY3RpbGVFbnRpdHksIHRhcmdldCwgcHJvamVjdGlsZSwgdGFyZ2V0SGVhbHRoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIG5vdCBwaWVyY2luZywgZGVzdHJveSBwcm9qZWN0aWxlXG4gICAgICAgIGlmICghcHJvamVjdGlsZS5waWVyY2luZykge1xuICAgICAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChwcm9qZWN0aWxlRW50aXR5LmlkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlSGl0KFxuICAgIHByb2plY3RpbGVFbnRpdHk6IEVudGl0eSwgXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIHByb2plY3RpbGU6IFByb2plY3RpbGUsIFxuICAgIHRhcmdldEhlYWx0aDogSGVhbHRoXG4gICk6IHZvaWQge1xuICAgIC8vIE1hcmsgdGFyZ2V0IGFzIGhpdFxuICAgIHByb2plY3RpbGUuYWRkSGl0VGFyZ2V0KHRhcmdldC5pZCk7XG5cbiAgICAvLyBEZWFsIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZGlyZWN0bHlcbiAgICBpZiAodGhpcy5jb21iYXRTeXN0ZW0pIHtcbiAgICAgIC8vIENoZWNrIHByb2plY3RpbGUgdHlwZSBmb3Igc3BlY2lhbCBkYW1hZ2UgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgY29uc3QgaXNDcm9zc2VudHJvcHlCb2x0ID0gcmVuZGVyZXI/Lm1lc2g/LnVzZXJEYXRhPy5pc0Nyb3NzZW50cm9weUJvbHQ7XG4gICAgICBjb25zdCBpc0VudHJvcGljQm9sdCA9IHJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNFbnRyb3BpY0JvbHQ7XG4gICAgICBcbiAgICAgIGxldCBkYW1hZ2VUeXBlID0gJ3Byb2plY3RpbGUnO1xuICAgICAgaWYgKGlzQ3Jvc3NlbnRyb3B5Qm9sdCkge1xuICAgICAgICBkYW1hZ2VUeXBlID0gJ2Nyb3NzZW50cm9weSc7XG4gICAgICB9IGVsc2UgaWYgKGlzRW50cm9waWNCb2x0KSB7XG4gICAgICAgIGRhbWFnZVR5cGUgPSAnZW50cm9waWMnO1xuICAgICAgfVxuICAgICAgXG5cbiAgICAgIFxuICAgICAgdGhpcy5jb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCBwcm9qZWN0aWxlLmRhbWFnZSwgcHJvamVjdGlsZUVudGl0eSwgZGFtYWdlVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCBkYW1hZ2UgKHBhc3MgZW50aXR5IGZvciBzaGllbGQgYWJzb3JwdGlvbilcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBjb25zdCBkYW1hZ2VEZWFsdCA9IHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKHByb2plY3RpbGUuZGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICAgIFxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBleHBsb3Npb24gaWYgZXhwbG9zaXZlXG4gICAgaWYgKHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzID4gMCkge1xuICAgICAgdGhpcy5oYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eSwgcHJvamVjdGlsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eTogRW50aXR5LCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKTogdm9pZCB7XG4gICAgY29uc3QgcHJvamVjdGlsZVRyYW5zZm9ybSA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IGV4cGxvc2lvbkNlbnRlciA9IHByb2plY3RpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG5cbiAgICAvLyBFbWl0IGV4cGxvc2lvbiBldmVudCBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICB0aGlzLndvcmxkLmVtaXRFdmVudCgnZXhwbG9zaW9uJywge1xuICAgICAgcG9zaXRpb246IGV4cGxvc2lvbkNlbnRlci5jbG9uZSgpLFxuICAgICAgY29sb3I6IG5ldyBDb2xvcignIzAwZmY0NCcpLFxuICAgICAgc2l6ZTogcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMsXG4gICAgICBkdXJhdGlvbjogMC41XG4gICAgfSk7XG5cbiAgICAvLyBGaW5kIGFsbCBlbnRpdGllcyB3aXRoaW4gZXhwbG9zaW9uIHJhZGl1c1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoXSk7XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSBjb250aW51ZTsgLy8gRG9uJ3QgZGFtYWdlIG93bmVyXG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBleHBsb3Npb25DZW50ZXIuZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRhbWFnZSBmYWxsb2ZmIGJhc2VkIG9uIGRpc3RhbmNlXG4gICAgICAgIGNvbnN0IGRhbWFnZUZhbGxvZmYgPSAxIC0gKGRpc3RhbmNlIC8gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpO1xuICAgICAgICBjb25zdCBleHBsb3Npb25EYW1hZ2UgPSBNYXRoLmZsb29yKHByb2plY3RpbGUuZGFtYWdlICogZGFtYWdlRmFsbG9mZik7XG5cbiAgICAgICAgaWYgKGV4cGxvc2lvbkRhbWFnZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgIHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKGV4cGxvc2lvbkRhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrV29ybGRCb3VuZHMoZW50aXR5OiBFbnRpdHksIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgcG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IG1heERpc3RhbmNlID0gNDA7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW5cbiAgICBjb25zdCBtYXhEaXN0YW5jZVNxdWFyZWQgPSBtYXhEaXN0YW5jZSAqIG1heERpc3RhbmNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBpcyB0b28gZmFyIGZyb20gb3JpZ2luICh1c2luZyBzcXVhcmVkIGRpc3RhbmNlKVxuICAgIGlmIChwb3MubGVuZ3RoU3EoKSA+IG1heERpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICByZXR1cm47IC8vIEVhcmx5IGV4aXRcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGlzIGJlbG93IGdyb3VuZCAoc2ltcGxlIGdyb3VuZCBjaGVjaylcbiAgICBpZiAocG9zLnkgPCAtMTApIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENoYXJnZWRBcnJvdyBwcm9qZWN0aWxlIGZvciBmdWxseSBjaGFyZ2VkIGJvd1xuICBwdWJsaWMgY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBjaGFyZ2VkIGFycm93LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAzNTsgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDI1OyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCA1OyAvLyBMb25nZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBDaGFyZ2VkQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDaGFyZ2VkQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNDaGFyZ2VkQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIFxuICAgIHJlbmRlcmVyLm1lc2ggPSBwbGFjZWhvbGRlck1lc2g7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG5cbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlXG4gIHB1YmxpYyBjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBzY3l0aGUtc3BlY2lmaWMgc2V0dGluZ3NcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDIwOyAvLyBTbG93ZXIgdGhhbiBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDMwOyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gYXJyb3dzXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgMS43NTsgLy8gTG9uZ2VyIGxpZmV0aW1lXG4gICAgcHJvamVjdGlsZS5vd25lciA9IG93bmVySWQ7XG4gICAgcHJvamVjdGlsZS5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIGNvbnN0IHJlbmRlcmVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgcGxhY2Vob2xkZXIgbWVzaCB0aGF0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIFJlYWN0IGNvbXBvbmVudFxuICAgIGNvbnN0IHBsYWNlaG9sZGVyR2VvbWV0cnkgPSBuZXcgU3BoZXJlR2VvbWV0cnkoMC4yOCwgOCwgOCk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNYXRlcmlhbCA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogJyMwMGZmNDQnLFxuICAgICAgZW1pc3NpdmU6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAwLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDcm9zc2VudHJvcHlCb2x0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzQ3Jvc3NlbnRyb3B5Qm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5XG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlIGxlZnQgY2xpY2tcbiAgcHVibGljIGNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUoXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRpcmVjdGlvbjogVmVjdG9yMyxcbiAgICBvd25lcklkOiBudW1iZXIsXG4gICAgY29uZmlnPzoge1xuICAgICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgICBkYW1hZ2U/OiBudW1iZXI7XG4gICAgICBsaWZldGltZT86IG51bWJlcjtcbiAgICAgIHBpZXJjaW5nPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2l2ZT86IGJvb2xlYW47XG4gICAgICBleHBsb3Npb25SYWRpdXM/OiBudW1iZXI7XG4gICAgICBzdWJjbGFzcz86IFdlYXBvblN1YmNsYXNzO1xuICAgICAgbGV2ZWw/OiBudW1iZXI7XG4gICAgICBvcGFjaXR5PzogbnVtYmVyO1xuICAgIH1cbiAgKTogRW50aXR5IHtcbiAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gd29ybGQuY3JlYXRlRW50aXR5KCk7XG5cbiAgICAvLyBBZGQgVHJhbnNmb3JtIGNvbXBvbmVudFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudCh0cmFuc2Zvcm0pO1xuXG4gICAgLy8gQWRkIFByb2plY3RpbGUgY29tcG9uZW50IHdpdGggRW50cm9waWNCb2x0LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAyMDsgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgIHByb2plY3RpbGUuZGFtYWdlID0gY29uZmlnPy5kYW1hZ2UgfHwgMjA7IC8vIEVudHJvcGljQm9sdCBkYW1hZ2VcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fDEuNzU7IC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBFbnRyb3BpY0JvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDYsIDYpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMCxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMCAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGFuIEVudHJvcGljQm9sdCBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5pc0VudHJvcGljQm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG5cbiAgICAvLyBOb3RpZnkgc3lzdGVtcyB0aGF0IHRoZSBlbnRpdHkgaXMgcmVhZHlcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGEgcHJvamVjdGlsZVxuICBwdWJsaWMgY3JlYXRlUHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgICBtYXhEaXN0YW5jZT86IG51bWJlcjtcbiAgICB9XG4gICk6IEVudGl0eSB7XG4gICAgY29uc3QgcHJvamVjdGlsZUVudGl0eSA9IHdvcmxkLmNyZWF0ZUVudGl0eSgpO1xuXG4gICAgLy8gQWRkIFRyYW5zZm9ybSBjb21wb25lbnRcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICB0cmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQodHJhbnNmb3JtKTtcblxuICAgIC8vIEFkZCBQcm9qZWN0aWxlIGNvbXBvbmVudFxuICAgIGNvbnN0IHByb2plY3RpbGUgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUHJvamVjdGlsZSk7XG4gICAgcHJvamVjdGlsZS5zcGVlZCA9IGNvbmZpZz8uc3BlZWQgfHwgMjA7XG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCA1OyAvLyBTZXQgZGVmYXVsdCBkYW1hZ2UgdG8gNSBhcyByZXF1ZXN0ZWRcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCAyO1xuICAgIHByb2plY3RpbGUub3duZXIgPSBvd25lcklkO1xuICAgIHByb2plY3RpbGUuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgcHJvamVjdGlsZS5zZXRTdGFydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBTZXQgbWF4IGRpc3RhbmNlIGlmIHNwZWNpZmllZCAoZm9yIGJvdyBhcnJvd3MpXG4gICAgaWYgKGNvbmZpZz8ubWF4RGlzdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvamVjdGlsZS5zZXRNYXhEaXN0YW5jZShjb25maWcubWF4RGlzdGFuY2UpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoY29uZmlnPy5waWVyY2luZykgcHJvamVjdGlsZS5zZXRQaWVyY2luZyh0cnVlKTtcbiAgICBpZiAoY29uZmlnPy5leHBsb3NpdmUgJiYgY29uZmlnPy5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgIHByb2plY3RpbGUuc2V0RXhwbG9zaXZlKGNvbmZpZy5leHBsb3Npb25SYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChwcm9qZWN0aWxlKTtcblxuICAgIC8vIEFkZCBSZW5kZXJlciBjb21wb25lbnQgLSB3ZSdsbCB1c2UgYSBzcGVjaWFsIG1hcmtlciBmb3IgUmVndWxhckFycm93XG4gICAgY29uc3QgcmVuZGVyZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBwbGFjZWhvbGRlciBtZXNoIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgUmVhY3QgY29tcG9uZW50XG4gICAgY29uc3QgcGxhY2Vob2xkZXJHZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeSgwLjE1LCA4LCA4KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1hdGVyaWFsID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZTogJyNmZmFhMDAnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDMsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIG9wYWNpdHk6IDAuMSAvLyBWZXJ5IGxvdyBvcGFjaXR5IHNpbmNlIFJlYWN0IGNvbXBvbmVudCB3aWxsIGhhbmRsZSB2aXN1YWxzXG4gICAgfSk7XG4gICAgY29uc3QgcGxhY2Vob2xkZXJNZXNoID0gbmV3IE1lc2gocGxhY2Vob2xkZXJHZW9tZXRyeSwgcGxhY2Vob2xkZXJNYXRlcmlhbCk7XG4gICAgXG4gICAgLy8gTWFyayB0aGlzIGFzIGEgUmVndWxhckFycm93IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzUmVndWxhckFycm93ID0gdHJ1ZTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnN1YmNsYXNzID0gY29uZmlnPy5zdWJjbGFzcztcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEubGV2ZWwgPSBjb25maWc/LmxldmVsO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5vcGFjaXR5ID0gY29uZmlnPy5vcGFjaXR5IHx8IDEuMDtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7IC8vIFByb2plY3RpbGVzIGRvbid0IG5lZWQgdG8gY2FzdCBzaGFkb3dzXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG4gICAgXG4gICAgLy8gTm90aWZ5IHN5c3RlbXMgdGhhdCB0aGUgZW50aXR5IGlzIHJlYWR5ICh0aGlzIHdpbGwgdHJpZ2dlciBSZW5kZXJTeXN0ZW0ub25FbnRpdHlBZGRlZClcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cblxuXG4gIC8vIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UG9vbFN0YXRzKCk6IHsgXG4gICAgdmVjdG9yMzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVjdG9yMzogdGhpcy52ZWN0b3IzUG9vbC5nZXRQb29sU2l6ZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8vIERpc3Bvc2Ugb2YgYWxsIHBvb2xzIHdoZW4gc3lzdGVtIGlzIGRlc3Ryb3llZFxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFuaW5nIHVwIFByb2plY3RpbGVTeXN0ZW0gcG9vbHM6JywgdGhpcy5nZXRQb29sU3RhdHMoKSk7XG4gICAgdGhpcy52ZWN0b3IzUG9vbC5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbG9yIiwiU3BoZXJlR2VvbWV0cnkiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsIk1lc2giLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJQcm9qZWN0aWxlIiwiSGVhbHRoIiwiUmVuZGVyZXIiLCJDb2xsaWRlciIsIkNvbGxpc2lvbkxheWVyIiwiT2JqZWN0UG9vbCIsIlByb2plY3RpbGVTeXN0ZW0iLCJzZXRDb21iYXRTeXN0ZW0iLCJjb21iYXRTeXN0ZW0iLCJ1cGRhdGUiLCJlbnRpdGllcyIsImRlbHRhVGltZSIsInByb2plY3RpbGVzVG9EZXN0cm95IiwibGVuZ3RoIiwiZW50aXR5IiwidHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwicHJvamVjdGlsZSIsImVuYWJsZWQiLCJpc0V4cGlyZWQiLCJwdXNoIiwiaWQiLCJtb3ZlUHJvamVjdGlsZSIsImNoZWNrQ29sbGlzaW9ucyIsImNoZWNrV29ybGRCb3VuZHMiLCJlbnRpdHlJZCIsIndvcmxkIiwiZGVzdHJveUVudGl0eSIsInRlbXBWZWN0b3IiLCJjb3B5IiwidmVsb2NpdHkiLCJtdWx0aXBseVNjYWxhciIsInRyYW5zbGF0ZSIsIngiLCJ5IiwieiIsIm1hdHJpeE5lZWRzVXBkYXRlIiwicHJvamVjdGlsZUVudGl0eSIsInByb2plY3RpbGVQb3MiLCJwb3NpdGlvbiIsInBvdGVudGlhbFRhcmdldHMiLCJxdWVyeUVudGl0aWVzIiwidGFyZ2V0Iiwib3duZXIiLCJjYW5IaXRUYXJnZXQiLCJ0YXJnZXRUcmFuc2Zvcm0iLCJ0YXJnZXRIZWFsdGgiLCJ0YXJnZXRDb2xsaWRlciIsImlzRGVhZCIsImxheWVyIiwiRU5FTVkiLCJQTEFZRVIiLCJ0YXJnZXRQb3MiLCJnZXRXb3JsZFBvc2l0aW9uIiwicHJvamVjdGlsZVJhZGl1cyIsInRhcmdldFJhZGl1cyIsInJhZGl1cyIsImRpc3RhbmNlU3F1YXJlZCIsImRpc3RhbmNlVG9TcXVhcmVkIiwiY29sbGlzaW9uUmFkaXVzU3F1YXJlZCIsImhhbmRsZUhpdCIsInBpZXJjaW5nIiwiYWRkSGl0VGFyZ2V0IiwicmVuZGVyZXIiLCJpc0Nyb3NzZW50cm9weUJvbHQiLCJtZXNoIiwidXNlckRhdGEiLCJpc0VudHJvcGljQm9sdCIsImRhbWFnZVR5cGUiLCJxdWV1ZURhbWFnZSIsImRhbWFnZSIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImRhbWFnZURlYWx0IiwidGFrZURhbWFnZSIsImV4cGxvc2lvblJhZGl1cyIsImhhbmRsZUV4cGxvc2lvbiIsInByb2plY3RpbGVUcmFuc2Zvcm0iLCJleHBsb3Npb25DZW50ZXIiLCJlbWl0RXZlbnQiLCJjbG9uZSIsImNvbG9yIiwic2l6ZSIsImR1cmF0aW9uIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZGFtYWdlRmFsbG9mZiIsImV4cGxvc2lvbkRhbWFnZSIsIk1hdGgiLCJmbG9vciIsInBvcyIsIm1heERpc3RhbmNlIiwibWF4RGlzdGFuY2VTcXVhcmVkIiwibGVuZ3RoU3EiLCJjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlIiwiZGlyZWN0aW9uIiwib3duZXJJZCIsImNvbmZpZyIsImNyZWF0ZUVudGl0eSIsImNyZWF0ZUNvbXBvbmVudCIsImFkZENvbXBvbmVudCIsInNwZWVkIiwibWF4TGlmZXRpbWUiLCJsaWZldGltZSIsInNldERpcmVjdGlvbiIsInNldFBpZXJjaW5nIiwiZXhwbG9zaXZlIiwic2V0RXhwbG9zaXZlIiwicGxhY2Vob2xkZXJHZW9tZXRyeSIsInBsYWNlaG9sZGVyTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwicGxhY2Vob2xkZXJNZXNoIiwiaXNDaGFyZ2VkQXJyb3ciLCJzdWJjbGFzcyIsImxldmVsIiwiY29sbGlkZXIiLCJQUk9KRUNUSUxFIiwiY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUiLCJzZXRDYXN0U2hhZG93IiwiY29uc29sZSIsIndhcm4iLCJub3RpZnlFbnRpdHlBZGRlZCIsImNyZWF0ZUVudHJvcGljQm9sdFByb2plY3RpbGUiLCJjcmVhdGVQcm9qZWN0aWxlIiwic2V0U3RhcnRQb3NpdGlvbiIsInVuZGVmaW5lZCIsInNldE1heERpc3RhbmNlIiwiaXNSZWd1bGFyQXJyb3ciLCJnZXRQb29sU3RhdHMiLCJ2ZWN0b3IzIiwidmVjdG9yM1Bvb2wiLCJnZXRQb29sU2l6ZSIsIm9uRGlzYWJsZSIsImxvZyIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5IiwidmVjdG9yIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ProjectileSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/RenderSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/RenderSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n// Render system for 3D rendering with Three.js\n\n\n\n\nclass RenderSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update animations and renderer components\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            // Update animations with safety check\n            if (typeof rendererComponent.updateAnimations === \"function\") {\n                rendererComponent.updateAnimations(deltaTime);\n            } else {\n                console.warn(\"⚠️ Renderer component missing updateAnimations method:\", rendererComponent);\n            }\n            // Update mesh if needed\n            this.updateEntityMesh(entity, transform, rendererComponent);\n        }\n    }\n    render(entities, deltaTime) {\n        // Update all entity transforms and meshes\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            this.updateEntityTransform(entity, transform, rendererComponent);\n        }\n        // Render the scene\n        this.renderer.render(this.scene, this.camera);\n    }\n    updateEntityMesh(entity, transform, rendererComponent) {\n        const existingMesh = this.meshMap.get(entity.id);\n        // Handle pre-built mesh/group (like arrows)\n        if (!existingMesh && rendererComponent.mesh) {\n            this.meshMap.set(entity.id, rendererComponent.mesh);\n            this.scene.add(rendererComponent.mesh);\n            return;\n        }\n        // Create mesh if it doesn't exist or needs update (traditional geometry + material)\n        if (!existingMesh && rendererComponent.geometry && rendererComponent.material) {\n            const mesh = rendererComponent.createMesh();\n            if (mesh) {\n                this.meshMap.set(entity.id, mesh);\n                this.scene.add(mesh);\n            }\n        } else if (existingMesh) {\n            // Update existing mesh with safety check\n            if (typeof rendererComponent.updateMesh === \"function\") {\n                rendererComponent.updateMesh();\n            } else {\n                console.warn(\"⚠️ Renderer component missing updateMesh method:\", rendererComponent);\n            }\n        }\n    }\n    updateEntityTransform(entity, transform, rendererComponent) {\n        const meshOrGroup = this.meshMap.get(entity.id);\n        if (!meshOrGroup) return;\n        // Update transform matrix\n        transform.updateMatrix();\n        // Apply transform to mesh or group\n        meshOrGroup.position.copy(transform.position);\n        meshOrGroup.quaternion.copy(transform.quaternion);\n        meshOrGroup.scale.copy(transform.scale);\n        // Handle instanced rendering (only for meshes)\n        if (rendererComponent.isInstanced && meshOrGroup instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            rendererComponent.updateInstanceMatrix(transform.matrix);\n        }\n    }\n    onEntityAdded(entity) {\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent) {\n            console.log(\"\\uD83C\\uDFA8 RenderSystem: Adding entity \".concat(entity.id, \" to scene\"));\n            // Handle pre-built mesh/group (like arrows and elite enemies)\n            if (rendererComponent.mesh) {\n                console.log(\"\\uD83C\\uDFF9 Adding pre-built mesh/group for entity \".concat(entity.id));\n                this.meshMap.set(entity.id, rendererComponent.mesh);\n                this.scene.add(rendererComponent.mesh);\n                return;\n            }\n            // Handle traditional geometry + material\n            if (rendererComponent.geometry && rendererComponent.material) {\n                console.log(\"\\uD83D\\uDD37 Creating mesh from geometry + material for entity \".concat(entity.id));\n                const mesh = rendererComponent.createMesh();\n                if (mesh) {\n                    this.meshMap.set(entity.id, mesh);\n                    this.scene.add(mesh);\n                }\n            } else {\n                console.log(\"⚪ Entity \".concat(entity.id, \" has Renderer but no geometry/material - skipping mesh creation\"));\n            }\n        } else {\n            console.log(\"⚠️ RenderSystem: Entity \".concat(entity.id, \" has no Renderer component\"));\n        }\n    }\n    onEntityRemoved(entity) {\n        const mesh = this.meshMap.get(entity.id);\n        if (mesh) {\n            this.scene.remove(mesh);\n            this.meshMap.delete(entity.id);\n        }\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent && typeof rendererComponent.dispose === \"function\") {\n            rendererComponent.dispose();\n        }\n    }\n    getMesh(entityId) {\n        return this.meshMap.get(entityId);\n    }\n    getScene() {\n        return this.scene;\n    }\n    getCamera() {\n        return this.camera;\n    }\n    getRenderer() {\n        return this.renderer;\n    }\n    // Utility methods for managing the scene\n    addLight(light) {\n        this.scene.add(light);\n    }\n    removeLight(light) {\n        this.scene.remove(light);\n    }\n    addObject(object) {\n        this.scene.add(object);\n    }\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    setFog(fog) {\n        this.scene.fog = fog;\n    }\n    setBackground(background) {\n        this.scene.background = background;\n    }\n    enableShadows() {\n        let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.renderer.shadowMap.enabled = enable;\n        this.renderer.shadowMap.type = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;\n    }\n    setPixelRatio(ratio) {\n        this.renderer.setPixelRatio(ratio || window.devicePixelRatio);\n    }\n    setSize(width, height) {\n        this.renderer.setSize(width, height);\n        if (this.camera instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    dispose() {\n        // Clean up all meshes\n        for (const [entityId, mesh] of Array.from(this.meshMap.entries())){\n            this.scene.remove(mesh);\n        }\n        this.meshMap.clear();\n        // Dispose renderer\n        this.renderer.dispose();\n    }\n    constructor(scene, camera, renderer){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer\n        ];\n        this.meshMap = new Map() // Entity ID -> Mesh/Group mapping\n        ;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.priority = 1000; // Render systems should run last\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLCtDQUErQztBQUNvSTtBQUNuSDtBQUVUO0FBQ0Y7QUFFOUMsTUFBTUcscUJBQXFCQyxxREFBZ0JBO0lBZXpDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDRDQUE0QztRQUM1QyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9ELGtCQUFrQkUsZ0JBQWdCLEtBQUssWUFBWTtnQkFDNURGLGtCQUFrQkUsZ0JBQWdCLENBQUNOO1lBQ3JDLE9BQU87Z0JBQ0xPLFFBQVFDLElBQUksQ0FBQywwREFBMERKO1lBQ3pFO1lBRUEsd0JBQXdCO1lBQ3hCLElBQUksQ0FBQ0ssZ0JBQWdCLENBQUNSLFFBQVFDLFdBQVdFO1FBQzNDO0lBQ0Y7SUFFT00sT0FBT1gsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQ0FBMEM7UUFDMUMsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBQy9DLE1BQU1RLG9CQUFvQkgsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFdEQsSUFBSSxDQUFDSyxVQUFVRyxPQUFPLElBQUksQ0FBQ0Qsa0JBQWtCQyxPQUFPLEVBQUU7Z0JBQ3BEO1lBQ0Y7WUFFQSxJQUFJLENBQUNNLHFCQUFxQixDQUFDVixRQUFRQyxXQUFXRTtRQUNoRDtRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNRLFFBQVEsQ0FBQ0Ys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QUNILE9BQU8sQ0FBQ3dELEtBQUs7UUFFbEIsbUJBQW1CO1FBQ25CLElBQUksQ0FBQzVELFFBQVEsQ0FBQzRCLE9BQU87SUFDdkI7SUExTUFpQyxZQUFZNUQsS0FBWSxFQUFFQyxNQUFjLEVBQUVGLFFBQXVCLENBQUU7UUFDakUsS0FBSzthQVBTOEQscUJBQXFCO1lBQUM5RSxnRUFBU0E7WUFBRUMsOERBQVFBO1NBQUM7YUFJbERtQixVQUFVLElBQUkyRCxNQUE2QixrQ0FBa0M7O1FBSW5GLElBQUksQ0FBQzlELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDZ0UsUUFBUSxHQUFHLE1BQU0saUNBQWlDO0lBQ3pEO0FBcU1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cz9iMzA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlciBzeXN0ZW0gZm9yIDNEIHJlbmRlcmluZyB3aXRoIFRocmVlLmpzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBXZWJHTFJlbmRlcmVyLCBNZXNoLCBHcm91cCwgTGlnaHQsIE9iamVjdDNELCBDb2xvciwgVGV4dHVyZSwgUENGU29mdFNoYWRvd01hcCwgUGVyc3BlY3RpdmVDYW1lcmEsIEZvZywgRm9nRXhwMiwgQ3ViZVRleHR1cmUgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUmVuZGVyU3lzdGVtIGFzIEJhc2VSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5cbmV4cG9ydCBjbGFzcyBSZW5kZXJTeXN0ZW0gZXh0ZW5kcyBCYXNlUmVuZGVyU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFJlbmRlcmVyXTtcbiAgcHJpdmF0ZSBzY2VuZTogU2NlbmU7XG4gIHByaXZhdGUgY2FtZXJhOiBDYW1lcmE7XG4gIHByaXZhdGUgcmVuZGVyZXI6IFdlYkdMUmVuZGVyZXI7XG4gIHByaXZhdGUgbWVzaE1hcCA9IG5ldyBNYXA8bnVtYmVyLCBNZXNoIHwgR3JvdXA+KCk7IC8vIEVudGl0eSBJRCAtPiBNZXNoL0dyb3VwIG1hcHBpbmdcblxuICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIGNhbWVyYTogQ2FtZXJhLCByZW5kZXJlcjogV2ViR0xSZW5kZXJlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwMDsgLy8gUmVuZGVyIHN5c3RlbXMgc2hvdWxkIHJ1biBsYXN0XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgYW5pbWF0aW9ucyBhbmQgcmVuZGVyZXIgY29tcG9uZW50c1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXJlbmRlcmVyQ29tcG9uZW50LmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb25zIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZUFuaW1hdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlQW5pbWF0aW9ucyhkZWx0YVRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlQW5pbWF0aW9ucyBtZXRob2Q6JywgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbWVzaCBpZiBuZWVkZWRcbiAgICAgIHRoaXMudXBkYXRlRW50aXR5TWVzaChlbnRpdHksIHRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBhbGwgZW50aXR5IHRyYW5zZm9ybXMgYW5kIG1lc2hlc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXJlbmRlcmVyQ29tcG9uZW50LmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRW50aXR5VHJhbnNmb3JtKGVudGl0eSwgdHJhbnNmb3JtLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRW50aXR5TWVzaChlbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50OiBSZW5kZXJlcik6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nTWVzaCA9IHRoaXMubWVzaE1hcC5nZXQoZW50aXR5LmlkKTtcblxuICAgIC8vIEhhbmRsZSBwcmUtYnVpbHQgbWVzaC9ncm91cCAobGlrZSBhcnJvd3MpXG4gICAgaWYgKCFleGlzdGluZ01lc2ggJiYgcmVuZGVyZXJDb21wb25lbnQubWVzaCkge1xuICAgICAgdGhpcy5tZXNoTWFwLnNldChlbnRpdHkuaWQsIHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQocmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG1lc2ggaWYgaXQgZG9lc24ndCBleGlzdCBvciBuZWVkcyB1cGRhdGUgKHRyYWRpdGlvbmFsIGdlb21ldHJ5ICsgbWF0ZXJpYWwpXG4gICAgaWYgKCFleGlzdGluZ01lc2ggJiYgcmVuZGVyZXJDb21wb25lbnQuZ2VvbWV0cnkgJiYgcmVuZGVyZXJDb21wb25lbnQubWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IG1lc2ggPSByZW5kZXJlckNvbXBvbmVudC5jcmVhdGVNZXNoKCk7XG4gICAgICBpZiAobWVzaCkge1xuICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgbWVzaCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKG1lc2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdNZXNoKSB7XG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgbWVzaCB3aXRoIHNhZmV0eSBjaGVja1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlckNvbXBvbmVudC51cGRhdGVNZXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZU1lc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHVwZGF0ZU1lc2ggbWV0aG9kOicsIHJlbmRlcmVyQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUVudGl0eVRyYW5zZm9ybShlbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50OiBSZW5kZXJlcik6IHZvaWQge1xuICAgIGNvbnN0IG1lc2hPckdyb3VwID0gdGhpcy5tZXNoTWFwLmdldChlbnRpdHkuaWQpO1xuICAgIGlmICghbWVzaE9yR3JvdXApIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgdHJhbnNmb3JtLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtIHRvIG1lc2ggb3IgZ3JvdXBcbiAgICBtZXNoT3JHcm91cC5wb3NpdGlvbi5jb3B5KHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgbWVzaE9yR3JvdXAucXVhdGVybmlvbi5jb3B5KHRyYW5zZm9ybS5xdWF0ZXJuaW9uKTtcbiAgICBtZXNoT3JHcm91cC5zY2FsZS5jb3B5KHRyYW5zZm9ybS5zY2FsZSk7XG5cbiAgICAvLyBIYW5kbGUgaW5zdGFuY2VkIHJlbmRlcmluZyAob25seSBmb3IgbWVzaGVzKVxuICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5pc0luc3RhbmNlZCAmJiBtZXNoT3JHcm91cCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZUluc3RhbmNlTWF0cml4KHRyYW5zZm9ybS5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXJDb21wb25lbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIFJlbmRlclN5c3RlbTogQWRkaW5nIGVudGl0eSAke2VudGl0eS5pZH0gdG8gc2NlbmVgKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHByZS1idWlsdCBtZXNoL2dyb3VwIChsaWtlIGFycm93cyBhbmQgZWxpdGUgZW5lbWllcylcbiAgICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5tZXNoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn4+5IEFkZGluZyBwcmUtYnVpbHQgbWVzaC9ncm91cCBmb3IgZW50aXR5ICR7ZW50aXR5LmlkfWApO1xuICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgcmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB0cmFkaXRpb25hbCBnZW9tZXRyeSArIG1hdGVyaWFsXG4gICAgICBpZiAocmVuZGVyZXJDb21wb25lbnQuZ2VvbWV0cnkgJiYgcmVuZGVyZXJDb21wb25lbnQubWF0ZXJpYWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflLcgQ3JlYXRpbmcgbWVzaCBmcm9tIGdlb21ldHJ5ICsgbWF0ZXJpYWwgZm9yIGVudGl0eSAke2VudGl0eS5pZH1gKTtcbiAgICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVyQ29tcG9uZW50LmNyZWF0ZU1lc2goKTtcbiAgICAgICAgaWYgKG1lc2gpIHtcbiAgICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgbWVzaCk7XG4gICAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqogRW50aXR5ICR7ZW50aXR5LmlkfSBoYXMgUmVuZGVyZXIgYnV0IG5vIGdlb21ldHJ5L21hdGVyaWFsIC0gc2tpcHBpbmcgbWVzaCBjcmVhdGlvbmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFJlbmRlclN5c3RlbTogRW50aXR5ICR7ZW50aXR5LmlkfSBoYXMgbm8gUmVuZGVyZXIgY29tcG9uZW50YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IG1lc2ggPSB0aGlzLm1lc2hNYXAuZ2V0KGVudGl0eS5pZCk7XG4gICAgaWYgKG1lc2gpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgICAgdGhpcy5tZXNoTWFwLmRlbGV0ZShlbnRpdHkuaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyQ29tcG9uZW50ID0gZW50aXR5LmdldENvbXBvbmVudChSZW5kZXJlcik7XG4gICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50ICYmIHR5cGVvZiByZW5kZXJlckNvbXBvbmVudC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZW5kZXJlckNvbXBvbmVudC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE1lc2goZW50aXR5SWQ6IG51bWJlcik6IE1lc2ggfCBHcm91cCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubWVzaE1hcC5nZXQoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGdldFNjZW5lKCk6IFNjZW5lIHtcbiAgICByZXR1cm4gdGhpcy5zY2VuZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogQ2FtZXJhIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmE7XG4gIH1cblxuICBwdWJsaWMgZ2V0UmVuZGVyZXIoKTogV2ViR0xSZW5kZXJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG1hbmFnaW5nIHRoZSBzY2VuZVxuICBwdWJsaWMgYWRkTGlnaHQobGlnaHQ6IExpZ2h0KTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5hZGQobGlnaHQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUxpZ2h0KGxpZ2h0OiBMaWdodCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUucmVtb3ZlKGxpZ2h0KTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRPYmplY3Qob2JqZWN0OiBPYmplY3QzRCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdCk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlT2JqZWN0KG9iamVjdDogT2JqZWN0M0QpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLnJlbW92ZShvYmplY3QpO1xuICB9XG5cbiAgcHVibGljIHNldEZvZyhmb2c6IEZvZyB8IEZvZ0V4cDIgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5mb2cgPSBmb2c7XG4gIH1cblxuICBwdWJsaWMgc2V0QmFja2dyb3VuZChiYWNrZ3JvdW5kOiBDb2xvciB8IFRleHR1cmUgfCBDdWJlVGV4dHVyZSB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVNoYWRvd3MoZW5hYmxlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSBlbmFibGU7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFBDRlNvZnRTaGFkb3dNYXA7XG4gIH1cblxuICBwdWJsaWMgc2V0UGl4ZWxSYXRpbyhyYXRpbz86IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhyYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gIH1cblxuICBwdWJsaWMgc2V0U2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICBpZiAodGhpcy5jYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIG1lc2hlc1xuICAgIGZvciAoY29uc3QgW2VudGl0eUlkLCBtZXNoXSBvZiBBcnJheS5mcm9tKHRoaXMubWVzaE1hcC5lbnRyaWVzKCkpKSB7XG4gICAgICB0aGlzLnNjZW5lLnJlbW92ZShtZXNoKTtcbiAgICB9XG4gICAgdGhpcy5tZXNoTWFwLmNsZWFyKCk7XG5cbiAgICAvLyBEaXNwb3NlIHJlbmRlcmVyXG4gICAgdGhpcy5yZW5kZXJlci5kaXNwb3NlKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJNZXNoIiwiUENGU29mdFNoYWRvd01hcCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiUmVuZGVyU3lzdGVtIiwiQmFzZVJlbmRlclN5c3RlbSIsIlRyYW5zZm9ybSIsIlJlbmRlcmVyIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJyZW5kZXJlckNvbXBvbmVudCIsImVuYWJsZWQiLCJ1cGRhdGVBbmltYXRpb25zIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVFbnRpdHlNZXNoIiwicmVuZGVyIiwidXBkYXRlRW50aXR5VHJhbnNmb3JtIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImV4aXN0aW5nTWVzaCIsIm1lc2hNYXAiLCJnZXQiLCJpZCIsIm1lc2giLCJzZXQiLCJhZGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiY3JlYXRlTWVzaCIsInVwZGF0ZU1lc2giLCJtZXNoT3JHcm91cCIsInVwZGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwiY29weSIsInF1YXRlcm5pb24iLCJzY2FsZSIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJvbkVudGl0eUFkZGVkIiwibG9nIiwib25FbnRpdHlSZW1vdmVkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZGlzcG9zZSIsImdldE1lc2giLCJlbnRpdHlJZCIsImdldFNjZW5lIiwiZ2V0Q2FtZXJhIiwiZ2V0UmVuZGVyZXIiLCJhZGRMaWdodCIsImxpZ2h0IiwicmVtb3ZlTGlnaHQiLCJhZGRPYmplY3QiLCJvYmplY3QiLCJyZW1vdmVPYmplY3QiLCJzZXRGb2ciLCJmb2ciLCJzZXRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsImVuYWJsZVNoYWRvd3MiLCJlbmFibGUiLCJzaGFkb3dNYXAiLCJ0eXBlIiwic2V0UGl4ZWxSYXRpbyIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/RenderSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/TowerSystem.ts":
/*!************************************!*\
  !*** ./src/systems/TowerSystem.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TowerSystem: function() { return /* binding */ TowerSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n// Tower system for managing PVP tower AI, targeting, and shooting\n\n\n\n\n\n\nclass TowerSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setProjectileSystem(projectileSystem) {\n        this.projectileSystem = projectileSystem;\n    }\n    setTowerAttackCallback(callback) {\n        this.onTowerAttackCallback = callback;\n    }\n    setPlayerMapping(serverPlayerEntities, localSocketId) {\n        this.serverPlayerEntities = serverPlayerEntities;\n        this.localSocketId = localSocketId;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            if (!transform || !tower || !health) continue;\n            // Check if tower is dead\n            if (health.isDead && !tower.isDead) {\n                tower.die(currentTime);\n                continue;\n            }\n            // Skip inactive or dead towers\n            if (!tower.isActive || tower.isDead) continue;\n            // Search for targets periodically\n            if (tower.canSearchForTargets(currentTime)) {\n                this.searchForTarget(entity, transform, tower, currentTime);\n            }\n            // Validate current target (check if still alive and in range)\n            if (tower.currentTarget) {\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                if (!this.isValidTarget(targetEntity || null, transform, tower)) {\n                    tower.clearTarget();\n                }\n            }\n            // Attack current target if possible\n            if (tower.currentTarget && tower.canAttack(currentTime)) {\n                this.attackTarget(entity, transform, tower, currentTime);\n            }\n        }\n    }\n    searchForTarget(towerEntity, towerTransform, tower, currentTime) {\n        tower.updateTargetSearch(currentTime);\n        // Get all potential targets (players that are not the tower owner)\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider\n        ]);\n        let closestTarget = null;\n        let closestDistance = Infinity;\n        let validTargetCount = 0;\n        for (const target of potentialTargets){\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider);\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (targetCollider && targetTransform) {\n                const distance = towerTransform.position.distanceTo(targetTransform.position);\n            }\n            if (!this.isValidTarget(target, towerTransform, tower)) continue;\n            validTargetCount++;\n            const targetTransform2 = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetTransform2) continue;\n            const distance = towerTransform.position.distanceTo(targetTransform2.position);\n            if (distance <= tower.targetSearchRange && distance < closestDistance) {\n                closestTarget = target;\n                closestDistance = distance;\n            }\n        }\n        if (closestTarget) {\n            tower.setTarget(closestTarget.id);\n        } else if (tower.currentTarget) {\n            // Clear target if no valid targets found\n            tower.clearTarget();\n        }\n    }\n    isValidTarget(target, towerTransform, tower) {\n        if (!target) {\n            return false;\n        }\n        const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n        const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider);\n        // Must have required components and be alive\n        if (!targetHealth || !targetTransform || !targetCollider || targetHealth.isDead) {\n            return false;\n        }\n        // Must be a player (not an enemy or other tower)\n        if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY) {\n            return false;\n        }\n        // Don't target other towers\n        if (target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)) {\n            return false;\n        }\n        // In PVP mode, identify if this is an enemy player\n        if (this.localSocketId && this.serverPlayerEntities.size > 0) {\n            // Check if this is the local player (PLAYER layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER) {\n                const shouldTarget = tower.ownerId !== this.localSocketId;\n                return shouldTarget;\n            }\n            // Check if this is a remote player (ENEMY layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY) {\n                // Find which player this entity belongs to\n                let targetPlayerId = null;\n                this.serverPlayerEntities.forEach((entityId, playerId)=>{\n                    if (entityId === target.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n                if (targetPlayerId) {\n                    const shouldTarget = tower.ownerId !== targetPlayerId;\n                    return shouldTarget;\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n    attackTarget(towerEntity, towerTransform, tower, currentTime) {\n        const targetEntity = this.world.getEntity(tower.currentTarget);\n        if (!targetEntity) {\n            tower.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            tower.clearTarget();\n            return;\n        }\n        // Calculate direction to target\n        this.tempVector.copy(targetTransform.position);\n        this.tempVector.sub(towerTransform.position);\n        const distance = this.tempVector.length();\n        // Check if target is still in range\n        if (distance > tower.attackRange) {\n            tower.clearTarget();\n            return;\n        }\n        // Normalize direction\n        this.tempVector.normalize();\n        // Calculate projectile spawn position (slightly above tower center)\n        this.tempVector2.copy(towerTransform.position);\n        this.tempVector2.y += 2; // Spawn projectiles 2 units above tower base\n        // Create projectile\n        if (this.projectileSystem) {\n            const projectileConfig = {\n                speed: tower.projectileSpeed,\n                damage: tower.attackDamage,\n                lifetime: 2,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, this.tempVector2, this.tempVector, towerEntity.id, projectileConfig);\n            // Mark projectile as tower projectile for special handling\n            const projectileRenderer = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (projectileRenderer) {\n                // Add metadata to identify this as a tower projectile\n                projectileEntity.isTowerProjectile = true;\n                projectileEntity.towerOwnerId = tower.ownerId;\n            }\n        }\n        // Broadcast attack to multiplayer if callback is set\n        if (this.onTowerAttackCallback) {\n            // We need to map the target entity back to a player ID\n            // For now, we'll use a placeholder - this will need to be improved with proper player mapping\n            const targetPlayerId = \"player_\".concat(tower.currentTarget);\n            this.onTowerAttackCallback(tower.ownerId, targetPlayerId, this.tempVector2, this.tempVector);\n        }\n        tower.performAttack(currentTime);\n    }\n    // Utility method to get all towers owned by a specific player\n    getTowersByOwner(ownerId) {\n        const allTowers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ]);\n        return allTowers.filter((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            return tower && tower.ownerId === ownerId;\n        });\n    }\n    // Utility method to get tower count for a player\n    getTowerCount(ownerId) {\n        return this.getTowersByOwner(ownerId).length;\n    }\n    // Utility method to check if a player has any active towers\n    hasActiveTowers(ownerId) {\n        const towers = this.getTowersByOwner(ownerId);\n        return towers.some((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            return tower && health && tower.isActive && !tower.isDead && !health.isDead;\n        });\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ];\n        this.projectileSystem = null;\n        // Player entity mapping for identifying tower owners vs enemies\n        this.serverPlayerEntities = new Map();\n        this.localSocketId = null;\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 25; // Run after movement and projectiles\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxrRUFBa0U7QUFDbEI7QUFDVjtBQUVpQjtBQUNOO0FBQ0Y7QUFDc0I7QUFJOUQsTUFBTU8sb0JBQW9CTiwrQ0FBTUE7SUFzQjlCTyxvQkFBb0JDLGdCQUFrQyxFQUFRO1FBQ25FLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdBO0lBQzFCO0lBRU9DLHVCQUF1QkMsUUFBdUcsRUFBUTtRQUMzSSxJQUFJLENBQUNDLHFCQUFxQixHQUFHRDtJQUMvQjtJQUVPRSxpQkFBaUJDLG9CQUF5QyxFQUFFQyxhQUFxQixFQUFRO1FBQzlGLElBQUksQ0FBQ0Qsb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtJQUN2QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELE1BQU1DLGNBQWNDLEtBQUtDLEdBQUcsS0FBSyxNQUFNLHFCQUFxQjtRQUU1RCxLQUFLLE1BQU1DLFVBQVVMLFNBQVU7WUFDN0IsTUFBTU0sWUFBWUQsT0FBT0UsWUFBWSxDQUFDdEIsZ0VBQVNBO1lBQy9DLE1BQU11QixRQUFRSCxPQUFPRSxZQUFZLENBQUNwQix3REFBS0E7WUFDdkMsTUFBTXNCLFNBQVNKLE9BQU9FLFlBQVksQ0FBQ3JCLDBEQUFNQTtZQUV6QyxJQUFJLENBQUNvQixhQUFhLENBQUNFLFNBQVMsQ0FBQ0MsUUFBUTtZQUVyQyx5QkFBeUI7WUFDekIsSUFBSUEsT0FBT0MsTUFBTSxJQUFJLENBQUNGLE1BQU1FLE1BQU0sRUFBRTtnQkFDbENGLE1BQU1HLEdBQUcsQ0FBQ1Q7Z0JBQ1Y7WUFDRjtZQUVBLCtCQUErQjtZQUMvQixJQUFJLENBQUNNLE1BQU1JLFFBQVEsSUFBSUosTUFBTUUsTUFBTSxFQUFFO1lBRXJDLGtDQUFrQztZQUNsQyxJQUFJRixNQUFNSyxtQkFBbUIsQ0FBQ1gsY0FBYztnQkFDMUMsSUFBSSxD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QUN4REssdUJBQTRDLElBQUl1RjthQUNoRHRGLGdCQUErQjtRQUV2Qyx5Q0FBeUM7YUFDakN3RCxhQUFhLElBQUl2RSx5REFBT0E7YUFDeEI2RSxjQUFjLElBQUk3RSx5REFBT0E7UUFJL0IsSUFBSSxDQUFDa0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ29FLFFBQVEsR0FBRyxJQUFJLHFDQUFxQztJQUMzRDtBQW1QRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Ub3dlclN5c3RlbS50cz82YjIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIHN5c3RlbSBmb3IgbWFuYWdpbmcgUFZQIHRvd2VyIEFJLCB0YXJnZXRpbmcsIGFuZCBzaG9vdGluZ1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFRvd2VyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Ub3dlcic7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlclN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJyb2FkY2FzdGluZyB0b3dlciBhdHRhY2tzIGluIG11bHRpcGxheWVyXG4gIHByaXZhdGUgb25Ub3dlckF0dGFja0NhbGxiYWNrPzogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gUGxheWVyIGVudGl0eSBtYXBwaW5nIGZvciBpZGVudGlmeWluZyB0b3dlciBvd25lcnMgdnMgZW5lbWllc1xuICBwcml2YXRlIHNlcnZlclBsYXllckVudGl0aWVzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGxvY2FsU29ja2V0SWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gUmV1c2FibGUgb2JqZWN0cyB0byByZWR1Y2UgYWxsb2NhdGlvbnNcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3Iod29ybGQ6IFdvcmxkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgbW92ZW1lbnQgYW5kIHByb2plY3RpbGVzXG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQcm9qZWN0aWxlU3lzdGVtKHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0pOiB2b2lkIHtcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0gPSBwcm9qZWN0aWxlU3lzdGVtO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0VG93ZXJBdHRhY2tDYWxsYmFjayhjYWxsYmFjazogKHRvd2VyT3duZXJJZDogc3RyaW5nLCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFBsYXllck1hcHBpbmcoc2VydmVyUGxheWVyRW50aXRpZXM6IE1hcDxzdHJpbmcsIG51bWJlcj4sIGxvY2FsU29ja2V0SWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMgPSBzZXJ2ZXJQbGF5ZXJFbnRpdGllcztcbiAgICB0aGlzLmxvY2FsU29ja2V0SWQgPSBsb2NhbFNvY2tldElkO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBcbiAgICAgIGlmICghdHJhbnNmb3JtIHx8ICF0b3dlciB8fCAhaGVhbHRoKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdG93ZXIgaXMgZGVhZFxuICAgICAgaWYgKGhlYWx0aC5pc0RlYWQgJiYgIXRvd2VyLmlzRGVhZCkge1xuICAgICAgICB0b3dlci5kaWUoY3VycmVudFRpbWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2tpcCBpbmFjdGl2ZSBvciBkZWFkIHRvd2Vyc1xuICAgICAgaWYgKCF0b3dlci5pc0FjdGl2ZSB8fCB0b3dlci5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBTZWFyY2ggZm9yIHRhcmdldHMgcGVyaW9kaWNhbGx5XG4gICAgICBpZiAodG93ZXIuY2FuU2VhcmNoRm9yVGFyZ2V0cyhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGb3JUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIGN1cnJlbnQgdGFyZ2V0IChjaGVjayBpZiBzdGlsbCBhbGl2ZSBhbmQgaW4gcmFuZ2UpXG4gICAgICBpZiAodG93ZXIuY3VycmVudFRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbnRpdHkgPSB0aGlzLndvcmxkLmdldEVudGl0eSh0b3dlci5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYXJnZXQodGFyZ2V0RW50aXR5IHx8IG51bGwsIHRyYW5zZm9ybSwgdG93ZXIpKSB7XG4gICAgICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBdHRhY2sgY3VycmVudCB0YXJnZXQgaWYgcG9zc2libGVcbiAgICAgIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0ICYmIHRvd2VyLmNhbkF0dGFjayhjdXJyZW50VGltZSkpIHtcbiAgICAgICAgdGhpcy5hdHRhY2tUYXJnZXQoZW50aXR5LCB0cmFuc2Zvcm0sIHRvd2VyLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIHNlYXJjaEZvclRhcmdldCh0b3dlckVudGl0eTogRW50aXR5LCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0b3dlci51cGRhdGVUYXJnZXRTZWFyY2goY3VycmVudFRpbWUpO1xuICAgIFxuICAgIC8vIEdldCBhbGwgcG90ZW50aWFsIHRhcmdldHMgKHBsYXllcnMgdGhhdCBhcmUgbm90IHRoZSB0b3dlciBvd25lcilcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBcbiAgICBcbiAgICBsZXQgY2xvc2VzdFRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCB2YWxpZFRhcmdldENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIgJiYgdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhcmdldCh0YXJnZXQsIHRvd2VyVHJhbnNmb3JtLCB0b3dlcikpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICB2YWxpZFRhcmdldENvdW50Kys7XG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0yID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0yKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgY29uc3QgZGlzdGFuY2UgPSB0b3dlclRyYW5zZm9ybS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldFRyYW5zZm9ybTIucG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gdG93ZXIudGFyZ2V0U2VhcmNoUmFuZ2UgJiYgZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgY2xvc2VzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIGlmIChjbG9zZXN0VGFyZ2V0KSB7XG4gICAgICB0b3dlci5zZXRUYXJnZXQoY2xvc2VzdFRhcmdldC5pZCk7XG4gICAgfSBlbHNlIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhciB0YXJnZXQgaWYgbm8gdmFsaWQgdGFyZ2V0cyBmb3VuZFxuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgaXNWYWxpZFRhcmdldCh0YXJnZXQ6IEVudGl0eSB8IG51bGwsIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlcik6IGJvb2xlYW4ge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRhcmdldEhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgdGFyZ2V0Q29sbGlkZXIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBcbiAgICAvLyBNdXN0IGhhdmUgcmVxdWlyZWQgY29tcG9uZW50cyBhbmQgYmUgYWxpdmVcbiAgICBpZiAoIXRhcmdldEhlYWx0aCB8fCAhdGFyZ2V0VHJhbnNmb3JtIHx8ICF0YXJnZXRDb2xsaWRlciB8fCB0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIE11c3QgYmUgYSBwbGF5ZXIgKG5vdCBhbiBlbmVteSBvciBvdGhlciB0b3dlcilcbiAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLlBMQVlFUiAmJiB0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gRG9uJ3QgdGFyZ2V0IG90aGVyIHRvd2Vyc1xuICAgIGlmICh0YXJnZXQuaGFzQ29tcG9uZW50KFRvd2VyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbiBQVlAgbW9kZSwgaWRlbnRpZnkgaWYgdGhpcyBpcyBhbiBlbmVteSBwbGF5ZXJcbiAgICBpZiAodGhpcy5sb2NhbFNvY2tldElkICYmIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMuc2l6ZSA+IDApIHtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgbG9jYWwgcGxheWVyIChQTEFZRVIgbGF5ZXIpXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLlBMQVlFUikge1xuICAgICAgICBjb25zdCBzaG91bGRUYXJnZXQgPSB0b3dlci5vd25lcklkICE9PSB0aGlzLmxvY2FsU29ja2V0SWQ7XG4gICAgICAgIHJldHVybiBzaG91bGRUYXJnZXQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSByZW1vdGUgcGxheWVyIChFTkVNWSBsYXllcilcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkpIHtcbiAgICAgICAgLy8gRmluZCB3aGljaCBwbGF5ZXIgdGhpcyBlbnRpdHkgYmVsb25ncyB0b1xuICAgICAgICBsZXQgdGFyZ2V0UGxheWVySWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlclBsYXllckVudGl0aWVzLmZvckVhY2goKGVudGl0eUlkLCBwbGF5ZXJJZCkgPT4ge1xuICAgICAgICAgIGlmIChlbnRpdHlJZCA9PT0gdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICB0YXJnZXRQbGF5ZXJJZCA9IHBsYXllcklkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGFyZ2V0UGxheWVySWQpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRUYXJnZXQgPSB0b3dlci5vd25lcklkICE9PSB0YXJnZXRQbGF5ZXJJZDtcbiAgICAgICAgICByZXR1cm4gc2hvdWxkVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHByaXZhdGUgYXR0YWNrVGFyZ2V0KHRvd2VyRW50aXR5OiBFbnRpdHksIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHRvd2VyLmN1cnJlbnRUYXJnZXQhKTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgdGhpcy50ZW1wVmVjdG9yLnN1Yih0b3dlclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnRlbXBWZWN0b3IubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHN0aWxsIGluIHJhbmdlXG4gICAgaWYgKGRpc3RhbmNlID4gdG93ZXIuYXR0YWNrUmFuZ2UpIHtcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb25cbiAgICB0aGlzLnRlbXBWZWN0b3Iubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gKHNsaWdodGx5IGFib3ZlIHRvd2VyIGNlbnRlcilcbiAgICB0aGlzLnRlbXBWZWN0b3IyLmNvcHkodG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGVtcFZlY3RvcjIueSArPSAyOyAvLyBTcGF3biBwcm9qZWN0aWxlcyAyIHVuaXRzIGFib3ZlIHRvd2VyIGJhc2VcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLnByb2plY3RpbGVTeXN0ZW0pIHtcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiB0b3dlci5wcm9qZWN0aWxlU3BlZWQsXG4gICAgICAgIGRhbWFnZTogdG93ZXIuYXR0YWNrRGFtYWdlLFxuICAgICAgICBsaWZldGltZTogMiwgLy8gNSBzZWNvbmQgbGlmZXRpbWVcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHRoaXMudGVtcFZlY3RvcjIsIC8vIHNwYXduIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudGVtcFZlY3RvciwgIC8vIGRpcmVjdGlvblxuICAgICAgICB0b3dlckVudGl0eS5pZCwgICAvLyB0b3dlciBhcyBvd25lclxuICAgICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIHByb2plY3RpbGUgYXMgdG93ZXIgcHJvamVjdGlsZSBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgY29uc3QgcHJvamVjdGlsZVJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmIChwcm9qZWN0aWxlUmVuZGVyZXIpIHtcbiAgICAgICAgLy8gQWRkIG1ldGFkYXRhIHRvIGlkZW50aWZ5IHRoaXMgYXMgYSB0b3dlciBwcm9qZWN0aWxlXG4gICAgICAgIChwcm9qZWN0aWxlRW50aXR5IGFzIGFueSkuaXNUb3dlclByb2plY3RpbGUgPSB0cnVlO1xuICAgICAgICAocHJvamVjdGlsZUVudGl0eSBhcyBhbnkpLnRvd2VyT3duZXJJZCA9IHRvd2VyLm93bmVySWQ7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IGF0dGFjayB0byBtdWx0aXBsYXllciBpZiBjYWxsYmFjayBpcyBzZXRcbiAgICBpZiAodGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2spIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFwIHRoZSB0YXJnZXQgZW50aXR5IGJhY2sgdG8gYSBwbGF5ZXIgSURcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHVzZSBhIHBsYWNlaG9sZGVyIC0gdGhpcyB3aWxsIG5lZWQgdG8gYmUgaW1wcm92ZWQgd2l0aCBwcm9wZXIgcGxheWVyIG1hcHBpbmdcbiAgICAgIGNvbnN0IHRhcmdldFBsYXllcklkID0gYHBsYXllcl8ke3Rvd2VyLmN1cnJlbnRUYXJnZXR9YDtcbiAgICAgIHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrKHRvd2VyLm93bmVySWQsIHRhcmdldFBsYXllcklkLCB0aGlzLnRlbXBWZWN0b3IyLCB0aGlzLnRlbXBWZWN0b3IpO1xuICAgIH1cbiAgICBcbiAgICB0b3dlci5wZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lKTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IGFsbCB0b3dlcnMgb3duZWQgYnkgYSBzcGVjaWZpYyBwbGF5ZXJcbiAgcHVibGljIGdldFRvd2Vyc0J5T3duZXIob3duZXJJZDogc3RyaW5nKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGFsbFRvd2VycyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXSk7XG4gICAgcmV0dXJuIGFsbFRvd2Vycy5maWx0ZXIoZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICByZXR1cm4gdG93ZXIgJiYgdG93ZXIub3duZXJJZCA9PT0gb3duZXJJZDtcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IHRvd2VyIGNvdW50IGZvciBhIHBsYXllclxuICBwdWJsaWMgZ2V0VG93ZXJDb3VudChvd25lcklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCkubGVuZ3RoO1xuICB9XG4gIFxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjaGVjayBpZiBhIHBsYXllciBoYXMgYW55IGFjdGl2ZSB0b3dlcnNcbiAgcHVibGljIGhhc0FjdGl2ZVRvd2Vycyhvd25lcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0b3dlcnMgPSB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCk7XG4gICAgcmV0dXJuIHRvd2Vycy5zb21lKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgcmV0dXJuIHRvd2VyICYmIGhlYWx0aCAmJiB0b3dlci5pc0FjdGl2ZSAmJiAhdG93ZXIuaXNEZWFkICYmICFoZWFsdGguaXNEZWFkO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkhlYWx0aCIsIlRvd2VyIiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIlRvd2VyU3lzdGVtIiwic2V0UHJvamVjdGlsZVN5c3RlbSIsInByb2plY3RpbGVTeXN0ZW0iLCJzZXRUb3dlckF0dGFja0NhbGxiYWNrIiwiY2FsbGJhY2siLCJvblRvd2VyQXR0YWNrQ2FsbGJhY2siLCJzZXRQbGF5ZXJNYXBwaW5nIiwic2VydmVyUGxheWVyRW50aXRpZXMiLCJsb2NhbFNvY2tldElkIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJ0b3dlciIsImhlYWx0aCIsImlzRGVhZCIsImRpZSIsImlzQWN0aXZlIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsInNlYXJjaEZvclRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRFbnRpdHkiLCJ3b3JsZCIsImdldEVudGl0eSIsImlzVmFsaWRUYXJnZXQiLCJjbGVhclRhcmdldCIsImNhbkF0dGFjayIsImF0dGFja1RhcmdldCIsInRvd2VyRW50aXR5IiwidG93ZXJUcmFuc2Zvcm0iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsImNsb3Nlc3RUYXJnZXQiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInZhbGlkVGFyZ2V0Q291bnQiLCJ0YXJnZXQiLCJ0YXJnZXRDb2xsaWRlciIsInRhcmdldFRyYW5zZm9ybSIsImRpc3RhbmNlIiwicG9zaXRpb24iLCJkaXN0YW5jZVRvIiwidGFyZ2V0VHJhbnNmb3JtMiIsInRhcmdldFNlYXJjaFJhbmdlIiwic2V0VGFyZ2V0IiwiaWQiLCJ0YXJnZXRIZWFsdGgiLCJsYXllciIsIlBMQVlFUiIsIkVORU1ZIiwiaGFzQ29tcG9uZW50Iiwic2l6ZSIsInNob3VsZFRhcmdldCIsIm93bmVySWQiLCJ0YXJnZXRQbGF5ZXJJZCIsImZvckVhY2giLCJlbnRpdHlJZCIsInBsYXllcklkIiwidGVtcFZlY3RvciIsImNvcHkiLCJzdWIiLCJsZW5ndGgiLCJhdHRhY2tSYW5nZSIsIm5vcm1hbGl6ZSIsInRlbXBWZWN0b3IyIiwieSIsInByb2plY3RpbGVDb25maWciLCJzcGVlZCIsInByb2plY3RpbGVTcGVlZCIsImRhbWFnZSIsImF0dGFja0RhbWFnZSIsImxpZmV0aW1lIiwib3BhY2l0eSIsInByb2plY3RpbGVFbnRpdHkiLCJjcmVhdGVQcm9qZWN0aWxlIiwicHJvamVjdGlsZVJlbmRlcmVyIiwiaXNUb3dlclByb2plY3RpbGUiLCJ0b3dlck93bmVySWQiLCJwZXJmb3JtQXR0YWNrIiwiZ2V0VG93ZXJzQnlPd25lciIsImFsbFRvd2VycyIsImZpbHRlciIsImdldFRvd2VyQ291bnQiLCJoYXNBY3RpdmVUb3dlcnMiLCJ0b3dlcnMiLCJzb21lIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJNYXAiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/TowerSystem.ts\n"));

/***/ })

}]);