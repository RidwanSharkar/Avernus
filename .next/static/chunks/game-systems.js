"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["game-systems"],{

/***/ "(app-pages-browser)/./src/core/DamageCalculator.ts":
/*!**************************************!*\
  !*** ./src/core/DamageCalculator.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateDamage: function() { return /* binding */ calculateDamage; },\n/* harmony export */   getCriticalChance: function() { return /* binding */ getCriticalChance; },\n/* harmony export */   getCriticalDamageMultiplier: function() { return /* binding */ getCriticalDamageMultiplier; },\n/* harmony export */   getGlobalRuneCounts: function() { return /* binding */ getGlobalRuneCounts; },\n/* harmony export */   setGlobalCritDamageRuneCount: function() { return /* binding */ setGlobalCritDamageRuneCount; },\n/* harmony export */   setGlobalCriticalRuneCount: function() { return /* binding */ setGlobalCriticalRuneCount; }\n/* harmony export */ });\n// Core damage calculation system with critical hit mechanics\n// Placed in core/ for performance and shared access across all systems\n// Global rune counts - will be updated by the GameState context\nlet globalCriticalRuneCount = 0;\nlet globalCritDamageRuneCount = 0;\nfunction setGlobalCriticalRuneCount(count) {\n    globalCriticalRuneCount = count;\n}\nfunction setGlobalCritDamageRuneCount(count) {\n    globalCritDamageRuneCount = count;\n}\nfunction calculateDamage(baseAmount) {\n    // Base crit chance is 11%, each rune adds 3%\n    const criticalChance = 0.11 + globalCriticalRuneCount * 0.03;\n    const isCritical = Math.random() < criticalChance;\n    // Base crit damage multiplier is 2x, each crit damage rune adds 0.15x\n    const criticalDamageMultiplier = 2.0 + globalCritDamageRuneCount * 0.15;\n    const rawDamage = isCritical ? baseAmount * criticalDamageMultiplier : baseAmount;\n    // Round down to integer to avoid floating point precision issues\n    const damage = Math.floor(rawDamage);\n    return {\n        damage,\n        isCritical\n    };\n}\n// Utility functions for debugging and testing\nfunction getCriticalChance() {\n    return 0.11 + globalCriticalRuneCount * 0.03;\n}\nfunction getCriticalDamageMultiplier() {\n    return 2.0 + globalCritDamageRuneCount * 0.15;\n}\nfunction getGlobalRuneCounts() {\n    return {\n        criticalRunes: globalCriticalRuneCount,\n        critDamageRunes: globalCritDamageRuneCount\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0RhbWFnZUNhbGN1bGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsNkRBQTZEO0FBQzdELHVFQUF1RTtBQU92RSxnRUFBZ0U7QUFDaEUsSUFBSUEsMEJBQTBCO0FBQzlCLElBQUlDLDRCQUE0QjtBQUV6QixTQUFTQywyQkFBMkJDLEtBQWE7SUFDdERILDBCQUEwQkc7QUFDNUI7QUFFTyxTQUFTQyw2QkFBNkJELEtBQWE7SUFDeERGLDRCQUE0QkU7QUFDOUI7QUFFTyxTQUFTRSxnQkFBZ0JDLFVBQWtCO0lBQ2hELDZDQUE2QztJQUM3QyxNQUFNQyxpQkFBaUIsT0FBUVAsMEJBQTBCO0lBQ3pELE1BQU1RLGFBQWFDLEtBQUtDLE1BQU0sS0FBS0g7SUFFbkMsc0VBQXNFO0lBQ3RFLE1BQU1JLDJCQUEyQixNQUFPViw0QkFBNEI7SUFDcEUsTUFBTVcsWUFBWUosYUFBYUYsYUFBYUssMkJBQTJCTDtJQUV2RSxpRUFBaUU7SUFDakUsTUFBTU8sU0FBU0osS0FBS0ssS0FBSyxDQUFDRjtJQUUxQixPQUFPO1FBQUVDO1FBQVFMO0lBQVc7QUFDOUI7QUFFQSw4Q0FBOEM7QUFDdkMsU0FBU087SUFDZCxPQUFPLE9BQVFmLDBCQUEwQjtBQUMzQztBQUVPLFNBQVNnQjtJQUNkLE9BQU8sTUFBT2YsNEJBQTRCO0FBQzVDO0FBRU8sU0FBU2dCO0lBQ2QsT0FBTztRQUNMQyxlQUFlbEI7UUFDZm1CLGlCQUFpQmxCO0lBQ25CO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvcmUvRGFtYWdlQ2FsY3VsYXRvci50cz8yNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcmUgZGFtYWdlIGNhbGN1bGF0aW9uIHN5c3RlbSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3Ncbi8vIFBsYWNlZCBpbiBjb3JlLyBmb3IgcGVyZm9ybWFuY2UgYW5kIHNoYXJlZCBhY2Nlc3MgYWNyb3NzIGFsbCBzeXN0ZW1zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFtYWdlUmVzdWx0IHtcbiAgZGFtYWdlOiBudW1iZXI7XG4gIGlzQ3JpdGljYWw6IGJvb2xlYW47XG59XG5cbi8vIEdsb2JhbCBydW5lIGNvdW50cyAtIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgR2FtZVN0YXRlIGNvbnRleHRcbmxldCBnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCA9IDA7XG5sZXQgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0aWNhbFJ1bmVDb3VudChjb3VudDogbnVtYmVyKSB7XG4gIGdsb2JhbENyaXRpY2FsUnVuZUNvdW50ID0gY291bnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRHbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50KGNvdW50OiBudW1iZXIpIHtcbiAgZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCA9IGNvdW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRGFtYWdlKGJhc2VBbW91bnQ6IG51bWJlcik6IERhbWFnZVJlc3VsdCB7XG4gIC8vIEJhc2UgY3JpdCBjaGFuY2UgaXMgMTElLCBlYWNoIHJ1bmUgYWRkcyAzJVxuICBjb25zdCBjcml0aWNhbENoYW5jZSA9IDAuMTEgKyAoZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQgKiAwLjAzKTtcbiAgY29uc3QgaXNDcml0aWNhbCA9IE1hdGgucmFuZG9tKCkgPCBjcml0aWNhbENoYW5jZTtcbiAgXG4gIC8vIEJhc2UgY3JpdCBkYW1hZ2UgbXVsdGlwbGllciBpcyAyeCwgZWFjaCBjcml0IGRhbWFnZSBydW5lIGFkZHMgMC4xNXhcbiAgY29uc3QgY3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyID0gMi4wICsgKGdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQgKiAwLjE1KTtcbiAgY29uc3QgcmF3RGFtYWdlID0gaXNDcml0aWNhbCA/IGJhc2VBbW91bnQgKiBjcml0aWNhbERhbWFnZU11bHRpcGxpZXIgOiBiYXNlQW1vdW50O1xuICBcbiAgLy8gUm91bmQgZG93biB0byBpbnRlZ2VyIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiBpc3N1ZXNcbiAgY29uc3QgZGFtYWdlID0gTWF0aC5mbG9vcihyYXdEYW1hZ2UpO1xuICBcbiAgcmV0dXJuIHsgZGFtYWdlLCBpc0NyaXRpY2FsIH07XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbmV4cG9ydCBmdW5jdGlvbiBnZXRDcml0aWNhbENoYW5jZSgpOiBudW1iZXIge1xuICByZXR1cm4gMC4xMSArIChnbG9iYWxDcml0aWNhbFJ1bmVDb3VudCAqIDAuMDMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JpdGljYWxEYW1hZ2VNdWx0aXBsaWVyKCk6IG51bWJlciB7XG4gIHJldHVybiAyLjAgKyAoZ2xvYmFsQ3JpdERhbWFnZVJ1bmVDb3VudCAqIDAuMTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsUnVuZUNvdW50cygpOiB7IGNyaXRpY2FsUnVuZXM6IG51bWJlcjsgY3JpdERhbWFnZVJ1bmVzOiBudW1iZXIgfSB7XG4gIHJldHVybiB7XG4gICAgY3JpdGljYWxSdW5lczogZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQsXG4gICAgY3JpdERhbWFnZVJ1bmVzOiBnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZ2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJnbG9iYWxDcml0RGFtYWdlUnVuZUNvdW50Iiwic2V0R2xvYmFsQ3JpdGljYWxSdW5lQ291bnQiLCJjb3VudCIsInNldEdsb2JhbENyaXREYW1hZ2VSdW5lQ291bnQiLCJjYWxjdWxhdGVEYW1hZ2UiLCJiYXNlQW1vdW50IiwiY3JpdGljYWxDaGFuY2UiLCJpc0NyaXRpY2FsIiwiTWF0aCIsInJhbmRvbSIsImNyaXRpY2FsRGFtYWdlTXVsdGlwbGllciIsInJhd0RhbWFnZSIsImRhbWFnZSIsImZsb29yIiwiZ2V0Q3JpdGljYWxDaGFuY2UiLCJnZXRDcml0aWNhbERhbWFnZU11bHRpcGxpZXIiLCJnZXRHbG9iYWxSdW5lQ291bnRzIiwiY3JpdGljYWxSdW5lcyIsImNyaXREYW1hZ2VSdW5lcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/DamageCalculator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/Engine.ts":
/*!****************************!*\
  !*** ./src/core/Engine.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Engine: function() { return /* binding */ Engine; }\n/* harmony export */ });\n/* harmony import */ var _ecs_World__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/World */ \"(app-pages-browser)/./src/ecs/World.ts\");\n/* harmony import */ var _GameLoop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameLoop */ \"(app-pages-browser)/./src/core/GameLoop.ts\");\n/* harmony import */ var _InputManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InputManager */ \"(app-pages-browser)/./src/core/InputManager.ts\");\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Main game engine with ECS integration\n\n\n\n\nclass Engine extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n    async initialize(canvas) {\n        if (this.isInitialized) {\n            console.warn(\"Engine already initialized\");\n            return;\n        }\n        this.canvas = canvas;\n        this.inputManager.initialize(canvas);\n        this.isInitialized = true;\n        this.emit(\"initialized\");\n    }\n    start() {\n        if (!this.isInitialized) {\n            throw new Error(\"Engine must be initialized before starting\");\n        }\n        if (this.isRunning) {\n            console.warn(\"Engine already running\");\n            return;\n        }\n        this.isRunning = true;\n        this.gameLoop.start();\n        this.emit(\"started\");\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        this.gameLoop.stop();\n        this.emit(\"stopped\");\n    }\n    pause() {\n        if (this.isRunning) {\n            this.gameLoop.pause();\n            this.emit(\"paused\");\n        }\n    }\n    resume() {\n        if (this.isRunning) {\n            this.gameLoop.resume();\n            this.emit(\"resumed\");\n        }\n    }\n    getWorld() {\n        return this.world;\n    }\n    getInputManager() {\n        return this.inputManager;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    isEngineRunning() {\n        return this.isRunning;\n    }\n    getCurrentFPS() {\n        return this.gameLoop.getCurrentFPS();\n    }\n    getPerformanceStats() {\n        return {\n            fps: this.gameLoop.getCurrentFPS(),\n            frameTime: this.frameTime,\n            updateTime: this.updateTime,\n            renderTime: this.renderTime\n        };\n    }\n    enableDebugMode(enabled) {\n        this.debugMode = enabled;\n    }\n    isDebugMode() {\n        return this.debugMode;\n    }\n    setupGameLoop() {\n        // Handle fixed timestep updates (physics)\n        this.gameLoop.on(\"fixedUpdate\", (param)=>{\n            let { fixedDeltaTime } = param;\n            const startTime = performance.now();\n            this.world.fixedUpdate(fixedDeltaTime);\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n        });\n        // Handle variable timestep updates (game logic)\n        this.gameLoop.on(\"update\", (param)=>{\n            let { deltaTime } = param;\n            const startTime = performance.now();\n            // Update world systems first so they can read input deltas\n            this.world.update(deltaTime);\n            // Update input manager after systems have processed input\n            this.inputManager.update();\n            if (this.debugMode) {\n                this.updateTime = performance.now() - startTime;\n            }\n            this.emit(\"update\", {\n                deltaTime\n            });\n        });\n        // Handle rendering\n        this.gameLoop.on(\"render\", (param)=>{\n            let { deltaTime, interpolation } = param;\n            const startTime = performance.now();\n            // Render world\n            this.world.render(deltaTime);\n            if (this.debugMode) {\n                this.renderTime = performance.now() - startTime;\n                this.frameTime = this.updateTime + this.renderTime;\n            }\n            this.emit(\"render\", {\n                deltaTime,\n                interpolation\n            });\n        });\n    }\n    destroy() {\n        this.stop();\n        // Clean up systems\n        this.world.destroy();\n        this.inputManager.destroy();\n        // Clear event listeners\n        this.removeAllListeners();\n        this.isInitialized = false;\n    }\n    // Utility methods for common operations\n    requestPointerLock() {\n        this.inputManager.requestPointerLock();\n    }\n    exitPointerLock() {\n        this.inputManager.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.inputManager.isKeyPressed(key);\n    }\n    isMouseButtonPressed(button) {\n        return this.inputManager.isMouseButtonPressed(button);\n    }\n    getMouseDelta() {\n        return this.inputManager.getMouseDelta();\n    }\n    constructor(config = {}){\n        super();\n        this.canvas = null;\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.debugMode = false;\n        // Performance monitoring\n        this.frameTime = 0;\n        this.updateTime = 0;\n        this.renderTime = 0;\n        this.world = new _ecs_World__WEBPACK_IMPORTED_MODULE_0__.World();\n        this.gameLoop = new _GameLoop__WEBPACK_IMPORTED_MODULE_1__.GameLoop();\n        this.inputManager = new _InputManager__WEBPACK_IMPORTED_MODULE_2__.InputManager();\n        this.debugMode = config.enableDebug || false;\n        this.setupGameLoop();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0VuZ2luZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHdDQUF3QztBQUNKO0FBQ0U7QUFDUTtBQUNNO0FBUTdDLE1BQU1JLGVBQWVELDZEQUFZQTtJQXlCdEMsTUFBYUUsV0FBV0MsTUFBeUIsRUFBaUI7UUFDaEUsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QkMsUUFBUUMsSUFBSSxDQUFDO1lBQ2I7UUFDRjtRQUVBLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0ksWUFBWSxDQUFDTCxVQUFVLENBQUNDO1FBRTdCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0ksSUFBSSxDQUFDO0lBRVo7SUFFT0MsUUFBYztRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDTCxhQUFhLEVBQUU7WUFDdkIsTUFBTSxJQUFJTSxNQUFNO1FBQ2xCO1FBRUEsSUFBSSxJQUFJLENBQUNDLFNBQVMsRUFBRTtZQUNsQk4sUUFBUUMsSUFBSSxDQUFDO1lBQ2I7UUFDRjtRQUVBLElBQUksQ0FBQ0ssU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDSCxLQUFLO1FBQ25CLElBQUksQ0FBQ0QsSUFBSSxDQUFDO0lBR1o7SUFFT0ssT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDRixTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUk7UUFDbEIsSUFBSSxDQUFDTCxJQUFJLENBQUM7SUFHWjtJQUVPTSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDSCxTQUFTLEVBQUU7WUFDbEIsSUFBSSxDQUFDQyxRQUFRLENBQUNFLEtBQUs7WUFDbkIsSUFBSSxDQUFDTixJQUFJLENBQUM7UUFDWjtJQUNGO0lBRU9PLFNBQWU7UUFDcEIsSUFBSSxJQUFJLENBQUNKLFNBQVMsRUFBRTtZQUNsQixJQUFJLENB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LGtCQUF3QjtRQUM3QixJQUFJLENBQUN0QyxZQUFZLENBQUNzQyxlQUFlO0lBQ25DO0lBRU9DLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ3hDLFlBQVksQ0FBQ3VDLFlBQVksQ0FBQ0M7SUFDeEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUMxQyxZQUFZLENBQUN5QyxvQkFBb0IsQ0FBQ0M7SUFDaEQ7SUFFT0MsZ0JBQTBDO1FBQy9DLE9BQU8sSUFBSSxDQUFDM0MsWUFBWSxDQUFDMkMsYUFBYTtJQUN4QztJQXBMQUMsWUFBWUMsU0FBdUIsQ0FBQyxDQUFDLENBQUU7UUFDckMsS0FBSzthQVhDakQsU0FBbUM7YUFDbkNDLGdCQUFnQjthQUNoQk8sWUFBWTthQUNaa0IsWUFBWTtRQUVwQix5QkFBeUI7YUFDakJMLFlBQVk7YUFDWkMsYUFBYTthQUNiQyxhQUFhO1FBS25CLElBQUksQ0FBQ1QsS0FBSyxHQUFHLElBQUlwQiw2Q0FBS0E7UUFDdEIsSUFBSSxDQUFDZSxRQUFRLEdBQUcsSUFBSWQsK0NBQVFBO1FBQzVCLElBQUksQ0FBQ1MsWUFBWSxHQUFHLElBQUlSLHVEQUFZQTtRQUNwQyxJQUFJLENBQUM4QixTQUFTLEdBQUd1QixPQUFPQyxXQUFXLElBQUk7UUFFdkMsSUFBSSxDQUFDdEIsYUFBYTtJQUNwQjtBQTRLRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9FbmdpbmUudHM/MmY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYWluIGdhbWUgZW5naW5lIHdpdGggRUNTIGludGVncmF0aW9uXG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IEdhbWVMb29wIH0gZnJvbSAnLi9HYW1lTG9vcCc7XG5pbXBvcnQgeyBJbnB1dE1hbmFnZXIgfSBmcm9tICcuL0lucHV0TWFuYWdlcic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW5naW5lQ29uZmlnIHtcbiAgY2FudmFzPzogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGVuYWJsZURlYnVnPzogYm9vbGVhbjtcbiAgdGFyZ2V0RlBTPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRW5naW5lIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgZ2FtZUxvb3A6IEdhbWVMb29wO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgaXNSdW5uaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgZGVidWdNb2RlID0gZmFsc2U7XG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lVGltZSA9IDA7XG4gIHByaXZhdGUgdXBkYXRlVGltZSA9IDA7XG4gIHByaXZhdGUgcmVuZGVyVGltZSA9IDA7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBFbmdpbmVDb25maWcgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy53b3JsZCA9IG5ldyBXb3JsZCgpO1xuICAgIHRoaXMuZ2FtZUxvb3AgPSBuZXcgR2FtZUxvb3AoKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IG5ldyBJbnB1dE1hbmFnZXIoKTtcbiAgICB0aGlzLmRlYnVnTW9kZSA9IGNvbmZpZy5lbmFibGVEZWJ1ZyB8fCBmYWxzZTtcblxuICAgIHRoaXMuc2V0dXBHYW1lTG9vcCgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybignRW5naW5lIGFscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmlucHV0TWFuYWdlci5pbml0aWFsaXplKGNhbnZhcyk7XG4gICAgXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJyk7XG4gICAgXG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW5naW5lIG11c3QgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHN0YXJ0aW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0VuZ2luZSBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5nYW1lTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZW1pdCgnc3RhcnRlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUxvb3Auc3RvcCgpO1xuICAgIHRoaXMuZW1pdCgnc3RvcHBlZCcpO1xuICAgIFxuXG4gIH1cblxuICBwdWJsaWMgcGF1c2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnBhdXNlKCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhdXNlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLmdhbWVMb29wLnJlc3VtZSgpO1xuICAgICAgdGhpcy5lbWl0KCdyZXN1bWVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFdvcmxkKCk6IFdvcmxkIHtcbiAgICByZXR1cm4gdGhpcy53b3JsZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnB1dE1hbmFnZXIoKTogSW5wdXRNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXI7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FudmFzKCk6IEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG5cbiAgcHVibGljIGlzRW5naW5lUnVubmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1J1bm5pbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdhbWVMb29wLmdldEN1cnJlbnRGUFMoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmcHM6IHRoaXMuZ2FtZUxvb3AuZ2V0Q3VycmVudEZQUygpLFxuICAgICAgZnJhbWVUaW1lOiB0aGlzLmZyYW1lVGltZSxcbiAgICAgIHVwZGF0ZVRpbWU6IHRoaXMudXBkYXRlVGltZSxcbiAgICAgIHJlbmRlclRpbWU6IHRoaXMucmVuZGVyVGltZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVuYWJsZURlYnVnTW9kZShlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1Z01vZGUgPSBlbmFibGVkO1xuICB9XG5cbiAgcHVibGljIGlzRGVidWdNb2RlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmRlYnVnTW9kZTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBHYW1lTG9vcCgpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgZml4ZWQgdGltZXN0ZXAgdXBkYXRlcyAocGh5c2ljcylcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdmaXhlZFVwZGF0ZScsICh7IGZpeGVkRGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICB0aGlzLndvcmxkLmZpeGVkVXBkYXRlKGZpeGVkRGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXMgKGdhbWUgbG9naWMpXG4gICAgdGhpcy5nYW1lTG9vcC5vbigndXBkYXRlJywgKHsgZGVsdGFUaW1lIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgd29ybGQgc3lzdGVtcyBmaXJzdCBzbyB0aGV5IGNhbiByZWFkIGlucHV0IGRlbHRhc1xuICAgICAgdGhpcy53b3JsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGlucHV0IG1hbmFnZXIgYWZ0ZXIgc3lzdGVtcyBoYXZlIHByb2Nlc3NlZCBpbnB1dFxuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIudXBkYXRlKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGRlbHRhVGltZSB9KTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZW5kZXJpbmdcbiAgICB0aGlzLmdhbWVMb29wLm9uKCdyZW5kZXInLCAoeyBkZWx0YVRpbWUsIGludGVycG9sYXRpb24gfSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciB3b3JsZFxuICAgICAgdGhpcy53b3JsZC5yZW5kZXIoZGVsdGFUaW1lKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmZyYW1lVGltZSA9IHRoaXMudXBkYXRlVGltZSArIHRoaXMucmVuZGVyVGltZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICB0aGlzLndvcmxkLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICBcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0TWFuYWdlci5yZXF1ZXN0UG9pbnRlckxvY2soKTtcbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgdGhpcy5pbnB1dE1hbmFnZXIuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZChrZXkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0TW91c2VEZWx0YSgpOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0ge1xuICAgIHJldHVybiB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJXb3JsZCIsIkdhbWVMb29wIiwiSW5wdXRNYW5hZ2VyIiwiRXZlbnRFbWl0dGVyIiwiRW5naW5lIiwiaW5pdGlhbGl6ZSIsImNhbnZhcyIsImlzSW5pdGlhbGl6ZWQiLCJjb25zb2xlIiwid2FybiIsImlucHV0TWFuYWdlciIsImVtaXQiLCJzdGFydCIsIkVycm9yIiwiaXNSdW5uaW5nIiwiZ2FtZUxvb3AiLCJzdG9wIiwicGF1c2UiLCJyZXN1bWUiLCJnZXRXb3JsZCIsIndvcmxkIiwiZ2V0SW5wdXRNYW5hZ2VyIiwiZ2V0Q2FudmFzIiwiaXNFbmdpbmVSdW5uaW5nIiwiZ2V0Q3VycmVudEZQUyIsImdldFBlcmZvcm1hbmNlU3RhdHMiLCJmcHMiLCJmcmFtZVRpbWUiLCJ1cGRhdGVUaW1lIiwicmVuZGVyVGltZSIsImVuYWJsZURlYnVnTW9kZSIsImVuYWJsZWQiLCJkZWJ1Z01vZGUiLCJpc0RlYnVnTW9kZSIsInNldHVwR2FtZUxvb3AiLCJvbiIsImZpeGVkRGVsdGFUaW1lIiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJmaXhlZFVwZGF0ZSIsImRlbHRhVGltZSIsInVwZGF0ZSIsImludGVycG9sYXRpb24iLCJyZW5kZXIiLCJkZXN0cm95IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVxdWVzdFBvaW50ZXJMb2NrIiwiZXhpdFBvaW50ZXJMb2NrIiwiaXNLZXlQcmVzc2VkIiwia2V5IiwiaXNNb3VzZUJ1dHRvblByZXNzZWQiLCJidXR0b24iLCJnZXRNb3VzZURlbHRhIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJlbmFibGVEZWJ1ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/Engine.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/GameLoop.ts":
/*!******************************!*\
  !*** ./src/core/GameLoop.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameLoop: function() { return /* binding */ GameLoop; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Optimized game loop with fixed timestep physics\n\nclass GameLoop extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    start() {\n        if (this.isRunning) return;\n        this.isRunning = true;\n        this.lastTime = performance.now();\n        this.accumulator = 0;\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    stop() {\n        if (!this.isRunning) return;\n        this.isRunning = false;\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = 0;\n        }\n    }\n    getCurrentFPS() {\n        return this.currentFPS;\n    }\n    getFixedTimeStep() {\n        return this.fixedTimeStep;\n    }\n    gameLoop(currentTime) {\n        if (!this.isRunning) return;\n        // Calculate delta time and clamp it to prevent large jumps\n        const deltaTime = Math.min((currentTime - this.lastTime) / 1000, this.maxFrameTime);\n        this.lastTime = currentTime;\n        this.currentTime = currentTime;\n        // Update FPS counter\n        this.updateFPS(deltaTime);\n        // Accumulate time for fixed timestep physics\n        this.accumulator += deltaTime;\n        // Fixed timestep physics updates\n        let subSteps = 0;\n        while(this.accumulator >= this.fixedTimeStep && subSteps < this.maxSubSteps){\n            this.emit(\"fixedUpdate\", {\n                fixedDeltaTime: this.fixedTimeStep\n            });\n            this.accumulator -= this.fixedTimeStep;\n            subSteps++;\n        }\n        // Variable timestep game logic update\n        this.emit(\"update\", {\n            deltaTime\n        });\n        // Calculate interpolation factor for smooth rendering\n        const interpolation = this.accumulator / this.fixedTimeStep;\n        // Render with interpolation\n        this.emit(\"render\", {\n            deltaTime,\n            interpolation\n        });\n        // Schedule next frame\n        this.frameId = requestAnimationFrame(this.gameLoop.bind(this));\n    }\n    updateFPS(deltaTime) {\n        this.frameCount++;\n        this.fpsUpdateTime += deltaTime;\n        // Update FPS every second\n        if (this.fpsUpdateTime >= 1.0) {\n            this.currentFPS = Math.round(this.frameCount / this.fpsUpdateTime);\n            this.frameCount = 0;\n            this.fpsUpdateTime = 0;\n        }\n    }\n    pause() {\n        if (this.isRunning) {\n            this.stop();\n        }\n    }\n    resume() {\n        if (!this.isRunning) {\n            this.start();\n        }\n    }\n    isPaused() {\n        return !this.isRunning;\n    }\n    // Get current time for systems that need it\n    getCurrentTime() {\n        return this.currentTime;\n    }\n    // Get accumulator ratio for interpolation\n    getInterpolationRatio() {\n        return this.accumulator / this.fixedTimeStep;\n    }\n    constructor(){\n        super();\n        this.isRunning = false;\n        this.lastTime = 0;\n        this.accumulator = 0;\n        this.currentTime = 0;\n        this.frameId = 0;\n        // Performance settings\n        this.fixedTimeStep = 1 / 60 // 60 FPS physics\n        ;\n        this.maxFrameTime = 1 / 30 // Prevent spiral of death at 30 FPS\n        ;\n        this.maxSubSteps = 5 // Maximum physics substeps per frame\n        ;\n        // Performance monitoring\n        this.frameCount = 0;\n        this.fpsUpdateTime = 0;\n        this.currentFPS = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0dhbWVMb29wLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0RBQWtEO0FBQ0U7QUFRN0MsTUFBTUMsaUJBQWlCRCw2REFBWUE7SUFxQmpDRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDQyxTQUFTLEVBQUU7UUFFcEIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVlDLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUdDLHNCQUFzQixJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7SUFDOUQ7SUFFT0MsT0FBYTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDVCxTQUFTLEVBQUU7UUFFckIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDakIsSUFBSSxJQUFJLENBQUNLLE9BQU8sRUFBRTtZQUNoQksscUJBQXFCLElBQUksQ0FBQ0wsT0FBTztZQUNqQyxJQUFJLENBQUNBLE9BQU8sR0FBRztRQUNqQjtJQUNGO0lBRU9NLGdCQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUN4QjtJQUVPQyxtQkFBMkI7UUFDaEMsT0FBTyxJQUFJLENBQUNDLGFBQWE7SUFDM0I7SUFFUVAsU0FBU1EsV0FBbUIsRUFBUTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDZixTQUFTLEVBQUU7UUFFckIsMkRBQTJEO1FBQzNELE1BQU1nQixZQUFZQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsY0FBYyxJQUFJLENBQUNkLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQ2tCLFlBQVk7UUFDbEYsSUFBSSxDQUFDbEIsUUFBUSxHQUFHYztRQUNoQixJQUFJLENBQUNBLFdBQVcsR0FBR0E7UUFFbkIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssU0FBUyxDQUFDSjtRQUVmLDZDQUE2QztRQUM3QyxJQUFJLENBQUNaLFdBQVcsSUFBSVk7UUFFcEIsaUNBQWlDO1FBQ2pDLElBQUlLLFdBQVc7UUFDZixNQUFPLElBQUksQ0FBQ2pCLFdBQVcsSUFBSSxJQUFJLENBQUNVLGFBQWEsSUFBSU8sV0FBVyxJQUFJLENBQUNDLFdBQVcsQ0FBRTtZQUM1RSxJQUFJLENBQUNDLElBQUksQ0FBQyxlQUFlO2dCQUFFQyxnQkFBZ0IsSUFBSSxDQUFDVixhQUFhO1lBQUM7WUFDOUQsSUFBSSxDQUFDVixXQUFXLElBQUksSUFBSSxDQUFDVSxhQUFhO1lBQ3RDTztRQUNGO1FBRUEsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVU7WUFBRVA7UUFBVTtRQUVoQyxzREFBc0Q7UUFDdEQsTUFBTVMsZ0JBQWdCLElBQUksQ0FBQ3JCLFdBQVcsR0FBRyxJQUFJLENBQUNVLGFBQWE7UUFFM0QsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ1MsSUFBSSxDQUFDLFVBQVU7WUFBRVA7WUFBV1M7UUFBYztRQUUvQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHQyxzQkFBc0IsSUFBSSxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzlEO0lBRVFZLFVBQVVKLFNBQWlCLEVBQVE7UUFDekMsSUFBSSxDQUFDVSxVQUFVO1FBQ2YsSUFBSSxDQUFDQyxhQUFhLElBQUlYO1FBRXRCLDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQ1csYUFBYSxJQUFJLEtBQUs7WUFDN0IsSUFBSSxDQUFDZixVQUFVLEdBQUdLLEtBQUtXLEtBQUssQ0FBQyxJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLENBQUNDLGFBQWE7WUFDakUsSUFBSSxDQUFDRCxVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDdkI7SUFDRjtJQUVPRSxRQUFjO1FBQ25CLElBQUksSUFBSSxDQUFDN0IsU0FBUyxFQUFFO1lBQ2xCLElBQUksQ0FBQ1MsSUFBSTtRQUNYO0lBQ0Y7SUFFT3FCLFNBQWU7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQzlCLFNBQVMsRUFBRTtZQUNuQixJQUFJLENBQUNELEtBQUs7UUFDWjtJQUNGO0lBRU9nQyxXQUFvQjtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDL0IsU0FBUztJQUN4QjtJQUVBLDRDQUE0QztJQUNyQ2dDLGlCQUF5QjtRQUM5QixPQUFPLElBQUksQ0FBQ2pCLFdBQVc7SUFDekI7SUFFQSwwQ0FBMEM7SUFDbkNrQix3QkFBZ0M7UUFDckMsT0FBTyxJQUFJLENBQUM3QixXQUFXLEdBQUcsSUFBSSxDQUFDVSxhQUFhO0lBQzlDO0lBdEdBb0IsYUFBYztRQUNaLEtBQUs7YUFqQkNsQyxZQUFZO2FBQ1pDLFdBQVc7YUFDWEcsY0FBYzthQUNkVyxjQUFjO2FBQ2RWLFVBQVU7UUFFbEIsdUJBQXVCO2FBQ05TLGdCQUFnQixJQUFJLEdBQUksaUJBQWlCOzthQUN6Q0ssZUFBZSxJQUFJLEdBQUssb0NBQW9DOzthQUM1REcsY0FBYyxFQUFVLHFDQUFxQzs7UUFFOUUseUJBQXlCO2FBQ2pCSSxhQUFhO2FBQ2JDLGdCQUFnQjthQUNoQmYsYUFBYTtJQUlyQjtBQXFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29yZS9HYW1lTG9vcC50cz82ZTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9wdGltaXplZCBnYW1lIGxvb3Agd2l0aCBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAL3V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2FtZUxvb3BFdmVudHMge1xuICB1cGRhdGU6IHsgZGVsdGFUaW1lOiBudW1iZXIgfTtcbiAgZml4ZWRVcGRhdGU6IHsgZml4ZWREZWx0YVRpbWU6IG51bWJlciB9O1xuICByZW5kZXI6IHsgZGVsdGFUaW1lOiBudW1iZXI7IGludGVycG9sYXRpb246IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgR2FtZUxvb3AgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGlzUnVubmluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3RUaW1lID0gMDtcbiAgcHJpdmF0ZSBhY2N1bXVsYXRvciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFRpbWUgPSAwO1xuICBwcml2YXRlIGZyYW1lSWQgPSAwO1xuXG4gIC8vIFBlcmZvcm1hbmNlIHNldHRpbmdzXG4gIHByaXZhdGUgcmVhZG9ubHkgZml4ZWRUaW1lU3RlcCA9IDEgLyA2MDsgLy8gNjAgRlBTIHBoeXNpY3NcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGcmFtZVRpbWUgPSAxIC8gMzA7ICAvLyBQcmV2ZW50IHNwaXJhbCBvZiBkZWF0aCBhdCAzMCBGUFNcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhTdWJTdGVwcyA9IDU7ICAgICAgICAvLyBNYXhpbXVtIHBoeXNpY3Mgc3Vic3RlcHMgcGVyIGZyYW1lXG5cbiAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICBwcml2YXRlIGZyYW1lQ291bnQgPSAwO1xuICBwcml2YXRlIGZwc1VwZGF0ZVRpbWUgPSAwO1xuICBwcml2YXRlIGN1cnJlbnRGUFMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuYWNjdW11bGF0b3IgPSAwO1xuICAgIHRoaXMuZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVMb29wLmJpbmQodGhpcykpO1xuICB9XG5cbiAgcHVibGljIHN0b3AoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gMDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0Q3VycmVudEZQUygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRGUFM7XG4gIH1cblxuICBwdWJsaWMgZ2V0Rml4ZWRUaW1lU3RlcCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZVN0ZXA7XG4gIH1cblxuICBwcml2YXRlIGdhbWVMb29wKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSByZXR1cm47XG5cbiAgICAvLyBDYWxjdWxhdGUgZGVsdGEgdGltZSBhbmQgY2xhbXAgaXQgdG8gcHJldmVudCBsYXJnZSBqdW1wc1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKChjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWUpIC8gMTAwMCwgdGhpcy5tYXhGcmFtZVRpbWUpO1xuICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnVwZGF0ZUZQUyhkZWx0YVRpbWUpO1xuXG4gICAgLy8gQWNjdW11bGF0ZSB0aW1lIGZvciBmaXhlZCB0aW1lc3RlcCBwaHlzaWNzXG4gICAgdGhpcy5hY2N1bXVsYXRvciArPSBkZWx0YVRpbWU7XG5cbiAgICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZXNcbiAgICBsZXQgc3ViU3RlcHMgPSAwO1xuICAgIHdoaWxlICh0aGlzLmFjY3VtdWxhdG9yID49IHRoaXMuZml4ZWRUaW1lU3RlcCAmJiBzdWJTdGVwcyA8IHRoaXMubWF4U3ViU3RlcHMpIHtcbiAgICAgIHRoaXMuZW1pdCgnZml4ZWRVcGRhdGUnLCB7IGZpeGVkRGVsdGFUaW1lOiB0aGlzLmZpeGVkVGltZVN0ZXAgfSk7XG4gICAgICB0aGlzLmFjY3VtdWxhdG9yIC09IHRoaXMuZml4ZWRUaW1lU3RlcDtcbiAgICAgIHN1YlN0ZXBzKys7XG4gICAgfVxuXG4gICAgLy8gVmFyaWFibGUgdGltZXN0ZXAgZ2FtZSBsb2dpYyB1cGRhdGVcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZGVsdGFUaW1lIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yIGZvciBzbW9vdGggcmVuZGVyaW5nXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IHRoaXMuYWNjdW11bGF0b3IgLyB0aGlzLmZpeGVkVGltZVN0ZXA7XG5cbiAgICAvLyBSZW5kZXIgd2l0aCBpbnRlcnBvbGF0aW9uXG4gICAgdGhpcy5lbWl0KCdyZW5kZXInLCB7IGRlbHRhVGltZSwgaW50ZXJwb2xhdGlvbiB9KTtcblxuICAgIC8vIFNjaGVkdWxlIG5leHQgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lTG9vcC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRlBTKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgdGhpcy5mcHNVcGRhdGVUaW1lICs9IGRlbHRhVGltZTtcblxuICAgIC8vIFVwZGF0ZSBGUFMgZXZlcnkgc2Vjb25kXG4gICAgaWYgKHRoaXMuZnBzVXBkYXRlVGltZSA+PSAxLjApIHtcbiAgICAgIHRoaXMuY3VycmVudEZQUyA9IE1hdGgucm91bmQodGhpcy5mcmFtZUNvdW50IC8gdGhpcy5mcHNVcGRhdGVUaW1lKTtcbiAgICAgIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gICAgICB0aGlzLmZwc1VwZGF0ZVRpbWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXVzZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZXN1bWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBpc1BhdXNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nO1xuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgdGltZSBmb3Igc3lzdGVtcyB0aGF0IG5lZWQgaXRcbiAgcHVibGljIGdldEN1cnJlbnRUaW1lKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cblxuICAvLyBHZXQgYWNjdW11bGF0b3IgcmF0aW8gZm9yIGludGVycG9sYXRpb25cbiAgcHVibGljIGdldEludGVycG9sYXRpb25SYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmFjY3VtdWxhdG9yIC8gdGhpcy5maXhlZFRpbWVTdGVwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwiR2FtZUxvb3AiLCJzdGFydCIsImlzUnVubmluZyIsImxhc3RUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJhY2N1bXVsYXRvciIsImZyYW1lSWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJnYW1lTG9vcCIsImJpbmQiLCJzdG9wIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRDdXJyZW50RlBTIiwiY3VycmVudEZQUyIsImdldEZpeGVkVGltZVN0ZXAiLCJmaXhlZFRpbWVTdGVwIiwiY3VycmVudFRpbWUiLCJkZWx0YVRpbWUiLCJNYXRoIiwibWluIiwibWF4RnJhbWVUaW1lIiwidXBkYXRlRlBTIiwic3ViU3RlcHMiLCJtYXhTdWJTdGVwcyIsImVtaXQiLCJmaXhlZERlbHRhVGltZSIsImludGVycG9sYXRpb24iLCJmcmFtZUNvdW50IiwiZnBzVXBkYXRlVGltZSIsInJvdW5kIiwicGF1c2UiLCJyZXN1bWUiLCJpc1BhdXNlZCIsImdldEN1cnJlbnRUaW1lIiwiZ2V0SW50ZXJwb2xhdGlvblJhdGlvIiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/GameLoop.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/core/InputManager.ts":
/*!**********************************!*\
  !*** ./src/core/InputManager.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputManager: function() { return /* binding */ InputManager; }\n/* harmony export */ });\n/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/EventEmitter */ \"(app-pages-browser)/./src/utils/EventEmitter.ts\");\n// Centralized input handling system\n\nclass InputManager extends _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n    initialize(canvas) {\n        this.canvas = canvas;\n        // Add canvas-specific event listeners to ensure we capture events\n        // that might be handled by React Three Fiber\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        canvas.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        canvas.addEventListener(\"wheel\", this.onWheel.bind(this));\n        canvas.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n    // Don't automatically request pointer lock - let systems handle this\n    // canvas.addEventListener('click', () => {\n    //   if (!this.isPointerLocked) {\n    //     this.requestPointerLock();\n    //   }\n    // });\n    }\n    requestPointerLock() {\n        if (this.canvas) {\n            this.canvas.requestPointerLock();\n        }\n    }\n    exitPointerLock() {\n        document.exitPointerLock();\n    }\n    isKeyPressed(key) {\n        return this.keys.has(key.toLowerCase());\n    }\n    isMouseButtonPressed(button) {\n        return this.mouseButtons.has(button);\n    }\n    getMousePosition() {\n        return {\n            ...this.mousePosition\n        };\n    }\n    getMouseDelta() {\n        return {\n            ...this.mouseDelta\n        };\n    }\n    getInputState() {\n        return {\n            keys: new Set(this.keys),\n            mouse: {\n                x: this.mousePosition.x,\n                y: this.mousePosition.y,\n                deltaX: this.mouseDelta.x,\n                deltaY: this.mouseDelta.y,\n                buttons: new Set(this.mouseButtons)\n            }\n        };\n    }\n    checkDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return false;\n        const now = Date.now();\n        // Only return true if we have a valid double-tap sequence:\n        // 1. We have a valid first tap (press + release)\n        // 2. We're currently in a double-tap sequence\n        // 3. The second press happened within the threshold after the first release\n        if (timing.hasValidFirstTap && timing.isInDoubleTapSequence && timing.secondPressTime > 0) {\n            const timeBetweenTaps = timing.secondPressTime - timing.firstReleaseTime;\n            return timeBetweenTaps <= this.DOUBLE_TAP_THRESHOLD;\n        }\n        return false;\n    }\n    resetDoubleTap(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (timing) {\n            timing.firstPressTime = 0;\n            timing.firstReleaseTime = 0;\n            timing.secondPressTime = 0;\n            timing.isInDoubleTapSequence = false;\n            timing.hasValidFirstTap = false;\n        }\n    }\n    update() {\n        // Reset mouse delta each frame\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n        // Clean up old timing entries to prevent memory leaks\n        this.cleanupOldTimings();\n    }\n    cleanupOldTimings() {\n        const now = Date.now();\n        const CLEANUP_THRESHOLD = 5000; // 5 seconds\n        const keysToDelete = [];\n        // Use forEach instead of for...of to avoid ES2015 iteration issues\n        this.keyTimings.forEach((timing, key)=>{\n            // Remove entries that haven't been used in a while\n            const lastActivity = Math.max(timing.firstPressTime, timing.firstReleaseTime, timing.secondPressTime);\n            if (lastActivity > 0 && now - lastActivity > CLEANUP_THRESHOLD) {\n                keysToDelete.push(key);\n            }\n        });\n        // Delete the keys after iteration to avoid modifying map during iteration\n        keysToDelete.forEach((key)=>this.keyTimings.delete(key));\n    }\n    // Debug method to help track double tap detection\n    getDoubleTapDebugInfo(key) {\n        const keyLower = key.toLowerCase();\n        const timing = this.keyTimings.get(keyLower);\n        if (!timing) return null;\n        const now = Date.now();\n        return {\n            key: keyLower,\n            firstPressTime: timing.firstPressTime,\n            firstReleaseTime: timing.firstReleaseTime,\n            secondPressTime: timing.secondPressTime,\n            hasValidFirstTap: timing.hasValidFirstTap,\n            isInDoubleTapSequence: timing.isInDoubleTapSequence,\n            timeSinceFirstPress: timing.firstPressTime > 0 ? now - timing.firstPressTime : 0,\n            timeSinceFirstRelease: timing.firstReleaseTime > 0 ? now - timing.firstReleaseTime : 0,\n            timeSinceSecondPress: timing.secondPressTime > 0 ? now - timing.secondPressTime : 0,\n            threshold: this.DOUBLE_TAP_THRESHOLD\n        };\n    }\n    setupEventListeners() {\n        // Keyboard events\n        document.addEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.addEventListener(\"keyup\", this.onKeyUp.bind(this));\n        // Mouse events\n        document.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.addEventListener(\"wheel\", this.onWheel.bind(this));\n        // Pointer lock events\n        document.addEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.addEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        // Prevent context menu\n        document.addEventListener(\"contextmenu\", (e)=>e.preventDefault());\n        // Handle window focus/blur to reset input state\n        window.addEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.addEventListener(\"focus\", this.onWindowFocus.bind(this));\n    }\n    onKeyDown(event) {\n        const key = event.key.toLowerCase();\n        if (!this.keys.has(key)) {\n            this.keys.add(key);\n            this.emit(\"keyDown\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key timing for double-tap detection\n            const now = Date.now();\n            let timing = this.keyTimings.get(key);\n            if (!timing) {\n                timing = {\n                    firstPressTime: 0,\n                    firstReleaseTime: 0,\n                    secondPressTime: 0,\n                    isInDoubleTapSequence: false,\n                    hasValidFirstTap: false\n                };\n                this.keyTimings.set(key, timing);\n            }\n            // Handle double-tap sequence logic\n            if (!timing.hasValidFirstTap) {\n                // This is the first press\n                timing.firstPressTime = now;\n                timing.isInDoubleTapSequence = false;\n                timing.hasValidFirstTap = false; // Will be set to true on release\n            } else if (timing.hasValidFirstTap && !timing.isInDoubleTapSequence) {\n                // This could be the second press - check if it's within threshold\n                const timeSinceFirstRelease = now - timing.firstReleaseTime;\n                if (timeSinceFirstRelease <= this.DOUBLE_TAP_THRESHOLD) {\n                    // Valid second press\n                    timing.secondPressTime = now;\n                    timing.isInDoubleTapSequence = true;\n                } else {\n                    // Too late for double-tap, treat as new first press\n                    timing.firstPressTime = now;\n                    timing.firstReleaseTime = 0;\n                    timing.secondPressTime = 0;\n                    timing.isInDoubleTapSequence = false;\n                    timing.hasValidFirstTap = false;\n                }\n            }\n        }\n        // Prevent default for game keys\n        if (this.isGameKey(key)) {\n            event.preventDefault();\n        }\n    }\n    onKeyUp(event) {\n        const key = event.key.toLowerCase();\n        if (this.keys.has(key)) {\n            this.keys.delete(key);\n            this.emit(\"keyUp\", {\n                key: event.key,\n                code: event.code\n            });\n            // Track key release timing for double-tap detection\n            const timing = this.keyTimings.get(key);\n            if (timing) {\n                const now = Date.now();\n                if (!timing.hasValidFirstTap && timing.firstPressTime > 0) {\n                    // This completes the first tap\n                    timing.firstReleaseTime = now;\n                    timing.hasValidFirstTap = true;\n                } else if (timing.isInDoubleTapSequence) {\n                    // This completes the double-tap sequence\n                    // The double-tap detection should have already been triggered\n                    // Reset for next potential sequence\n                    setTimeout(()=>{\n                        if (timing) {\n                            timing.firstPressTime = 0;\n                            timing.firstReleaseTime = 0;\n                            timing.secondPressTime = 0;\n                            timing.isInDoubleTapSequence = false;\n                            timing.hasValidFirstTap = false;\n                        }\n                    }, 100); // Small delay to allow dash system to process\n                }\n            }\n        }\n    }\n    onMouseDown(event) {\n        this.mouseButtons.add(event.button);\n        this.emit(\"mouseDown\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseUp(event) {\n        this.mouseButtons.delete(event.button);\n        this.emit(\"mouseUp\", {\n            button: event.button,\n            x: event.clientX,\n            y: event.clientY\n        });\n    }\n    onMouseMove(event) {\n        if (this.isPointerLocked) {\n            // Use movement deltas when pointer is locked\n            this.mouseDelta.x += event.movementX;\n            this.mouseDelta.y += event.movementY;\n        } else {\n            // Use absolute position when not locked\n            this.previousMousePosition.x = this.mousePosition.x;\n            this.previousMousePosition.y = this.mousePosition.y;\n            this.mousePosition.x = event.clientX;\n            this.mousePosition.y = event.clientY;\n            // Calculate delta from previous position\n            const deltaX = this.mousePosition.x - this.previousMousePosition.x;\n            const deltaY = this.mousePosition.y - this.previousMousePosition.y;\n            // Accumulate delta for this frame\n            this.mouseDelta.x += deltaX;\n            this.mouseDelta.y += deltaY;\n        }\n        this.emit(\"mouseMove\", {\n            x: this.mousePosition.x,\n            y: this.mousePosition.y,\n            deltaX: this.mouseDelta.x,\n            deltaY: this.mouseDelta.y\n        });\n    }\n    onWheel(event) {\n        this.emit(\"wheel\", {\n            deltaX: event.deltaX,\n            deltaY: event.deltaY,\n            deltaZ: event.deltaZ\n        });\n        event.preventDefault();\n    }\n    onPointerLockChange() {\n        this.isPointerLocked = document.pointerLockElement !== null;\n    }\n    onPointerLockError() {\n        console.warn(\"Pointer lock failed\");\n        this.isPointerLocked = false;\n    }\n    onWindowBlur() {\n        // Clear all input state when window loses focus\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n    }\n    onWindowFocus() {\n        // Reset mouse delta when window regains focus\n        this.mouseDelta.x = 0;\n        this.mouseDelta.y = 0;\n    }\n    isGameKey(key) {\n        // Define which keys should have their default behavior prevented\n        const gameKeys = [\n            \"w\",\n            \"a\",\n            \"s\",\n            \"d\",\n            \" \",\n            \"shift\",\n            \"tab\",\n            \"escape\"\n        ];\n        return gameKeys.includes(key);\n    }\n    destroy() {\n        // Remove document event listeners\n        document.removeEventListener(\"keydown\", this.onKeyDown.bind(this));\n        document.removeEventListener(\"keyup\", this.onKeyUp.bind(this));\n        document.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n        document.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n        document.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n        document.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        document.removeEventListener(\"pointerlockchange\", this.onPointerLockChange.bind(this));\n        document.removeEventListener(\"pointerlockerror\", this.onPointerLockError.bind(this));\n        window.removeEventListener(\"blur\", this.onWindowBlur.bind(this));\n        window.removeEventListener(\"focus\", this.onWindowFocus.bind(this));\n        // Remove canvas event listeners if canvas exists\n        if (this.canvas) {\n            this.canvas.removeEventListener(\"mousedown\", this.onMouseDown.bind(this));\n            this.canvas.removeEventListener(\"mouseup\", this.onMouseUp.bind(this));\n            this.canvas.removeEventListener(\"mousemove\", this.onMouseMove.bind(this));\n            this.canvas.removeEventListener(\"wheel\", this.onWheel.bind(this));\n        }\n        // Clear state\n        this.keys.clear();\n        this.mouseButtons.clear();\n        this.keyTimings.clear();\n        this.removeAllListeners();\n    }\n    constructor(){\n        super();\n        this.keys = new Set();\n        this.mouseButtons = new Set();\n        this.mousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.mouseDelta = {\n            x: 0,\n            y: 0\n        };\n        this.previousMousePosition = {\n            x: 0,\n            y: 0\n        };\n        this.isPointerLocked = false;\n        this.canvas = null;\n        // Double-tap detection for dash system\n        this.keyTimings = new Map();\n        this.DOUBLE_TAP_THRESHOLD = 200 // 200ms window for double-tap (reduced from 250ms)\n        ;\n        this.setupEventListeners();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLG9DQUFvQztBQUNnQjtBQXNCN0MsTUFBTUMscUJBQXFCRCw2REFBWUE7SUF3QnJDRSxXQUFXQyxNQUF5QixFQUFRO1FBQ2pELElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUVkLGtFQUFrRTtRQUNsRSw2Q0FBNkM7UUFDN0NBLE9BQU9DLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDQyxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQy9ESCxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQ0csU0FBUyxDQUFDRCxJQUFJLENBQUMsSUFBSTtRQUMzREgsT0FBT0MsZ0JBQWdCLENBQUMsYUFBYSxJQUFJLENBQUNJLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDL0RILE9BQU9DLGdCQUFnQixDQUFDLFNBQVMsSUFBSSxDQUFDSyxPQUFPLENBQUNILElBQUksQ0FBQyxJQUFJO1FBQ3ZESCxPQUFPQyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUNNLElBQU1BLEVBQUVDLGNBQWM7SUFFOUQscUVBQXFFO0lBQ3JFLDJDQUEyQztJQUMzQyxpQ0FBaUM7SUFDakMsaUNBQWlDO0lBQ2pDLE1BQU07SUFDTixNQUFNO0lBQ1I7SUFFT0MscUJBQTJCO1FBQ2hDLElBQUksSUFBSSxDQUFDVCxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUNBLE1BQU0sQ0FBQ1Msa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFT0Msa0JBQXdCO1FBQzdCQyxTQUFTRCxlQUFlO0lBQzFCO0lBRU9FLGFBQWFDLEdBQVcsRUFBVztRQUN4QyxPQUFPLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxHQUFHLENBQUNGLElBQUlHLFdBQVc7SUFDdEM7SUFFT0MscUJBQXFCQyxNQUFjLEVBQVc7UUFDbkQsT0FBTyxJQUFJLENBQUNDLFlBQVksQ0FBQ0osR0FBRyxDQUFDRztJQUMvQjtJQUVPRSxt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QUNwRSxZQUFZLENBQUNvRSxLQUFLO1FBQ3ZCLElBQUksQ0FBQ3BELFVBQVUsQ0FBQ29ELEtBQUs7UUFDckIsSUFBSSxDQUFDSyxrQkFBa0I7SUFDekI7SUFwWEFDLGFBQWM7UUFDWixLQUFLO2FBbkJDL0UsT0FBTyxJQUFJVzthQUNYTixlQUFlLElBQUlNO2FBQ25CSixnQkFBZ0I7WUFBRU0sR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDN0JMLGFBQWE7WUFBRUksR0FBRztZQUFHQyxHQUFHO1FBQUU7YUFDMUJzRCx3QkFBd0I7WUFBRXZELEdBQUc7WUFBR0MsR0FBRztRQUFFO2FBQ3JDbUQsa0JBQWtCO2FBQ2xCL0UsU0FBbUM7UUFFM0MsdUNBQXVDO2FBQy9CbUMsYUFBYSxJQUFJMkQ7YUFPUmxELHVCQUF1QixJQUFLLG1EQUFtRDs7UUFJOUYsSUFBSSxDQUFDa0IsbUJBQW1CO0lBQzFCO0FBa1hGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb3JlL0lucHV0TWFuYWdlci50cz8wZDEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENlbnRyYWxpemVkIGlucHV0IGhhbmRsaW5nIHN5c3RlbVxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQC91dGlscy9FdmVudEVtaXR0ZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIElucHV0RXZlbnRzIHtcbiAga2V5RG93bjogeyBrZXk6IHN0cmluZzsgY29kZTogc3RyaW5nIH07XG4gIGtleVVwOiB7IGtleTogc3RyaW5nOyBjb2RlOiBzdHJpbmcgfTtcbiAgbW91c2VEb3duOiB7IGJ1dHRvbjogbnVtYmVyOyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBtb3VzZVVwOiB7IGJ1dHRvbjogbnVtYmVyOyB4OiBudW1iZXI7IHk6IG51bWJlciB9O1xuICBtb3VzZU1vdmU6IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGRlbHRhWDogbnVtYmVyOyBkZWx0YVk6IG51bWJlciB9O1xuICB3aGVlbDogeyBkZWx0YVg6IG51bWJlcjsgZGVsdGFZOiBudW1iZXI7IGRlbHRhWjogbnVtYmVyIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXRTdGF0ZSB7XG4gIGtleXM6IFNldDxzdHJpbmc+O1xuICBtb3VzZToge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgZGVsdGFYOiBudW1iZXI7XG4gICAgZGVsdGFZOiBudW1iZXI7XG4gICAgYnV0dG9uczogU2V0PG51bWJlcj47XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBJbnB1dE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGtleXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBtb3VzZUJ1dHRvbnMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBtb3VzZVBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gIHByaXZhdGUgbW91c2VEZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuICBwcml2YXRlIHByZXZpb3VzTW91c2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICBwcml2YXRlIGlzUG9pbnRlckxvY2tlZCA9IGZhbHNlO1xuICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAvLyBEb3VibGUtdGFwIGRldGVjdGlvbiBmb3IgZGFzaCBzeXN0ZW1cbiAgcHJpdmF0ZSBrZXlUaW1pbmdzID0gbmV3IE1hcDxzdHJpbmcsIHsgXG4gICAgZmlyc3RQcmVzc1RpbWU6IG51bWJlcjtcbiAgICBmaXJzdFJlbGVhc2VUaW1lOiBudW1iZXI7XG4gICAgc2Vjb25kUHJlc3NUaW1lOiBudW1iZXI7XG4gICAgaXNJbkRvdWJsZVRhcFNlcXVlbmNlOiBib29sZWFuO1xuICAgIGhhc1ZhbGlkRmlyc3RUYXA6IGJvb2xlYW47XG4gIH0+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgRE9VQkxFX1RBUF9USFJFU0hPTEQgPSAyMDA7IC8vIDIwMG1zIHdpbmRvdyBmb3IgZG91YmxlLXRhcCAocmVkdWNlZCBmcm9tIDI1MG1zKVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICBwdWJsaWMgaW5pdGlhbGl6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgXG4gICAgLy8gQWRkIGNhbnZhcy1zcGVjaWZpYyBldmVudCBsaXN0ZW5lcnMgdG8gZW5zdXJlIHdlIGNhcHR1cmUgZXZlbnRzXG4gICAgLy8gdGhhdCBtaWdodCBiZSBoYW5kbGVkIGJ5IFJlYWN0IFRocmVlIEZpYmVyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgXG4gICAgLy8gRG9uJ3QgYXV0b21hdGljYWxseSByZXF1ZXN0IHBvaW50ZXIgbG9jayAtIGxldCBzeXN0ZW1zIGhhbmRsZSB0aGlzXG4gICAgLy8gY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIC8vICAgaWYgKCF0aGlzLmlzUG9pbnRlckxvY2tlZCkge1xuICAgIC8vICAgICB0aGlzLnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIC8vICAgfVxuICAgIC8vIH0pO1xuICB9XG5cbiAgcHVibGljIHJlcXVlc3RQb2ludGVyTG9jaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBleGl0UG9pbnRlckxvY2soKTogdm9pZCB7XG4gICAgZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlQcmVzc2VkKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMua2V5cy5oYXMoa2V5LnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgcHVibGljIGlzTW91c2VCdXR0b25QcmVzc2VkKGJ1dHRvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VCdXR0b25zLmhhcyhidXR0b24pO1xuICB9XG5cbiAgcHVibGljIGdldE1vdXNlUG9zaXRpb24oKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgICByZXR1cm4geyAuLi50aGlzLm1vdXNlUG9zaXRpb24gfTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRNb3VzZURlbHRhKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5tb3VzZURlbHRhIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0SW5wdXRTdGF0ZSgpOiBJbnB1dFN0YXRlIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogbmV3IFNldCh0aGlzLmtleXMpLFxuICAgICAgbW91c2U6IHtcbiAgICAgICAgeDogdGhpcy5tb3VzZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IHRoaXMubW91c2VQb3NpdGlvbi55LFxuICAgICAgICBkZWx0YVg6IHRoaXMubW91c2VEZWx0YS54LFxuICAgICAgICBkZWx0YVk6IHRoaXMubW91c2VEZWx0YS55LFxuICAgICAgICBidXR0b25zOiBuZXcgU2V0KHRoaXMubW91c2VCdXR0b25zKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBjaGVja0RvdWJsZVRhcChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXlMb3dlcik7XG4gICAgXG4gICAgaWYgKCF0aW1pbmcpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gT25seSByZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIGEgdmFsaWQgZG91YmxlLXRhcCBzZXF1ZW5jZTpcbiAgICAvLyAxLiBXZSBoYXZlIGEgdmFsaWQgZmlyc3QgdGFwIChwcmVzcyArIHJlbGVhc2UpXG4gICAgLy8gMi4gV2UncmUgY3VycmVudGx5IGluIGEgZG91YmxlLXRhcCBzZXF1ZW5jZVxuICAgIC8vIDMuIFRoZSBzZWNvbmQgcHJlc3MgaGFwcGVuZWQgd2l0aGluIHRoZSB0aHJlc2hvbGQgYWZ0ZXIgdGhlIGZpcnN0IHJlbGVhc2VcbiAgICBpZiAodGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgXG4gICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgJiYgXG4gICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPiAwKSB7XG4gICAgICBcbiAgICAgIGNvbnN0IHRpbWVCZXR3ZWVuVGFwcyA9IHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgLSB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZTtcbiAgICAgIHJldHVybiB0aW1lQmV0d2VlblRhcHMgPD0gdGhpcy5ET1VCTEVfVEFQX1RIUkVTSE9MRDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHJlc2V0RG91YmxlVGFwKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qga2V5TG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB0aW1pbmcgPSB0aGlzLmtleVRpbWluZ3MuZ2V0KGtleUxvd2VyKTtcbiAgICBpZiAodGltaW5nKSB7XG4gICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSAwO1xuICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgdGltaW5nLnNlY29uZFByZXNzVGltZSA9IDA7XG4gICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoKTogdm9pZCB7XG4gICAgLy8gUmVzZXQgbW91c2UgZGVsdGEgZWFjaCBmcmFtZVxuICAgIHRoaXMubW91c2VEZWx0YS54ID0gMDtcbiAgICB0aGlzLm1vdXNlRGVsdGEueSA9IDA7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb2xkIHRpbWluZyBlbnRyaWVzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgdGhpcy5jbGVhbnVwT2xkVGltaW5ncygpO1xuICB9XG4gIFxuICBwcml2YXRlIGNsZWFudXBPbGRUaW1pbmdzKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgQ0xFQU5VUF9USFJFU0hPTEQgPSA1MDAwOyAvLyA1IHNlY29uZHNcbiAgICBjb25zdCBrZXlzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgLy8gVXNlIGZvckVhY2ggaW5zdGVhZCBvZiBmb3IuLi5vZiB0byBhdm9pZCBFUzIwMTUgaXRlcmF0aW9uIGlzc3Vlc1xuICAgIHRoaXMua2V5VGltaW5ncy5mb3JFYWNoKCh0aW1pbmcsIGtleSkgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGVudHJpZXMgdGhhdCBoYXZlbid0IGJlZW4gdXNlZCBpbiBhIHdoaWxlXG4gICAgICBjb25zdCBsYXN0QWN0aXZpdHkgPSBNYXRoLm1heChcbiAgICAgICAgdGltaW5nLmZpcnN0UHJlc3NUaW1lLCBcbiAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUsIFxuICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAobGFzdEFjdGl2aXR5ID4gMCAmJiBub3cgLSBsYXN0QWN0aXZpdHkgPiBDTEVBTlVQX1RIUkVTSE9MRCkge1xuICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIERlbGV0ZSB0aGUga2V5cyBhZnRlciBpdGVyYXRpb24gdG8gYXZvaWQgbW9kaWZ5aW5nIG1hcCBkdXJpbmcgaXRlcmF0aW9uXG4gICAga2V5c1RvRGVsZXRlLmZvckVhY2goa2V5ID0+IHRoaXMua2V5VGltaW5ncy5kZWxldGUoa2V5KSk7XG4gIH1cbiAgXG4gIC8vIERlYnVnIG1ldGhvZCB0byBoZWxwIHRyYWNrIGRvdWJsZSB0YXAgZGV0ZWN0aW9uXG4gIHB1YmxpYyBnZXREb3VibGVUYXBEZWJ1Z0luZm8oa2V5OiBzdHJpbmcpOiBhbnkge1xuICAgIGNvbnN0IGtleUxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXlMb3dlcik7XG4gICAgXG4gICAgaWYgKCF0aW1pbmcpIHJldHVybiBudWxsO1xuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleToga2V5TG93ZXIsXG4gICAgICBmaXJzdFByZXNzVGltZTogdGltaW5nLmZpcnN0UHJlc3NUaW1lLFxuICAgICAgZmlyc3RSZWxlYXNlVGltZTogdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUsXG4gICAgICBzZWNvbmRQcmVzc1RpbWU6IHRpbWluZy5zZWNvbmRQcmVzc1RpbWUsXG4gICAgICBoYXNWYWxpZEZpcnN0VGFwOiB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCxcbiAgICAgIGlzSW5Eb3VibGVUYXBTZXF1ZW5jZTogdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSxcbiAgICAgIHRpbWVTaW5jZUZpcnN0UHJlc3M6IHRpbWluZy5maXJzdFByZXNzVGltZSA+IDAgPyBub3cgLSB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgOiAwLFxuICAgICAgdGltZVNpbmNlRmlyc3RSZWxlYXNlOiB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA+IDAgPyBub3cgLSB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA6IDAsXG4gICAgICB0aW1lU2luY2VTZWNvbmRQcmVzczogdGltaW5nLnNlY29uZFByZXNzVGltZSA+IDAgPyBub3cgLSB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lIDogMCxcbiAgICAgIHRocmVzaG9sZDogdGhpcy5ET1VCTEVfVEFQX1RIUkVTSE9MRFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgLy8gS2V5Ym9hcmQgZXZlbnRzXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5vbktleVVwLmJpbmQodGhpcykpO1xuXG4gICAgLy8gTW91c2UgZXZlbnRzXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMub25XaGVlbC5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFBvaW50ZXIgbG9jayBldmVudHNcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2NoYW5nZScsIHRoaXMub25Qb2ludGVyTG9ja0NoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybG9ja2Vycm9yJywgdGhpcy5vblBvaW50ZXJMb2NrRXJyb3IuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBQcmV2ZW50IGNvbnRleHQgbWVudVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbiAgICAvLyBIYW5kbGUgd2luZG93IGZvY3VzL2JsdXIgdG8gcmVzZXQgaW5wdXQgc3RhdGVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgXG4gICAgaWYgKCF0aGlzLmtleXMuaGFzKGtleSkpIHtcbiAgICAgIHRoaXMua2V5cy5hZGQoa2V5KTtcbiAgICAgIHRoaXMuZW1pdCgna2V5RG93bicsIHsga2V5OiBldmVudC5rZXksIGNvZGU6IGV2ZW50LmNvZGUgfSk7XG5cbiAgICAgIC8vIFRyYWNrIGtleSB0aW1pbmcgZm9yIGRvdWJsZS10YXAgZGV0ZWN0aW9uXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHRpbWluZyA9IHRoaXMua2V5VGltaW5ncy5nZXQoa2V5KTtcbiAgICAgIFxuICAgICAgaWYgKCF0aW1pbmcpIHtcbiAgICAgICAgdGltaW5nID0geyBcbiAgICAgICAgICBmaXJzdFByZXNzVGltZTogMCwgXG4gICAgICAgICAgZmlyc3RSZWxlYXNlVGltZTogMCwgXG4gICAgICAgICAgc2Vjb25kUHJlc3NUaW1lOiAwLFxuICAgICAgICAgIGlzSW5Eb3VibGVUYXBTZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgaGFzVmFsaWRGaXJzdFRhcDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5rZXlUaW1pbmdzLnNldChrZXksIHRpbWluZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBkb3VibGUtdGFwIHNlcXVlbmNlIGxvZ2ljXG4gICAgICBpZiAoIXRpbWluZy5oYXNWYWxpZEZpcnN0VGFwKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHByZXNzXG4gICAgICAgIHRpbWluZy5maXJzdFByZXNzVGltZSA9IG5vdztcbiAgICAgICAgdGltaW5nLmlzSW5Eb3VibGVUYXBTZXF1ZW5jZSA9IGZhbHNlO1xuICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlOyAvLyBXaWxsIGJlIHNldCB0byB0cnVlIG9uIHJlbGVhc2VcbiAgICAgIH0gZWxzZSBpZiAodGltaW5nLmhhc1ZhbGlkRmlyc3RUYXAgJiYgIXRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSB0aGUgc2Vjb25kIHByZXNzIC0gY2hlY2sgaWYgaXQncyB3aXRoaW4gdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0UmVsZWFzZSA9IG5vdyAtIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lO1xuICAgICAgICBpZiAodGltZVNpbmNlRmlyc3RSZWxlYXNlIDw9IHRoaXMuRE9VQkxFX1RBUF9USFJFU0hPTEQpIHtcbiAgICAgICAgICAvLyBWYWxpZCBzZWNvbmQgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuc2Vjb25kUHJlc3NUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvbyBsYXRlIGZvciBkb3VibGUtdGFwLCB0cmVhdCBhcyBuZXcgZmlyc3QgcHJlc3NcbiAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSBub3c7XG4gICAgICAgICAgdGltaW5nLmZpcnN0UmVsZWFzZVRpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgIHRpbWluZy5pc0luRG91YmxlVGFwU2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgICAgICB0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGZvciBnYW1lIGtleXNcbiAgICBpZiAodGhpcy5pc0dhbWVLZXkoa2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICBcbiAgICBpZiAodGhpcy5rZXlzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLmtleXMuZGVsZXRlKGtleSk7XG4gICAgICB0aGlzLmVtaXQoJ2tleVVwJywgeyBrZXk6IGV2ZW50LmtleSwgY29kZTogZXZlbnQuY29kZSB9KTtcblxuICAgICAgLy8gVHJhY2sga2V5IHJlbGVhc2UgdGltaW5nIGZvciBkb3VibGUtdGFwIGRldGVjdGlvblxuICAgICAgY29uc3QgdGltaW5nID0gdGhpcy5rZXlUaW1pbmdzLmdldChrZXkpO1xuICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0aW1pbmcuaGFzVmFsaWRGaXJzdFRhcCAmJiB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPiAwKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGZpcnN0IHRhcFxuICAgICAgICAgIHRpbWluZy5maXJzdFJlbGVhc2VUaW1lID0gbm93O1xuICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wbGV0ZXMgdGhlIGRvdWJsZS10YXAgc2VxdWVuY2VcbiAgICAgICAgICAvLyBUaGUgZG91YmxlLXRhcCBkZXRlY3Rpb24gc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZFxuICAgICAgICAgIC8vIFJlc2V0IGZvciBuZXh0IHBvdGVudGlhbCBzZXF1ZW5jZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWluZykge1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuZmlyc3RSZWxlYXNlVGltZSA9IDA7XG4gICAgICAgICAgICAgIHRpbWluZy5zZWNvbmRQcmVzc1RpbWUgPSAwO1xuICAgICAgICAgICAgICB0aW1pbmcuaXNJbkRvdWJsZVRhcFNlcXVlbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRpbWluZy5oYXNWYWxpZEZpcnN0VGFwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwKTsgLy8gU21hbGwgZGVsYXkgdG8gYWxsb3cgZGFzaCBzeXN0ZW0gdG8gcHJvY2Vzc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbk1vdXNlRG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMubW91c2VCdXR0b25zLmFkZChldmVudC5idXR0b24pO1xuICAgIHRoaXMuZW1pdCgnbW91c2VEb3duJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZVVwKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuZGVsZXRlKGV2ZW50LmJ1dHRvbik7XG4gICAgdGhpcy5lbWl0KCdtb3VzZVVwJywge1xuICAgICAgYnV0dG9uOiBldmVudC5idXR0b24sXG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25Nb3VzZU1vdmUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc1BvaW50ZXJMb2NrZWQpIHtcbiAgICAgIC8vIFVzZSBtb3ZlbWVudCBkZWx0YXMgd2hlbiBwb2ludGVyIGlzIGxvY2tlZFxuICAgICAgdGhpcy5tb3VzZURlbHRhLnggKz0gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgdGhpcy5tb3VzZURlbHRhLnkgKz0gZXZlbnQubW92ZW1lbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgYWJzb2x1dGUgcG9zaXRpb24gd2hlbiBub3QgbG9ja2VkXG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi54ID0gdGhpcy5tb3VzZVBvc2l0aW9uLng7XG4gICAgICB0aGlzLnByZXZpb3VzTW91c2VQb3NpdGlvbi55ID0gdGhpcy5tb3VzZVBvc2l0aW9uLnk7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB0aGlzLm1vdXNlUG9zaXRpb24ueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSBkZWx0YSBmcm9tIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICBjb25zdCBkZWx0YVggPSB0aGlzLm1vdXNlUG9zaXRpb24ueCAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLng7XG4gICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLm1vdXNlUG9zaXRpb24ueSAtIHRoaXMucHJldmlvdXNNb3VzZVBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIC8vIEFjY3VtdWxhdGUgZGVsdGEgZm9yIHRoaXMgZnJhbWVcbiAgICAgIHRoaXMubW91c2VEZWx0YS54ICs9IGRlbHRhWDtcbiAgICAgIHRoaXMubW91c2VEZWx0YS55ICs9IGRlbHRhWTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ21vdXNlTW92ZScsIHtcbiAgICAgIHg6IHRoaXMubW91c2VQb3NpdGlvbi54LFxuICAgICAgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnksXG4gICAgICBkZWx0YVg6IHRoaXMubW91c2VEZWx0YS54LFxuICAgICAgZGVsdGFZOiB0aGlzLm1vdXNlRGVsdGEueSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25XaGVlbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdCgnd2hlZWwnLCB7XG4gICAgICBkZWx0YVg6IGV2ZW50LmRlbHRhWCxcbiAgICAgIGRlbHRhWTogZXZlbnQuZGVsdGFZLFxuICAgICAgZGVsdGFaOiBldmVudC5kZWx0YVosXG4gICAgfSk7XG4gICAgXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0NoYW5nZSgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUG9pbnRlckxvY2tlZCA9IGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudCAhPT0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgb25Qb2ludGVyTG9ja0Vycm9yKCk6IHZvaWQge1xuICAgIGNvbnNvbGUud2FybignUG9pbnRlciBsb2NrIGZhaWxlZCcpO1xuICAgIHRoaXMuaXNQb2ludGVyTG9ja2VkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIG9uV2luZG93Qmx1cigpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbGwgaW5wdXQgc3RhdGUgd2hlbiB3aW5kb3cgbG9zZXMgZm9jdXNcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbldpbmRvd0ZvY3VzKCk6IHZvaWQge1xuICAgIC8vIFJlc2V0IG1vdXNlIGRlbHRhIHdoZW4gd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgICB0aGlzLm1vdXNlRGVsdGEueCA9IDA7XG4gICAgdGhpcy5tb3VzZURlbHRhLnkgPSAwO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0dhbWVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBEZWZpbmUgd2hpY2gga2V5cyBzaG91bGQgaGF2ZSB0aGVpciBkZWZhdWx0IGJlaGF2aW9yIHByZXZlbnRlZFxuICAgIGNvbnN0IGdhbWVLZXlzID0gWyd3JywgJ2EnLCAncycsICdkJywgJyAnLCAnc2hpZnQnLCAndGFiJywgJ2VzY2FwZSddO1xuICAgIHJldHVybiBnYW1lS2V5cy5pbmNsdWRlcyhrZXkpO1xuICB9XG5cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyc1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5vbldoZWVsLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrY2hhbmdlJywgdGhpcy5vblBvaW50ZXJMb2NrQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsb2NrZXJyb3InLCB0aGlzLm9uUG9pbnRlckxvY2tFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMub25XaW5kb3dCbHVyLmJpbmQodGhpcykpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMub25XaW5kb3dGb2N1cy5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFJlbW92ZSBjYW52YXMgZXZlbnQgbGlzdGVuZXJzIGlmIGNhbnZhcyBleGlzdHNcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLm9uV2hlZWwuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgc3RhdGVcbiAgICB0aGlzLmtleXMuY2xlYXIoKTtcbiAgICB0aGlzLm1vdXNlQnV0dG9ucy5jbGVhcigpO1xuICAgIHRoaXMua2V5VGltaW5ncy5jbGVhcigpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJJbnB1dE1hbmFnZXIiLCJpbml0aWFsaXplIiwiY2FudmFzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uTW91c2VEb3duIiwiYmluZCIsIm9uTW91c2VVcCIsIm9uTW91c2VNb3ZlIiwib25XaGVlbCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInJlcXVlc3RQb2ludGVyTG9jayIsImV4aXRQb2ludGVyTG9jayIsImRvY3VtZW50IiwiaXNLZXlQcmVzc2VkIiwia2V5Iiwia2V5cyIsImhhcyIsInRvTG93ZXJDYXNlIiwiaXNNb3VzZUJ1dHRvblByZXNzZWQiLCJidXR0b24iLCJtb3VzZUJ1dHRvbnMiLCJnZXRNb3VzZVBvc2l0aW9uIiwibW91c2VQb3NpdGlvbiIsImdldE1vdXNlRGVsdGEiLCJtb3VzZURlbHRhIiwiZ2V0SW5wdXRTdGF0ZSIsIlNldCIsIm1vdXNlIiwieCIsInkiLCJkZWx0YVgiLCJkZWx0YVkiLCJidXR0b25zIiwiY2hlY2tEb3VibGVUYXAiLCJrZXlMb3dlciIsInRpbWluZyIsImtleVRpbWluZ3MiLCJnZXQiLCJub3ciLCJEYXRlIiwiaGFzVmFsaWRGaXJzdFRhcCIsImlzSW5Eb3VibGVUYXBTZXF1ZW5jZSIsInNlY29uZFByZXNzVGltZSIsInRpbWVCZXR3ZWVuVGFwcyIsImZpcnN0UmVsZWFzZVRpbWUiLCJET1VCTEVfVEFQX1RIUkVTSE9MRCIsInJlc2V0RG91YmxlVGFwIiwiZmlyc3RQcmVzc1RpbWUiLCJ1cGRhdGUiLCJjbGVhbnVwT2xkVGltaW5ncyIsIkNMRUFOVVBfVEhSRVNIT0xEIiwia2V5c1RvRGVsZXRlIiwiZm9yRWFjaCIsImxhc3RBY3Rpdml0eSIsIk1hdGgiLCJtYXgiLCJwdXNoIiwiZGVsZXRlIiwiZ2V0RG91YmxlVGFwRGVidWdJbmZvIiwidGltZVNpbmNlRmlyc3RQcmVzcyIsInRpbWVTaW5jZUZpcnN0UmVsZWFzZSIsInRpbWVTaW5jZVNlY29uZFByZXNzIiwidGhyZXNob2xkIiwic2V0dXBFdmVudExpc3RlbmVycyIsIm9uS2V5RG93biIsIm9uS2V5VXAiLCJvblBvaW50ZXJMb2NrQ2hhbmdlIiwib25Qb2ludGVyTG9ja0Vycm9yIiwid2luZG93Iiwib25XaW5kb3dCbHVyIiwib25XaW5kb3dGb2N1cyIsImV2ZW50IiwiYWRkIiwiZW1pdCIsImNvZGUiLCJzZXQiLCJpc0dhbWVLZXkiLCJzZXRUaW1lb3V0IiwiY2xpZW50WCIsImNsaWVudFkiLCJpc1BvaW50ZXJMb2NrZWQiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJwcmV2aW91c01vdXNlUG9zaXRpb24iLCJkZWx0YVoiLCJwb2ludGVyTG9ja0VsZW1lbnQiLCJjb25zb2xlIiwid2FybiIsImNsZWFyIiwiZ2FtZUtleXMiLCJpbmNsdWRlcyIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiY29uc3RydWN0b3IiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/core/InputManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/Entity.ts":
/*!***************************!*\
  !*** ./src/ecs/Entity.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: function() { return /* binding */ Component; },\n/* harmony export */   Entity: function() { return /* binding */ Entity; }\n/* harmony export */ });\n// Entity Component System - Entity Management\nclass Entity {\n    addComponent(component) {\n        // Use explicit componentType if available, fallback to constructor name\n        const componentName = component.componentType || component.constructor.name;\n        console.log(\"\\uD83D\\uDD27 Adding component \".concat(componentName, \" to entity \").concat(this.id));\n        this.components.set(componentName, component);\n        return component;\n    }\n    removeComponent(componentType) {\n        this.components.delete(componentType.name);\n    }\n    getComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        let component = this.components.get(requestedType);\n        // If not found with explicit type, try searching by constructor name as fallback\n        if (!component && componentType.componentType) {\n            component = this.components.get(componentType.name);\n            if (component) {\n                console.log(\"\\uD83D\\uDD27 Found component using constructor name fallback: \".concat(componentType.name));\n            }\n        }\n        // If still not found, search through all components to find a match by type\n        if (!component) {\n            const entries = Array.from(this.components.entries());\n            for (const [key, comp] of entries){\n                if (comp instanceof componentType) {\n                    // Reduce spam - only log occasionally for instanceof fallback usage\n                    if (Math.random() < 0.01) {\n                        console.log(\"\\uD83D\\uDD27 Found component using instanceof check: \".concat(key, \" -> \").concat(componentType.name));\n                    }\n                    component = comp;\n                    break;\n                }\n            }\n        }\n        if (component) {\n            const actualType = component.componentType || component.constructor.name;\n            if (actualType !== requestedType && !component.constructor.name.match(/^[a-z]$/)) {\n                // Only warn if it's not a minified single-letter class name\n                console.warn(\"\\uD83D\\uDEA8 Component type mismatch! Requested: \".concat(requestedType, \", Got: \").concat(actualType), component);\n            }\n        } else {\n            // Reduce spam - only log occasionally for missing components\n            if (Math.random() < 0.001) {\n                console.warn(\"❌ Component not found: \".concat(requestedType, \". Available components:\"), Array.from(this.components.keys()));\n            }\n        }\n        return component;\n    }\n    hasComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const requestedType = componentType.componentType || componentType.name;\n        // Check with explicit type first\n        if (this.components.has(requestedType)) {\n            return true;\n        }\n        // If not found with explicit type, try constructor name as fallback\n        if (componentType.componentType && this.components.has(componentType.name)) {\n            return true;\n        }\n        // If still not found, search through all components to find a match by type\n        const components = Array.from(this.components.values());\n        for (const comp of components){\n            if (comp instanceof componentType) {\n                return true;\n            }\n        }\n        return false;\n    }\n    hasComponents(componentTypes) {\n        return componentTypes.every((type)=>this.hasComponent(type));\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getComponentNames() {\n        return Array.from(this.components.keys());\n    }\n    isActive() {\n        return this.active;\n    }\n    setActive(active) {\n        this.active = active;\n    }\n    destroy() {\n        this.components.clear();\n        this.active = false;\n    }\n    constructor(){\n        this.components = new Map();\n        this.active = true;\n        this.id = Entity.nextId++;\n    }\n}\nEntity.nextId = 1;\nclass Component {\n    constructor(){\n        this.enabled = true;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvRW50aXR5LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsOENBQThDO0FBR3ZDLE1BQU1BO0lBVUpDLGFBQWtDQyxTQUFZLEVBQUs7UUFDeEQsd0VBQXdFO1FBQ3hFLE1BQU1DLGdCQUFnQixVQUFtQkMsYUFBYSxJQUFJRixVQUFVRyxXQUFXLENBQUNDLElBQUk7UUFDcEZDLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBa0QsT0FBM0JMLGVBQWMsZUFBcUIsT0FBUixJQUFJLENBQUNNLEVBQUU7UUFDckUsSUFBSSxDQUFDQyxVQUFVLENBQUNDLEdBQUcsQ0FBQ1IsZUFBZUQ7UUFDbkMsT0FBT0E7SUFDVDtJQUVPVSxnQkFBcUNSLGFBQTBCLEVBQVE7UUFDNUUsSUFBSSxDQUFDTSxVQUFVLENBQUNHLE1BQU0sQ0FBQ1QsY0FBY0UsSUFBSTtJQUMzQztJQUVPUSxhQUFrQ1YsYUFBMEIsRUFBaUI7UUFDbEYsd0VBQXdFO1FBQ3hFLE1BQU1XLGdCQUFnQixjQUF1QlgsYUFBYSxJQUFJQSxjQUFjRSxJQUFJO1FBQ2hGLElBQUlKLFlBQVksSUFBSSxDQUFDUSxVQUFVLENBQUNNLEdBQUcsQ0FBQ0Q7UUFFcEMsaUZBQWlGO1FBQ2pGLElBQUksQ0FBQ2IsYUFBYSxjQUF1QkUsYUFBYSxFQUFFO1lBQ3RERixZQUFZLElBQUksQ0FBQ1EsVUFBVSxDQUFDTSxHQUFHLENBQUNaLGNBQWNFLElBQUk7WUFDbEQsSUFBSUosV0FBVztnQkFDYkssUUFBUUMsR0FBRyxDQUFDLGlFQUEwRSxPQUFuQkosY0FBY0UsSUFBSTtZQUN2RjtRQUNGO1FBRUEsNEVBQTRFO1FBQzVFLElBQUksQ0FBQ0osV0FBVztZQUNkLE1BQU1lLFVBQVVDLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNULFVBQVUsQ0FBQ08sT0FBTztZQUNsRCxLQUFLLE1BQU0sQ0FBQ0csS0FBS0MsS0FBSyxJQUFJSixRQUFTO2dCQUNqQyxJQUFJSSxnQkFBZ0JqQixlQUFlO29CQUNqQyxvRUFBb0U7b0JBQ3BFLElBQUlrQixLQUFLQyxNQUFNLEtBQUssTUFBTTt3QkFDeEJoQixRQUFRQyxHQUFHLENBQUMsd0RBQXdESixPQUFWZ0IsS0FBSSxRQUF5QixPQUFuQmhCLGNBQWNFLElBQUk7b0JBQ3hGO29CQUNBSixZQUFZbUI7b0JBQ1o7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsSUFBSW5CLFdBQVc7WUFDYixNQUFNc0IsYUFBYSxVQUFtQnBCLGFBQWEsSUFBSUYsVUFBVUcsV0FBVyxDQUFDQyxJQUFJO1lBQ2pGLElBQUlrQixlQUFlVCxpQkFBaUIsQ0FBQ2IsVUFBVUcsV0FBVyxDQUFDQyxJQUFJLENBQUNtQixLQUFLLENBQUMsWUFBWTtnQkFDaEYsNERBQTREO2dCQUM1RGxCLFFBQVFtQixJQUFJLENBQUMsb0RBQWlFRixPQUF2QlQsZUFBYyxXQUFvQixPQUFYUyxhQUFjdEI7WUFDOUY7UUFDRixPQUFPO1lBQ0wsNkRBQTZEO1lBQzdELElBQUlvQixLQUFLQyxNQUFNLEtBQUssT0FBTztnQkFDekJoQixRQUFRbUIsSUFBSSxDQUFDLDBCQUF3QyxPQUFkWCxlQUFjLDRCQUEwQkcsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ1QsVUFBVSxDQUFDaUIsSUFBSTtZQUNoSDtRQUNGO1FBRUEsT0FBT3pCO0lBQ1Q7SUFFTzBCLGFBQWtDeEIsYUFBMEIsRUFBVztRQUM1RSx3RUFBd0U7UUFDeEUsTUFBTVcsZ0JBQWdCLGNBQXVCWCxhQUFhLElBQUlBLGNBQWNFLElBQUk7UUFFaEYsaUNBQWlDO1FBQ2pDLElBQUksSUFBSSxDQUFDSSxVQUFVLENBQUNtQixHQUFHLENBQUNkLGdCQUFnQjtZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxvRUFBb0U7UUFDcEUsSUFBSSxjQUF1QlgsYUFBYSxJQUFJLElBQUksQ0FBQ00sVUFBVSxDQUFDbUIsR0FBRyxDQUFDekIsY0FBY0UsSUFBSSxHQUFHO1lBQ25GLE9BQU87UUFDVDtRQUVBLDRFQUE0RTtRQUM1RSxNQUFNSSxhQUFhUSxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDVCxVQUFVLENBQUNvQixNQUFNO1FBQ3BELEtBQUssTUFBTVQsUUFBUVgsV0FBWTtZQUM3QixJQUFJVyxnQkFBZ0JqQixlQUFlO2dCQUNqQyxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVPMkIsY0FBY0MsY0FBdUMsRUFBVztRQUNyRSxPQUFPQSxlQUFlQyxLQUFLLENBQUNDLENBQUFBLE9BQVEsSUFBSSxDQUFDTixZQUFZLENBQUNNO0lBQ3hEO0lBRU9DLG1CQUFnQztRQUNyQyxPQUFPakIsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ1QsVUFBVSxDQUFDb0IsTUFBTTtJQUMxQztJQUVPTSxvQkFBOEI7UUFDbkMsT0FBT2xCLE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNULFVBQVUsQ0FBQ2lCLElBQUk7SUFDeEM7SUFFT1UsV0FBb0I7UUFDekIsT0FBTyxJQUFJLENBQUNDLE1BQU07SUFDcEI7SUFFT0MsVUFBVUQsTUFBZSxFQUFRO1FBQ3RDLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtJQUNoQjtJQUVPRSxVQUFnQjtRQUNyQixJQUFJLENBQUM5QixVQUFVLENBQUMrQixLQUFLO1FBQ3JCLElBQUksQ0FBQ0gsTUFBTSxHQUFHO0lBQ2hCO0lBNUdBakMsYUFBYzthQUhOSyxhQUFhLElBQUlnQzthQUNqQkosU0FBUztRQUdmLElBQUksQ0FBQzdCLEVBQUUsR0FBR1QsT0FBTzJDLE1BQU07SUFDekI7QUEyR0Y7QUFuSGEzQyxPQUNJMkMsU0FBbUI7QUFvSDdCLE1BQWVDOzthQUNiQyxVQUFVOztBQUduQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL0VudGl0eS50cz81ZjNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEVudGl0eSBDb21wb25lbnQgU3lzdGVtIC0gRW50aXR5IE1hbmFnZW1lbnRcbmV4cG9ydCB0eXBlIEVudGl0eUlkID0gbnVtYmVyO1xuXG5leHBvcnQgY2xhc3MgRW50aXR5IHtcbiAgcHJpdmF0ZSBzdGF0aWMgbmV4dElkOiBFbnRpdHlJZCA9IDE7XG4gIHB1YmxpYyByZWFkb25seSBpZDogRW50aXR5SWQ7XG4gIHByaXZhdGUgY29tcG9uZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBDb21wb25lbnQ+KCk7XG4gIHByaXZhdGUgYWN0aXZlID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gRW50aXR5Lm5leHRJZCsrO1xuICB9XG5cbiAgcHVibGljIGFkZENvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnQ6IFQpOiBUIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgY29tcG9uZW50VHlwZSBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGNvbnN0cnVjdG9yIG5hbWVcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gKGNvbXBvbmVudCBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgY29uc29sZS5sb2coYPCflKcgQWRkaW5nIGNvbXBvbmVudCAke2NvbXBvbmVudE5hbWV9IHRvIGVudGl0eSAke3RoaXMuaWR9YCk7XG4gICAgdGhpcy5jb21wb25lbnRzLnNldChjb21wb25lbnROYW1lLCBjb21wb25lbnQpO1xuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGNvbXBvbmVudFR5cGU6IG5ldyAoKSA9PiBUKTogdm9pZCB7XG4gICAgdGhpcy5jb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnRUeXBlLm5hbWUpO1xuICB9XG5cbiAgcHVibGljIGdldENvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IFQgfCB1bmRlZmluZWQge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IHJlcXVlc3RlZFR5cGUgPSAoY29tcG9uZW50VHlwZSBhcyBhbnkpLmNvbXBvbmVudFR5cGUgfHwgY29tcG9uZW50VHlwZS5uYW1lO1xuICAgIGxldCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHMuZ2V0KHJlcXVlc3RlZFR5cGUpO1xuICAgIFxuICAgIC8vIElmIG5vdCBmb3VuZCB3aXRoIGV4cGxpY2l0IHR5cGUsIHRyeSBzZWFyY2hpbmcgYnkgY29uc3RydWN0b3IgbmFtZSBhcyBmYWxsYmFja1xuICAgIGlmICghY29tcG9uZW50ICYmIChjb21wb25lbnRUeXBlIGFzIGFueSkuY29tcG9uZW50VHlwZSkge1xuICAgICAgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzLmdldChjb21wb25lbnRUeXBlLm5hbWUpO1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UpyBGb3VuZCBjb21wb25lbnQgdXNpbmcgY29uc3RydWN0b3IgbmFtZSBmYWxsYmFjazogJHtjb21wb25lbnRUeXBlLm5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgc2VhcmNoIHRocm91Z2ggYWxsIGNvbXBvbmVudHMgdG8gZmluZCBhIG1hdGNoIGJ5IHR5cGVcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5jb21wb25lbnRzLmVudHJpZXMoKSk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIGNvbXBdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgLy8gUmVkdWNlIHNwYW0gLSBvbmx5IGxvZyBvY2Nhc2lvbmFsbHkgZm9yIGluc3RhbmNlb2YgZmFsbGJhY2sgdXNhZ2VcbiAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDEpIHsgLy8gT25seSBsb2cgMSUgb2YgdGhlIHRpbWVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SnIEZvdW5kIGNvbXBvbmVudCB1c2luZyBpbnN0YW5jZW9mIGNoZWNrOiAke2tleX0gLT4gJHtjb21wb25lbnRUeXBlLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IChjb21wb25lbnQgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaWYgKGFjdHVhbFR5cGUgIT09IHJlcXVlc3RlZFR5cGUgJiYgIWNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lLm1hdGNoKC9eW2Etel0kLykpIHtcbiAgICAgICAgLy8gT25seSB3YXJuIGlmIGl0J3Mgbm90IGEgbWluaWZpZWQgc2luZ2xlLWxldHRlciBjbGFzcyBuYW1lXG4gICAgICAgIGNvbnNvbGUud2Fybihg8J+aqCBDb21wb25lbnQgdHlwZSBtaXNtYXRjaCEgUmVxdWVzdGVkOiAke3JlcXVlc3RlZFR5cGV9LCBHb3Q6ICR7YWN0dWFsVHlwZX1gLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWR1Y2Ugc3BhbSAtIG9ubHkgbG9nIG9jY2FzaW9uYWxseSBmb3IgbWlzc2luZyBjb21wb25lbnRzXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDAxKSB7IC8vIE9ubHkgbG9nIDAuMSUgb2YgdGhlIHRpbWVcbiAgICAgICAgY29uc29sZS53YXJuKGDinYwgQ29tcG9uZW50IG5vdCBmb3VuZDogJHtyZXF1ZXN0ZWRUeXBlfS4gQXZhaWxhYmxlIGNvbXBvbmVudHM6YCwgQXJyYXkuZnJvbSh0aGlzLmNvbXBvbmVudHMua2V5cygpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb21wb25lbnQgYXMgVDtcbiAgfVxuXG4gIHB1YmxpYyBoYXNDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oY29tcG9uZW50VHlwZTogbmV3ICgpID0+IFQpOiBib29sZWFuIHtcbiAgICAvLyBVc2UgZXhwbGljaXQgY29tcG9uZW50VHlwZSBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGNvbnN0cnVjdG9yIG5hbWVcbiAgICBjb25zdCByZXF1ZXN0ZWRUeXBlID0gKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICBcbiAgICAvLyBDaGVjayB3aXRoIGV4cGxpY2l0IHR5cGUgZmlyc3RcbiAgICBpZiAodGhpcy5jb21wb25lbnRzLmhhcyhyZXF1ZXN0ZWRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIG5vdCBmb3VuZCB3aXRoIGV4cGxpY2l0IHR5cGUsIHRyeSBjb25zdHJ1Y3RvciBuYW1lIGFzIGZhbGxiYWNrXG4gICAgaWYgKChjb21wb25lbnRUeXBlIGFzIGFueSkuY29tcG9uZW50VHlwZSAmJiB0aGlzLmNvbXBvbmVudHMuaGFzKGNvbXBvbmVudFR5cGUubmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBzdGlsbCBub3QgZm91bmQsIHNlYXJjaCB0aHJvdWdoIGFsbCBjb21wb25lbnRzIHRvIGZpbmQgYSBtYXRjaCBieSB0eXBlXG4gICAgY29uc3QgY29tcG9uZW50cyA9IEFycmF5LmZyb20odGhpcy5jb21wb25lbnRzLnZhbHVlcygpKTtcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgY29tcG9uZW50cykge1xuICAgICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBjb21wb25lbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgaGFzQ29tcG9uZW50cyhjb21wb25lbnRUeXBlczogKG5ldyAoKSA9PiBDb21wb25lbnQpW10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gY29tcG9uZW50VHlwZXMuZXZlcnkodHlwZSA9PiB0aGlzLmhhc0NvbXBvbmVudCh0eXBlKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QWxsQ29tcG9uZW50cygpOiBDb21wb25lbnRbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb21wb25lbnRzLnZhbHVlcygpKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb21wb25lbnROYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb21wb25lbnRzLmtleXMoKSk7XG4gIH1cblxuICBwdWJsaWMgaXNBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICB9XG5cbiAgcHVibGljIHNldEFjdGl2ZShhY3RpdmU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuY29tcG9uZW50cy5jbGVhcigpO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgXG4gIHB1YmxpYyBhYnN0cmFjdCByZXNldCgpOiB2b2lkOyAvLyBGb3Igb2JqZWN0IHBvb2xpbmdcbn1cbiJdLCJuYW1lcyI6WyJFbnRpdHkiLCJhZGRDb21wb25lbnQiLCJjb21wb25lbnQiLCJjb21wb25lbnROYW1lIiwiY29tcG9uZW50VHlwZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImNvbnNvbGUiLCJsb2ciLCJpZCIsImNvbXBvbmVudHMiLCJzZXQiLCJyZW1vdmVDb21wb25lbnQiLCJkZWxldGUiLCJnZXRDb21wb25lbnQiLCJyZXF1ZXN0ZWRUeXBlIiwiZ2V0IiwiZW50cmllcyIsIkFycmF5IiwiZnJvbSIsImtleSIsImNvbXAiLCJNYXRoIiwicmFuZG9tIiwiYWN0dWFsVHlwZSIsIm1hdGNoIiwid2FybiIsImtleXMiLCJoYXNDb21wb25lbnQiLCJoYXMiLCJ2YWx1ZXMiLCJoYXNDb21wb25lbnRzIiwiY29tcG9uZW50VHlwZXMiLCJldmVyeSIsInR5cGUiLCJnZXRBbGxDb21wb25lbnRzIiwiZ2V0Q29tcG9uZW50TmFtZXMiLCJpc0FjdGl2ZSIsImFjdGl2ZSIsInNldEFjdGl2ZSIsImRlc3Ryb3kiLCJjbGVhciIsIk1hcCIsIm5leHRJZCIsIkNvbXBvbmVudCIsImVuYWJsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/Entity.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/System.ts":
/*!***************************!*\
  !*** ./src/ecs/System.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; },\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; },\n/* harmony export */   System: function() { return /* binding */ System; }\n/* harmony export */ });\n// Entity Component System - Base System Classes\nclass System {\n    matchesEntity(entity) {\n        return entity.isActive() && entity.hasComponents(this.requiredComponents);\n    }\n    constructor(){\n        this.enabled = true;\n        this.priority = 0 // Lower numbers run first\n        ;\n    }\n}\nclass RenderSystem extends System {\n}\nclass PhysicsSystem extends System {\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdEQUFnRDtBQUd6QyxNQUFlQTtJQU9iQyxjQUFjQyxNQUFjLEVBQVc7UUFDNUMsT0FBT0EsT0FBT0MsUUFBUSxNQUFNRCxPQUFPRSxhQUFhLENBQUMsSUFBSSxDQUFDQyxrQkFBa0I7SUFDMUU7O2FBUE9DLFVBQVU7YUFDVkMsV0FBVyxFQUFHLDBCQUEwQjs7O0FBWWpEO0FBRU8sTUFBZUMscUJBQXFCUjtBQUUzQztBQUVPLE1BQWVTLHNCQUFzQlQ7QUFFNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9TeXN0ZW0udHM/YTgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIEJhc2UgU3lzdGVtIENsYXNzZXNcbmltcG9ydCB7IEVudGl0eSwgQ29tcG9uZW50IH0gZnJvbSAnLi9FbnRpdHknO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50czogKG5ldyAoKSA9PiBDb21wb25lbnQpW107XG4gIHB1YmxpYyBlbmFibGVkID0gdHJ1ZTtcbiAgcHVibGljIHByaW9yaXR5ID0gMDsgLy8gTG93ZXIgbnVtYmVycyBydW4gZmlyc3RcblxuICBwdWJsaWMgYWJzdHJhY3QgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkO1xuXG4gIHB1YmxpYyBtYXRjaGVzRW50aXR5KGVudGl0eTogRW50aXR5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGVudGl0eS5pc0FjdGl2ZSgpICYmIGVudGl0eS5oYXNDb21wb25lbnRzKHRoaXMucmVxdWlyZWRDb21wb25lbnRzKTtcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkPyhlbnRpdHk6IEVudGl0eSk6IHZvaWQ7XG4gIHB1YmxpYyBvbkVudGl0eVJlbW92ZWQ/KGVudGl0eTogRW50aXR5KTogdm9pZDtcbiAgcHVibGljIG9uRW5hYmxlPygpOiB2b2lkO1xuICBwdWJsaWMgb25EaXNhYmxlPygpOiB2b2lkO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVuZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIGFic3RyYWN0IHJlbmRlcihlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBoeXNpY3NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgYWJzdHJhY3QgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZDtcbn1cbiJdLCJuYW1lcyI6WyJTeXN0ZW0iLCJtYXRjaGVzRW50aXR5IiwiZW50aXR5IiwiaXNBY3RpdmUiLCJoYXNDb21wb25lbnRzIiwicmVxdWlyZWRDb21wb25lbnRzIiwiZW5hYmxlZCIsInByaW9yaXR5IiwiUmVuZGVyU3lzdGVtIiwiUGh5c2ljc1N5c3RlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/System.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/World.ts":
/*!**************************!*\
  !*** ./src/ecs/World.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: function() { return /* binding */ World; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Entity Component System - World Management\n\n\n\nclass World {\n    // Entity management\n    createEntity() {\n        const entity = new _Entity__WEBPACK_IMPORTED_MODULE_0__.Entity();\n        this.entities.set(entity.id, entity);\n        return entity;\n    }\n    destroyEntity(entityId) {\n        this.entitiesToDestroy.push(entityId);\n    }\n    // Notify systems that an entity has been fully configured and is ready\n    notifyEntityAdded(entity) {\n        for (const system of this.systems){\n            if (system.onEntityAdded && system.matchesEntity(entity)) {\n                system.onEntityAdded(entity);\n            }\n        }\n    }\n    getEntity(entityId) {\n        return this.entities.get(entityId);\n    }\n    getAllEntities() {\n        return Array.from(this.entities.values());\n    }\n    // System management\n    addSystem(system) {\n        var _system_onEnable;\n        this.systems.push(system);\n        this.systems.sort((a, b)=>a.priority - b.priority);\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem) {\n            this.renderSystems.push(system);\n        }\n        if (system instanceof _System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem) {\n            this.physicsSystems.push(system);\n        }\n        (_system_onEnable = system.onEnable) === null || _system_onEnable === void 0 ? void 0 : _system_onEnable.call(system);\n    }\n    getSystem(systemClass) {\n        return this.systems.find((system)=>system instanceof systemClass);\n    }\n    removeSystem(systemType) {\n        const index = this.systems.findIndex((s)=>s instanceof systemType);\n        if (index !== -1) {\n            var _system_onDisable;\n            const system = this.systems[index];\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n            this.systems.splice(index, 1);\n            // Remove from specialized arrays\n            const renderIndex = this.renderSystems.findIndex((s)=>s === system);\n            if (renderIndex !== -1) this.renderSystems.splice(renderIndex, 1);\n            const physicsIndex = this.physicsSystems.findIndex((s)=>s === system);\n            if (physicsIndex !== -1) this.physicsSystems.splice(physicsIndex, 1);\n        }\n    }\n    // Component pooling for performance\n    createComponent(componentType) {\n        // Use explicit componentType if available, fallback to constructor name\n        const typeName = componentType.componentType || componentType.name;\n        // Disable pooling for components that have prototype method issues in production\n        const problematicComponents = [\n            \"Health\",\n            \"HealthBar\",\n            \"Transform\",\n            \"Movement\",\n            \"Collider\",\n            \"Renderer\",\n            \"Enemy\",\n            \"Projectile\",\n            \"Animation\"\n        ];\n        if (problematicComponents.includes(typeName)) {\n            console.log(\"Creating \".concat(typeName, \" component without pooling to avoid prototype issues\"));\n            return new componentType();\n        }\n        let pool = this.componentPools.get(typeName);\n        if (!pool) {\n            pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_2__.ObjectPool(()=>new componentType(), (obj)=>obj.reset(), 100);\n            this.componentPools.set(typeName, pool);\n        }\n        return pool.acquire();\n    }\n    returnComponent(component) {\n        const pool = this.componentPools.get(component.constructor.name);\n        if (pool) {\n            pool.release(component);\n        }\n    }\n    // Main update loop\n    update(deltaTime) {\n        // Clean up destroyed entities\n        this.cleanupDestroyedEntities();\n        // Update all systems\n        for (const system of this.systems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.update(matchingEntities, deltaTime);\n        }\n    }\n    // Fixed timestep physics update\n    fixedUpdate(fixedDeltaTime) {\n        for (const system of this.physicsSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.fixedUpdate(matchingEntities, fixedDeltaTime);\n        }\n    }\n    // Render update\n    render(deltaTime) {\n        for (const system of this.renderSystems){\n            if (!system.enabled) continue;\n            const matchingEntities = this.getEntitiesForSystem(system);\n            system.render(matchingEntities, deltaTime);\n        }\n    }\n    // Get entities that match a system's requirements\n    getEntitiesForSystem(system) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (system.matchesEntity(entity)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Clean up destroyed entities\n    cleanupDestroyedEntities() {\n        for (const entityId of this.entitiesToDestroy){\n            const entity = this.entities.get(entityId);\n            if (entity) {\n                // Notify systems about entity removal\n                for (const system of this.systems){\n                    if (system.onEntityRemoved && system.matchesEntity(entity)) {\n                        system.onEntityRemoved(entity);\n                    }\n                }\n                // Return components to pools\n                for (const component of entity.getAllComponents()){\n                    this.returnComponent(component);\n                }\n                entity.destroy();\n                this.entities.delete(entityId);\n            }\n        }\n        this.entitiesToDestroy.length = 0;\n    }\n    // Query entities by components\n    queryEntities(componentTypes) {\n        const entities = [];\n        for (const entity of Array.from(this.entities.values())){\n            if (entity.isActive() && entity.hasComponents(componentTypes)) {\n                entities.push(entity);\n            }\n        }\n        return entities;\n    }\n    // Event system\n    emitEvent(eventType, eventData) {\n        if (!this.events.has(eventType)) {\n            this.events.set(eventType, []);\n        }\n        this.events.get(eventType).push(eventData);\n    }\n    getEvents(eventType) {\n        return this.events.get(eventType) || [];\n    }\n    clearEvents(eventType) {\n        this.events.set(eventType, []);\n    }\n    destroy() {\n        // Clean up all entities\n        for (const entity of Array.from(this.entities.values())){\n            entity.destroy();\n        }\n        this.entities.clear();\n        // Clean up systems\n        for (const system of this.systems){\n            var _system_onDisable;\n            (_system_onDisable = system.onDisable) === null || _system_onDisable === void 0 ? void 0 : _system_onDisable.call(system);\n        }\n        this.systems.length = 0;\n        this.renderSystems.length = 0;\n        this.physicsSystems.length = 0;\n        // Clear component pools\n        this.componentPools.clear();\n        // Clear events\n        this.events.clear();\n    }\n    constructor(){\n        this.entities = new Map();\n        this.systems = [];\n        this.renderSystems = [];\n        this.physicsSystems = [];\n        this.componentPools = new Map();\n        this.entitiesToDestroy = [];\n        this.events = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFFbkIsbUJBQW1CO1FBQ25CLEtBQUssTUFBTXhFLFVBQVUsSUFBSSxDQUFDQyxPQUFPLENBQUU7Z0JBQ2pDRDthQUFBQSxvQkFBQUEsT0FBTzBCLFNBQVMsY0FBaEIxQix3Q0FBQUEsdUJBQUFBO1FBQ0Y7UUFDQSxJQUFJLENBQUNDLE9BQU8sQ0FBQzJELE1BQU0sR0FBRztRQUN0QixJQUFJLENBQUM3QyxhQUFhLENBQUM2QyxNQUFNLEdBQUc7UUFDNUIsSUFBSSxDQUFDNUMsY0FBYyxDQUFDNEMsTUFBTSxHQUFHO1FBRTdCLHdCQUF3QjtRQUN4QixJQUFJLENBQUNyQixjQUFjLENBQUNpQyxLQUFLO1FBRXpCLGVBQWU7UUFDZixJQUFJLENBQUNKLE1BQU0sQ0FBQ0ksS0FBSztJQUNuQjs7YUE1TlFoRixXQUFXLElBQUlpRjthQUNmeEUsVUFBb0IsRUFBRTthQUN0QmMsZ0JBQWdDLEVBQUU7YUFDbENDLGlCQUFrQyxFQUFFO2FBQ3BDdUIsaUJBQWlCLElBQUlrQzthQUNyQjVFLG9CQUFnQyxFQUFFO2FBQ2xDdUUsU0FBUyxJQUFJSzs7QUF1TnZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvV29ybGQudHM/MzE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbnRpdHkgQ29tcG9uZW50IFN5c3RlbSAtIFdvcmxkIE1hbmFnZW1lbnRcbmltcG9ydCB7IEVudGl0eSwgRW50aXR5SWQsIENvbXBvbmVudCB9IGZyb20gJy4vRW50aXR5JztcbmltcG9ydCB7IFN5c3RlbSwgUmVuZGVyU3lzdGVtLCBQaHlzaWNzU3lzdGVtIH0gZnJvbSAnLi9TeXN0ZW0nO1xuaW1wb3J0IHsgT2JqZWN0UG9vbCB9IGZyb20gJ0AvdXRpbHMvT2JqZWN0UG9vbCc7XG5cbmV4cG9ydCBjbGFzcyBXb3JsZCB7XG4gIHByaXZhdGUgZW50aXRpZXMgPSBuZXcgTWFwPEVudGl0eUlkLCBFbnRpdHk+KCk7XG4gIHByaXZhdGUgc3lzdGVtczogU3lzdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSByZW5kZXJTeXN0ZW1zOiBSZW5kZXJTeXN0ZW1bXSA9IFtdO1xuICBwcml2YXRlIHBoeXNpY3NTeXN0ZW1zOiBQaHlzaWNzU3lzdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBjb21wb25lbnRQb29scyA9IG5ldyBNYXA8c3RyaW5nLCBPYmplY3RQb29sPGFueT4+KCk7XG4gIHByaXZhdGUgZW50aXRpZXNUb0Rlc3Ryb3k6IEVudGl0eUlkW10gPSBbXTtcbiAgcHJpdmF0ZSBldmVudHMgPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XG5cbiAgLy8gRW50aXR5IG1hbmFnZW1lbnRcbiAgcHVibGljIGNyZWF0ZUVudGl0eSgpOiBFbnRpdHkge1xuICAgIGNvbnN0IGVudGl0eSA9IG5ldyBFbnRpdHkoKTtcbiAgICB0aGlzLmVudGl0aWVzLnNldChlbnRpdHkuaWQsIGVudGl0eSk7XG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95RW50aXR5KGVudGl0eUlkOiBFbnRpdHlJZCk6IHZvaWQge1xuICAgIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHlJZCk7XG4gIH1cblxuICAvLyBOb3RpZnkgc3lzdGVtcyB0aGF0IGFuIGVudGl0eSBoYXMgYmVlbiBmdWxseSBjb25maWd1cmVkIGFuZCBpcyByZWFkeVxuICBwdWJsaWMgbm90aWZ5RW50aXR5QWRkZWQoZW50aXR5OiBFbnRpdHkpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIGlmIChzeXN0ZW0ub25FbnRpdHlBZGRlZCAmJiBzeXN0ZW0ubWF0Y2hlc0VudGl0eShlbnRpdHkpKSB7XG4gICAgICAgIHN5c3RlbS5vbkVudGl0eUFkZGVkKGVudGl0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldEVudGl0eShlbnRpdHlJZDogRW50aXR5SWQpOiBFbnRpdHkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0QWxsRW50aXRpZXMoKTogRW50aXR5W10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpO1xuICB9XG5cbiAgLy8gU3lzdGVtIG1hbmFnZW1lbnRcbiAgcHVibGljIGFkZFN5c3RlbShzeXN0ZW06IFN5c3RlbSk6IHZvaWQge1xuICAgIHRoaXMuc3lzdGVtcy5wdXNoKHN5c3RlbSk7XG4gICAgdGhpcy5zeXN0ZW1zLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcblxuICAgIGlmIChzeXN0ZW0gaW5zdGFuY2VvZiBSZW5kZXJTeXN0ZW0pIHtcbiAgICAgIHRoaXMucmVuZGVyU3lzdGVtcy5wdXNoKHN5c3RlbSk7XG4gICAgfVxuICAgIGlmIChzeXN0ZW0gaW5zdGFuY2VvZiBQaHlzaWNzU3lzdGVtKSB7XG4gICAgICB0aGlzLnBoeXNpY3NTeXN0ZW1zLnB1c2goc3lzdGVtKTtcbiAgICB9XG5cbiAgICBzeXN0ZW0ub25FbmFibGU/LigpO1xuICB9XG5cbiAgcHVibGljIGdldFN5c3RlbTxUIGV4dGVuZHMgU3lzdGVtPihzeXN0ZW1DbGFzczogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVCk6IFQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN5c3RlbXMuZmluZChzeXN0ZW0gPT4gc3lzdGVtIGluc3RhbmNlb2Ygc3lzdGVtQ2xhc3MpIGFzIFQgfCB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlU3lzdGVtKHN5c3RlbVR5cGU6IG5ldyAoKSA9PiBTeXN0ZW0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3lzdGVtcy5maW5kSW5kZXgocyA9PiBzIGluc3RhbmNlb2Ygc3lzdGVtVHlwZSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3Qgc3lzdGVtID0gdGhpcy5zeXN0ZW1zW2luZGV4XTtcbiAgICAgIHN5c3RlbS5vbkRpc2FibGU/LigpO1xuICAgICAgdGhpcy5zeXN0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIC8vIFJlbW92ZSBmcm9tIHNwZWNpYWxpemVkIGFycmF5c1xuICAgICAgY29uc3QgcmVuZGVySW5kZXggPSB0aGlzLnJlbmRlclN5c3RlbXMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3lzdGVtKTtcbiAgICAgIGlmIChyZW5kZXJJbmRleCAhPT0gLTEpIHRoaXMucmVuZGVyU3lzdGVtcy5zcGxpY2UocmVuZGVySW5kZXgsIDEpO1xuXG4gICAgICBjb25zdCBwaHlzaWNzSW5kZXggPSB0aGlzLnBoeXNpY3NTeXN0ZW1zLmZpbmRJbmRleChzID0+IHMgPT09IHN5c3RlbSk7XG4gICAgICBpZiAocGh5c2ljc0luZGV4ICE9PSAtMSkgdGhpcy5waHlzaWNzU3lzdGVtcy5zcGxpY2UocGh5c2ljc0luZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvLyBDb21wb25lbnQgcG9vbGluZyBmb3IgcGVyZm9ybWFuY2VcbiAgcHVibGljIGNyZWF0ZUNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnRUeXBlOiBuZXcgKCkgPT4gVCk6IFQge1xuICAgIC8vIFVzZSBleHBsaWNpdCBjb21wb25lbnRUeXBlIGlmIGF2YWlsYWJsZSwgZmFsbGJhY2sgdG8gY29uc3RydWN0b3IgbmFtZVxuICAgIGNvbnN0IHR5cGVOYW1lID0gKGNvbXBvbmVudFR5cGUgYXMgYW55KS5jb21wb25lbnRUeXBlIHx8IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICBcbiAgICAvLyBEaXNhYmxlIHBvb2xpbmcgZm9yIGNvbXBvbmVudHMgdGhhdCBoYXZlIHByb3RvdHlwZSBtZXRob2QgaXNzdWVzIGluIHByb2R1Y3Rpb25cbiAgICBjb25zdCBwcm9ibGVtYXRpY0NvbXBvbmVudHMgPSBbJ0hlYWx0aCcsICdIZWFsdGhCYXInLCAnVHJhbnNmb3JtJywgJ01vdmVtZW50JywgJ0NvbGxpZGVyJywgJ1JlbmRlcmVyJywgJ0VuZW15JywgJ1Byb2plY3RpbGUnLCAnQW5pbWF0aW9uJ107XG4gICAgaWYgKHByb2JsZW1hdGljQ29tcG9uZW50cy5pbmNsdWRlcyh0eXBlTmFtZSkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyAke3R5cGVOYW1lfSBjb21wb25lbnQgd2l0aG91dCBwb29saW5nIHRvIGF2b2lkIHByb3RvdHlwZSBpc3N1ZXNgKTtcbiAgICAgIHJldHVybiBuZXcgY29tcG9uZW50VHlwZSgpO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcG9vbCA9IHRoaXMuY29tcG9uZW50UG9vbHMuZ2V0KHR5cGVOYW1lKTtcbiAgICBcbiAgICBpZiAoIXBvb2wpIHtcbiAgICAgIHBvb2wgPSBuZXcgT2JqZWN0UG9vbDxUPigoKSA9PiBuZXcgY29tcG9uZW50VHlwZSgpLCAob2JqKSA9PiBvYmoucmVzZXQoKSwgMTAwKTtcbiAgICAgIHRoaXMuY29tcG9uZW50UG9vbHMuc2V0KHR5cGVOYW1lLCBwb29sKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBvb2wuYWNxdWlyZSgpO1xuICB9XG5cbiAgcHVibGljIHJldHVybkNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50Pihjb21wb25lbnQ6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBwb29sID0gdGhpcy5jb21wb25lbnRQb29scy5nZXQoY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIGlmIChwb29sKSB7XG4gICAgICBwb29sLnJlbGVhc2UoY29tcG9uZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBNYWluIHVwZGF0ZSBsb29wXG4gIHB1YmxpYyB1cGRhdGUoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBkZXN0cm95ZWQgZW50aXRpZXNcbiAgICB0aGlzLmNsZWFudXBEZXN0cm95ZWRFbnRpdGllcygpO1xuXG4gICAgLy8gVXBkYXRlIGFsbCBzeXN0ZW1zXG4gICAgZm9yIChjb25zdCBzeXN0ZW0gb2YgdGhpcy5zeXN0ZW1zKSB7XG4gICAgICBpZiAoIXN5c3RlbS5lbmFibGVkKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgbWF0Y2hpbmdFbnRpdGllcyA9IHRoaXMuZ2V0RW50aXRpZXNGb3JTeXN0ZW0oc3lzdGVtKTtcbiAgICAgIHN5c3RlbS51cGRhdGUobWF0Y2hpbmdFbnRpdGllcywgZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaXhlZCB0aW1lc3RlcCBwaHlzaWNzIHVwZGF0ZVxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZml4ZWREZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMucGh5c2ljc1N5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLmZpeGVkVXBkYXRlKG1hdGNoaW5nRW50aXRpZXMsIGZpeGVkRGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW5kZXIgdXBkYXRlXG4gIHB1YmxpYyByZW5kZXIoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnJlbmRlclN5c3RlbXMpIHtcbiAgICAgIGlmICghc3lzdGVtLmVuYWJsZWQpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBtYXRjaGluZ0VudGl0aWVzID0gdGhpcy5nZXRFbnRpdGllc0ZvclN5c3RlbShzeXN0ZW0pO1xuICAgICAgc3lzdGVtLnJlbmRlcihtYXRjaGluZ0VudGl0aWVzLCBkZWx0YVRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBlbnRpdGllcyB0aGF0IG1hdGNoIGEgc3lzdGVtJ3MgcmVxdWlyZW1lbnRzXG4gIHByaXZhdGUgZ2V0RW50aXRpZXNGb3JTeXN0ZW0oc3lzdGVtOiBTeXN0ZW0pOiBFbnRpdHlbXSB7XG4gICAgY29uc3QgZW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgQXJyYXkuZnJvbSh0aGlzLmVudGl0aWVzLnZhbHVlcygpKSkge1xuICAgICAgaWYgKHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH1cblxuICAvLyBDbGVhbiB1cCBkZXN0cm95ZWQgZW50aXRpZXNcbiAgcHJpdmF0ZSBjbGVhbnVwRGVzdHJveWVkRW50aXRpZXMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiB0aGlzLmVudGl0aWVzVG9EZXN0cm95KSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmVudGl0aWVzLmdldChlbnRpdHlJZCk7XG4gICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgIC8vIE5vdGlmeSBzeXN0ZW1zIGFib3V0IGVudGl0eSByZW1vdmFsXG4gICAgICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xuICAgICAgICAgIGlmIChzeXN0ZW0ub25FbnRpdHlSZW1vdmVkICYmIHN5c3RlbS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcbiAgICAgICAgICAgIHN5c3RlbS5vbkVudGl0eVJlbW92ZWQoZW50aXR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJldHVybiBjb21wb25lbnRzIHRvIHBvb2xzXG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGVudGl0eS5nZXRBbGxDb21wb25lbnRzKCkpIHtcbiAgICAgICAgICB0aGlzLnJldHVybkNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBlbnRpdHkuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVudGl0aWVzLmRlbGV0ZShlbnRpdHlJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW50aXRpZXNUb0Rlc3Ryb3kubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8vIFF1ZXJ5IGVudGl0aWVzIGJ5IGNvbXBvbmVudHNcbiAgcHVibGljIHF1ZXJ5RW50aXRpZXMoY29tcG9uZW50VHlwZXM6IChuZXcgKCkgPT4gQ29tcG9uZW50KVtdKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGVudGl0aWVzOiBFbnRpdHlbXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSkpIHtcbiAgICAgIGlmIChlbnRpdHkuaXNBY3RpdmUoKSAmJiBlbnRpdHkuaGFzQ29tcG9uZW50cyhjb21wb25lbnRUeXBlcykpIHtcbiAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZW50aXRpZXM7XG4gIH1cblxuICAvLyBFdmVudCBzeXN0ZW1cbiAgcHVibGljIGVtaXRFdmVudChldmVudFR5cGU6IHN0cmluZywgZXZlbnREYXRhOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXZlbnRzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICB0aGlzLmV2ZW50cy5zZXQoZXZlbnRUeXBlLCBbXSk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpIS5wdXNoKGV2ZW50RGF0YSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0RXZlbnRzKGV2ZW50VHlwZTogc3RyaW5nKTogYW55W10ge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cy5nZXQoZXZlbnRUeXBlKSB8fCBbXTtcbiAgfVxuXG4gIHB1YmxpYyBjbGVhckV2ZW50cyhldmVudFR5cGU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIFtdKTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBlbnRpdGllc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIEFycmF5LmZyb20odGhpcy5lbnRpdGllcy52YWx1ZXMoKSkpIHtcbiAgICAgIGVudGl0eS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZW50aXRpZXMuY2xlYXIoKTtcblxuICAgIC8vIENsZWFuIHVwIHN5c3RlbXNcbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcbiAgICAgIHN5c3RlbS5vbkRpc2FibGU/LigpO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnJlbmRlclN5c3RlbXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnBoeXNpY3NTeXN0ZW1zLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBDbGVhciBjb21wb25lbnQgcG9vbHNcbiAgICB0aGlzLmNvbXBvbmVudFBvb2xzLmNsZWFyKCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgZXZlbnRzXG4gICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkVudGl0eSIsIlJlbmRlclN5c3RlbSIsIlBoeXNpY3NTeXN0ZW0iLCJPYmplY3RQb29sIiwiV29ybGQiLCJjcmVhdGVFbnRpdHkiLCJlbnRpdHkiLCJlbnRpdGllcyIsInNldCIsImlkIiwiZGVzdHJveUVudGl0eSIsImVudGl0eUlkIiwiZW50aXRpZXNUb0Rlc3Ryb3kiLCJwdXNoIiwibm90aWZ5RW50aXR5QWRkZWQiLCJzeXN0ZW0iLCJzeXN0ZW1zIiwib25FbnRpdHlBZGRlZCIsIm1hdGNoZXNFbnRpdHkiLCJnZXRFbnRpdHkiLCJnZXQiLCJnZXRBbGxFbnRpdGllcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImFkZFN5c3RlbSIsInNvcnQiLCJhIiwiYiIsInByaW9yaXR5IiwicmVuZGVyU3lzdGVtcyIsInBoeXNpY3NTeXN0ZW1zIiwib25FbmFibGUiLCJnZXRTeXN0ZW0iLCJzeXN0ZW1DbGFzcyIsImZpbmQiLCJyZW1vdmVTeXN0ZW0iLCJzeXN0ZW1UeXBlIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJzIiwib25EaXNhYmxlIiwic3BsaWNlIiwicmVuZGVySW5kZXgiLCJwaHlzaWNzSW5kZXgiLCJjcmVhdGVDb21wb25lbnQiLCJjb21wb25lbnRUeXBlIiwidHlwZU5hbWUiLCJuYW1lIiwicHJvYmxlbWF0aWNDb21wb25lbnRzIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwibG9nIiwicG9vbCIsImNvbXBvbmVudFBvb2xzIiwib2JqIiwicmVzZXQiLCJhY3F1aXJlIiwicmV0dXJuQ29tcG9uZW50IiwiY29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJyZWxlYXNlIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiY2xlYW51cERlc3Ryb3llZEVudGl0aWVzIiwiZW5hYmxlZCIsIm1hdGNoaW5nRW50aXRpZXMiLCJnZXRFbnRpdGllc0ZvclN5c3RlbSIsImZpeGVkVXBkYXRlIiwiZml4ZWREZWx0YVRpbWUiLCJyZW5kZXIiLCJvbkVudGl0eVJlbW92ZWQiLCJnZXRBbGxDb21wb25lbnRzIiwiZGVzdHJveSIsImRlbGV0ZSIsImxlbmd0aCIsInF1ZXJ5RW50aXRpZXMiLCJjb21wb25lbnRUeXBlcyIsImlzQWN0aXZlIiwiaGFzQ29tcG9uZW50cyIsImVtaXRFdmVudCIsImV2ZW50VHlwZSIsImV2ZW50RGF0YSIsImV2ZW50cyIsImhhcyIsImdldEV2ZW50cyIsImNsZWFyRXZlbnRzIiwiY2xlYXIiLCJNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/World.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Collider.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Collider.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collider: function() { return /* binding */ Collider; },\n/* harmony export */   ColliderType: function() { return /* binding */ ColliderType; },\n/* harmony export */   CollisionLayer: function() { return /* binding */ CollisionLayer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Collider component for collision detection\n\n\nvar ColliderType;\n(function(ColliderType) {\n    ColliderType[\"SPHERE\"] = \"sphere\";\n    ColliderType[\"BOX\"] = \"box\";\n    ColliderType[\"CAPSULE\"] = \"capsule\";\n    ColliderType[\"CYLINDER\"] = \"cylinder\";\n})(ColliderType || (ColliderType = {}));\nvar CollisionLayer;\n(function(CollisionLayer) {\n    CollisionLayer[CollisionLayer[\"DEFAULT\"] = 1] = \"DEFAULT\";\n    CollisionLayer[CollisionLayer[\"PLAYER\"] = 2] = \"PLAYER\";\n    CollisionLayer[CollisionLayer[\"ENEMY\"] = 4] = \"ENEMY\";\n    CollisionLayer[CollisionLayer[\"PROJECTILE\"] = 8] = \"PROJECTILE\";\n    CollisionLayer[CollisionLayer[\"ENVIRONMENT\"] = 16] = \"ENVIRONMENT\";\n    CollisionLayer[CollisionLayer[\"PICKUP\"] = 32] = \"PICKUP\";\n})(CollisionLayer || (CollisionLayer = {}));\nclass Collider extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    getDefaultMask(layer) {\n        switch(layer){\n            case 2:\n                return 4 | 16 | 32;\n            case 4:\n                return 2 | 8 | 16;\n            case 8:\n                return 2 | 4 | 16;\n            case 16:\n                return 2 | 4 | 8;\n            case 32:\n                return 2;\n            default:\n                return 0xFFFFFFFF; // Collide with everything\n        }\n    }\n    static createSphere(radius) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        return new Collider(\"sphere\", radius, layer);\n    }\n    static createBox(size) {\n        let layer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const collider = new Collider(\"box\", 0, layer);\n        collider.size.copy(size);\n        return collider;\n    }\n    static createCapsule(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"capsule\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    static createCylinder(radius, height) {\n        let layer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n        const collider = new Collider(\"cylinder\", radius, layer);\n        collider.height = height;\n        return collider;\n    }\n    setOffset(x, y, z) {\n        this.offset.set(x, y, z);\n        this.boundsNeedUpdate = true;\n    }\n    setLayer(layer) {\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n    }\n    setMask(mask) {\n        this.mask = mask;\n    }\n    canCollideWith(other) {\n        return (this.mask & other.layer) !== 0 && (other.mask & this.layer) !== 0;\n    }\n    updateBounds(worldPosition) {\n        if (!this.boundsNeedUpdate && !this.isStatic) {\n            return;\n        }\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                this.boundingSphere.set(center, this.radius);\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.radius * 2, this.radius * 2));\n                break;\n            case \"box\":\n                this.bounds.setFromCenterAndSize(center, this.size);\n                this.boundingSphere.setFromPoints([\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-this.size.x / 2, -this.size.y / 2, -this.size.z / 2)),\n                    center.clone().add(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.size.x / 2, this.size.y / 2, this.size.z / 2))\n                ]);\n                break;\n            case \"capsule\":\n                const capsuleRadius = Math.max(this.radius, this.size.x / 2, this.size.z / 2);\n                this.boundingSphere.set(center, Math.max(capsuleRadius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(capsuleRadius * 2, this.height, capsuleRadius * 2));\n                break;\n            case \"cylinder\":\n                this.boundingSphere.set(center, Math.max(this.radius, this.height / 2));\n                this.bounds.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.radius * 2, this.height, this.radius * 2));\n                break;\n        }\n        this.boundsNeedUpdate = false;\n    }\n    intersects(other, thisPosition, otherPosition) {\n        // Update bounds if needed\n        this.updateBounds(thisPosition);\n        other.updateBounds(otherPosition);\n        // Quick bounding sphere check first\n        if (!this.boundingSphere.intersectsSphere(other.boundingSphere)) {\n            return false;\n        }\n        // More precise collision detection based on collider types\n        return this.preciseIntersection(other, thisPosition, otherPosition);\n    }\n    preciseIntersection(other, thisPosition, otherPosition) {\n        const thisCenter = thisPosition.clone().add(this.offset);\n        const otherCenter = otherPosition.clone().add(other.offset);\n        // Sphere vs Sphere\n        if (this.type === \"sphere\" && other.type === \"sphere\") {\n            const distance = thisCenter.distanceTo(otherCenter);\n            return distance <= this.radius + other.radius;\n        }\n        // Box vs Box\n        if (this.type === \"box\" && other.type === \"box\") {\n            return this.bounds.intersectsBox(other.bounds);\n        }\n        // Sphere vs Box\n        if (this.type === \"sphere\" && other.type === \"box\" || this.type === \"box\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const box = this.type === \"box\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            box.bounds.clampPoint(sphereCenter, closestPoint);\n            return sphereCenter.distanceTo(closestPoint) <= sphere.radius;\n        }\n        // Sphere vs Cylinder (for pillar collisions)\n        if (this.type === \"sphere\" && other.type === \"cylinder\" || this.type === \"cylinder\" && other.type === \"sphere\") {\n            const sphere = this.type === \"sphere\" ? this : other;\n            const cylinder = this.type === \"cylinder\" ? this : other;\n            const sphereCenter = this.type === \"sphere\" ? thisCenter : otherCenter;\n            const cylinderCenter = this.type === \"cylinder\" ? thisCenter : otherCenter;\n            // Check if sphere is within cylinder's height range\n            const heightDiff = Math.abs(sphereCenter.y - cylinderCenter.y);\n            if (heightDiff > cylinder.height / 2 + sphere.radius) {\n                return false; // Sphere is above or below cylinder\n            }\n            // Check horizontal distance (XZ plane)\n            const horizontalDistance = Math.sqrt(Math.pow(sphereCenter.x - cylinderCenter.x, 2) + Math.pow(sphereCenter.z - cylinderCenter.z, 2));\n            return horizontalDistance <= sphere.radius + cylinder.radius;\n        }\n        // For other combinations, fall back to bounding box intersection\n        return this.bounds.intersectsBox(other.bounds);\n    }\n    getClosestPoint(point, worldPosition) {\n        this.updateBounds(worldPosition);\n        const center = worldPosition.clone().add(this.offset);\n        switch(this.type){\n            case \"sphere\":\n                const direction = point.clone().sub(center).normalize();\n                return center.clone().add(direction.multiplyScalar(this.radius));\n            case \"box\":\n                const closestPoint = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, closestPoint);\n                return closestPoint;\n            default:\n                // For other types, use bounding box\n                const boxClosest = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.bounds.clampPoint(point, boxClosest);\n                return boxClosest;\n        }\n    }\n    getVolume() {\n        switch(this.type){\n            case \"sphere\":\n                return 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n            case \"box\":\n                return this.size.x * this.size.y * this.size.z;\n            case \"cylinder\":\n                return Math.PI * Math.pow(this.radius, 2) * this.height;\n            case \"capsule\":\n                const sphereVolume = 4 / 3 * Math.PI * Math.pow(this.radius, 3);\n                const cylinderVolume = Math.PI * Math.pow(this.radius, 2) * (this.height - 2 * this.radius);\n                return sphereVolume + cylinderVolume;\n            default:\n                return 1;\n        }\n    }\n    reset() {\n        this.type = \"sphere\";\n        this.radius = 0.5;\n        this.size.set(1, 1, 1);\n        this.height = 2;\n        this.offset.set(0, 0, 0);\n        this.layer = 1;\n        this.mask = this.getDefaultMask(1);\n        this.isTrigger = false;\n        this.isStatic = false;\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n        this.onCollisionEnter = undefined;\n        this.onCollisionStay = undefined;\n        this.onCollisionExit = undefined;\n        this.onTriggerEnter = undefined;\n        this.onTriggerStay = undefined;\n        this.onTriggerExit = undefined;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Collider(this.type, this.radius, this.layer);\n        clone.size.copy(this.size);\n        clone.height = this.height;\n        clone.offset.copy(this.offset);\n        clone.mask = this.mask;\n        clone.isTrigger = this.isTrigger;\n        clone.isStatic = this.isStatic;\n        return clone;\n    }\n    constructor(type = \"sphere\", radius = 0.5, layer = 1){\n        super();\n        this.componentType = \"Collider\" // Instance identifier\n        ;\n        this.type = type;\n        this.radius = radius;\n        this.size = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        this.height = 2;\n        this.offset = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.layer = layer;\n        this.mask = this.getDefaultMask(layer);\n        this.isTrigger = false;\n        this.isStatic = false;\n        // Initialize bounds\n        this.bounds = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.boundingSphere = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.boundsNeedUpdate = true;\n    }\n}\nCollider.componentType = \"Collider\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Db2xsaWRlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDZDQUE2QztBQUNpQjtBQUN4Qjs7VUFFMUJJOzs7OztHQUFBQSxpQkFBQUE7O1VBT0FDOzs7Ozs7O0dBQUFBLG1CQUFBQTtBQVNMLE1BQU1DLGlCQUFpQkgsOENBQVNBO0lBaUQ3QkksZUFBZUMsS0FBcUIsRUFBVTtRQUNwRCxPQUFRQTtZQUNOO2dCQUNFLE9BQU9IO1lBQ1Q7Z0JBQ0UsT0FBT0E7WUFDVDtnQkFDRSxPQUFPQTtZQUNUO2dCQUNFLE9BQU9BO1lBQ1Q7Z0JBQ0U7WUFDRjtnQkFDRSxPQUFPLFlBQVksMEJBQTBCO1FBQ2pEO0lBQ0Y7SUFFQSxPQUFjSSxhQUFhQyxNQUFjLEVBQTREO1lBQTFERixRQUFBQTtRQUN6QyxPQUFPLElBQUlGLG1CQUE4QkksUUFBUUY7SUFDbkQ7SUFFQSxPQUFjRyxVQUFVQyxJQUFhLEVBQTREO1lBQTFESixRQUFBQTtRQUNyQyxNQUFNSyxXQUFXLElBQUlQLGdCQUEyQixHQUFHRTtRQUNuREssU0FBU0QsSUFBSSxDQUFDRSxJQUFJLENBQUNGO1FBQ25CLE9BQU9DO0lBQ1Q7SUFFQSxPQUFjRSxjQUFjTCxNQUFjLEVBQUVNLE1BQWMsRUFBNEQ7WUFBMURSLFFBQUFBO1FBQzFELE1BQU1LLFdBQVcsSUFBSVAsb0JBQStCSSxRQUFRRjtRQUM1REssU0FBU0csTUFBTSxHQUFHQTtRQUNsQixPQUFPSDtJQUNUO0lBRUEsT0FBY0ksZUFBZVAsTUFBYyxFQUFFTSxNQUFjLEVBQTREO1lBQTFEUixRQUFBQTtRQUMzRCxNQUFNSyxXQUFXLElBQUlQLHFCQUFnQ0ksUUFBUUY7UUFDN0RLLFNBQVNHLE1BQU0sR0FBR0E7UUFDbEIsT0FBT0g7SUFDVDtJQUVPSyxVQUFVQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFRO1FBQ3RELElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxHQUFHLENBQUNK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QjtRQUNwQixJQUFJLENBQUNNLE1BQU0sR0FBRyxJQUFJckMsc0RBQUlBO1FBQ3RCLElBQUksQ0FBQ29DLGNBQWMsR0FBRyxJQUFJbkMsd0RBQU1BO1FBQ2hDLElBQUksQ0FBQ3NCLGdCQUFnQixHQUFHO0lBQzFCO0FBZ1BGO0FBL1JhbEIsU0FDWWtGLGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXIudHM/MzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2xsaWRlciBjb21wb25lbnQgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMsIFNwaGVyZSB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBDb2xsaWRlclR5cGUge1xuICBTUEhFUkUgPSAnc3BoZXJlJyxcbiAgQk9YID0gJ2JveCcsXG4gIENBUFNVTEUgPSAnY2Fwc3VsZScsXG4gIENZTElOREVSID0gJ2N5bGluZGVyJ1xufVxuXG5leHBvcnQgZW51bSBDb2xsaXNpb25MYXllciB7XG4gIERFRkFVTFQgPSAxLFxuICBQTEFZRVIgPSAyLFxuICBFTkVNWSA9IDQsXG4gIFBST0pFQ1RJTEUgPSA4LFxuICBFTlZJUk9OTUVOVCA9IDE2LFxuICBQSUNLVVAgPSAzMlxufVxuXG5leHBvcnQgY2xhc3MgQ29sbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnQ29sbGlkZXInOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyB0eXBlOiBDb2xsaWRlclR5cGU7XG4gIHB1YmxpYyByYWRpdXM6IG51bWJlcjsgLy8gRm9yIHNwaGVyZSBhbmQgY3lsaW5kZXJcbiAgcHVibGljIHNpemU6IFZlY3RvcjM7IC8vIEZvciBib3ggKHdpZHRoLCBoZWlnaHQsIGRlcHRoKVxuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7IC8vIEZvciBjYXBzdWxlIGFuZCBjeWxpbmRlclxuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzOyAvLyBPZmZzZXQgZnJvbSB0cmFuc2Zvcm0gcG9zaXRpb25cbiAgcHVibGljIGxheWVyOiBDb2xsaXNpb25MYXllcjtcbiAgcHVibGljIG1hc2s6IG51bWJlcjsgLy8gV2hpY2ggbGF5ZXJzIHRoaXMgY29sbGlkZXIgY2FuIGNvbGxpZGUgd2l0aFxuICBwdWJsaWMgaXNUcmlnZ2VyOiBib29sZWFuOyAvLyBJZiB0cnVlLCBkb2Vzbid0IGJsb2NrIG1vdmVtZW50IGJ1dCBzdGlsbCBkZXRlY3RzIGNvbGxpc2lvbnNcbiAgcHVibGljIGlzU3RhdGljOiBib29sZWFuOyAvLyBJZiB0cnVlLCBjb2xsaWRlciBkb2Vzbid0IG1vdmUgKG9wdGltaXphdGlvbilcbiAgXG4gIC8vIENhY2hlZCBib3VuZHMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBib3VuZHM6IEJveDM7XG4gIHB1YmxpYyBib3VuZGluZ1NwaGVyZTogU3BoZXJlO1xuICBwdWJsaWMgYm91bmRzTmVlZFVwZGF0ZTogYm9vbGVhbjtcbiAgXG4gIC8vIENvbGxpc2lvbiBjYWxsYmFja3NcbiAgcHVibGljIG9uQ29sbGlzaW9uRW50ZXI/OiAob3RoZXI6IENvbGxpZGVyLCBlbnRpdHk6IGFueSkgPT4gdm9pZDtcbiAgcHVibGljIG9uQ29sbGlzaW9uU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25Db2xsaXNpb25FeGl0PzogKG90aGVyOiBDb2xsaWRlciwgZW50aXR5OiBhbnkpID0+IHZvaWQ7XG4gIHB1YmxpYyBvblRyaWdnZXJFbnRlcj86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyU3RheT86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuICBwdWJsaWMgb25UcmlnZ2VyRXhpdD86IChvdGhlcjogQ29sbGlkZXIsIGVudGl0eTogYW55KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGU6IENvbGxpZGVyVHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkUsXG4gICAgcmFkaXVzOiBudW1iZXIgPSAwLjUsXG4gICAgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgdGhpcy5zaXplID0gbmV3IFZlY3RvcjMoMSwgMSwgMSk7XG4gICAgdGhpcy5oZWlnaHQgPSAyO1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2sobGF5ZXIpO1xuICAgIHRoaXMuaXNUcmlnZ2VyID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgYm91bmRzXG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1hc2sobGF5ZXI6IENvbGxpc2lvbkxheWVyKTogbnVtYmVyIHtcbiAgICBzd2l0Y2ggKGxheWVyKSB7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBMQVlFUjpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLkVORU1ZIHwgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQgfCBDb2xsaXNpb25MYXllci5QSUNLVVA7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLkVORU1ZOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRSB8IENvbGxpc2lvbkxheWVyLkVOVklST05NRU5UO1xuICAgICAgY2FzZSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFOlxuICAgICAgICByZXR1cm4gQ29sbGlzaW9uTGF5ZXIuUExBWUVSIHwgQ29sbGlzaW9uTGF5ZXIuRU5FTVkgfCBDb2xsaXNpb25MYXllci5FTlZJUk9OTUVOVDtcbiAgICAgIGNhc2UgQ29sbGlzaW9uTGF5ZXIuRU5WSVJPTk1FTlQ6XG4gICAgICAgIHJldHVybiBDb2xsaXNpb25MYXllci5QTEFZRVIgfCBDb2xsaXNpb25MYXllci5FTkVNWSB8IENvbGxpc2lvbkxheWVyLlBST0pFQ1RJTEU7XG4gICAgICBjYXNlIENvbGxpc2lvbkxheWVyLlBJQ0tVUDpcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkxheWVyLlBMQVlFUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAweEZGRkZGRkZGOyAvLyBDb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlU3BoZXJlKHJhZGl1czogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIHJldHVybiBuZXcgQ29sbGlkZXIoQ29sbGlkZXJUeXBlLlNQSEVSRSwgcmFkaXVzLCBsYXllcik7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUJveChzaXplOiBWZWN0b3IzLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5CT1gsIDAsIGxheWVyKTtcbiAgICBjb2xsaWRlci5zaXplLmNvcHkoc2l6ZSk7XG4gICAgcmV0dXJuIGNvbGxpZGVyO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVDYXBzdWxlKHJhZGl1czogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgbGF5ZXI6IENvbGxpc2lvbkxheWVyID0gQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk6IENvbGxpZGVyIHtcbiAgICBjb25zdCBjb2xsaWRlciA9IG5ldyBDb2xsaWRlcihDb2xsaWRlclR5cGUuQ0FQU1VMRSwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ3lsaW5kZXIocmFkaXVzOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBsYXllcjogQ29sbGlzaW9uTGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNvbGxpZGVyID0gbmV3IENvbGxpZGVyKENvbGxpZGVyVHlwZS5DWUxJTkRFUiwgcmFkaXVzLCBsYXllcik7XG4gICAgY29sbGlkZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPZmZzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMub2Zmc2V0LnNldCh4LCB5LCB6KTtcbiAgICB0aGlzLmJvdW5kc05lZWRVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIHNldExheWVyKGxheWVyOiBDb2xsaXNpb25MYXllcik6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICB0aGlzLm1hc2sgPSB0aGlzLmdldERlZmF1bHRNYXNrKGxheWVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXNrKG1hc2s6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWFzayA9IG1hc2s7XG4gIH1cblxuICBwdWJsaWMgY2FuQ29sbGlkZVdpdGgob3RoZXI6IENvbGxpZGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICh0aGlzLm1hc2sgJiBvdGhlci5sYXllcikgIT09IDAgJiYgKG90aGVyLm1hc2sgJiB0aGlzLmxheWVyKSAhPT0gMDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVCb3VuZHMod29ybGRQb3NpdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ib3VuZHNOZWVkVXBkYXRlICYmICF0aGlzLmlzU3RhdGljKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuU1BIRVJFOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIHRoaXMucmFkaXVzKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyXG4gICAgICAgICkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQk9YOlxuICAgICAgICB0aGlzLmJvdW5kcy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyhbXG4gICAgICAgICAgY2VudGVyLmNsb25lKCkuYWRkKG5ldyBWZWN0b3IzKC10aGlzLnNpemUueC8yLCAtdGhpcy5zaXplLnkvMiwgLXRoaXMuc2l6ZS56LzIpKSxcbiAgICAgICAgICBjZW50ZXIuY2xvbmUoKS5hZGQobmV3IFZlY3RvcjModGhpcy5zaXplLngvMiwgdGhpcy5zaXplLnkvMiwgdGhpcy5zaXplLnovMikpXG4gICAgICAgIF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb2xsaWRlclR5cGUuQ0FQU1VMRTpcbiAgICAgICAgY29uc3QgY2Fwc3VsZVJhZGl1cyA9IE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLnNpemUueCAvIDIsIHRoaXMuc2l6ZS56IC8gMik7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0KGNlbnRlciwgTWF0aC5tYXgoY2Fwc3VsZVJhZGl1cywgdGhpcy5oZWlnaHQgLyAyKSk7XG4gICAgICAgIHRoaXMuYm91bmRzLnNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgbmV3IFZlY3RvcjMoXG4gICAgICAgICAgY2Fwc3VsZVJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCBjYXBzdWxlUmFkaXVzICogMlxuICAgICAgICApKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNZTElOREVSOlxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChjZW50ZXIsIE1hdGgubWF4KHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodCAvIDIpKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuc2V0RnJvbUNlbnRlckFuZFNpemUoY2VudGVyLCBuZXcgVmVjdG9yMyhcbiAgICAgICAgICB0aGlzLnJhZGl1cyAqIDIsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyAqIDJcbiAgICAgICAgKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGludGVyc2VjdHMob3RoZXI6IENvbGxpZGVyLCB0aGlzUG9zaXRpb246IFZlY3RvcjMsIG90aGVyUG9zaXRpb246IFZlY3RvcjMpOiBib29sZWFuIHtcbiAgICAvLyBVcGRhdGUgYm91bmRzIGlmIG5lZWRlZFxuICAgIHRoaXMudXBkYXRlQm91bmRzKHRoaXNQb3NpdGlvbik7XG4gICAgb3RoZXIudXBkYXRlQm91bmRzKG90aGVyUG9zaXRpb24pO1xuXG4gICAgLy8gUXVpY2sgYm91bmRpbmcgc3BoZXJlIGNoZWNrIGZpcnN0XG4gICAgaWYgKCF0aGlzLmJvdW5kaW5nU3BoZXJlLmludGVyc2VjdHNTcGhlcmUob3RoZXIuYm91bmRpbmdTcGhlcmUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTW9yZSBwcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb24gYmFzZWQgb24gY29sbGlkZXIgdHlwZXNcbiAgICByZXR1cm4gdGhpcy5wcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyLCB0aGlzUG9zaXRpb24sIG90aGVyUG9zaXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVjaXNlSW50ZXJzZWN0aW9uKG90aGVyOiBDb2xsaWRlciwgdGhpc1Bvc2l0aW9uOiBWZWN0b3IzLCBvdGhlclBvc2l0aW9uOiBWZWN0b3IzKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGhpc0NlbnRlciA9IHRoaXNQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgY29uc3Qgb3RoZXJDZW50ZXIgPSBvdGhlclBvc2l0aW9uLmNsb25lKCkuYWRkKG90aGVyLm9mZnNldCk7XG5cbiAgICAvLyBTcGhlcmUgdnMgU3BoZXJlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXNDZW50ZXIuZGlzdGFuY2VUbyhvdGhlckNlbnRlcik7XG4gICAgICByZXR1cm4gZGlzdGFuY2UgPD0gKHRoaXMucmFkaXVzICsgb3RoZXIucmFkaXVzKTtcbiAgICB9XG5cbiAgICAvLyBCb3ggdnMgQm94XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLkJPWCAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZHMuaW50ZXJzZWN0c0JveChvdGhlci5ib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIFNwaGVyZSB2cyBCb3hcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YKSB8fFxuICAgICAgICAodGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQk9YICYmIG90aGVyLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUpKSB7XG4gICAgICBjb25zdCBzcGhlcmUgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBib3ggPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5CT1ggPyB0aGlzIDogb3RoZXI7XG4gICAgICBjb25zdCBzcGhlcmVDZW50ZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5TUEhFUkUgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBib3guYm91bmRzLmNsYW1wUG9pbnQoc3BoZXJlQ2VudGVyLCBjbG9zZXN0UG9pbnQpO1xuICAgICAgcmV0dXJuIHNwaGVyZUNlbnRlci5kaXN0YW5jZVRvKGNsb3Nlc3RQb2ludCkgPD0gc3BoZXJlLnJhZGl1cztcbiAgICB9XG5cbiAgICAvLyBTcGhlcmUgdnMgQ3lsaW5kZXIgKGZvciBwaWxsYXIgY29sbGlzaW9ucylcbiAgICBpZiAoKHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIpIHx8XG4gICAgICAgICh0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiAmJiBvdGhlci50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFKSkge1xuICAgICAgY29uc3Qgc3BoZXJlID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuU1BIRVJFID8gdGhpcyA6IG90aGVyO1xuICAgICAgY29uc3QgY3lsaW5kZXIgPSB0aGlzLnR5cGUgPT09IENvbGxpZGVyVHlwZS5DWUxJTkRFUiA/IHRoaXMgOiBvdGhlcjtcbiAgICAgIGNvbnN0IHNwaGVyZUNlbnRlciA9IHRoaXMudHlwZSA9PT0gQ29sbGlkZXJUeXBlLlNQSEVSRSA/IHRoaXNDZW50ZXIgOiBvdGhlckNlbnRlcjtcbiAgICAgIGNvbnN0IGN5bGluZGVyQ2VudGVyID0gdGhpcy50eXBlID09PSBDb2xsaWRlclR5cGUuQ1lMSU5ERVIgPyB0aGlzQ2VudGVyIDogb3RoZXJDZW50ZXI7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNwaGVyZSBpcyB3aXRoaW4gY3lsaW5kZXIncyBoZWlnaHQgcmFuZ2VcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhzcGhlcmVDZW50ZXIueSAtIGN5bGluZGVyQ2VudGVyLnkpO1xuICAgICAgaWYgKGhlaWdodERpZmYgPiAoY3lsaW5kZXIuaGVpZ2h0IC8gMiArIHNwaGVyZS5yYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU3BoZXJlIGlzIGFib3ZlIG9yIGJlbG93IGN5bGluZGVyXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKFhaIHBsYW5lKVxuICAgICAgY29uc3QgaG9yaXpvbnRhbERpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLnBvdyhzcGhlcmVDZW50ZXIueCAtIGN5bGluZGVyQ2VudGVyLngsIDIpICsgXG4gICAgICAgIE1hdGgucG93KHNwaGVyZUNlbnRlci56IC0gY3lsaW5kZXJDZW50ZXIueiwgMilcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBob3Jpem9udGFsRGlzdGFuY2UgPD0gKHNwaGVyZS5yYWRpdXMgKyBjeWxpbmRlci5yYWRpdXMpO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBjb21iaW5hdGlvbnMsIGZhbGwgYmFjayB0byBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmludGVyc2VjdHNCb3gob3RoZXIuYm91bmRzKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDbG9zZXN0UG9pbnQocG9pbnQ6IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kcyh3b3JsZFBvc2l0aW9uKTtcbiAgICBjb25zdCBjZW50ZXIgPSB3b3JsZFBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMub2Zmc2V0KTtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHBvaW50LmNsb25lKCkuc3ViKGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBjZW50ZXIuY2xvbmUoKS5hZGQoZGlyZWN0aW9uLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKSk7XG5cbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkJPWDpcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5ib3VuZHMuY2xhbXBQb2ludChwb2ludCwgY2xvc2VzdFBvaW50KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yIG90aGVyIHR5cGVzLCB1c2UgYm91bmRpbmcgYm94XG4gICAgICAgIGNvbnN0IGJveENsb3Nlc3QgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB0aGlzLmJvdW5kcy5jbGFtcFBvaW50KHBvaW50LCBib3hDbG9zZXN0KTtcbiAgICAgICAgcmV0dXJuIGJveENsb3Nlc3Q7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFZvbHVtZSgpOiBudW1iZXIge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5TUEhFUkU6XG4gICAgICAgIHJldHVybiAoNC8zKSAqIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMyk7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5CT1g6XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUueCAqIHRoaXMuc2l6ZS55ICogdGhpcy5zaXplLno7XG4gICAgICBjYXNlIENvbGxpZGVyVHlwZS5DWUxJTkRFUjpcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNhc2UgQ29sbGlkZXJUeXBlLkNBUFNVTEU6XG4gICAgICAgIGNvbnN0IHNwaGVyZVZvbHVtZSA9ICg0LzMpICogTWF0aC5QSSAqIE1hdGgucG93KHRoaXMucmFkaXVzLCAzKTtcbiAgICAgICAgY29uc3QgY3lsaW5kZXJWb2x1bWUgPSBNYXRoLlBJICogTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpICogKHRoaXMuaGVpZ2h0IC0gMiAqIHRoaXMucmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHNwaGVyZVZvbHVtZSArIGN5bGluZGVyVm9sdW1lO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudHlwZSA9IENvbGxpZGVyVHlwZS5TUEhFUkU7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjU7XG4gICAgdGhpcy5zaXplLnNldCgxLCAxLCAxKTtcbiAgICB0aGlzLmhlaWdodCA9IDI7XG4gICAgdGhpcy5vZmZzZXQuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMubGF5ZXIgPSBDb2xsaXNpb25MYXllci5ERUZBVUxUO1xuICAgIHRoaXMubWFzayA9IHRoaXMuZ2V0RGVmYXVsdE1hc2soQ29sbGlzaW9uTGF5ZXIuREVGQVVMVCk7XG4gICAgdGhpcy5pc1RyaWdnZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgQm94MygpO1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm9uQ29sbGlzaW9uRW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvblN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vbkNvbGxpc2lvbkV4aXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uVHJpZ2dlclN0YXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblRyaWdnZXJFeGl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogQ29sbGlkZXIge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IENvbGxpZGVyKHRoaXMudHlwZSwgdGhpcy5yYWRpdXMsIHRoaXMubGF5ZXIpO1xuICAgIGNsb25lLnNpemUuY29weSh0aGlzLnNpemUpO1xuICAgIGNsb25lLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub2Zmc2V0KTtcbiAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgIGNsb25lLmlzVHJpZ2dlciA9IHRoaXMuaXNUcmlnZ2VyO1xuICAgIGNsb25lLmlzU3RhdGljID0gdGhpcy5pc1N0YXRpYztcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwaGVyZSIsIkNvbXBvbmVudCIsIkNvbGxpZGVyVHlwZSIsIkNvbGxpc2lvbkxheWVyIiwiQ29sbGlkZXIiLCJnZXREZWZhdWx0TWFzayIsImxheWVyIiwiY3JlYXRlU3BoZXJlIiwicmFkaXVzIiwiY3JlYXRlQm94Iiwic2l6ZSIsImNvbGxpZGVyIiwiY29weSIsImNyZWF0ZUNhcHN1bGUiLCJoZWlnaHQiLCJjcmVhdGVDeWxpbmRlciIsInNldE9mZnNldCIsIngiLCJ5IiwieiIsIm9mZnNldCIsInNldCIsImJvdW5kc05lZWRVcGRhdGUiLCJzZXRMYXllciIsIm1hc2siLCJzZXRNYXNrIiwiY2FuQ29sbGlkZVdpdGgiLCJvdGhlciIsInVwZGF0ZUJvdW5kcyIsIndvcmxkUG9zaXRpb24iLCJpc1N0YXRpYyIsImNlbnRlciIsImNsb25lIiwiYWRkIiwidHlwZSIsImJvdW5kaW5nU3BoZXJlIiwiYm91bmRzIiwic2V0RnJvbUNlbnRlckFuZFNpemUiLCJzZXRGcm9tUG9pbnRzIiwiY2Fwc3VsZVJhZGl1cyIsIk1hdGgiLCJtYXgiLCJpbnRlcnNlY3RzIiwidGhpc1Bvc2l0aW9uIiwib3RoZXJQb3NpdGlvbiIsImludGVyc2VjdHNTcGhlcmUiLCJwcmVjaXNlSW50ZXJzZWN0aW9uIiwidGhpc0NlbnRlciIsIm90aGVyQ2VudGVyIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiaW50ZXJzZWN0c0JveCIsInNwaGVyZSIsImJveCIsInNwaGVyZUNlbnRlciIsImNsb3Nlc3RQb2ludCIsImNsYW1wUG9pbnQiLCJjeWxpbmRlciIsImN5bGluZGVyQ2VudGVyIiwiaGVpZ2h0RGlmZiIsImFicyIsImhvcml6b250YWxEaXN0YW5jZSIsInNxcnQiLCJwb3ciLCJnZXRDbG9zZXN0UG9pbnQiLCJwb2ludCIsImRpcmVjdGlvbiIsInN1YiIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiYm94Q2xvc2VzdCIsImdldFZvbHVtZSIsIlBJIiwic3BoZXJlVm9sdW1lIiwiY3lsaW5kZXJWb2x1bWUiLCJyZXNldCIsImlzVHJpZ2dlciIsIm9uQ29sbGlzaW9uRW50ZXIiLCJ1bmRlZmluZWQiLCJvbkNvbGxpc2lvblN0YXkiLCJvbkNvbGxpc2lvbkV4aXQiLCJvblRyaWdnZXJFbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvblRyaWdnZXJFeGl0IiwiZW5hYmxlZCIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Collider.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Enemy.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Enemy.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Enemy: function() { return /* binding */ Enemy; },\n/* harmony export */   EnemyType: function() { return /* binding */ EnemyType; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Enemy component for identifying enemy entities\n\nvar EnemyType;\n(function(EnemyType) {\n    EnemyType[\"DUMMY\"] = \"dummy\";\n    EnemyType[\"GRUNT\"] = \"grunt\";\n    EnemyType[\"ELITE\"] = \"elite\";\n    EnemyType[\"BOSS\"] = \"boss\";\n})(EnemyType || (EnemyType = {}));\nclass Enemy extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    calculateExperienceReward() {\n        const baseExp = {\n            [\"dummy\"]: 5,\n            [\"grunt\"]: 10,\n            [\"elite\"]: 25,\n            [\"boss\"]: 100\n        };\n        return baseExp[this.type] * this.level;\n    }\n    calculateAggroRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 5,\n            [\"elite\"]: 8,\n            [\"boss\"]: 12\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackRange() {\n        const baseRange = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 1.5,\n            [\"elite\"]: 2,\n            [\"boss\"]: 3\n        };\n        return baseRange[this.type];\n    }\n    calculateAttackDamage() {\n        const baseDamage = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 15,\n            [\"elite\"]: 25,\n            [\"boss\"]: 50\n        };\n        return baseDamage[this.type] * this.level;\n    }\n    calculateAttackCooldown() {\n        const baseCooldown = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 2,\n            [\"elite\"]: 1.5,\n            [\"boss\"]: 1\n        };\n        return baseCooldown[this.type];\n    }\n    calculateMovementSpeed() {\n        const baseSpeed = {\n            [\"dummy\"]: 0,\n            [\"grunt\"]: 3,\n            [\"elite\"]: 0,\n            [\"boss\"]: 2.5\n        };\n        return baseSpeed[this.type];\n    }\n    canAttack(currentTime) {\n        if (!this.isAggressive || this.isDead || this.attackDamage === 0) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    takeDamage() {\n    // This will be handled by the Health component\n    // This method is for enemy-specific damage reactions\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.deathTime = currentTime;\n    }\n    canRespawnNow(currentTime) {\n        if (!this.canRespawn || !this.isDead) {\n            return false;\n        }\n        return currentTime - this.deathTime >= this.respawnTime;\n    }\n    respawn() {\n        this.isDead = false;\n        this.deathTime = 0;\n        this.lastAttackTime = 0;\n        // Clear freeze status on respawn\n        this.unfreeze();\n        // Clear venom status on respawn\n        this.removeVenom();\n    }\n    freeze(duration, currentTime) {\n        if (this.isDead) return; // Can't freeze dead enemies\n        this.isFrozen = true;\n        this.freezeStartTime = currentTime;\n        this.freezeDuration = duration;\n        // Set movement speed to 0 when frozen\n        this.movementSpeed = 0;\n    }\n    unfreeze() {\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        // Restore original movement speed\n        this.movementSpeed = this.originalMovementSpeed;\n    }\n    updateFreezeStatus(currentTime) {\n        if (!this.isFrozen) return;\n        const elapsed = currentTime - this.freezeStartTime;\n        if (elapsed >= this.freezeDuration) {\n            this.unfreeze();\n        }\n    }\n    canMove() {\n        return !this.isFrozen && !this.isDead;\n    }\n    applyVenom(duration, damagePerSecond, currentTime) {\n        if (this.isDead) return; // Can't apply venom to dead enemies\n        this.isVenomous = true;\n        this.venomStartTime = currentTime;\n        this.venomDuration = duration;\n        this.venomDamagePerSecond = damagePerSecond;\n        this.lastVenomDamageTime = currentTime;\n    }\n    removeVenom() {\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    updateVenomStatus(currentTime) {\n        if (!this.isVenomous) return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n        const elapsed = currentTime - this.venomStartTime;\n        if (elapsed >= this.venomDuration) {\n            this.removeVenom();\n            return {\n                shouldDealDamage: false,\n                damage: 0\n            };\n        }\n        // Check if we should deal damage (every second)\n        const timeSinceLastDamage = currentTime - this.lastVenomDamageTime;\n        if (timeSinceLastDamage >= 1.0) {\n            this.lastVenomDamageTime = currentTime;\n            return {\n                shouldDealDamage: true,\n                damage: this.venomDamagePerSecond\n            };\n        }\n        return {\n            shouldDealDamage: false,\n            damage: 0\n        };\n    }\n    setLevel(newLevel) {\n        this.level = Math.max(1, newLevel);\n        this.experienceReward = this.calculateExperienceReward();\n        this.attackDamage = this.calculateAttackDamage();\n    }\n    getDisplayName() {\n        const typeNames = {\n            [\"dummy\"]: \"Training Dummy\",\n            [\"grunt\"]: \"Grunt\",\n            [\"elite\"]: \"Elite\",\n            [\"boss\"]: \"Boss\"\n        };\n        return \"\".concat(typeNames[this.type], \" (Lv.\").concat(this.level, \")\");\n    }\n    reset() {\n        this.type = \"dummy\";\n        this.level = 1;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = false;\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30;\n        this.canRespawn = true;\n        this.enabled = true;\n        // Reset freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Reset venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n    clone() {\n        const clone = new Enemy(this.type, this.level);\n        clone.experienceReward = this.experienceReward;\n        clone.isAggressive = this.isAggressive;\n        clone.aggroRange = this.aggroRange;\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.movementSpeed = this.movementSpeed;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        clone.respawnTime = this.respawnTime;\n        clone.canRespawn = this.canRespawn;\n        // Clone freeze status\n        clone.isFrozen = this.isFrozen;\n        clone.freezeStartTime = this.freezeStartTime;\n        clone.freezeDuration = this.freezeDuration;\n        clone.originalMovementSpeed = this.originalMovementSpeed;\n        // Clone venom status\n        clone.isVenomous = this.isVenomous;\n        clone.venomStartTime = this.venomStartTime;\n        clone.venomDuration = this.venomDuration;\n        clone.venomDamagePerSecond = this.venomDamagePerSecond;\n        clone.lastVenomDamageTime = this.lastVenomDamageTime;\n        return clone;\n    }\n    constructor(type = \"dummy\", level = 1){\n        super();\n        this.componentType = \"Enemy\" // Instance identifier\n        ;\n        this.type = type;\n        this.level = level;\n        this.experienceReward = this.calculateExperienceReward();\n        this.isAggressive = type !== \"dummy\";\n        this.aggroRange = this.calculateAggroRange();\n        this.attackRange = this.calculateAttackRange();\n        this.attackDamage = this.calculateAttackDamage();\n        this.attackCooldown = this.calculateAttackCooldown();\n        this.lastAttackTime = 0;\n        this.movementSpeed = this.calculateMovementSpeed();\n        this.isDead = false;\n        this.deathTime = 0;\n        this.respawnTime = 30; // 30 seconds default respawn time\n        this.canRespawn = true;\n        // Initialize freeze status\n        this.isFrozen = false;\n        this.freezeStartTime = 0;\n        this.freezeDuration = 0;\n        this.originalMovementSpeed = this.movementSpeed;\n        // Initialize venom status\n        this.isVenomous = false;\n        this.venomStartTime = 0;\n        this.venomDuration = 0;\n        this.venomDamagePerSecond = 0;\n        this.lastVenomDamageTime = 0;\n    }\n}\nEnemy.componentType = \"Enemy\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9FbmVteS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpREFBaUQ7QUFDWDs7VUFFMUJDOzs7OztHQUFBQSxjQUFBQTtBQU9MLE1BQU1DLGNBQWNGLDhDQUFTQTtJQWtFMUJHLDRCQUFvQztRQUMxQyxNQUFNQyxVQUFVO1lBQ2QsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLE9BQU8sQ0FBQyxJQUFJLENBQUNDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUN4QztJQUVRQyxzQkFBOEI7UUFDcEMsTUFBTUMsWUFBWTtZQUNoQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixFQUFFO1FBQ3BCO1FBQ0EsT0FBT0EsU0FBUyxDQUFDLElBQUksQ0FBQ0gsSUFBSSxDQUFDO0lBQzdCO0lBRVFJLHVCQUErQjtRQUNyQyxNQUFNRCxZQUFZO1lBQ2hCLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFFBQWdCLEVBQUU7UUFDcEI7UUFDQSxPQUFPQSxTQUFTLENBQUMsSUFBSSxDQUFDSCxJQUFJLENBQUM7SUFDN0I7SUFFUUssd0JBQWdDO1FBQ3RDLE1BQU1DLGFBQWE7WUFDakIsU0FBaUIsRUFBRTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsUUFBZ0IsRUFBRTtRQUNwQjtRQUNBLE9BQU9BLFVBQVUsQ0FBQyxJQUFJLENBQUNOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQ0MsS0FBSztJQUMzQztJQUVRTSwwQkFBa0M7UUFDeEMsTUFBTUMsZUFBZTtZQUNuQixTQUFpQixFQUFFO1lBQ25CLFNBQWlCLEVBQUU7WUFDbkIsU0FBaUIsRUFBRTtZQUNuQixRQUFnQixF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SUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG1CQUFtQixHQUFHO0lBQzdCO0FBcVBGO0FBclRhL0MsTUFDWWlFLGdCQUFnQixRQUFTLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvRW5lbXkudHM/M2Y3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmVteSBjb21wb25lbnQgZm9yIGlkZW50aWZ5aW5nIGVuZW15IGVudGl0aWVzXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgZW51bSBFbmVteVR5cGUge1xuICBEVU1NWSA9ICdkdW1teScsXG4gIEdSVU5UID0gJ2dydW50JyxcbiAgRUxJVEUgPSAnZWxpdGUnLFxuICBCT1NTID0gJ2Jvc3MnXG59XG5cbmV4cG9ydCBjbGFzcyBFbmVteSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdFbmVteSc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHR5cGU6IEVuZW15VHlwZTtcbiAgcHVibGljIGxldmVsOiBudW1iZXI7XG4gIHB1YmxpYyBleHBlcmllbmNlUmV3YXJkOiBudW1iZXI7XG4gIHB1YmxpYyBpc0FnZ3Jlc3NpdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBhZ2dyb1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tSYW5nZTogbnVtYmVyO1xuICBwdWJsaWMgYXR0YWNrRGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tDb29sZG93bjogbnVtYmVyO1xuICBwdWJsaWMgbGFzdEF0dGFja1RpbWU6IG51bWJlcjtcbiAgcHVibGljIG1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcmVzcGF3blRpbWU6IG51bWJlcjtcbiAgcHVibGljIGNhblJlc3Bhd246IGJvb2xlYW47XG4gIFxuICAvLyBGcmVlemUgc3RhdHVzIGVmZmVjdFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcmVlemVTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGZyZWV6ZUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvcmlnaW5hbE1vdmVtZW50U3BlZWQ6IG51bWJlcjtcbiAgXG4gIC8vIFZlbm9tIGRlYnVmZiBlZmZlY3RcbiAgcHVibGljIGlzVmVub21vdXM6IGJvb2xlYW47XG4gIHB1YmxpYyB2ZW5vbVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgdmVub21EYW1hZ2VQZXJTZWNvbmQ6IG51bWJlcjtcbiAgcHVibGljIGxhc3RWZW5vbURhbWFnZVRpbWU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBFbmVteVR5cGUgPSBFbmVteVR5cGUuRFVNTVksXG4gICAgbGV2ZWw6IG51bWJlciA9IDFcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLmV4cGVyaWVuY2VSZXdhcmQgPSB0aGlzLmNhbGN1bGF0ZUV4cGVyaWVuY2VSZXdhcmQoKTtcbiAgICB0aGlzLmlzQWdncmVzc2l2ZSA9IHR5cGUgIT09IEVuZW15VHlwZS5EVU1NWTtcbiAgICB0aGlzLmFnZ3JvUmFuZ2UgPSB0aGlzLmNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tSYW5nZSgpO1xuICAgIHRoaXMuYXR0YWNrRGFtYWdlID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tEYW1hZ2UoKTtcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gdGhpcy5jYWxjdWxhdGVBdHRhY2tDb29sZG93bigpO1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSAwO1xuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMuY2FsY3VsYXRlTW92ZW1lbnRTcGVlZCgpO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICAgIHRoaXMucmVzcGF3blRpbWUgPSAzMDsgLy8gMzAgc2Vjb25kcyBkZWZhdWx0IHJlc3Bhd24gdGltZVxuICAgIHRoaXMuY2FuUmVzcGF3biA9IHRydWU7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBmcmVlemUgc3RhdHVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmZyZWV6ZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHZlbm9tIHN0YXR1c1xuICAgIHRoaXMuaXNWZW5vbW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSAwO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IDA7XG4gICAgdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCA9IDA7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VFeHAgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogNSxcbiAgICAgIFtFbmVteVR5cGUuR1JVTlRdOiAxMCxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAyNSxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEwMFxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VFeHBbdGhpcy50eXBlXSAqIHRoaXMubGV2ZWw7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUFnZ3JvUmFuZ2UoKTogbnVtYmVyIHtcbiAgICBjb25zdCBiYXNlUmFuZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBhZ2dyb1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDUsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogOCxcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDEyXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja1JhbmdlKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVJhbmdlID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgYXR0YWNrXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDIsXG4gICAgICBbRW5lbXlUeXBlLkJPU1NdOiAzXG4gICAgfTtcbiAgICByZXR1cm4gYmFzZVJhbmdlW3RoaXMudHlwZV07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VEYW1hZ2UgPSB7XG4gICAgICBbRW5lbXlUeXBlLkRVTU1ZXTogMCwgLy8gRHVtbXkgZW5lbWllcyBkb24ndCBkZWFsIGRhbWFnZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDE1LFxuICAgICAgW0VuZW15VHlwZS5FTElURV06IDI1LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogNTBcbiAgICB9O1xuICAgIHJldHVybiBiYXNlRGFtYWdlW3RoaXMudHlwZV0gKiB0aGlzLmxldmVsO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBdHRhY2tDb29sZG93bigpOiBudW1iZXIge1xuICAgIGNvbnN0IGJhc2VDb29sZG93biA9IHtcbiAgICAgIFtFbmVteVR5cGUuRFVNTVldOiAwLCAvLyBEdW1teSBlbmVtaWVzIGRvbid0IGF0dGFja1xuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDIsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMS41LFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogMVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VDb29sZG93blt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNb3ZlbWVudFNwZWVkKCk6IG51bWJlciB7XG4gICAgY29uc3QgYmFzZVNwZWVkID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06IDAsIC8vIER1bW15IGVuZW1pZXMgZG9uJ3QgbW92ZVxuICAgICAgW0VuZW15VHlwZS5HUlVOVF06IDMsXG4gICAgICBbRW5lbXlUeXBlLkVMSVRFXTogMCwgLy8gRWxpdGUgZW5lbWllcyBhcmUgc3RhdGlvbmFyeSBsaWtlIHRyYWluaW5nIGR1bW1pZXNcbiAgICAgIFtFbmVteVR5cGUuQk9TU106IDIuNVxuICAgIH07XG4gICAgcmV0dXJuIGJhc2VTcGVlZFt0aGlzLnR5cGVdO1xuICB9XG5cbiAgcHVibGljIGNhbkF0dGFjayhjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmlzQWdncmVzc2l2ZSB8fCB0aGlzLmlzRGVhZCB8fCB0aGlzLmF0dGFja0RhbWFnZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuXG4gIHB1YmxpYyBwZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBwdWJsaWMgdGFrZURhbWFnZSgpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgSGVhbHRoIGNvbXBvbmVudFxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGZvciBlbmVteS1zcGVjaWZpYyBkYW1hZ2UgcmVhY3Rpb25zXG4gIH1cblxuICBwdWJsaWMgZGllKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IHRydWU7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2FuUmVzcGF3biB8fCAhdGhpcy5pc0RlYWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjdXJyZW50VGltZSAtIHRoaXMuZGVhdGhUaW1lKSA+PSB0aGlzLnJlc3Bhd25UaW1lO1xuICB9XG5cbiAgcHVibGljIHJlc3Bhd24oKTogdm9pZCB7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgLy8gQ2xlYXIgZnJlZXplIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy51bmZyZWV6ZSgpO1xuICAgIC8vIENsZWFyIHZlbm9tIHN0YXR1cyBvbiByZXNwYXduXG4gICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICB9XG4gIFxuICBwdWJsaWMgZnJlZXplKGR1cmF0aW9uOiBudW1iZXIsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0RlYWQpIHJldHVybjsgLy8gQ2FuJ3QgZnJlZXplIGRlYWQgZW5lbWllc1xuICAgIFxuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJlZXplU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIC8vIFNldCBtb3ZlbWVudCBzcGVlZCB0byAwIHdoZW4gZnJvemVuXG4gICAgdGhpcy5tb3ZlbWVudFNwZWVkID0gMDtcbiAgfVxuICBcbiAgcHVibGljIHVuZnJlZXplKCk6IHZvaWQge1xuICAgIHRoaXMuaXNGcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmZyZWV6ZVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5mcmVlemVEdXJhdGlvbiA9IDA7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBtb3ZlbWVudCBzcGVlZFxuICAgIHRoaXMubW92ZW1lbnRTcGVlZCA9IHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlRnJlZXplU3RhdHVzKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNGcm96ZW4pIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLmZyZWV6ZVN0YXJ0VGltZTtcbiAgICBpZiAoZWxhcHNlZCA+PSB0aGlzLmZyZWV6ZUR1cmF0aW9uKSB7XG4gICAgICB0aGlzLnVuZnJlZXplKCk7XG4gICAgfVxuICB9XG4gIFxuICBwdWJsaWMgY2FuTW92ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuaXNGcm96ZW4gJiYgIXRoaXMuaXNEZWFkO1xuICB9XG4gIFxuICBwdWJsaWMgYXBwbHlWZW5vbShkdXJhdGlvbjogbnVtYmVyLCBkYW1hZ2VQZXJTZWNvbmQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGVhZCkgcmV0dXJuOyAvLyBDYW4ndCBhcHBseSB2ZW5vbSB0byBkZWFkIGVuZW1pZXNcbiAgICBcbiAgICB0aGlzLmlzVmVub21vdXMgPSB0cnVlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLnZlbm9tRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gZGFtYWdlUGVyU2Vjb25kO1xuICAgIHRoaXMubGFzdFZlbm9tRGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIFxuICBwdWJsaWMgcmVtb3ZlVmVub20oKTogdm9pZCB7XG4gICAgdGhpcy5pc1Zlbm9tb3VzID0gZmFsc2U7XG4gICAgdGhpcy52ZW5vbVN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy52ZW5vbUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gMDtcbiAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVmVub21TdGF0dXMoY3VycmVudFRpbWU6IG51bWJlcik6IHsgc2hvdWxkRGVhbERhbWFnZTogYm9vbGVhbjsgZGFtYWdlOiBudW1iZXIgfSB7XG4gICAgaWYgKCF0aGlzLmlzVmVub21vdXMpIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IGZhbHNlLCBkYW1hZ2U6IDAgfTtcbiAgICBcbiAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudFRpbWUgLSB0aGlzLnZlbm9tU3RhcnRUaW1lO1xuICAgIGlmIChlbGFwc2VkID49IHRoaXMudmVub21EdXJhdGlvbikge1xuICAgICAgdGhpcy5yZW1vdmVWZW5vbSgpO1xuICAgICAgcmV0dXJuIHsgc2hvdWxkRGVhbERhbWFnZTogZmFsc2UsIGRhbWFnZTogMCB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgZGVhbCBkYW1hZ2UgKGV2ZXJ5IHNlY29uZClcbiAgICBjb25zdCB0aW1lU2luY2VMYXN0RGFtYWdlID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWU7XG4gICAgaWYgKHRpbWVTaW5jZUxhc3REYW1hZ2UgPj0gMS4wKSB7XG4gICAgICB0aGlzLmxhc3RWZW5vbURhbWFnZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiB7IHNob3VsZERlYWxEYW1hZ2U6IHRydWUsIGRhbWFnZTogdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzaG91bGREZWFsRGFtYWdlOiBmYWxzZSwgZGFtYWdlOiAwIH07XG4gIH1cblxuICBwdWJsaWMgc2V0TGV2ZWwobmV3TGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGV2ZWwgPSBNYXRoLm1heCgxLCBuZXdMZXZlbCk7XG4gICAgdGhpcy5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5jYWxjdWxhdGVFeHBlcmllbmNlUmV3YXJkKCk7XG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSB0aGlzLmNhbGN1bGF0ZUF0dGFja0RhbWFnZSgpO1xuICB9XG5cbiAgcHVibGljIGdldERpc3BsYXlOYW1lKCk6IHN0cmluZyB7XG4gICAgY29uc3QgdHlwZU5hbWVzID0ge1xuICAgICAgW0VuZW15VHlwZS5EVU1NWV06ICdUcmFpbmluZyBEdW1teScsXG4gICAgICBbRW5lbXlUeXBlLkdSVU5UXTogJ0dydW50JyxcbiAgICAgIFtFbmVteVR5cGUuRUxJVEVdOiAnRWxpdGUnLFxuICAgICAgW0VuZW15VHlwZS5CT1NTXTogJ0Jvc3MnXG4gICAgfTtcbiAgICByZXR1cm4gYCR7dHlwZU5hbWVzW3RoaXMudHlwZV19IChMdi4ke3RoaXMubGV2ZWx9KWA7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy50eXBlID0gRW5lbXlUeXBlLkRVTU1ZO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMuZXhwZXJpZW5jZVJld2FyZCA9IHRoaXMuY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCgpO1xuICAgIHRoaXMuaXNBZ2dyZXNzaXZlID0gZmFsc2U7XG4gICAgdGhpcy5hZ2dyb1JhbmdlID0gdGhpcy5jYWxjdWxhdGVBZ2dyb1JhbmdlKCk7XG4gICAgdGhpcy5hdHRhY2tSYW5nZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrUmFuZ2UoKTtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrRGFtYWdlKCk7XG4gICAgdGhpcy5hdHRhY2tDb29sZG93biA9IHRoaXMuY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24oKTtcbiAgICB0aGlzLmxhc3RBdHRhY2tUaW1lID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWQgPSB0aGlzLmNhbGN1bGF0ZU1vdmVtZW50U3BlZWQoKTtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVhdGhUaW1lID0gMDtcbiAgICB0aGlzLnJlc3Bhd25UaW1lID0gMzA7XG4gICAgdGhpcy5jYW5SZXNwYXduID0gdHJ1ZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFJlc2V0IGZyZWV6ZSBzdGF0dXNcbiAgICB0aGlzLmlzRnJvemVuID0gZmFsc2U7XG4gICAgdGhpcy5mcmVlemVTdGFydFRpbWUgPSAwO1xuICAgIHRoaXMuZnJlZXplRHVyYXRpb24gPSAwO1xuICAgIHRoaXMub3JpZ2luYWxNb3ZlbWVudFNwZWVkID0gdGhpcy5tb3ZlbWVudFNwZWVkO1xuICAgIFxuICAgIC8vIFJlc2V0IHZlbm9tIHN0YXR1c1xuICAgIHRoaXMuaXNWZW5vbW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmVub21TdGFydFRpbWUgPSAwO1xuICAgIHRoaXMudmVub21EdXJhdGlvbiA9IDA7XG4gICAgdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZCA9IDA7XG4gICAgdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBFbmVteSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRW5lbXkodGhpcy50eXBlLCB0aGlzLmxldmVsKTtcbiAgICBjbG9uZS5leHBlcmllbmNlUmV3YXJkID0gdGhpcy5leHBlcmllbmNlUmV3YXJkO1xuICAgIGNsb25lLmlzQWdncmVzc2l2ZSA9IHRoaXMuaXNBZ2dyZXNzaXZlO1xuICAgIGNsb25lLmFnZ3JvUmFuZ2UgPSB0aGlzLmFnZ3JvUmFuZ2U7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUubW92ZW1lbnRTcGVlZCA9IHRoaXMubW92ZW1lbnRTcGVlZDtcbiAgICBjbG9uZS5pc0RlYWQgPSB0aGlzLmlzRGVhZDtcbiAgICBjbG9uZS5kZWF0aFRpbWUgPSB0aGlzLmRlYXRoVGltZTtcbiAgICBjbG9uZS5yZXNwYXduVGltZSA9IHRoaXMucmVzcGF3blRpbWU7XG4gICAgY2xvbmUuY2FuUmVzcGF3biA9IHRoaXMuY2FuUmVzcGF3bjtcbiAgICBcbiAgICAvLyBDbG9uZSBmcmVlemUgc3RhdHVzXG4gICAgY2xvbmUuaXNGcm96ZW4gPSB0aGlzLmlzRnJvemVuO1xuICAgIGNsb25lLmZyZWV6ZVN0YXJ0VGltZSA9IHRoaXMuZnJlZXplU3RhcnRUaW1lO1xuICAgIGNsb25lLmZyZWV6ZUR1cmF0aW9uID0gdGhpcy5mcmVlemVEdXJhdGlvbjtcbiAgICBjbG9uZS5vcmlnaW5hbE1vdmVtZW50U3BlZWQgPSB0aGlzLm9yaWdpbmFsTW92ZW1lbnRTcGVlZDtcbiAgICBcbiAgICAvLyBDbG9uZSB2ZW5vbSBzdGF0dXNcbiAgICBjbG9uZS5pc1Zlbm9tb3VzID0gdGhpcy5pc1Zlbm9tb3VzO1xuICAgIGNsb25lLnZlbm9tU3RhcnRUaW1lID0gdGhpcy52ZW5vbVN0YXJ0VGltZTtcbiAgICBjbG9uZS52ZW5vbUR1cmF0aW9uID0gdGhpcy52ZW5vbUR1cmF0aW9uO1xuICAgIGNsb25lLnZlbm9tRGFtYWdlUGVyU2Vjb25kID0gdGhpcy52ZW5vbURhbWFnZVBlclNlY29uZDtcbiAgICBjbG9uZS5sYXN0VmVub21EYW1hZ2VUaW1lID0gdGhpcy5sYXN0VmVub21EYW1hZ2VUaW1lO1xuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbXBvbmVudCIsIkVuZW15VHlwZSIsIkVuZW15IiwiY2FsY3VsYXRlRXhwZXJpZW5jZVJld2FyZCIsImJhc2VFeHAiLCJ0eXBlIiwibGV2ZWwiLCJjYWxjdWxhdGVBZ2dyb1JhbmdlIiwiYmFzZVJhbmdlIiwiY2FsY3VsYXRlQXR0YWNrUmFuZ2UiLCJjYWxjdWxhdGVBdHRhY2tEYW1hZ2UiLCJiYXNlRGFtYWdlIiwiY2FsY3VsYXRlQXR0YWNrQ29vbGRvd24iLCJiYXNlQ29vbGRvd24iLCJjYWxjdWxhdGVNb3ZlbWVudFNwZWVkIiwiYmFzZVNwZWVkIiwiY2FuQXR0YWNrIiwiY3VycmVudFRpbWUiLCJpc0FnZ3Jlc3NpdmUiLCJpc0RlYWQiLCJhdHRhY2tEYW1hZ2UiLCJsYXN0QXR0YWNrVGltZSIsImF0dGFja0Nvb2xkb3duIiwicGVyZm9ybUF0dGFjayIsInRha2VEYW1hZ2UiLCJkaWUiLCJkZWF0aFRpbWUiLCJjYW5SZXNwYXduTm93IiwiY2FuUmVzcGF3biIsInJlc3Bhd25UaW1lIiwicmVzcGF3biIsInVuZnJlZXplIiwicmVtb3ZlVmVub20iLCJmcmVlemUiLCJkdXJhdGlvbiIsImlzRnJvemVuIiwiZnJlZXplU3RhcnRUaW1lIiwiZnJlZXplRHVyYXRpb24iLCJtb3ZlbWVudFNwZWVkIiwib3JpZ2luYWxNb3ZlbWVudFNwZWVkIiwidXBkYXRlRnJlZXplU3RhdHVzIiwiZWxhcHNlZCIsImNhbk1vdmUiLCJhcHBseVZlbm9tIiwiZGFtYWdlUGVyU2Vjb25kIiwiaXNWZW5vbW91cyIsInZlbm9tU3RhcnRUaW1lIiwidmVub21EdXJhdGlvbiIsInZlbm9tRGFtYWdlUGVyU2Vjb25kIiwibGFzdFZlbm9tRGFtYWdlVGltZSIsInVwZGF0ZVZlbm9tU3RhdHVzIiwic2hvdWxkRGVhbERhbWFnZSIsImRhbWFnZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJzZXRMZXZlbCIsIm5ld0xldmVsIiwiTWF0aCIsIm1heCIsImV4cGVyaWVuY2VSZXdhcmQiLCJnZXREaXNwbGF5TmFtZSIsInR5cGVOYW1lcyIsInJlc2V0IiwiYWdncm9SYW5nZSIsImF0dGFja1JhbmdlIiwiZW5hYmxlZCIsImNsb25lIiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Enemy.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Health.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Health.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Health: function() { return /* binding */ Health; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n/* harmony import */ var _Shield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n// Health component for damage and healing\n\n\nclass Health extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    takeDamage(amount) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000, entity = arguments.length > 2 ? arguments[2] : void 0;\n        if (this.isDead || this.isInvulnerable || amount <= 0) {\n            return false;\n        }\n        let finalDamage = amount;\n        // Check if entity has a shield component and absorb damage through it first\n        if (entity) {\n            const shield = entity.getComponent(_Shield__WEBPACK_IMPORTED_MODULE_1__.Shield);\n            if (shield) {\n                finalDamage = shield.absorbDamage(amount);\n            }\n        }\n        // Apply remaining damage to health\n        if (finalDamage > 0) {\n            this.currentHealth = Math.max(0, this.currentHealth - finalDamage);\n            this.lastDamageTime = currentTime;\n            // Start invulnerability period\n            this.isInvulnerable = true;\n            this.invulnerabilityTimer = this.invulnerabilityDuration;\n            // Check if dead\n            if (this.currentHealth <= 0) {\n                this.isDead = true;\n            }\n        }\n        return true;\n    }\n    heal(amount) {\n        if (this.isDead || amount <= 0) {\n            return false;\n        }\n        const oldHealth = this.currentHealth;\n        this.currentHealth = Math.min(this.maxHealth, this.currentHealth + amount);\n        return this.currentHealth > oldHealth;\n    }\n    setMaxHealth(newMaxHealth) {\n        const healthRatio = this.getHealthRatio();\n        this.maxHealth = Math.max(1, newMaxHealth);\n        this.currentHealth = Math.floor(this.maxHealth * healthRatio);\n    }\n    getHealthRatio() {\n        return this.maxHealth > 0 ? this.currentHealth / this.maxHealth : 0;\n    }\n    getHealthPercentage() {\n        return this.getHealthRatio() * 100;\n    }\n    isFullHealth() {\n        return this.currentHealth >= this.maxHealth;\n    }\n    isLowHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.25;\n        return this.getHealthRatio() <= threshold;\n    }\n    isCriticalHealth() {\n        let threshold = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.1;\n        return this.getHealthRatio() <= threshold;\n    }\n    revive(healthAmount) {\n        this.isDead = false;\n        this.currentHealth = healthAmount !== undefined ? Math.min(this.maxHealth, healthAmount) : this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    update(deltaTime) {\n        let currentTime = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now() / 1000;\n        // Update invulnerability timer\n        if (this.isInvulnerable) {\n            this.invulnerabilityTimer -= deltaTime;\n            if (this.invulnerabilityTimer <= 0) {\n                this.isInvulnerable = false;\n                this.invulnerabilityTimer = 0;\n            }\n        }\n        // Handle regeneration\n        if (this.canRegenerate && !this.isDead && !this.isFullHealth()) {\n            const timeSinceLastDamage = currentTime - this.lastDamageTime;\n            if (timeSinceLastDamage >= this.regenerationDelay) {\n                this.heal(this.regenerationRate * deltaTime);\n            }\n        }\n    }\n    setInvulnerable(duration) {\n        this.isInvulnerable = true;\n        this.invulnerabilityTimer = duration;\n    }\n    removeInvulnerability() {\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n    }\n    enableRegeneration() {\n        let rate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n        this.canRegenerate = true;\n        this.regenerationRate = rate;\n        this.regenerationDelay = delay;\n    }\n    disableRegeneration() {\n        this.canRegenerate = false;\n    }\n    reset() {\n        this.currentHealth = this.maxHealth;\n        this.isInvulnerable = false;\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5;\n        this.regenerationDelay = 3;\n        this.lastDamageTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Health(this.maxHealth);\n        clone.currentHealth = this.currentHealth;\n        clone.isInvulnerable = this.isInvulnerable;\n        clone.invulnerabilityDuration = this.invulnerabilityDuration;\n        clone.invulnerabilityTimer = this.invulnerabilityTimer;\n        clone.isDead = this.isDead;\n        clone.canRegenerate = this.canRegenerate;\n        clone.regenerationRate = this.regenerationRate;\n        clone.regenerationDelay = this.regenerationDelay;\n        clone.lastDamageTime = this.lastDamageTime;\n        return clone;\n    }\n    constructor(maxHealth = 100){\n        super();\n        this.componentType = \"Health\" // Instance identifier\n        ;\n        this.maxHealth = maxHealth;\n        this.currentHealth = maxHealth; // Always start with full health\n        this.isInvulnerable = false;\n        this.invulnerabilityDuration = 0.5; // 0.5 seconds of invulnerability after damage\n        this.invulnerabilityTimer = 0;\n        this.isDead = false;\n        this.canRegenerate = false;\n        this.regenerationRate = 5; // Health per second\n        this.regenerationDelay = 3; // Seconds after damage before regeneration starts\n        this.lastDamageTime = 0;\n    }\n}\nHealth.componentType = \"Health\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQ0o7QUFDSjtBQUUzQixNQUFNRSxlQUFlRiw4Q0FBU0E7SUE2QjVCRyxXQUFXQyxNQUFjLEVBQWtFO1lBQWhFQyxjQUFBQSxpRUFBc0JDLEtBQUtDLEdBQUcsS0FBSyxNQUFNQztRQUN6RSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLElBQUksQ0FBQ0MsY0FBYyxJQUFJTixVQUFVLEdBQUc7WUFDckQsT0FBTztRQUNUO1FBRUEsSUFBSU8sY0FBY1A7UUFFbEIsNEVBQTRFO1FBQzVFLElBQUlJLFFBQVE7WUFDVixNQUFNSSxTQUFTSixPQUFPSyxZQUFZLENBQUNaLDJDQUFNQTtZQUN6QyxJQUFJVyxRQUFRO2dCQUNWRCxjQUFjQyxPQUFPRSxZQUFZLENBQUNWO1lBQ3BDO1FBQ0Y7UUFFQSxtQ0FBbUM7UUFDbkMsSUFBSU8sY0FBYyxHQUFHO1lBQ25CLElBQUksQ0FBQ0ksYUFBYSxHQUFHQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUNGLGFBQWEsR0FBR0o7WUFDdEQsSUFBSSxDQUFDTyxjQUFjLEdBQUdiO1lBRXRCLCtCQUErQjtZQUMvQixJQUFJLENBQUNLLGNBQWMsR0FBRztZQUN0QixJQUFJLENBQUNTLG9CQUFvQixHQUFHLElBQUksQ0FBQ0MsdUJBQXVCO1lBRXhELGdCQUFnQjtZQUNoQixJQUFJLElBQUksQ0FBQ0wsYUFBYSxJQUFJLEdBQUc7Z0JBQzNCLElBQUksQ0FBQ04sTUFBTSxHQUFHO1lBQ2hCO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFT1ksS0FBS2pCLE1BQWMsRUFBVztRQUNuQyxJQUFJLElBQUksQ0FBQ0ssTUFBTSxJQUFJTCxVQUFVLEdBQUc7WUFDOUIsT0FBTztRQUNUO1FBRUEsTUFBTWtCLFlBQVksSUFBSSxDQUFDUCxhQUFhO1FBQ3BDLElBQUksQ0FBQ0EsYUFBYSxHQUFHQyxL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VixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUMrQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDRyxnQkFBZ0IsR0FBRyxHQUFHLG9CQUFvQjtRQUMvQyxJQUFJLENBQUNELGlCQUFpQixHQUFHLEdBQUcsa0RBQWtEO1FBQzlFLElBQUksQ0FBQ3hCLGNBQWMsR0FBRztJQUN4QjtBQWlKRjtBQTVLYWhCLE9BQ1lxRCxnQkFBZ0IsU0FBVSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL0hlYWx0aC50cz81ZjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhlYWx0aCBjb21wb25lbnQgZm9yIGRhbWFnZSBhbmQgaGVhbGluZ1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vRW50aXR5JztcbmltcG9ydCB7IFNoaWVsZCB9IGZyb20gJy4vU2hpZWxkJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGgnOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgY3VycmVudEhlYWx0aDogbnVtYmVyO1xuICBwdWJsaWMgbWF4SGVhbHRoOiBudW1iZXI7XG4gIHB1YmxpYyBpc0ludnVsbmVyYWJsZTogYm9vbGVhbjtcbiAgcHVibGljIGludnVsbmVyYWJpbGl0eUR1cmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBpbnZ1bG5lcmFiaWxpdHlUaW1lcjogbnVtYmVyO1xuICBwdWJsaWMgaXNEZWFkOiBib29sZWFuO1xuICBwdWJsaWMgY2FuUmVnZW5lcmF0ZTogYm9vbGVhbjtcbiAgcHVibGljIHJlZ2VuZXJhdGlvblJhdGU6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuZXJhdGlvbkRlbGF5OiBudW1iZXI7XG4gIHB1YmxpYyBsYXN0RGFtYWdlVGltZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG1heEhlYWx0aDogbnVtYmVyID0gMTAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLm1heEhlYWx0aCA9IG1heEhlYWx0aDtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSBtYXhIZWFsdGg7IC8vIEFsd2F5cyBzdGFydCB3aXRoIGZ1bGwgaGVhbHRoXG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5RHVyYXRpb24gPSAwLjU7IC8vIDAuNSBzZWNvbmRzIG9mIGludnVsbmVyYWJpbGl0eSBhZnRlciBkYW1hZ2VcbiAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IGZhbHNlO1xuICAgIHRoaXMucmVnZW5lcmF0aW9uUmF0ZSA9IDU7IC8vIEhlYWx0aCBwZXIgc2Vjb25kXG4gICAgdGhpcy5yZWdlbmVyYXRpb25EZWxheSA9IDM7IC8vIFNlY29uZHMgYWZ0ZXIgZGFtYWdlIGJlZm9yZSByZWdlbmVyYXRpb24gc3RhcnRzXG4gICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgdGFrZURhbWFnZShhbW91bnQ6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlciA9IERhdGUubm93KCkgLyAxMDAwLCBlbnRpdHk/OiBhbnkpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgdGhpcy5pc0ludnVsbmVyYWJsZSB8fCBhbW91bnQgPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBmaW5hbERhbWFnZSA9IGFtb3VudDtcblxuICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgYSBzaGllbGQgY29tcG9uZW50IGFuZCBhYnNvcmIgZGFtYWdlIHRocm91Z2ggaXQgZmlyc3RcbiAgICBpZiAoZW50aXR5KSB7XG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIGZpbmFsRGFtYWdlID0gc2hpZWxkLmFic29yYkRhbWFnZShhbW91bnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHJlbWFpbmluZyBkYW1hZ2UgdG8gaGVhbHRoXG4gICAgaWYgKGZpbmFsRGFtYWdlID4gMCkge1xuICAgICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5tYXgoMCwgdGhpcy5jdXJyZW50SGVhbHRoIC0gZmluYWxEYW1hZ2UpO1xuICAgICAgdGhpcy5sYXN0RGFtYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBpbnZ1bG5lcmFiaWxpdHkgcGVyaW9kXG4gICAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSB0aGlzLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uO1xuXG4gICAgICAvLyBDaGVjayBpZiBkZWFkXG4gICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0RlYWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIGhlYWwoYW1vdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5pc0RlYWQgfHwgYW1vdW50IDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5taW4odGhpcy5tYXhIZWFsdGgsIHRoaXMuY3VycmVudEhlYWx0aCArIGFtb3VudCk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhlYWx0aCA+IG9sZEhlYWx0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRNYXhIZWFsdGgobmV3TWF4SGVhbHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBoZWFsdGhSYXRpbyA9IHRoaXMuZ2V0SGVhbHRoUmF0aW8oKTtcbiAgICB0aGlzLm1heEhlYWx0aCA9IE1hdGgubWF4KDEsIG5ld01heEhlYWx0aCk7XG4gICAgdGhpcy5jdXJyZW50SGVhbHRoID0gTWF0aC5mbG9vcih0aGlzLm1heEhlYWx0aCAqIGhlYWx0aFJhdGlvKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRIZWFsdGhSYXRpbygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLm1heEhlYWx0aCA+IDAgPyB0aGlzLmN1cnJlbnRIZWFsdGggLyB0aGlzLm1heEhlYWx0aCA6IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0SGVhbHRoUGVyY2VudGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgKiAxMDA7XG4gIH1cblxuICBwdWJsaWMgaXNGdWxsSGVhbHRoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFsdGggPj0gdGhpcy5tYXhIZWFsdGg7XG4gIH1cblxuICBwdWJsaWMgaXNMb3dIZWFsdGgodGhyZXNob2xkOiBudW1iZXIgPSAwLjI1KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SGVhbHRoUmF0aW8oKSA8PSB0aHJlc2hvbGQ7XG4gIH1cblxuICBwdWJsaWMgaXNDcml0aWNhbEhlYWx0aCh0aHJlc2hvbGQ6IG51bWJlciA9IDAuMSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhlYWx0aFJhdGlvKCkgPD0gdGhyZXNob2xkO1xuICB9XG5cbiAgcHVibGljIHJldml2ZShoZWFsdGhBbW91bnQ/OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEhlYWx0aCA9IGhlYWx0aEFtb3VudCAhPT0gdW5kZWZpbmVkID8gXG4gICAgICBNYXRoLm1pbih0aGlzLm1heEhlYWx0aCwgaGVhbHRoQW1vdW50KSA6IFxuICAgICAgdGhpcy5tYXhIZWFsdGg7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShkZWx0YVRpbWU6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlciA9IERhdGUubm93KCkgLyAxMDAwKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGludnVsbmVyYWJpbGl0eSB0aW1lclxuICAgIGlmICh0aGlzLmlzSW52dWxuZXJhYmxlKSB7XG4gICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIGlmICh0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyIDw9IDApIHtcbiAgICAgICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludnVsbmVyYWJpbGl0eVRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcmVnZW5lcmF0aW9uXG4gICAgaWYgKHRoaXMuY2FuUmVnZW5lcmF0ZSAmJiAhdGhpcy5pc0RlYWQgJiYgIXRoaXMuaXNGdWxsSGVhbHRoKCkpIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5KSB7XG4gICAgICAgIHRoaXMuaGVhbCh0aGlzLnJlZ2VuZXJhdGlvblJhdGUgKiBkZWx0YVRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRJbnZ1bG5lcmFibGUoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNJbnZ1bG5lcmFibGUgPSB0cnVlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSBkdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVJbnZ1bG5lcmFiaWxpdHkoKTogdm9pZCB7XG4gICAgdGhpcy5pc0ludnVsbmVyYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXIgPSAwO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVJlZ2VuZXJhdGlvbihyYXRlOiBudW1iZXIgPSA1LCBkZWxheTogbnVtYmVyID0gMyk6IHZvaWQge1xuICAgIHRoaXMuY2FuUmVnZW5lcmF0ZSA9IHRydWU7XG4gICAgdGhpcy5yZWdlbmVyYXRpb25SYXRlID0gcmF0ZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvbkRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBwdWJsaWMgZGlzYWJsZVJlZ2VuZXJhdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGggPSB0aGlzLm1heEhlYWx0aDtcbiAgICB0aGlzLmlzSW52dWxuZXJhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IDA7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhblJlZ2VuZXJhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlZ2VuZXJhdGlvblJhdGUgPSA1O1xuICAgIHRoaXMucmVnZW5lcmF0aW9uRGVsYXkgPSAzO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogSGVhbHRoIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBIZWFsdGgodGhpcy5tYXhIZWFsdGgpO1xuICAgIGNsb25lLmN1cnJlbnRIZWFsdGggPSB0aGlzLmN1cnJlbnRIZWFsdGg7XG4gICAgY2xvbmUuaXNJbnZ1bG5lcmFibGUgPSB0aGlzLmlzSW52dWxuZXJhYmxlO1xuICAgIGNsb25lLmludnVsbmVyYWJpbGl0eUR1cmF0aW9uID0gdGhpcy5pbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbjtcbiAgICBjbG9uZS5pbnZ1bG5lcmFiaWxpdHlUaW1lciA9IHRoaXMuaW52dWxuZXJhYmlsaXR5VGltZXI7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuY2FuUmVnZW5lcmF0ZSA9IHRoaXMuY2FuUmVnZW5lcmF0ZTtcbiAgICBjbG9uZS5yZWdlbmVyYXRpb25SYXRlID0gdGhpcy5yZWdlbmVyYXRpb25SYXRlO1xuICAgIGNsb25lLnJlZ2VuZXJhdGlvbkRlbGF5ID0gdGhpcy5yZWdlbmVyYXRpb25EZWxheTtcbiAgICBjbG9uZS5sYXN0RGFtYWdlVGltZSA9IHRoaXMubGFzdERhbWFnZVRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiSGVhbHRoIiwidGFrZURhbWFnZSIsImFtb3VudCIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImVudGl0eSIsImlzRGVhZCIsImlzSW52dWxuZXJhYmxlIiwiZmluYWxEYW1hZ2UiLCJzaGllbGQiLCJnZXRDb21wb25lbnQiLCJhYnNvcmJEYW1hZ2UiLCJjdXJyZW50SGVhbHRoIiwiTWF0aCIsIm1heCIsImxhc3REYW1hZ2VUaW1lIiwiaW52dWxuZXJhYmlsaXR5VGltZXIiLCJpbnZ1bG5lcmFiaWxpdHlEdXJhdGlvbiIsImhlYWwiLCJvbGRIZWFsdGgiLCJtaW4iLCJtYXhIZWFsdGgiLCJzZXRNYXhIZWFsdGgiLCJuZXdNYXhIZWFsdGgiLCJoZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiZmxvb3IiLCJnZXRIZWFsdGhQZXJjZW50YWdlIiwiaXNGdWxsSGVhbHRoIiwiaXNMb3dIZWFsdGgiLCJ0aHJlc2hvbGQiLCJpc0NyaXRpY2FsSGVhbHRoIiwicmV2aXZlIiwiaGVhbHRoQW1vdW50IiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwiY2FuUmVnZW5lcmF0ZSIsInRpbWVTaW5jZUxhc3REYW1hZ2UiLCJyZWdlbmVyYXRpb25EZWxheSIsInJlZ2VuZXJhdGlvblJhdGUiLCJzZXRJbnZ1bG5lcmFibGUiLCJkdXJhdGlvbiIsInJlbW92ZUludnVsbmVyYWJpbGl0eSIsImVuYWJsZVJlZ2VuZXJhdGlvbiIsInJhdGUiLCJkZWxheSIsImRpc2FibGVSZWdlbmVyYXRpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Health.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/HealthBar.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/HealthBar.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBar: function() { return /* binding */ HealthBar; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Health bar component for rendering health bars above entities\n\n\nclass HealthBar extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    createHealthBarMeshes() {\n        this.group = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group();\n        // Create border (slightly larger than background)\n        const borderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width + this.borderWidth * 2, this.height + this.borderWidth * 2);\n        const borderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.borderColor,\n            transparent: true,\n            opacity: 0.8\n        });\n        this.borderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(borderGeometry, borderMaterial);\n        this.borderMesh.position.z = -0.001; // Slightly behind\n        this.group.add(this.borderMesh);\n        // Create background\n        const backgroundGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const backgroundMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.backgroundColor,\n            transparent: true,\n            opacity: 0.7\n        });\n        this.backgroundMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(backgroundGeometry, backgroundMaterial);\n        this.group.add(this.backgroundMesh);\n        // Create health bar (starts full width)\n        const healthGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(this.width, this.height);\n        const healthMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n            color: this.healthColor,\n            transparent: true,\n            opacity: 0.9\n        });\n        this.healthMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(healthGeometry, healthMaterial);\n        this.healthMesh.position.z = 0.001; // Slightly in front\n        this.group.add(this.healthMesh);\n        // Make health bar always face camera\n        this.group.lookAt(0, 0, 1);\n    }\n    updateHealthBar(healthRatio, cameraPosition, worldPosition, deltaTime) {\n        this.currentHealthRatio = Math.max(0, Math.min(1, healthRatio));\n        // Animate health bar changes\n        if (Math.abs(this.lastHealthRatio - this.currentHealthRatio) > 0.01) {\n            this.lastHealthRatio = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this.lastHealthRatio, this.currentHealthRatio, this.animationSpeed * deltaTime);\n        } else {\n            this.lastHealthRatio = this.currentHealthRatio;\n        }\n        // Update health bar width and position\n        this.updateHealthMesh();\n        // Update health bar color based on health ratio\n        this.updateHealthColor();\n        // Update visibility based on distance and health\n        this.updateVisibility(cameraPosition, worldPosition);\n        // Update position and rotation to face camera\n        this.updatePositionAndRotation(cameraPosition, worldPosition);\n        // Update damage flash\n        this.updateDamageFlash(deltaTime);\n    }\n    updateHealthMesh() {\n        // Update scale to represent health\n        this.healthMesh.scale.x = this.lastHealthRatio;\n        // Adjust position so health bar shrinks from right to left\n        const offsetX = this.width * (1 - this.lastHealthRatio) / 2;\n        this.healthMesh.position.x = -offsetX;\n    }\n    updateHealthColor() {\n        let color;\n        if (this.currentHealthRatio <= this.criticalHealthThreshold) {\n            color = this.criticalHealthColor;\n        } else if (this.currentHealthRatio <= this.lowHealthThreshold) {\n            // Interpolate between low health and critical health colors\n            const t = (this.currentHealthRatio - this.criticalHealthThreshold) / (this.lowHealthThreshold - this.criticalHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.criticalHealthColor, this.lowHealthColor, t);\n        } else {\n            // Interpolate between health and low health colors\n            const t = (this.currentHealthRatio - this.lowHealthThreshold) / (1 - this.lowHealthThreshold);\n            color = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color().lerpColors(this.lowHealthColor, this.healthColor, t);\n        }\n        this.healthMesh.material.color.copy(color);\n    }\n    updateVisibility(cameraPosition, worldPosition) {\n        // Calculate distance to camera\n        const distance = cameraPosition.distanceTo(worldPosition);\n        // Determine if should be visible\n        let shouldBeVisible = distance <= this.fadeDistance;\n        // Hide when full health if configured\n        if (!this.showWhenFull && this.currentHealthRatio >= 0.99) {\n            shouldBeVisible = false;\n        }\n        // Update visibility\n        this.isVisible = shouldBeVisible;\n        this.group.visible = this.isVisible;\n        // Fade based on distance\n        if (this.isVisible && distance > this.fadeDistance * 0.7) {\n            const fadeRatio = 1 - (distance - this.fadeDistance * 0.7) / (this.fadeDistance * 0.3);\n            const opacity = Math.max(0.1, fadeRatio);\n            this.backgroundMesh.material.opacity = opacity * 0.7;\n            this.healthMesh.material.opacity = opacity * 0.9;\n            this.borderMesh.material.opacity = opacity * 0.8;\n        } else if (this.isVisible) {\n            this.backgroundMesh.material.opacity = 0.7;\n            this.healthMesh.material.opacity = 0.9;\n            this.borderMesh.material.opacity = 0.8;\n        }\n    }\n    updatePositionAndRotation(cameraPosition, worldPosition) {\n        // Position health bar above entity\n        const barPosition = worldPosition.clone().add(this.offset);\n        this.group.position.copy(barPosition);\n        // Make health bar face camera\n        this.group.lookAt(cameraPosition);\n    }\n    updateDamageFlash(deltaTime) {\n        if (this.damageFlashTimer > 0) {\n            this.damageFlashTimer -= deltaTime;\n            // Flash effect - make health bar brighter\n            const flashIntensity = this.damageFlashTimer / this.damageFlashDuration;\n            const flashColor = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            // Mix current color with white for flash effect\n            const currentColor = this.healthMesh.material.color.clone();\n            currentColor.lerp(flashColor, flashIntensity * 0.5);\n            this.healthMesh.material.color.copy(currentColor);\n        }\n    }\n    triggerDamageFlash() {\n        this.damageFlashTimer = this.damageFlashDuration;\n    }\n    setHealthRatio(ratio) {\n        const oldRatio = this.currentHealthRatio;\n        this.currentHealthRatio = Math.max(0, Math.min(1, ratio));\n        // Trigger damage flash if health decreased\n        if (this.currentHealthRatio < oldRatio) {\n            this.triggerDamageFlash();\n        }\n    }\n    getGroup() {\n        return this.group;\n    }\n    dispose() {\n        // Clean up geometries and materials\n        this.backgroundMesh.geometry.dispose();\n        this.backgroundMesh.material.dispose();\n        this.healthMesh.geometry.dispose();\n        this.healthMesh.material.dispose();\n        this.borderMesh.geometry.dispose();\n        this.borderMesh.material.dispose();\n        // Remove from parent if it has one\n        if (this.group.parent) {\n            this.group.parent.remove(this.group);\n        }\n    }\n    reset() {\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.isVisible = true;\n        this.damageFlashTimer = 0;\n        this.enabled = true;\n        // Reset visual state\n        this.updateHealthMesh();\n        this.updateHealthColor();\n    }\n    clone() {\n        const config = {\n            width: this.width,\n            height: this.height,\n            offset: this.offset.clone(),\n            backgroundColor: this.backgroundColor.clone(),\n            healthColor: this.healthColor.clone(),\n            lowHealthColor: this.lowHealthColor.clone(),\n            criticalHealthColor: this.criticalHealthColor.clone(),\n            borderColor: this.borderColor.clone(),\n            borderWidth: this.borderWidth,\n            showWhenFull: this.showWhenFull,\n            fadeDistance: this.fadeDistance,\n            lowHealthThreshold: this.lowHealthThreshold,\n            criticalHealthThreshold: this.criticalHealthThreshold\n        };\n        return new HealthBar(config);\n    }\n    constructor(config = {}){\n        var _config_offset, _config_backgroundColor, _config_healthColor, _config_lowHealthColor, _config_criticalHealthColor, _config_borderColor;\n        super();\n        this.componentType = \"HealthBar\" // Instance identifier\n        ;\n        // Configuration\n        this.width = config.width || 1.0;\n        this.height = config.height || 0.1;\n        this.offset = ((_config_offset = config.offset) === null || _config_offset === void 0 ? void 0 : _config_offset.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1.5, 0);\n        this.backgroundColor = ((_config_backgroundColor = config.backgroundColor) === null || _config_backgroundColor === void 0 ? void 0 : _config_backgroundColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x333333);\n        this.healthColor = ((_config_healthColor = config.healthColor) === null || _config_healthColor === void 0 ? void 0 : _config_healthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x00ff00);\n        this.lowHealthColor = ((_config_lowHealthColor = config.lowHealthColor) === null || _config_lowHealthColor === void 0 ? void 0 : _config_lowHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xffff00);\n        this.criticalHealthColor = ((_config_criticalHealthColor = config.criticalHealthColor) === null || _config_criticalHealthColor === void 0 ? void 0 : _config_criticalHealthColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0xff0000);\n        this.borderColor = ((_config_borderColor = config.borderColor) === null || _config_borderColor === void 0 ? void 0 : _config_borderColor.clone()) || new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(0x000000);\n        this.borderWidth = config.borderWidth || 0.02;\n        this.showWhenFull = config.showWhenFull !== undefined ? config.showWhenFull : false;\n        this.fadeDistance = config.fadeDistance || 20;\n        this.lowHealthThreshold = config.lowHealthThreshold || 0.5;\n        this.criticalHealthThreshold = config.criticalHealthThreshold || 0.25;\n        // State\n        this.isVisible = true;\n        this.currentHealthRatio = 1.0;\n        this.lastHealthRatio = 1.0;\n        this.animationSpeed = 5.0; // How fast health bar animates\n        this.damageFlashTimer = 0;\n        this.damageFlashDuration = 0.2;\n        // Create rendering objects\n        this.createHealthBarMeshes();\n    }\n}\nHealthBar.componentType = \"HealthBar\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQWdFO0FBQzJEO0FBQ3JGO0FBa0IvQixNQUFNUSxrQkFBa0JELDhDQUFTQTtJQTZEOUJFLHdCQUE4QjtRQUNwQyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJUix1REFBS0E7UUFFdEIsa0RBQWtEO1FBQ2xELE1BQU1TLGlCQUFpQixJQUFJUCwrREFBYUEsQ0FDdEMsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxXQUFXLEdBQUc7UUFFbkMsTUFBTUUsaUJBQWlCLElBQUlWLG1FQUFpQkEsQ0FBQztZQUMzQ1csT0FBTyxJQUFJLENBQUNDLFdBQVc7WUFDdkJDLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSWpCLHNEQUFJQSxDQUFDUSxnQkFBZ0JJO1FBQzNDLElBQUksQ0FBQ0ssVUFBVSxDQUFDQyxRQUFRLENBQUNDLENBQUMsR0FBRyxDQUFDLE9BQU8sa0JBQWtCO1FBQ3ZELElBQUksQ0FBQ1osS0FBSyxDQUFDYSxHQUFHLENBQUMsSUFBSSxDQUFDSCxVQUFVO1FBRTlCLG9CQUFvQjtRQUNwQixNQUFNSSxxQkFBcUIsSUFBSXBCLCtEQUFhQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsTUFBTTtRQUNwRSxNQUFNVyxxQkFBcUIsSUFBSXBCLG1FQUFpQkEsQ0FBQztZQUMvQ1csT0FBTyxJQUFJLENBQUNVLGVBQWU7WUFDM0JSLGFBQWE7WUFDYkMsU0FBUztRQUNYO1FBQ0EsSUFBSSxDQUFDUSxjQUFjLEdBQUcsSUFBSXhCLHNEQUFJQSxDQUFDcUIsb0JBQW9CQztRQUNuRCxJQUFJLENBQUNmLEtBQUssQ0FBQ2EsR0FBRyxDQUFDLElBQUksQ0FBQ0ksY0FB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LEdBQUc7UUFDdkIsSUFBSSxDQUFDRSxjQUFjLEdBQUcsS0FBSywrQkFBK0I7UUFDMUQsSUFBSSxDQUFDNEIsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxtQkFBbUIsR0FBRztRQUUzQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDbEUscUJBQXFCO0lBQzVCO0FBcU9GO0FBaFNhRCxVQUNZbUYsZ0JBQWdCLFlBQWEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9IZWFsdGhCYXIudHM/MzQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBWZWN0b3IzLCBDb2xvciwgR3JvdXAsIE1lc2gsIFBsYW5lR2VvbWV0cnksIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRoVXRpbHMsIE1hdGVyaWFsIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQmFyQ29uZmlnIHtcbiAgd2lkdGg/OiBudW1iZXI7XG4gIGhlaWdodD86IG51bWJlcjtcbiAgb2Zmc2V0PzogVmVjdG9yMztcbiAgYmFja2dyb3VuZENvbG9yPzogQ29sb3I7XG4gIGhlYWx0aENvbG9yPzogQ29sb3I7XG4gIGxvd0hlYWx0aENvbG9yPzogQ29sb3I7XG4gIGNyaXRpY2FsSGVhbHRoQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyQ29sb3I/OiBDb2xvcjtcbiAgYm9yZGVyV2lkdGg/OiBudW1iZXI7XG4gIHNob3dXaGVuRnVsbD86IGJvb2xlYW47XG4gIGZhZGVEaXN0YW5jZT86IG51bWJlcjtcbiAgbG93SGVhbHRoVGhyZXNob2xkPzogbnVtYmVyO1xuICBjcml0aWNhbEhlYWx0aFRocmVzaG9sZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdIZWFsdGhCYXInOyAvLyBFeHBsaWNpdCB0eXBlIGlkZW50aWZpZXJcbiAgcHVibGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnSGVhbHRoQmFyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgb2Zmc2V0OiBWZWN0b3IzO1xuICBwdWJsaWMgYmFja2dyb3VuZENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGhlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGxvd0hlYWx0aENvbG9yOiBDb2xvcjtcbiAgcHVibGljIGNyaXRpY2FsSGVhbHRoQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyQ29sb3I6IENvbG9yO1xuICBwdWJsaWMgYm9yZGVyV2lkdGg6IG51bWJlcjtcbiAgcHVibGljIHNob3dXaGVuRnVsbDogYm9vbGVhbjtcbiAgcHVibGljIGZhZGVEaXN0YW5jZTogbnVtYmVyO1xuICBwdWJsaWMgbG93SGVhbHRoVGhyZXNob2xkOiBudW1iZXI7XG4gIHB1YmxpYyBjcml0aWNhbEhlYWx0aFRocmVzaG9sZDogbnVtYmVyO1xuXG4gIC8vIFJlbmRlcmluZyBvYmplY3RzXG4gIHB1YmxpYyBncm91cCE6IEdyb3VwO1xuICBwdWJsaWMgYmFja2dyb3VuZE1lc2ghOiBNZXNoO1xuICBwdWJsaWMgaGVhbHRoTWVzaCE6IE1lc2g7XG4gIHB1YmxpYyBib3JkZXJNZXNoITogTWVzaDtcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc1Zpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyBjdXJyZW50SGVhbHRoUmF0aW86IG51bWJlcjtcbiAgcHVibGljIGxhc3RIZWFsdGhSYXRpbzogbnVtYmVyO1xuICBwdWJsaWMgYW5pbWF0aW9uU3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoVGltZXI6IG51bWJlcjtcbiAgcHVibGljIGRhbWFnZUZsYXNoRHVyYXRpb246IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IEhlYWx0aEJhckNvbmZpZyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmF0aW9uXG4gICAgdGhpcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCAxLjA7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8IDAuMTtcbiAgICB0aGlzLm9mZnNldCA9IGNvbmZpZy5vZmZzZXQ/LmNsb25lKCkgfHwgbmV3IFZlY3RvcjMoMCwgMS41LCAwKTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I/LmNsb25lKCkgfHwgbmV3IENvbG9yKDB4MzMzMzMzKTtcbiAgICB0aGlzLmhlYWx0aENvbG9yID0gY29uZmlnLmhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweDAwZmYwMCk7XG4gICAgdGhpcy5sb3dIZWFsdGhDb2xvciA9IGNvbmZpZy5sb3dIZWFsdGhDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHhmZmZmMDApO1xuICAgIHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvciA9IGNvbmZpZy5jcml0aWNhbEhlYWx0aENvbG9yPy5jbG9uZSgpIHx8IG5ldyBDb2xvcigweGZmMDAwMCk7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9IGNvbmZpZy5ib3JkZXJDb2xvcj8uY2xvbmUoKSB8fCBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIHRoaXMuYm9yZGVyV2lkdGggPSBjb25maWcuYm9yZGVyV2lkdGggfHwgMC4wMjtcbiAgICB0aGlzLnNob3dXaGVuRnVsbCA9IGNvbmZpZy5zaG93V2hlbkZ1bGwgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5zaG93V2hlbkZ1bGwgOiBmYWxzZTtcbiAgICB0aGlzLmZhZGVEaXN0YW5jZSA9IGNvbmZpZy5mYWRlRGlzdGFuY2UgfHwgMjA7XG4gICAgdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQgPSBjb25maWcubG93SGVhbHRoVGhyZXNob2xkIHx8IDAuNTtcbiAgICB0aGlzLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkID0gY29uZmlnLmNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIHx8IDAuMjU7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmxhc3RIZWFsdGhSYXRpbyA9IDEuMDtcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gNS4wOyAvLyBIb3cgZmFzdCBoZWFsdGggYmFyIGFuaW1hdGVzXG4gICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyID0gMDtcbiAgICB0aGlzLmRhbWFnZUZsYXNoRHVyYXRpb24gPSAwLjI7XG5cbiAgICAvLyBDcmVhdGUgcmVuZGVyaW5nIG9iamVjdHNcbiAgICB0aGlzLmNyZWF0ZUhlYWx0aEJhck1lc2hlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVIZWFsdGhCYXJNZXNoZXMoKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgLy8gQ3JlYXRlIGJvcmRlciAoc2xpZ2h0bHkgbGFyZ2VyIHRoYW4gYmFja2dyb3VuZClcbiAgICBjb25zdCBib3JkZXJHZW9tZXRyeSA9IG5ldyBQbGFuZUdlb21ldHJ5KFxuICAgICAgdGhpcy53aWR0aCArIHRoaXMuYm9yZGVyV2lkdGggKiAyLCBcbiAgICAgIHRoaXMuaGVpZ2h0ICsgdGhpcy5ib3JkZXJXaWR0aCAqIDJcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlck1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC44XG4gICAgfSk7XG4gICAgdGhpcy5ib3JkZXJNZXNoID0gbmV3IE1lc2goYm9yZGVyR2VvbWV0cnksIGJvcmRlck1hdGVyaWFsKTtcbiAgICB0aGlzLmJvcmRlck1lc2gucG9zaXRpb24ueiA9IC0wLjAwMTsgLy8gU2xpZ2h0bHkgYmVoaW5kXG4gICAgdGhpcy5ncm91cC5hZGQodGhpcy5ib3JkZXJNZXNoKTtcblxuICAgIC8vIENyZWF0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgYmFja2dyb3VuZEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGJhY2tncm91bmRNYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoID0gbmV3IE1lc2goYmFja2dyb3VuZEdlb21ldHJ5LCBiYWNrZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuYmFja2dyb3VuZE1lc2gpO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWx0aCBiYXIgKHN0YXJ0cyBmdWxsIHdpZHRoKVxuICAgIGNvbnN0IGhlYWx0aEdlb21ldHJ5ID0gbmV3IFBsYW5lR2VvbWV0cnkodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIGNvbnN0IGhlYWx0aE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICBjb2xvcjogdGhpcy5oZWFsdGhDb2xvcixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC45XG4gICAgfSk7XG4gICAgdGhpcy5oZWFsdGhNZXNoID0gbmV3IE1lc2goaGVhbHRoR2VvbWV0cnksIGhlYWx0aE1hdGVyaWFsKTtcbiAgICB0aGlzLmhlYWx0aE1lc2gucG9zaXRpb24ueiA9IDAuMDAxOyAvLyBTbGlnaHRseSBpbiBmcm9udFxuICAgIHRoaXMuZ3JvdXAuYWRkKHRoaXMuaGVhbHRoTWVzaCk7XG5cbiAgICAvLyBNYWtlIGhlYWx0aCBiYXIgYWx3YXlzIGZhY2UgY2FtZXJhXG4gICAgdGhpcy5ncm91cC5sb29rQXQoMCwgMCwgMSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSGVhbHRoQmFyKFxuICAgIGhlYWx0aFJhdGlvOiBudW1iZXIsIFxuICAgIGNhbWVyYVBvc2l0aW9uOiBWZWN0b3IzLCBcbiAgICB3b3JsZFBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRlbHRhVGltZTogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgaGVhbHRoUmF0aW8pKTtcblxuICAgIC8vIEFuaW1hdGUgaGVhbHRoIGJhciBjaGFuZ2VzXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGFzdEhlYWx0aFJhdGlvIC0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8pID4gMC4wMSkge1xuICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8gPSBNYXRoVXRpbHMubGVycChcbiAgICAgICAgdGhpcy5sYXN0SGVhbHRoUmF0aW8sIFxuICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbywgXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gdGhpcy5jdXJyZW50SGVhbHRoUmF0aW87XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2lkdGggYW5kIHBvc2l0aW9uXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG5cbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBjb2xvciBiYXNlZCBvbiBoZWFsdGggcmF0aW9cbiAgICB0aGlzLnVwZGF0ZUhlYWx0aENvbG9yKCk7XG5cbiAgICAvLyBVcGRhdGUgdmlzaWJpbGl0eSBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXG4gICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KGNhbWVyYVBvc2l0aW9uLCB3b3JsZFBvc2l0aW9uKTtcblxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBhbmQgcm90YXRpb24gdG8gZmFjZSBjYW1lcmFcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuXG4gICAgLy8gVXBkYXRlIGRhbWFnZSBmbGFzaFxuICAgIHRoaXMudXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoTWVzaCgpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc2NhbGUgdG8gcmVwcmVzZW50IGhlYWx0aFxuICAgIHRoaXMuaGVhbHRoTWVzaC5zY2FsZS54ID0gdGhpcy5sYXN0SGVhbHRoUmF0aW87XG4gICAgXG4gICAgLy8gQWRqdXN0IHBvc2l0aW9uIHNvIGhlYWx0aCBiYXIgc2hyaW5rcyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggKiAoMSAtIHRoaXMubGFzdEhlYWx0aFJhdGlvKSkgLyAyO1xuICAgIHRoaXMuaGVhbHRoTWVzaC5wb3NpdGlvbi54ID0gLW9mZnNldFg7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUhlYWx0aENvbG9yKCk6IHZvaWQge1xuICAgIGxldCBjb2xvcjogQ29sb3I7XG4gICAgXG4gICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIDw9IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIGNvbG9yID0gdGhpcy5jcml0aWNhbEhlYWx0aENvbG9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPD0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIHtcbiAgICAgIC8vIEludGVycG9sYXRlIGJldHdlZW4gbG93IGhlYWx0aCBhbmQgY3JpdGljYWwgaGVhbHRoIGNvbG9yc1xuICAgICAgY29uc3QgdCA9ICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyAtIHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKHRoaXMubG93SGVhbHRoVGhyZXNob2xkIC0gdGhpcy5jcml0aWNhbEhlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5jcml0aWNhbEhlYWx0aENvbG9yLCB0aGlzLmxvd0hlYWx0aENvbG9yLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW50ZXJwb2xhdGUgYmV0d2VlbiBoZWFsdGggYW5kIGxvdyBoZWFsdGggY29sb3JzXG4gICAgICBjb25zdCB0ID0gKHRoaXMuY3VycmVudEhlYWx0aFJhdGlvIC0gdGhpcy5sb3dIZWFsdGhUaHJlc2hvbGQpIC8gXG4gICAgICAgICAgICAgICAgKDEgLSB0aGlzLmxvd0hlYWx0aFRocmVzaG9sZCk7XG4gICAgICBjb2xvciA9IG5ldyBDb2xvcigpLmxlcnBDb2xvcnModGhpcy5sb3dIZWFsdGhDb2xvciwgdGhpcy5oZWFsdGhDb2xvciwgdCk7XG4gICAgfVxuXG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY29weShjb2xvcik7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVZpc2liaWxpdHkoY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBDYWxjdWxhdGUgZGlzdGFuY2UgdG8gY2FtZXJhXG4gICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmFQb3NpdGlvbi5kaXN0YW5jZVRvKHdvcmxkUG9zaXRpb24pO1xuICAgIFxuICAgIC8vIERldGVybWluZSBpZiBzaG91bGQgYmUgdmlzaWJsZVxuICAgIGxldCBzaG91bGRCZVZpc2libGUgPSBkaXN0YW5jZSA8PSB0aGlzLmZhZGVEaXN0YW5jZTtcbiAgICBcbiAgICAvLyBIaWRlIHdoZW4gZnVsbCBoZWFsdGggaWYgY29uZmlndXJlZFxuICAgIGlmICghdGhpcy5zaG93V2hlbkZ1bGwgJiYgdGhpcy5jdXJyZW50SGVhbHRoUmF0aW8gPj0gMC45OSkge1xuICAgICAgc2hvdWxkQmVWaXNpYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpc2liaWxpdHlcbiAgICB0aGlzLmlzVmlzaWJsZSA9IHNob3VsZEJlVmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcblxuICAgIC8vIEZhZGUgYmFzZWQgb24gZGlzdGFuY2VcbiAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgZGlzdGFuY2UgPiB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykge1xuICAgICAgY29uc3QgZmFkZVJhdGlvID0gMSAtICgoZGlzdGFuY2UgLSB0aGlzLmZhZGVEaXN0YW5jZSAqIDAuNykgLyAodGhpcy5mYWRlRGlzdGFuY2UgKiAwLjMpKTtcbiAgICAgIGNvbnN0IG9wYWNpdHkgPSBNYXRoLm1heCgwLjEsIGZhZGVSYXRpbyk7XG4gICAgICBcbiAgICAgICh0aGlzLmJhY2tncm91bmRNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gb3BhY2l0eSAqIDAuNztcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSBvcGFjaXR5ICogMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IG9wYWNpdHkgKiAwLjg7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgKHRoaXMuYmFja2dyb3VuZE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLm9wYWNpdHkgPSAwLjc7XG4gICAgICAodGhpcy5oZWFsdGhNZXNoLm1hdGVyaWFsIGFzIE1lc2hCYXNpY01hdGVyaWFsKS5vcGFjaXR5ID0gMC45O1xuICAgICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkub3BhY2l0eSA9IDAuODtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVBvc2l0aW9uQW5kUm90YXRpb24oY2FtZXJhUG9zaXRpb246IFZlY3RvcjMsIHdvcmxkUG9zaXRpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICAvLyBQb3NpdGlvbiBoZWFsdGggYmFyIGFib3ZlIGVudGl0eVxuICAgIGNvbnN0IGJhclBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi5jbG9uZSgpLmFkZCh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5ncm91cC5wb3NpdGlvbi5jb3B5KGJhclBvc2l0aW9uKTtcblxuICAgIC8vIE1ha2UgaGVhbHRoIGJhciBmYWNlIGNhbWVyYVxuICAgIHRoaXMuZ3JvdXAubG9va0F0KGNhbWVyYVBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGFtYWdlRmxhc2goZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kYW1hZ2VGbGFzaFRpbWVyID4gMCkge1xuICAgICAgdGhpcy5kYW1hZ2VGbGFzaFRpbWVyIC09IGRlbHRhVGltZTtcbiAgICAgIFxuICAgICAgLy8gRmxhc2ggZWZmZWN0IC0gbWFrZSBoZWFsdGggYmFyIGJyaWdodGVyXG4gICAgICBjb25zdCBmbGFzaEludGVuc2l0eSA9IHRoaXMuZGFtYWdlRmxhc2hUaW1lciAvIHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgICAgIGNvbnN0IGZsYXNoQ29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIE1peCBjdXJyZW50IGNvbG9yIHdpdGggd2hpdGUgZm9yIGZsYXNoIGVmZmVjdFxuICAgICAgY29uc3QgY3VycmVudENvbG9yID0gKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNZXNoQmFzaWNNYXRlcmlhbCkuY29sb3IuY2xvbmUoKTtcbiAgICAgIGN1cnJlbnRDb2xvci5sZXJwKGZsYXNoQ29sb3IsIGZsYXNoSW50ZW5zaXR5ICogMC41KTtcbiAgICAgICh0aGlzLmhlYWx0aE1lc2gubWF0ZXJpYWwgYXMgTWVzaEJhc2ljTWF0ZXJpYWwpLmNvbG9yLmNvcHkoY3VycmVudENvbG9yKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdHJpZ2dlckRhbWFnZUZsYXNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlRmxhc2hUaW1lciA9IHRoaXMuZGFtYWdlRmxhc2hEdXJhdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBzZXRIZWFsdGhSYXRpbyhyYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkUmF0aW8gPSB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbztcbiAgICB0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhdGlvKSk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkYW1hZ2UgZmxhc2ggaWYgaGVhbHRoIGRlY3JlYXNlZFxuICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhSYXRpbyA8IG9sZFJhdGlvKSB7XG4gICAgICB0aGlzLnRyaWdnZXJEYW1hZ2VGbGFzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRHcm91cCgpOiBHcm91cCB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXA7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICB0aGlzLmJhY2tncm91bmRNZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAodGhpcy5iYWNrZ3JvdW5kTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuaGVhbHRoTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuaGVhbHRoTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIHRoaXMuYm9yZGVyTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgKHRoaXMuYm9yZGVyTWVzaC5tYXRlcmlhbCBhcyBNYXRlcmlhbCkuZGlzcG9zZSgpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIHBhcmVudCBpZiBpdCBoYXMgb25lXG4gICAgaWYgKHRoaXMuZ3JvdXAucGFyZW50KSB7XG4gICAgICB0aGlzLmdyb3VwLnBhcmVudC5yZW1vdmUodGhpcy5ncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMubGFzdEhlYWx0aFJhdGlvID0gMS4wO1xuICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRhbWFnZUZsYXNoVGltZXIgPSAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gUmVzZXQgdmlzdWFsIHN0YXRlXG4gICAgdGhpcy51cGRhdGVIZWFsdGhNZXNoKCk7XG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb2xvcigpO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IEhlYWx0aEJhciB7XG4gICAgY29uc3QgY29uZmlnOiBIZWFsdGhCYXJDb25maWcgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuYmFja2dyb3VuZENvbG9yLmNsb25lKCksXG4gICAgICBoZWFsdGhDb2xvcjogdGhpcy5oZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgbG93SGVhbHRoQ29sb3I6IHRoaXMubG93SGVhbHRoQ29sb3IuY2xvbmUoKSxcbiAgICAgIGNyaXRpY2FsSGVhbHRoQ29sb3I6IHRoaXMuY3JpdGljYWxIZWFsdGhDb2xvci5jbG9uZSgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IuY2xvbmUoKSxcbiAgICAgIGJvcmRlcldpZHRoOiB0aGlzLmJvcmRlcldpZHRoLFxuICAgICAgc2hvd1doZW5GdWxsOiB0aGlzLnNob3dXaGVuRnVsbCxcbiAgICAgIGZhZGVEaXN0YW5jZTogdGhpcy5mYWRlRGlzdGFuY2UsXG4gICAgICBsb3dIZWFsdGhUaHJlc2hvbGQ6IHRoaXMubG93SGVhbHRoVGhyZXNob2xkLFxuICAgICAgY3JpdGljYWxIZWFsdGhUaHJlc2hvbGQ6IHRoaXMuY3JpdGljYWxIZWFsdGhUaHJlc2hvbGRcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBuZXcgSGVhbHRoQmFyKGNvbmZpZyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29sb3IiLCJHcm91cCIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJNYXRoVXRpbHMiLCJDb21wb25lbnQiLCJIZWFsdGhCYXIiLCJjcmVhdGVIZWFsdGhCYXJNZXNoZXMiLCJncm91cCIsImJvcmRlckdlb21ldHJ5Iiwid2lkdGgiLCJib3JkZXJXaWR0aCIsImhlaWdodCIsImJvcmRlck1hdGVyaWFsIiwiY29sb3IiLCJib3JkZXJDb2xvciIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImJvcmRlck1lc2giLCJwb3NpdGlvbiIsInoiLCJhZGQiLCJiYWNrZ3JvdW5kR2VvbWV0cnkiLCJiYWNrZ3JvdW5kTWF0ZXJpYWwiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kTWVzaCIsImhlYWx0aEdlb21ldHJ5IiwiaGVhbHRoTWF0ZXJpYWwiLCJoZWFsdGhDb2xvciIsImhlYWx0aE1lc2giLCJsb29rQXQiLCJ1cGRhdGVIZWFsdGhCYXIiLCJoZWFsdGhSYXRpbyIsImNhbWVyYVBvc2l0aW9uIiwid29ybGRQb3NpdGlvbiIsImRlbHRhVGltZSIsImN1cnJlbnRIZWFsdGhSYXRpbyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJhYnMiLCJsYXN0SGVhbHRoUmF0aW8iLCJsZXJwIiwiYW5pbWF0aW9uU3BlZWQiLCJ1cGRhdGVIZWFsdGhNZXNoIiwidXBkYXRlSGVhbHRoQ29sb3IiLCJ1cGRhdGVWaXNpYmlsaXR5IiwidXBkYXRlUG9zaXRpb25BbmRSb3RhdGlvbiIsInVwZGF0ZURhbWFnZUZsYXNoIiwic2NhbGUiLCJ4Iiwib2Zmc2V0WCIsImNyaXRpY2FsSGVhbHRoVGhyZXNob2xkIiwiY3JpdGljYWxIZWFsdGhDb2xvciIsImxvd0hlYWx0aFRocmVzaG9sZCIsInQiLCJsZXJwQ29sb3JzIiwibG93SGVhbHRoQ29sb3IiLCJtYXRlcmlhbCIsImNvcHkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJzaG91bGRCZVZpc2libGUiLCJmYWRlRGlzdGFuY2UiLCJzaG93V2hlbkZ1bGwiLCJpc1Zpc2libGUiLCJ2aXNpYmxlIiwiZmFkZVJhdGlvIiwiYmFyUG9zaXRpb24iLCJjbG9uZSIsIm9mZnNldCIsImRhbWFnZUZsYXNoVGltZXIiLCJmbGFzaEludGVuc2l0eSIsImRhbWFnZUZsYXNoRHVyYXRpb24iLCJmbGFzaENvbG9yIiwiY3VycmVudENvbG9yIiwidHJpZ2dlckRhbWFnZUZsYXNoIiwic2V0SGVhbHRoUmF0aW8iLCJyYXRpbyIsIm9sZFJhdGlvIiwiZ2V0R3JvdXAiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJwYXJlbnQiLCJyZW1vdmUiLCJyZXNldCIsImVuYWJsZWQiLCJjb25maWciLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/HealthBar.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Movement.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Movement.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Movement: function() { return /* binding */ Movement; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Movement component for velocity and movement properties\n\n\nclass Movement extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    addForce(force) {\n        this.acceleration.add(force);\n    }\n    addImpulse(impulse) {\n        this.velocity.add(impulse);\n    }\n    jump() {\n        if (this.canJump && (this.isGrounded || this.canFly)) {\n            this.velocity.y = this.jumpForce;\n            this.isGrounded = false;\n        }\n    }\n    setMoveDirection(direction) {\n        let strength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1.0;\n        this.moveDirection.copy(direction).normalize();\n        this.inputStrength = Math.max(0, Math.min(1, strength));\n    }\n    freeze(duration) {\n        const currentTime = Date.now();\n        this.isFrozen = true;\n        this.frozenUntil = currentTime + duration;\n        console.log(\"\\uD83E\\uDDCA Player frozen for \".concat(duration, \"ms until \").concat(this.frozenUntil, \" (current: \").concat(currentTime, \")\"));\n    }\n    slow(duration) {\n        let speedMultiplier = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;\n        const currentTime = Date.now();\n        this.isSlowed = true;\n        this.slowedUntil = currentTime + duration;\n        this.movementSpeedMultiplier = speedMultiplier;\n        console.log(\"\\uD83D\\uDC0C Player slowed to \".concat(speedMultiplier * 100, \"% speed for \").concat(duration, \"ms until \").concat(this.slowedUntil));\n    }\n    updateDebuffs() {\n        const currentTime = Date.now();\n        // Check frozen state\n        if (this.isFrozen && currentTime >= this.frozenUntil) {\n            this.isFrozen = false;\n            this.frozenUntil = 0;\n            console.log(\"\\uD83E\\uDDCA Player unfrozen\");\n        }\n        // Check slowed state\n        if (this.isSlowed && currentTime >= this.slowedUntil) {\n            this.isSlowed = false;\n            this.slowedUntil = 0;\n            this.movementSpeedMultiplier = 1.0;\n            console.log(\"\\uD83D\\uDC0C Player no longer slowed\");\n        }\n    }\n    getEffectiveMaxSpeed() {\n        if (this.isFrozen) {\n            return 0; // Completely frozen\n        }\n        return this.maxSpeed * this.movementSpeedMultiplier;\n    }\n    startDash(direction, currentPosition, currentTime) {\n        // Check if already dashing\n        if (this.isDashing) {\n            return false;\n        }\n        // Find first available charge\n        const availableChargeIndex = this.dashCharges.findIndex((charge)=>charge.isAvailable);\n        if (availableChargeIndex === -1) {\n            return false; // No charges available\n        }\n        // Start the dash\n        this.isDashing = true;\n        this.dashDirection.copy(direction).normalize();\n        this.dashStartTime = currentTime;\n        this.dashStartPosition.copy(currentPosition);\n        // Consume the charge\n        this.dashCharges[availableChargeIndex].isAvailable = false;\n        this.dashCharges[availableChargeIndex].cooldownStartTime = currentTime;\n        // Set cooldown timer for this specific charge (6 seconds)\n        setTimeout(()=>{\n            this.dashCharges[availableChargeIndex].isAvailable = true;\n            this.dashCharges[availableChargeIndex].cooldownStartTime = null;\n        }, 6000); // 6 second cooldown\n        return true;\n    }\n    updateDash(currentTime) {\n        if (!this.isDashing) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.dashStartTime;\n        const progress = Math.min(elapsed / this.dashDuration, 1);\n        if (progress >= 1) {\n            // Dash complete\n            this.isDashing = false;\n            const finalPosition = this.dashStartPosition.clone().add(this.dashDirection.clone().multiplyScalar(this.dashDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad, same as old implementation)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.dashDirection.clone().multiplyScalar(this.dashDistance * easeOutQuad);\n        const newPosition = this.dashStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelDash() {\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n    }\n    stop() {\n        this.velocity.set(0, 0, 0);\n        this.acceleration.set(0, 0, 0);\n        this.moveDirection.set(0, 0, 0);\n        this.inputStrength = 0;\n    }\n    getSpeed() {\n        return this.velocity.length();\n    }\n    getHorizontalSpeed() {\n        return Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.z * this.velocity.z);\n    }\n    isMoving() {\n        return this.getSpeed() > 0.01;\n    }\n    isMovingHorizontally() {\n        return this.getHorizontalSpeed() > 0.01;\n    }\n    isFalling() {\n        return this.velocity.y < -0.1;\n    }\n    isRising() {\n        return this.velocity.y > 0.1;\n    }\n    getAvailableDashCharges() {\n        return this.dashCharges.filter((charge)=>charge.isAvailable).length;\n    }\n    getDashChargeStatus() {\n        const currentTime = Date.now() / 1000;\n        return this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownRemaining: charge.cooldownStartTime ? Math.max(0, 6 - (currentTime - charge.cooldownStartTime)) : 0\n            }));\n    }\n    startCharge(direction, currentPosition, currentTime) {\n        // Check if already charging or dashing\n        if (this.isCharging || this.isDashing) {\n            return false;\n        }\n        // Start the charge\n        this.isCharging = true;\n        this.chargeDirection.copy(direction).normalize();\n        this.chargeStartTime = currentTime;\n        this.chargeStartPosition.copy(currentPosition);\n        return true;\n    }\n    updateCharge(currentTime) {\n        if (!this.isCharging) {\n            return {\n                isComplete: false,\n                newPosition: null\n            };\n        }\n        const elapsed = currentTime - this.chargeStartTime;\n        const progress = Math.min(elapsed / this.chargeDuration, 1);\n        if (progress >= 1) {\n            // Charge complete\n            this.isCharging = false;\n            const finalPosition = this.chargeStartPosition.clone().add(this.chargeDirection.clone().multiplyScalar(this.chargeDistance));\n            return {\n                isComplete: true,\n                newPosition: finalPosition\n            };\n        }\n        // Calculate current position using easing (ease-out quad)\n        const easeOutQuad = 1 - Math.pow(1 - progress, 2);\n        const displacement = this.chargeDirection.clone().multiplyScalar(this.chargeDistance * easeOutQuad);\n        const newPosition = this.chargeStartPosition.clone().add(displacement);\n        return {\n            isComplete: false,\n            newPosition\n        };\n    }\n    cancelCharge() {\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n    }\n    clampVelocity() {\n        // Get effective max speed (considering debuffs)\n        const effectiveMaxSpeed = this.getEffectiveMaxSpeed();\n        // Clamp horizontal velocity to effective max speed\n        const horizontalVelocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.velocity.x, 0, this.velocity.z);\n        const horizontalSpeed = horizontalVelocity.length();\n        if (horizontalSpeed > effectiveMaxSpeed) {\n            if (effectiveMaxSpeed === 0) {\n                // Completely frozen - stop all horizontal movement\n                this.velocity.x = 0;\n                this.velocity.z = 0;\n            } else {\n                horizontalVelocity.normalize().multiplyScalar(effectiveMaxSpeed);\n                this.velocity.x = horizontalVelocity.x;\n                this.velocity.z = horizontalVelocity.z;\n            }\n        }\n    }\n    applyFriction(deltaTime) {\n        if (!this.canMove) return;\n        // Apply friction to horizontal movement\n        const frictionForce = Math.pow(this.friction, deltaTime);\n        this.velocity.x *= frictionForce;\n        this.velocity.z *= frictionForce;\n        // Stop very small velocities to prevent jitter\n        if (Math.abs(this.velocity.x) < 0.01) this.velocity.x = 0;\n        if (Math.abs(this.velocity.z) < 0.01) this.velocity.z = 0;\n    }\n    applyGravity(deltaTime) {\n        if (!this.canFly) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.velocity) {\n            this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.velocity.set(0, 0, 0);\n        }\n        if (!this.acceleration) {\n            this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.acceleration.set(0, 0, 0);\n        }\n        if (!this.moveDirection) {\n            this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.moveDirection.set(0, 0, 0);\n        }\n        this.inputStrength = 0;\n        this.isGrounded = false;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        this.maxSpeed = 5.0;\n        this.friction = 0.8;\n        this.jumpForce = 20.0;\n        this.gravity = -12.5;\n        this.enabled = true;\n        // Reset debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        // Reset dash properties\n        this.isDashing = false;\n        this.dashDirection.set(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35;\n        this.dashDistance = 4;\n        this.dashStartPosition.set(0, 0, 0);\n        // Reset dash charges\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Reset charge properties\n        this.isCharging = false;\n        this.chargeDirection.set(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35;\n        this.chargeDistance = 9;\n        this.chargeStartPosition.set(0, 0, 0);\n    }\n    clone() {\n        const clone = new Movement(this.maxSpeed, this.friction, this.jumpForce, this.gravity);\n        clone.velocity.copy(this.velocity);\n        clone.acceleration.copy(this.acceleration);\n        clone.moveDirection.copy(this.moveDirection);\n        clone.inputStrength = this.inputStrength;\n        clone.isGrounded = this.isGrounded;\n        clone.canMove = this.canMove;\n        clone.canJump = this.canJump;\n        clone.canFly = this.canFly;\n        // Clone debuff states\n        clone.isFrozen = this.isFrozen;\n        clone.frozenUntil = this.frozenUntil;\n        clone.isSlowed = this.isSlowed;\n        clone.slowedUntil = this.slowedUntil;\n        clone.movementSpeedMultiplier = this.movementSpeedMultiplier;\n        // Clone dash properties\n        clone.isDashing = this.isDashing;\n        clone.dashDirection.copy(this.dashDirection);\n        clone.dashStartTime = this.dashStartTime;\n        clone.dashDuration = this.dashDuration;\n        clone.dashDistance = this.dashDistance;\n        clone.dashStartPosition.copy(this.dashStartPosition);\n        // Clone dash charges\n        clone.maxDashCharges = this.maxDashCharges;\n        clone.dashCharges = this.dashCharges.map((charge)=>({\n                isAvailable: charge.isAvailable,\n                cooldownStartTime: charge.cooldownStartTime\n            }));\n        // Clone charge properties\n        clone.isCharging = this.isCharging;\n        clone.chargeDirection.copy(this.chargeDirection);\n        clone.chargeStartTime = this.chargeStartTime;\n        clone.chargeDuration = this.chargeDuration;\n        clone.chargeDistance = this.chargeDistance;\n        clone.chargeStartPosition.copy(this.chargeStartPosition);\n        return clone;\n    }\n    constructor(maxSpeed = 3.65, friction = 0.8, jumpForce = 20.0, gravity = -12.5){\n        super();\n        this.componentType = \"Movement\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.acceleration = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.maxSpeed = maxSpeed;\n        this.friction = friction;\n        this.isGrounded = false;\n        this.jumpForce = jumpForce;\n        this.gravity = gravity;\n        this.canMove = true;\n        this.canJump = true;\n        this.canFly = false;\n        // Initialize debuff states\n        this.isFrozen = false;\n        this.frozenUntil = 0;\n        this.isSlowed = false;\n        this.slowedUntil = 0;\n        this.movementSpeedMultiplier = 1.0;\n        this.moveDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.inputStrength = 0;\n        // Initialize dash properties\n        this.isDashing = false;\n        this.dashDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.dashStartTime = 0;\n        this.dashDuration = 0.35; // 350ms dash duration (same as old implementation)\n        this.dashDistance = 4; // Increased from 3.125 for more noticeable dash\n        this.dashStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Initialize multiple dash charges (3 charges, each with 6s cooldown)\n        this.maxDashCharges = 3;\n        this.dashCharges = Array.from({\n            length: this.maxDashCharges\n        }, ()=>({\n                isAvailable: true,\n                cooldownStartTime: null\n            }));\n        // Initialize sword charge properties\n        this.isCharging = false;\n        this.chargeDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.chargeStartTime = 0;\n        this.chargeDuration = 0.35; // 350ms charge duration\n        this.chargeDistance = 9; // Sword charge distance\n        this.chargeStartPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n    }\n}\nMovement.componentType = \"Movement\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwwREFBMEQ7QUFDVjtBQUNWO0FBRS9CLE1BQU1FLGlCQUFpQkQsOENBQVNBO0lBd0c5QkUsU0FBU0MsS0FBYyxFQUFRO1FBQ3BDLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUNGO0lBQ3hCO0lBRU9HLFdBQVdDLE9BQWdCLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxRQUFRLENBQUNILEdBQUcsQ0FBQ0U7SUFDcEI7SUFFT0UsT0FBYTtRQUNsQixJQUFJLElBQUksQ0FBQ0MsT0FBTyxJQUFLLEtBQUksQ0FBQ0MsVUFBVSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ3BELElBQUksQ0FBQ0osUUFBUSxDQUFDSyxDQUFDLEdBQUcsSUFBSSxDQUFDQyxTQUFTO1lBQ2hDLElBQUksQ0FBQ0gsVUFBVSxHQUFHO1FBQ3BCO0lBQ0Y7SUFFT0ksaUJBQWlCQyxTQUFrQixFQUFnQztZQUE5QkMsV0FBQUEsaUVBQW1CO1FBQzdELElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxJQUFJLENBQUNILFdBQVdJLFNBQVM7UUFDNUMsSUFBSSxDQUFDQyxhQUFhLEdBQUdDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUMsR0FBR1A7SUFDL0M7SUFFT1EsT0FBT0MsUUFBZ0IsRUFBUTtRQUNwQyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO1FBQzVCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsV0FBVyxHQUFHSixjQUFjRDtRQUNqQ00sUUFBUUMsR0FBRyxDQUFDLGtDQUE0QyxPQUFwQlAsVUFBUyxhQUF5Q0MsT0FBOUIsSUFBSSxDQUFDSSxXQUFXLEVBQUMsZUFBeUIsT0FBWkosYUFBWTtJQUNwRztJQUVPTyxLQUFLUixRQUFnQixFQUF1QztZQUFyQ1Msa0JBQUFBLGlFQUEwQjtRQUN0RCxNQUFNUixj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Q0gsbUJBQW1CLEdBQUcsSUFBSTNGLHlEQUFPQSxDQUFDLEdBQUcsR0FBRztJQUMvQztBQXVXRjtBQTdjYUUsU0FDWWdILGdCQUFnQixXQUFZLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQudHM/MThhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb3ZlbWVudCBjb21wb25lbnQgZm9yIHZlbG9jaXR5IGFuZCBtb3ZlbWVudCBwcm9wZXJ0aWVzXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBNb3ZlbWVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdNb3ZlbWVudCc7IC8vIEluc3RhbmNlIGlkZW50aWZpZXJcbiAgcHVibGljIHZlbG9jaXR5OiBWZWN0b3IzO1xuICBwdWJsaWMgYWNjZWxlcmF0aW9uOiBWZWN0b3IzO1xuICBwdWJsaWMgbWF4U3BlZWQ6IG51bWJlcjtcbiAgcHVibGljIGZyaWN0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBpc0dyb3VuZGVkOiBib29sZWFuO1xuICBwdWJsaWMganVtcEZvcmNlOiBudW1iZXI7XG4gIHB1YmxpYyBncmF2aXR5OiBudW1iZXI7XG5cbiAgLy8gTW92ZW1lbnQgZmxhZ3NcbiAgcHVibGljIGNhbk1vdmU6IGJvb2xlYW47XG4gIHB1YmxpYyBjYW5KdW1wOiBib29sZWFuO1xuICBwdWJsaWMgY2FuRmx5OiBib29sZWFuO1xuXG4gIC8vIERlYnVmZiBzdGF0ZXMgZm9yIFBWUFxuICBwdWJsaWMgaXNGcm96ZW46IGJvb2xlYW47XG4gIHB1YmxpYyBmcm96ZW5VbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgaXNTbG93ZWQ6IGJvb2xlYW47XG4gIHB1YmxpYyBzbG93ZWRVbnRpbDogbnVtYmVyO1xuICBwdWJsaWMgbW92ZW1lbnRTcGVlZE11bHRpcGxpZXI6IG51bWJlcjtcblxuICAvLyBJbnB1dC1iYXNlZCBtb3ZlbWVudFxuICBwdWJsaWMgbW92ZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGlucHV0U3RyZW5ndGg6IG51bWJlcjtcblxuICAvLyBEYXNoL1ZhdWx0IHN5c3RlbVxuICBwdWJsaWMgaXNEYXNoaW5nOiBib29sZWFuO1xuICBwdWJsaWMgZGFzaERpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGRhc2hTdGFydFRpbWU6IG51bWJlcjtcbiAgcHVibGljIGRhc2hEdXJhdGlvbjogbnVtYmVyO1xuICBwdWJsaWMgZGFzaERpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBkYXNoU3RhcnRQb3NpdGlvbjogVmVjdG9yMztcbiAgXG4gIC8vIE11bHRpcGxlIGRhc2ggY2hhcmdlcyBzeXN0ZW1cbiAgcHVibGljIGRhc2hDaGFyZ2VzOiBBcnJheTx7XG4gICAgaXNBdmFpbGFibGU6IGJvb2xlYW47XG4gICAgY29vbGRvd25TdGFydFRpbWU6IG51bWJlciB8IG51bGw7XG4gIH0+O1xuICBwdWJsaWMgbWF4RGFzaENoYXJnZXM6IG51bWJlcjtcblxuICAvLyBTd29yZCBDaGFyZ2UgYWJpbGl0eSBzeXN0ZW0gKHNlcGFyYXRlIGZyb20gZGFzaGVzKVxuICBwdWJsaWMgaXNDaGFyZ2luZzogYm9vbGVhbjtcbiAgcHVibGljIGNoYXJnZURpcmVjdGlvbjogVmVjdG9yMztcbiAgcHVibGljIGNoYXJnZVN0YXJ0VGltZTogbnVtYmVyO1xuICBwdWJsaWMgY2hhcmdlRHVyYXRpb246IG51bWJlcjtcbiAgcHVibGljIGNoYXJnZURpc3RhbmNlOiBudW1iZXI7XG4gIHB1YmxpYyBjaGFyZ2VTdGFydFBvc2l0aW9uOiBWZWN0b3IzO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIG1heFNwZWVkOiBudW1iZXIgPSAzLjY1LFxuICAgIGZyaWN0aW9uOiBudW1iZXIgPSAwLjgsXG4gICAganVtcEZvcmNlOiBudW1iZXIgPSAyMC4wLFxuICAgIGdyYXZpdHk6IG51bWJlciA9IC0xMi41XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5tYXhTcGVlZCA9IG1heFNwZWVkO1xuICAgIHRoaXMuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmp1bXBGb3JjZSA9IGp1bXBGb3JjZTtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICAgIFxuICAgIHRoaXMuY2FuTW92ZSA9IHRydWU7XG4gICAgdGhpcy5jYW5KdW1wID0gdHJ1ZTtcbiAgICB0aGlzLmNhbkZseSA9IGZhbHNlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgIFxuICAgIHRoaXMubW92ZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuaW5wdXRTdHJlbmd0aCA9IDA7XG5cbiAgICAvLyBJbml0aWFsaXplIGRhc2ggcHJvcGVydGllc1xuICAgIHRoaXMuaXNEYXNoaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kYXNoRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5kYXNoU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmRhc2hEdXJhdGlvbiA9IDAuMzU7IC8vIDM1MG1zIGRhc2ggZHVyYXRpb24gKHNhbWUgYXMgb2xkIGltcGxlbWVudGF0aW9uKVxuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDsgLy8gSW5jcmVhc2VkIGZyb20gMy4xMjUgZm9yIG1vcmUgbm90aWNlYWJsZSBkYXNoXG4gICAgdGhpcy5kYXNoU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgbXVsdGlwbGUgZGFzaCBjaGFyZ2VzICgzIGNoYXJnZXMsIGVhY2ggd2l0aCA2cyBjb29sZG93bilcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIEluaXRpYWxpemUgc3dvcmQgY2hhcmdlIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJnZURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTsgLy8gMzUwbXMgY2hhcmdlIGR1cmF0aW9uXG4gICAgdGhpcy5jaGFyZ2VEaXN0YW5jZSA9IDk7IC8vIFN3b3JkIGNoYXJnZSBkaXN0YW5jZVxuICAgIHRoaXMuY2hhcmdlU3RhcnRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGFkZEZvcmNlKGZvcmNlOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy5hY2NlbGVyYXRpb24uYWRkKGZvcmNlKTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRJbXB1bHNlKGltcHVsc2U6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LmFkZChpbXB1bHNlKTtcbiAgfVxuXG4gIHB1YmxpYyBqdW1wKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbkp1bXAgJiYgKHRoaXMuaXNHcm91bmRlZCB8fCB0aGlzLmNhbkZseSkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuanVtcEZvcmNlO1xuICAgICAgdGhpcy5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldE1vdmVEaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzLCBzdHJlbmd0aDogbnVtYmVyID0gMS4wKTogdm9pZCB7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKS5ub3JtYWxpemUoKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzdHJlbmd0aCkpO1xuICB9XG5cbiAgcHVibGljIGZyZWV6ZShkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuaXNGcm96ZW4gPSB0cnVlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSBjdXJyZW50VGltZSArIGR1cmF0aW9uO1xuICAgIGNvbnNvbGUubG9nKGDwn6eKIFBsYXllciBmcm96ZW4gZm9yICR7ZHVyYXRpb259bXMgdW50aWwgJHt0aGlzLmZyb3plblVudGlsfSAoY3VycmVudDogJHtjdXJyZW50VGltZX0pYCk7XG4gIH1cblxuICBwdWJsaWMgc2xvdyhkdXJhdGlvbjogbnVtYmVyLCBzcGVlZE11bHRpcGxpZXI6IG51bWJlciA9IDAuNSk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzU2xvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gY3VycmVudFRpbWUgKyBkdXJhdGlvbjtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gc3BlZWRNdWx0aXBsaWVyO1xuICAgIGNvbnNvbGUubG9nKGDwn5CMIFBsYXllciBzbG93ZWQgdG8gJHtzcGVlZE11bHRpcGxpZXIgKiAxMDB9JSBzcGVlZCBmb3IgJHtkdXJhdGlvbn1tcyB1bnRpbCAke3RoaXMuc2xvd2VkVW50aWx9YCk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGVidWZmcygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZnJvemVuIHN0YXRlXG4gICAgaWYgKHRoaXMuaXNGcm96ZW4gJiYgY3VycmVudFRpbWUgPj0gdGhpcy5mcm96ZW5VbnRpbCkge1xuICAgICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgdGhpcy5mcm96ZW5VbnRpbCA9IDA7XG4gICAgICBjb25zb2xlLmxvZygn8J+niiBQbGF5ZXIgdW5mcm96ZW4nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgc2xvd2VkIHN0YXRlXG4gICAgaWYgKHRoaXMuaXNTbG93ZWQgJiYgY3VycmVudFRpbWUgPj0gdGhpcy5zbG93ZWRVbnRpbCkge1xuICAgICAgdGhpcy5pc1Nsb3dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zbG93ZWRVbnRpbCA9IDA7XG4gICAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuICAgICAgY29uc29sZS5sb2coJ/CfkIwgUGxheWVyIG5vIGxvbmdlciBzbG93ZWQnKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RWZmZWN0aXZlTWF4U3BlZWQoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Zyb3plbikge1xuICAgICAgcmV0dXJuIDA7IC8vIENvbXBsZXRlbHkgZnJvemVuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1heFNwZWVkICogdGhpcy5tb3ZlbWVudFNwZWVkTXVsdGlwbGllcjtcbiAgfVxuXG4gIHB1YmxpYyBzdGFydERhc2goZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0Rhc2hpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGZpcnN0IGF2YWlsYWJsZSBjaGFyZ2VcbiAgICBjb25zdCBhdmFpbGFibGVDaGFyZ2VJbmRleCA9IHRoaXMuZGFzaENoYXJnZXMuZmluZEluZGV4KGNoYXJnZSA9PiBjaGFyZ2UuaXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVDaGFyZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gY2hhcmdlcyBhdmFpbGFibGVcbiAgICB9XG5cbiAgICAvLyBTdGFydCB0aGUgZGFzaFxuICAgIHRoaXMuaXNEYXNoaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY29weShjdXJyZW50UG9zaXRpb24pO1xuXG4gICAgLy8gQ29uc3VtZSB0aGUgY2hhcmdlXG4gICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hDaGFyZ2VzW2F2YWlsYWJsZUNoYXJnZUluZGV4XS5jb29sZG93blN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgLy8gU2V0IGNvb2xkb3duIHRpbWVyIGZvciB0aGlzIHNwZWNpZmljIGNoYXJnZSAoNiBzZWNvbmRzKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uaXNBdmFpbGFibGUgPSB0cnVlO1xuICAgICAgdGhpcy5kYXNoQ2hhcmdlc1thdmFpbGFibGVDaGFyZ2VJbmRleF0uY29vbGRvd25TdGFydFRpbWUgPSBudWxsO1xuICAgIH0sIDYwMDApOyAvLyA2IHNlY29uZCBjb29sZG93blxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlRGFzaChjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzRGFzaGluZykge1xuICAgICAgcmV0dXJuIHsgaXNDb21wbGV0ZTogZmFsc2UsIG5ld1Bvc2l0aW9uOiBudWxsIH07XG4gICAgfVxuXG4gICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnRUaW1lIC0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuZGFzaER1cmF0aW9uLCAxKTtcblxuICAgIGlmIChwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAvLyBEYXNoIGNvbXBsZXRlXG4gICAgICB0aGlzLmlzRGFzaGluZyA9IGZhbHNlO1xuICAgICAgY29uc3QgZmluYWxQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKVxuICAgICAgICAuYWRkKHRoaXMuZGFzaERpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuZGFzaERpc3RhbmNlKSk7XG4gICAgICByZXR1cm4geyBpc0NvbXBsZXRlOiB0cnVlLCBuZXdQb3NpdGlvbjogZmluYWxQb3NpdGlvbiB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IHBvc2l0aW9uIHVzaW5nIGVhc2luZyAoZWFzZS1vdXQgcXVhZCwgc2FtZSBhcyBvbGQgaW1wbGVtZW50YXRpb24pXG4gICAgY29uc3QgZWFzZU91dFF1YWQgPSAxIC0gTWF0aC5wb3coMSAtIHByb2dyZXNzLCAyKTtcbiAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLmRhc2hEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmRhc2hEaXN0YW5jZSAqIGVhc2VPdXRRdWFkKTtcbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuZGFzaFN0YXJ0UG9zaXRpb24uY2xvbmUoKS5hZGQoZGlzcGxhY2VtZW50KTtcblxuICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbiB9O1xuICB9XG5cbiAgcHVibGljIGNhbmNlbERhc2goKTogdm9pZCB7XG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gIH1cblxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB0aGlzLmlucHV0U3RyZW5ndGggPSAwO1xuICB9XG5cbiAgcHVibGljIGdldFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkubGVuZ3RoKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0SG9yaXpvbnRhbFNwZWVkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnZlbG9jaXR5LnggKiB0aGlzLnZlbG9jaXR5LnggKyB0aGlzLnZlbG9jaXR5LnogKiB0aGlzLnZlbG9jaXR5LnopO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldFNwZWVkKCkgPiAwLjAxO1xuICB9XG5cbiAgcHVibGljIGlzTW92aW5nSG9yaXpvbnRhbGx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEhvcml6b250YWxTcGVlZCgpID4gMC4wMTtcbiAgfVxuXG4gIHB1YmxpYyBpc0ZhbGxpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA8IC0wLjE7XG4gIH1cblxuICBwdWJsaWMgaXNSaXNpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueSA+IDAuMTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRBdmFpbGFibGVEYXNoQ2hhcmdlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLmZpbHRlcihjaGFyZ2UgPT4gY2hhcmdlLmlzQXZhaWxhYmxlKS5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0RGFzaENoYXJnZVN0YXR1cygpOiBBcnJheTx7IGlzQXZhaWxhYmxlOiBib29sZWFuOyBjb29sZG93blJlbWFpbmluZzogbnVtYmVyIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIHJldHVybiB0aGlzLmRhc2hDaGFyZ2VzLm1hcChjaGFyZ2UgPT4gKHtcbiAgICAgIGlzQXZhaWxhYmxlOiBjaGFyZ2UuaXNBdmFpbGFibGUsXG4gICAgICBjb29sZG93blJlbWFpbmluZzogY2hhcmdlLmNvb2xkb3duU3RhcnRUaW1lIFxuICAgICAgICA/IE1hdGgubWF4KDAsIDYgLSAoY3VycmVudFRpbWUgLSBjaGFyZ2UuY29vbGRvd25TdGFydFRpbWUpKVxuICAgICAgICA6IDBcbiAgICB9KSk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRDaGFyZ2UoZGlyZWN0aW9uOiBWZWN0b3IzLCBjdXJyZW50UG9zaXRpb246IFZlY3RvcjMsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiBhbHJlYWR5IGNoYXJnaW5nIG9yIGRhc2hpbmdcbiAgICBpZiAodGhpcy5pc0NoYXJnaW5nIHx8IHRoaXMuaXNEYXNoaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGhlIGNoYXJnZVxuICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY29weShkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkoY3VycmVudFBvc2l0aW9uKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUNoYXJnZShjdXJyZW50VGltZTogbnVtYmVyKTogeyBpc0NvbXBsZXRlOiBib29sZWFuOyBuZXdQb3NpdGlvbjogVmVjdG9yMyB8IG51bGwgfSB7XG4gICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IGZhbHNlLCBuZXdQb3NpdGlvbjogbnVsbCB9O1xuICAgIH1cblxuICAgIGNvbnN0IGVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHRoaXMuY2hhcmdlU3RhcnRUaW1lO1xuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIHRoaXMuY2hhcmdlRHVyYXRpb24sIDEpO1xuXG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgIC8vIENoYXJnZSBjb21wbGV0ZVxuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBmaW5hbFBvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKClcbiAgICAgICAgLmFkZCh0aGlzLmNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuY2hhcmdlRGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiB7IGlzQ29tcGxldGU6IHRydWUsIG5ld1Bvc2l0aW9uOiBmaW5hbFBvc2l0aW9uIH07XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGN1cnJlbnQgcG9zaXRpb24gdXNpbmcgZWFzaW5nIChlYXNlLW91dCBxdWFkKVxuICAgIGNvbnN0IGVhc2VPdXRRdWFkID0gMSAtIE1hdGgucG93KDEgLSBwcm9ncmVzcywgMik7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5jaGFyZ2VEaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLmNoYXJnZURpc3RhbmNlICogZWFzZU91dFF1YWQpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uLmNsb25lKCkuYWRkKGRpc3BsYWNlbWVudCk7XG5cbiAgICByZXR1cm4geyBpc0NvbXBsZXRlOiBmYWxzZSwgbmV3UG9zaXRpb24gfTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5jZWxDaGFyZ2UoKTogdm9pZCB7XG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgfVxuXG4gIHB1YmxpYyBjbGFtcFZlbG9jaXR5KCk6IHZvaWQge1xuICAgIC8vIEdldCBlZmZlY3RpdmUgbWF4IHNwZWVkIChjb25zaWRlcmluZyBkZWJ1ZmZzKVxuICAgIGNvbnN0IGVmZmVjdGl2ZU1heFNwZWVkID0gdGhpcy5nZXRFZmZlY3RpdmVNYXhTcGVlZCgpO1xuICAgIFxuICAgIC8vIENsYW1wIGhvcml6b250YWwgdmVsb2NpdHkgdG8gZWZmZWN0aXZlIG1heCBzcGVlZFxuICAgIGNvbnN0IGhvcml6b250YWxWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKHRoaXMudmVsb2NpdHkueCwgMCwgdGhpcy52ZWxvY2l0eS56KTtcbiAgICBjb25zdCBob3Jpem9udGFsU3BlZWQgPSBob3Jpem9udGFsVmVsb2NpdHkubGVuZ3RoKCk7XG4gICAgXG4gICAgaWYgKGhvcml6b250YWxTcGVlZCA+IGVmZmVjdGl2ZU1heFNwZWVkKSB7XG4gICAgICBpZiAoZWZmZWN0aXZlTWF4U3BlZWQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tcGxldGVseSBmcm96ZW4gLSBzdG9wIGFsbCBob3Jpem9udGFsIG1vdmVtZW50XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3Jpem9udGFsVmVsb2NpdHkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoZWZmZWN0aXZlTWF4U3BlZWQpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnggPSBob3Jpem9udGFsVmVsb2NpdHkueDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS56ID0gaG9yaXpvbnRhbFZlbG9jaXR5Lno7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFwcGx5RnJpY3Rpb24oZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuTW92ZSkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgZnJpY3Rpb24gdG8gaG9yaXpvbnRhbCBtb3ZlbWVudFxuICAgIGNvbnN0IGZyaWN0aW9uRm9yY2UgPSBNYXRoLnBvdyh0aGlzLmZyaWN0aW9uLCBkZWx0YVRpbWUpO1xuICAgIHRoaXMudmVsb2NpdHkueCAqPSBmcmljdGlvbkZvcmNlO1xuICAgIHRoaXMudmVsb2NpdHkueiAqPSBmcmljdGlvbkZvcmNlO1xuXG4gICAgLy8gU3RvcCB2ZXJ5IHNtYWxsIHZlbG9jaXRpZXMgdG8gcHJldmVudCBqaXR0ZXJcbiAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eS54KSA8IDAuMDEpIHRoaXMudmVsb2NpdHkueCA9IDA7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueikgPCAwLjAxKSB0aGlzLnZlbG9jaXR5LnogPSAwO1xuICB9XG5cbiAgcHVibGljIGFwcGx5R3Jhdml0eShkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy5jYW5GbHkpIHtcbiAgICAgIHRoaXMudmVsb2NpdHkueSArPSB0aGlzLmdyYXZpdHkgKiBkZWx0YVRpbWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIC8vIEVuc3VyZSBWZWN0b3IzIG9iamVjdHMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgaWYgKCF0aGlzLnZlbG9jaXR5KSB7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXRoaXMuYWNjZWxlcmF0aW9uKSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tb3ZlRGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1vdmVEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlRGlyZWN0aW9uLnNldCgwLCAwLCAwKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5pbnB1dFN0cmVuZ3RoID0gMDtcbiAgICB0aGlzLmlzR3JvdW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbk1vdmUgPSB0cnVlO1xuICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgdGhpcy5jYW5GbHkgPSBmYWxzZTtcbiAgICB0aGlzLm1heFNwZWVkID0gNS4wO1xuICAgIHRoaXMuZnJpY3Rpb24gPSAwLjg7XG4gICAgdGhpcy5qdW1wRm9yY2UgPSAyMC4wO1xuICAgIHRoaXMuZ3Jhdml0eSA9IC0xMi41O1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAvLyBSZXNldCBkZWJ1ZmYgc3RhdGVzXG4gICAgdGhpcy5pc0Zyb3plbiA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuVW50aWwgPSAwO1xuICAgIHRoaXMuaXNTbG93ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNsb3dlZFVudGlsID0gMDtcbiAgICB0aGlzLm1vdmVtZW50U3BlZWRNdWx0aXBsaWVyID0gMS4wO1xuXG4gICAgLy8gUmVzZXQgZGFzaCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0Rhc2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuZGFzaFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kYXNoRHVyYXRpb24gPSAwLjM1O1xuICAgIHRoaXMuZGFzaERpc3RhbmNlID0gNDtcbiAgICB0aGlzLmRhc2hTdGFydFBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICBcbiAgICAvLyBSZXNldCBkYXNoIGNoYXJnZXNcbiAgICB0aGlzLm1heERhc2hDaGFyZ2VzID0gMztcbiAgICB0aGlzLmRhc2hDaGFyZ2VzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5tYXhEYXNoQ2hhcmdlcyB9LCAoKSA9PiAoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICBjb29sZG93blN0YXJ0VGltZTogbnVsbFxuICAgIH0pKTtcblxuICAgIC8vIFJlc2V0IGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jaGFyZ2VEaXJlY3Rpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuY2hhcmdlU3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmNoYXJnZUR1cmF0aW9uID0gMC4zNTtcbiAgICB0aGlzLmNoYXJnZURpc3RhbmNlID0gOTtcbiAgICB0aGlzLmNoYXJnZVN0YXJ0UG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICB9XG5cbiAgcHVibGljIGNsb25lKCk6IE1vdmVtZW50IHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBNb3ZlbWVudCh0aGlzLm1heFNwZWVkLCB0aGlzLmZyaWN0aW9uLCB0aGlzLmp1bXBGb3JjZSwgdGhpcy5ncmF2aXR5KTtcbiAgICBjbG9uZS52ZWxvY2l0eS5jb3B5KHRoaXMudmVsb2NpdHkpO1xuICAgIGNsb25lLmFjY2VsZXJhdGlvbi5jb3B5KHRoaXMuYWNjZWxlcmF0aW9uKTtcbiAgICBjbG9uZS5tb3ZlRGlyZWN0aW9uLmNvcHkodGhpcy5tb3ZlRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5pbnB1dFN0cmVuZ3RoID0gdGhpcy5pbnB1dFN0cmVuZ3RoO1xuICAgIGNsb25lLmlzR3JvdW5kZWQgPSB0aGlzLmlzR3JvdW5kZWQ7XG4gICAgY2xvbmUuY2FuTW92ZSA9IHRoaXMuY2FuTW92ZTtcbiAgICBjbG9uZS5jYW5KdW1wID0gdGhpcy5jYW5KdW1wO1xuICAgIGNsb25lLmNhbkZseSA9IHRoaXMuY2FuRmx5O1xuXG4gICAgLy8gQ2xvbmUgZGVidWZmIHN0YXRlc1xuICAgIGNsb25lLmlzRnJvemVuID0gdGhpcy5pc0Zyb3plbjtcbiAgICBjbG9uZS5mcm96ZW5VbnRpbCA9IHRoaXMuZnJvemVuVW50aWw7XG4gICAgY2xvbmUuaXNTbG93ZWQgPSB0aGlzLmlzU2xvd2VkO1xuICAgIGNsb25lLnNsb3dlZFVudGlsID0gdGhpcy5zbG93ZWRVbnRpbDtcbiAgICBjbG9uZS5tb3ZlbWVudFNwZWVkTXVsdGlwbGllciA9IHRoaXMubW92ZW1lbnRTcGVlZE11bHRpcGxpZXI7XG5cbiAgICAvLyBDbG9uZSBkYXNoIHByb3BlcnRpZXNcbiAgICBjbG9uZS5pc0Rhc2hpbmcgPSB0aGlzLmlzRGFzaGluZztcbiAgICBjbG9uZS5kYXNoRGlyZWN0aW9uLmNvcHkodGhpcy5kYXNoRGlyZWN0aW9uKTtcbiAgICBjbG9uZS5kYXNoU3RhcnRUaW1lID0gdGhpcy5kYXNoU3RhcnRUaW1lO1xuICAgIGNsb25lLmRhc2hEdXJhdGlvbiA9IHRoaXMuZGFzaER1cmF0aW9uO1xuICAgIGNsb25lLmRhc2hEaXN0YW5jZSA9IHRoaXMuZGFzaERpc3RhbmNlO1xuICAgIGNsb25lLmRhc2hTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5kYXNoU3RhcnRQb3NpdGlvbik7XG4gICAgXG4gICAgLy8gQ2xvbmUgZGFzaCBjaGFyZ2VzXG4gICAgY2xvbmUubWF4RGFzaENoYXJnZXMgPSB0aGlzLm1heERhc2hDaGFyZ2VzO1xuICAgIGNsb25lLmRhc2hDaGFyZ2VzID0gdGhpcy5kYXNoQ2hhcmdlcy5tYXAoY2hhcmdlID0+ICh7XG4gICAgICBpc0F2YWlsYWJsZTogY2hhcmdlLmlzQXZhaWxhYmxlLFxuICAgICAgY29vbGRvd25TdGFydFRpbWU6IGNoYXJnZS5jb29sZG93blN0YXJ0VGltZVxuICAgIH0pKTtcblxuICAgIC8vIENsb25lIGNoYXJnZSBwcm9wZXJ0aWVzXG4gICAgY2xvbmUuaXNDaGFyZ2luZyA9IHRoaXMuaXNDaGFyZ2luZztcbiAgICBjbG9uZS5jaGFyZ2VEaXJlY3Rpb24uY29weSh0aGlzLmNoYXJnZURpcmVjdGlvbik7XG4gICAgY2xvbmUuY2hhcmdlU3RhcnRUaW1lID0gdGhpcy5jaGFyZ2VTdGFydFRpbWU7XG4gICAgY2xvbmUuY2hhcmdlRHVyYXRpb24gPSB0aGlzLmNoYXJnZUR1cmF0aW9uO1xuICAgIGNsb25lLmNoYXJnZURpc3RhbmNlID0gdGhpcy5jaGFyZ2VEaXN0YW5jZTtcbiAgICBjbG9uZS5jaGFyZ2VTdGFydFBvc2l0aW9uLmNvcHkodGhpcy5jaGFyZ2VTdGFydFBvc2l0aW9uKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJDb21wb25lbnQiLCJNb3ZlbWVudCIsImFkZEZvcmNlIiwiZm9yY2UiLCJhY2NlbGVyYXRpb24iLCJhZGQiLCJhZGRJbXB1bHNlIiwiaW1wdWxzZSIsInZlbG9jaXR5IiwianVtcCIsImNhbkp1bXAiLCJpc0dyb3VuZGVkIiwiY2FuRmx5IiwieSIsImp1bXBGb3JjZSIsInNldE1vdmVEaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJzdHJlbmd0aCIsIm1vdmVEaXJlY3Rpb24iLCJjb3B5Iiwibm9ybWFsaXplIiwiaW5wdXRTdHJlbmd0aCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJmcmVlemUiLCJkdXJhdGlvbiIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImlzRnJvemVuIiwiZnJvemVuVW50aWwiLCJjb25zb2xlIiwibG9nIiwic2xvdyIsInNwZWVkTXVsdGlwbGllciIsImlzU2xvd2VkIiwic2xvd2VkVW50aWwiLCJtb3ZlbWVudFNwZWVkTXVsdGlwbGllciIsInVwZGF0ZURlYnVmZnMiLCJnZXRFZmZlY3RpdmVNYXhTcGVlZCIsIm1heFNwZWVkIiwic3RhcnREYXNoIiwiY3VycmVudFBvc2l0aW9uIiwiaXNEYXNoaW5nIiwiYXZhaWxhYmxlQ2hhcmdlSW5kZXgiLCJkYXNoQ2hhcmdlcyIsImZpbmRJbmRleCIsImNoYXJnZSIsImlzQXZhaWxhYmxlIiwiZGFzaERpcmVjdGlvbiIsImRhc2hTdGFydFRpbWUiLCJkYXNoU3RhcnRQb3NpdGlvbiIsImNvb2xkb3duU3RhcnRUaW1lIiwic2V0VGltZW91dCIsInVwZGF0ZURhc2giLCJpc0NvbXBsZXRlIiwibmV3UG9zaXRpb24iLCJlbGFwc2VkIiwicHJvZ3Jlc3MiLCJkYXNoRHVyYXRpb24iLCJmaW5hbFBvc2l0aW9uIiwiY2xvbmUiLCJtdWx0aXBseVNjYWxhciIsImRhc2hEaXN0YW5jZSIsImVhc2VPdXRRdWFkIiwicG93IiwiZGlzcGxhY2VtZW50IiwiY2FuY2VsRGFzaCIsInNldCIsInN0b3AiLCJnZXRTcGVlZCIsImxlbmd0aCIsImdldEhvcml6b250YWxTcGVlZCIsInNxcnQiLCJ4IiwieiIsImlzTW92aW5nIiwiaXNNb3ZpbmdIb3Jpem9udGFsbHkiLCJpc0ZhbGxpbmciLCJpc1Jpc2luZyIsImdldEF2YWlsYWJsZURhc2hDaGFyZ2VzIiwiZmlsdGVyIiwiZ2V0RGFzaENoYXJnZVN0YXR1cyIsIm1hcCIsImNvb2xkb3duUmVtYWluaW5nIiwic3RhcnRDaGFyZ2UiLCJpc0NoYXJnaW5nIiwiY2hhcmdlRGlyZWN0aW9uIiwiY2hhcmdlU3RhcnRUaW1lIiwiY2hhcmdlU3RhcnRQb3NpdGlvbiIsInVwZGF0ZUNoYXJnZSIsImNoYXJnZUR1cmF0aW9uIiwiY2hhcmdlRGlzdGFuY2UiLCJjYW5jZWxDaGFyZ2UiLCJjbGFtcFZlbG9jaXR5IiwiZWZmZWN0aXZlTWF4U3BlZWQiLCJob3Jpem9udGFsVmVsb2NpdHkiLCJob3Jpem9udGFsU3BlZWQiLCJhcHBseUZyaWN0aW9uIiwiZGVsdGFUaW1lIiwiY2FuTW92ZSIsImZyaWN0aW9uRm9yY2UiLCJmcmljdGlvbiIsImFicyIsImFwcGx5R3Jhdml0eSIsImdyYXZpdHkiLCJyZXNldCIsImVuYWJsZWQiLCJtYXhEYXNoQ2hhcmdlcyIsIkFycmF5IiwiZnJvbSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Movement.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Projectile.ts":
/*!******************************************!*\
  !*** ./src/ecs/components/Projectile.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Projectile: function() { return /* binding */ Projectile; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Projectile component for bullets, spells, and other projectiles\n\n\nclass Projectile extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setDirection(direction) {\n        this.velocity.copy(direction).normalize().multiplyScalar(this.speed);\n    }\n    addGravity(gravity) {\n        this.gravity = gravity;\n    }\n    setPiercing(piercing) {\n        this.piercing = piercing;\n    }\n    setExplosive(radius) {\n        this.explosionRadius = radius;\n    }\n    setBouncing(maxBounces) {\n        this.maxBounces = maxBounces;\n    }\n    hasHitTarget(entityId) {\n        return this.hitTargets.has(entityId);\n    }\n    addHitTarget(entityId) {\n        this.hitTargets.add(entityId);\n    }\n    canHitTarget(entityId) {\n        // Can't hit owner\n        if (entityId === this.owner) return false;\n        // If piercing, can hit targets multiple times\n        if (this.piercing) return true;\n        // Otherwise, can only hit each target once\n        return !this.hasHitTarget(entityId);\n    }\n    isExpired() {\n        return this.lifetime >= this.maxLifetime;\n    }\n    canBounce() {\n        return this.bounces < this.maxBounces;\n    }\n    bounce(normal) {\n        if (!this.canBounce()) return;\n        // Reflect velocity off the surface normal\n        const reflection = this.velocity.clone().reflect(normal);\n        this.velocity.copy(reflection);\n        this.bounces++;\n    }\n    update(deltaTime) {\n        this.lifetime += deltaTime;\n        // Apply gravity if enabled\n        if (this.gravity !== 0) {\n            this.velocity.y += this.gravity * deltaTime;\n        }\n    }\n    getPosition(transform) {\n        return transform.clone();\n    }\n    getPredictedPosition(transform, deltaTime) {\n        const predicted = transform.clone();\n        predicted.add(this.velocity.clone().multiplyScalar(deltaTime));\n        return predicted;\n    }\n    reset() {\n        this.velocity.set(0, 0, 0);\n        this.speed = 20;\n        this.damage = 10;\n        this.lifetime = 0;\n        this.maxLifetime = 5;\n        this.piercing = false;\n        this.hitTargets.clear();\n        this.explosionRadius = 0;\n        this.gravity = 0;\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Projectile(this.speed, this.damage, this.maxLifetime, this.owner);\n        clone.velocity.copy(this.velocity);\n        clone.lifetime = this.lifetime;\n        clone.piercing = this.piercing;\n        clone.hitTargets = new Set(this.hitTargets);\n        clone.explosionRadius = this.explosionRadius;\n        clone.gravity = this.gravity;\n        clone.bounces = this.bounces;\n        clone.maxBounces = this.maxBounces;\n        return clone;\n    }\n    constructor(speed = 20, damage = 10, maxLifetime = 5, owner = -1){\n        super();\n        this.componentType = \"Projectile\" // Instance identifier\n        ;\n        this.velocity = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        this.speed = speed;\n        this.damage = damage;\n        this.lifetime = 0;\n        this.maxLifetime = maxLifetime;\n        this.piercing = false;\n        this.hitTargets = new Set();\n        this.explosionRadius = 0;\n        this.gravity = 0; // Most projectiles ignore gravity\n        this.bounces = 0;\n        this.maxBounces = 0;\n        this.owner = owner;\n    }\n}\nProjectile.componentType = \"Projectile\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Qcm9qZWN0aWxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtFQUFrRTtBQUNsQjtBQUNWO0FBRS9CLE1BQU1FLG1CQUFtQkQsOENBQVNBO0lBc0NoQ0UsYUFBYUMsU0FBa0IsRUFBUTtRQUM1QyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixXQUFXRyxTQUFTLEdBQUdDLGNBQWMsQ0FBQyxJQUFJLENBQUNDLEtBQUs7SUFDckU7SUFFT0MsV0FBV0MsT0FBZSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVPQyxZQUFZQyxRQUFpQixFQUFRO1FBQzFDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtJQUNsQjtJQUVPQyxhQUFhQyxNQUFjLEVBQVE7UUFDeEMsSUFBSSxDQUFDQyxlQUFlLEdBQUdEO0lBQ3pCO0lBRU9FLFlBQVlDLFVBQWtCLEVBQVE7UUFDM0MsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3BCO0lBRU9DLGFBQWFDLFFBQWdCLEVBQVc7UUFDN0MsT0FBTyxJQUFJLENBQUNDLFVBQVUsQ0FBQ0MsR0FBRyxDQUFDRjtJQUM3QjtJQUVPRyxhQUFhSCxRQUFnQixFQUFRO1FBQzFDLElBQUksQ0FBQ0MsVUFBVSxDQUFDRyxHQUFHLENBQUNKO0lBQ3RCO0lBRU9LLGFBQWFMLFFBQWdCLEVBQVc7UUFDN0Msa0JBQWtCO1FBQ2xCLElBQUlBLGFBQWEsSUFBSSxDQUFDTSxLQUFLLEVBQUUsT0FBTztRQUVwQyw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUNiLFFBQVEsRUFBRSxPQUFPO1FBRTFCLDJDQUEyQztRQUMzQyxPQUFPLENBQUMsSUFBSSxDQUFDTSxZQUFZLENBQUNDO0lBQzVCO0lBRU9PLFlBQXFCO1FBQzFCLE9BQU8sSUFBSSxDQUFDQyxRQUFRLElBQUksSUFBSSxDQUFDQyxXQUFXO0lBQzFDO0lBRU9DLFlBQXFCO1FBQzFCLE9BQU8s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Q0FBQ0MsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNoQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDUSxVQUFVLEdBQUcsSUFBSTRCO1FBQ3RCLElBQUksQ0FBQ2pDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNMLE9BQU8sR0FBRyxHQUFHLGtDQUFrQztRQUNwRCxJQUFJLENBQUNvQixPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNiLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNRLEtBQUssR0FBR0E7SUFDZjtBQXlHRjtBQTdJYXhCLFdBQ1lpRCxnQkFBZ0IsYUFBYywyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1Byb2plY3RpbGUudHM/NzA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcm9qZWN0aWxlIGNvbXBvbmVudCBmb3IgYnVsbGV0cywgc3BlbGxzLCBhbmQgb3RoZXIgcHJvamVjdGlsZXNcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vRW50aXR5JztcblxuZXhwb3J0IGNsYXNzIFByb2plY3RpbGUgZXh0ZW5kcyBDb21wb25lbnQge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IGNvbXBvbmVudFR5cGUgPSAnUHJvamVjdGlsZSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdQcm9qZWN0aWxlJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgdmVsb2NpdHk6IFZlY3RvcjM7XG4gIHB1YmxpYyBzcGVlZDogbnVtYmVyO1xuICBwdWJsaWMgZGFtYWdlOiBudW1iZXI7XG4gIHB1YmxpYyBsaWZldGltZTogbnVtYmVyO1xuICBwdWJsaWMgbWF4TGlmZXRpbWU6IG51bWJlcjtcbiAgcHVibGljIHBpZXJjaW5nOiBib29sZWFuO1xuICBwdWJsaWMgaGl0VGFyZ2V0czogU2V0PG51bWJlcj47IC8vIEVudGl0eSBJRHMgdGhhdCBoYXZlIGJlZW4gaGl0XG4gIHB1YmxpYyBleHBsb3Npb25SYWRpdXM6IG51bWJlcjtcbiAgcHVibGljIGdyYXZpdHk6IG51bWJlcjtcbiAgcHVibGljIGJvdW5jZXM6IG51bWJlcjtcbiAgcHVibGljIG1heEJvdW5jZXM6IG51bWJlcjtcbiAgcHVibGljIG93bmVyOiBudW1iZXI7IC8vIEVudGl0eSBJRCBvZiB0aGUgb3duZXJcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzcGVlZDogbnVtYmVyID0gMjAsXG4gICAgZGFtYWdlOiBudW1iZXIgPSAxMCxcbiAgICBtYXhMaWZldGltZTogbnVtYmVyID0gNSxcbiAgICBvd25lcjogbnVtYmVyID0gLTFcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgIHRoaXMuZGFtYWdlID0gZGFtYWdlO1xuICAgIHRoaXMubGlmZXRpbWUgPSAwO1xuICAgIHRoaXMubWF4TGlmZXRpbWUgPSBtYXhMaWZldGltZTtcbiAgICB0aGlzLnBpZXJjaW5nID0gZmFsc2U7XG4gICAgdGhpcy5oaXRUYXJnZXRzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gMDtcbiAgICB0aGlzLmdyYXZpdHkgPSAwOyAvLyBNb3N0IHByb2plY3RpbGVzIGlnbm9yZSBncmF2aXR5XG4gICAgdGhpcy5ib3VuY2VzID0gMDtcbiAgICB0aGlzLm1heEJvdW5jZXMgPSAwO1xuICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgfVxuXG4gIHB1YmxpYyBzZXREaXJlY3Rpb24oZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWxvY2l0eS5jb3B5KGRpcmVjdGlvbikubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zcGVlZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkR3Jhdml0eShncmF2aXR5OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdyYXZpdHkgPSBncmF2aXR5O1xuICB9XG5cbiAgcHVibGljIHNldFBpZXJjaW5nKHBpZXJjaW5nOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5waWVyY2luZyA9IHBpZXJjaW5nO1xuICB9XG5cbiAgcHVibGljIHNldEV4cGxvc2l2ZShyYWRpdXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZXhwbG9zaW9uUmFkaXVzID0gcmFkaXVzO1xuICB9XG5cbiAgcHVibGljIHNldEJvdW5jaW5nKG1heEJvdW5jZXM6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IG1heEJvdW5jZXM7XG4gIH1cblxuICBwdWJsaWMgaGFzSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5oaXRUYXJnZXRzLmhhcyhlbnRpdHlJZCk7XG4gIH1cblxuICBwdWJsaWMgYWRkSGl0VGFyZ2V0KGVudGl0eUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhpdFRhcmdldHMuYWRkKGVudGl0eUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBjYW5IaXRUYXJnZXQoZW50aXR5SWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIC8vIENhbid0IGhpdCBvd25lclxuICAgIGlmIChlbnRpdHlJZCA9PT0gdGhpcy5vd25lcikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIElmIHBpZXJjaW5nLCBjYW4gaGl0IHRhcmdldHMgbXVsdGlwbGUgdGltZXNcbiAgICBpZiAodGhpcy5waWVyY2luZykgcmV0dXJuIHRydWU7XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlLCBjYW4gb25seSBoaXQgZWFjaCB0YXJnZXQgb25jZVxuICAgIHJldHVybiAhdGhpcy5oYXNIaXRUYXJnZXQoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGlzRXhwaXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5saWZldGltZSA+PSB0aGlzLm1heExpZmV0aW1lO1xuICB9XG5cbiAgcHVibGljIGNhbkJvdW5jZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuY2VzIDwgdGhpcy5tYXhCb3VuY2VzO1xuICB9XG5cbiAgcHVibGljIGJvdW5jZShub3JtYWw6IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2FuQm91bmNlKCkpIHJldHVybjtcbiAgICBcbiAgICAvLyBSZWZsZWN0IHZlbG9jaXR5IG9mZiB0aGUgc3VyZmFjZSBub3JtYWxcbiAgICBjb25zdCByZWZsZWN0aW9uID0gdGhpcy52ZWxvY2l0eS5jbG9uZSgpLnJlZmxlY3Qobm9ybWFsKTtcbiAgICB0aGlzLnZlbG9jaXR5LmNvcHkocmVmbGVjdGlvbik7XG4gICAgdGhpcy5ib3VuY2VzKys7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5saWZldGltZSArPSBkZWx0YVRpbWU7XG4gICAgXG4gICAgLy8gQXBwbHkgZ3Jhdml0eSBpZiBlbmFibGVkXG4gICAgaWYgKHRoaXMuZ3Jhdml0eSAhPT0gMCkge1xuICAgICAgdGhpcy52ZWxvY2l0eS55ICs9IHRoaXMuZ3Jhdml0eSAqIGRlbHRhVGltZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0UG9zaXRpb24odHJhbnNmb3JtOiBWZWN0b3IzKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybS5jbG9uZSgpO1xuICB9XG5cbiAgcHVibGljIGdldFByZWRpY3RlZFBvc2l0aW9uKHRyYW5zZm9ybTogVmVjdG9yMywgZGVsdGFUaW1lOiBudW1iZXIpOiBWZWN0b3IzIHtcbiAgICBjb25zdCBwcmVkaWN0ZWQgPSB0cmFuc2Zvcm0uY2xvbmUoKTtcbiAgICBwcmVkaWN0ZWQuYWRkKHRoaXMudmVsb2NpdHkuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpKTtcbiAgICByZXR1cm4gcHJlZGljdGVkO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuc3BlZWQgPSAyMDtcbiAgICB0aGlzLmRhbWFnZSA9IDEwO1xuICAgIHRoaXMubGlmZXRpbWUgPSAwO1xuICAgIHRoaXMubWF4TGlmZXRpbWUgPSA1O1xuICAgIHRoaXMucGllcmNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmhpdFRhcmdldHMuY2xlYXIoKTtcbiAgICB0aGlzLmV4cGxvc2lvblJhZGl1cyA9IDA7XG4gICAgdGhpcy5ncmF2aXR5ID0gMDtcbiAgICB0aGlzLmJvdW5jZXMgPSAwO1xuICAgIHRoaXMubWF4Qm91bmNlcyA9IDA7XG4gICAgdGhpcy5vd25lciA9IC0xO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogUHJvamVjdGlsZSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUHJvamVjdGlsZSh0aGlzLnNwZWVkLCB0aGlzLmRhbWFnZSwgdGhpcy5tYXhMaWZldGltZSwgdGhpcy5vd25lcik7XG4gICAgY2xvbmUudmVsb2NpdHkuY29weSh0aGlzLnZlbG9jaXR5KTtcbiAgICBjbG9uZS5saWZldGltZSA9IHRoaXMubGlmZXRpbWU7XG4gICAgY2xvbmUucGllcmNpbmcgPSB0aGlzLnBpZXJjaW5nO1xuICAgIGNsb25lLmhpdFRhcmdldHMgPSBuZXcgU2V0KHRoaXMuaGl0VGFyZ2V0cyk7XG4gICAgY2xvbmUuZXhwbG9zaW9uUmFkaXVzID0gdGhpcy5leHBsb3Npb25SYWRpdXM7XG4gICAgY2xvbmUuZ3Jhdml0eSA9IHRoaXMuZ3Jhdml0eTtcbiAgICBjbG9uZS5ib3VuY2VzID0gdGhpcy5ib3VuY2VzO1xuICAgIGNsb25lLm1heEJvdW5jZXMgPSB0aGlzLm1heEJvdW5jZXM7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbXBvbmVudCIsIlByb2plY3RpbGUiLCJzZXREaXJlY3Rpb24iLCJkaXJlY3Rpb24iLCJ2ZWxvY2l0eSIsImNvcHkiLCJub3JtYWxpemUiLCJtdWx0aXBseVNjYWxhciIsInNwZWVkIiwiYWRkR3Jhdml0eSIsImdyYXZpdHkiLCJzZXRQaWVyY2luZyIsInBpZXJjaW5nIiwic2V0RXhwbG9zaXZlIiwicmFkaXVzIiwiZXhwbG9zaW9uUmFkaXVzIiwic2V0Qm91bmNpbmciLCJtYXhCb3VuY2VzIiwiaGFzSGl0VGFyZ2V0IiwiZW50aXR5SWQiLCJoaXRUYXJnZXRzIiwiaGFzIiwiYWRkSGl0VGFyZ2V0IiwiYWRkIiwiY2FuSGl0VGFyZ2V0Iiwib3duZXIiLCJpc0V4cGlyZWQiLCJsaWZldGltZSIsIm1heExpZmV0aW1lIiwiY2FuQm91bmNlIiwiYm91bmNlcyIsImJvdW5jZSIsIm5vcm1hbCIsInJlZmxlY3Rpb24iLCJjbG9uZSIsInJlZmxlY3QiLCJ1cGRhdGUiLCJkZWx0YVRpbWUiLCJ5IiwiZ2V0UG9zaXRpb24iLCJ0cmFuc2Zvcm0iLCJnZXRQcmVkaWN0ZWRQb3NpdGlvbiIsInByZWRpY3RlZCIsInJlc2V0Iiwic2V0IiwiZGFtYWdlIiwiY2xlYXIiLCJlbmFibGVkIiwiU2V0IiwiY29uc3RydWN0b3IiLCJjb21wb25lbnRUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Projectile.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Renderer.ts":
/*!****************************************!*\
  !*** ./src/ecs/components/Renderer.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Renderer: function() { return /* binding */ Renderer; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Renderer component for 3D rendering data\n\n\nclass Renderer extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setGeometry(geometry) {\n        if (this.geometry && this.geometry !== geometry) {\n            this.geometry.dispose();\n        }\n        this.geometry = geometry;\n        this.needsUpdate = true;\n    }\n    setMaterial(material) {\n        if (this.material && this.material !== material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n        }\n        this.material = material;\n        this.needsUpdate = true;\n    }\n    createMesh() {\n        if (!this.geometry || !this.material) {\n            return null;\n        }\n        if (this.mesh) {\n            this.disposeMesh();\n        }\n        this.mesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(this.geometry, this.material);\n        this.mesh.castShadow = this.castShadow;\n        this.mesh.receiveShadow = this.receiveShadow;\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        this.needsUpdate = false;\n        return this.mesh;\n    }\n    updateMesh() {\n        if (!this.mesh) return;\n        // Handle shadow properties for both Mesh and Group\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = this.castShadow;\n            this.mesh.receiveShadow = this.receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            // Apply shadow properties to all meshes in the group\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = this.castShadow;\n                    child.receiveShadow = this.receiveShadow;\n                }\n            });\n        }\n        this.mesh.frustumCulled = this.frustumCulled;\n        this.mesh.visible = this.visible;\n        this.mesh.renderOrder = this.renderOrder;\n        if (this.needsUpdate && this.geometry && this.material && this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.geometry = this.geometry;\n            this.mesh.material = this.material;\n            this.needsUpdate = false;\n        }\n    }\n    setVisible(visible) {\n        this.visible = visible;\n        if (this.mesh) {\n            this.mesh.visible = visible;\n        }\n    }\n    setCastShadow(castShadow) {\n        this.castShadow = castShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.castShadow = castShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.castShadow = castShadow;\n                }\n            });\n        }\n    }\n    setReceiveShadow(receiveShadow) {\n        this.receiveShadow = receiveShadow;\n        if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            this.mesh.receiveShadow = receiveShadow;\n        } else if (this.mesh instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group) {\n            this.mesh.traverse((child)=>{\n                if (child instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n                    child.receiveShadow = receiveShadow;\n                }\n            });\n        }\n    }\n    // Animation methods\n    setupAnimations(animations) {\n        if (!this.mesh) return;\n        this.animations = animations;\n        if (animations.length > 0) {\n            this.animationMixer = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(this.mesh);\n        }\n    }\n    playAnimation(name) {\n        let loop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, fadeTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.2;\n        if (!this.animationMixer) return null;\n        const clip = this.animations.find((clip)=>clip.name === name);\n        if (!clip) return null;\n        // Stop current animation\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n        }\n        // Start new animation\n        const action = this.animationMixer.clipAction(clip);\n        action.setLoop(loop ? _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat : _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.LoopOnce, loop ? Infinity : 1);\n        action.fadeIn(fadeTime);\n        action.play();\n        this.currentAnimation = action;\n        return action;\n    }\n    stopAnimation() {\n        let fadeTime = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0.2;\n        if (this.currentAnimation) {\n            this.currentAnimation.fadeOut(fadeTime);\n            this.currentAnimation = null;\n        }\n    }\n    updateAnimations(deltaTime) {\n        if (this.animationMixer) {\n            this.animationMixer.update(deltaTime);\n        }\n    }\n    // Instancing methods\n    setupInstancing(instancedMesh, instanceId) {\n        this.isInstanced = true;\n        this.instancedMesh = instancedMesh;\n        this.instanceId = instanceId;\n    }\n    updateInstanceMatrix(matrix) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    setInstanceVisible(visible) {\n        if (this.isInstanced && this.instancedMesh && this.instanceId >= 0) {\n            // For instanced meshes, we can hide instances by scaling them to 0\n            const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            this.instancedMesh.getMatrixAt(this.instanceId, matrix);\n            if (!visible) {\n                matrix.scale(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\n            }\n            this.instancedMesh.setMatrixAt(this.instanceId, matrix);\n            this.instancedMesh.instanceMatrix.needsUpdate = true;\n        }\n    }\n    disposeMesh() {\n        if (this.mesh) {\n            if (this.mesh.parent) {\n                this.mesh.parent.remove(this.mesh);\n            }\n            this.mesh = null;\n        }\n    }\n    dispose() {\n        this.disposeMesh();\n        if (this.geometry) {\n            this.geometry.dispose();\n            this.geometry = null;\n        }\n        if (this.material) {\n            if (Array.isArray(this.material)) {\n                this.material.forEach((mat)=>mat.dispose());\n            } else {\n                this.material.dispose();\n            }\n            this.material = null;\n        }\n        if (this.animationMixer) {\n            this.animationMixer.stopAllAction();\n            this.animationMixer = null;\n        }\n        this.animations = [];\n        this.currentAnimation = null;\n        this.instancedMesh = null;\n    }\n    reset() {\n        this.dispose();\n        this.castShadow = true;\n        this.receiveShadow = true;\n        this.frustumCulled = true;\n        this.visible = true;\n        this.renderOrder = 0;\n        this.needsUpdate = true;\n        this.isInstanced = false;\n        this.instanceId = -1;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Renderer({\n            castShadow: this.castShadow,\n            receiveShadow: this.receiveShadow,\n            frustumCulled: this.frustumCulled,\n            visible: this.visible,\n            renderOrder: this.renderOrder\n        });\n        // Note: We don't clone the actual geometry/material/mesh as they should be shared\n        // The cloned component will need to have its geometry and material set separately\n        return clone;\n    }\n    constructor(options = {}){\n        super();\n        this.componentType = \"Renderer\" // Instance identifier\n        ;\n        this.mesh = null;\n        this.geometry = null;\n        this.material = null;\n        // Animation properties\n        this.animationMixer = null;\n        this.animations = [];\n        this.currentAnimation = null;\n        // Instancing support\n        this.isInstanced = false;\n        this.instancedMesh = null;\n        this.instanceId = -1;\n        var _options_castShadow;\n        this.castShadow = (_options_castShadow = options.castShadow) !== null && _options_castShadow !== void 0 ? _options_castShadow : true;\n        var _options_receiveShadow;\n        this.receiveShadow = (_options_receiveShadow = options.receiveShadow) !== null && _options_receiveShadow !== void 0 ? _options_receiveShadow : true;\n        var _options_frustumCulled;\n        this.frustumCulled = (_options_frustumCulled = options.frustumCulled) !== null && _options_frustumCulled !== void 0 ? _options_frustumCulled : true;\n        var _options_visible;\n        this.visible = (_options_visible = options.visible) !== null && _options_visible !== void 0 ? _options_visible : true;\n        var _options_renderOrder;\n        this.renderOrder = (_options_renderOrder = options.renderOrder) !== null && _options_renderOrder !== void 0 ? _options_renderOrder : 0;\n        this.needsUpdate = true;\n    }\n}\nRenderer.componentType = \"Renderer\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwyQ0FBMkM7QUFDMEk7QUFDL0k7QUFVL0IsTUFBTVEsaUJBQWlCRCw4Q0FBU0E7SUFrQzlCRSxZQUFZQyxRQUF3QixFQUFRO1FBQ2pELElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEtBQUtBLFVBQVU7WUFDL0MsSUFBSSxDQUFDQSxRQUFRLENBQUNDLE9BQU87UUFDdkI7UUFDQSxJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRSxXQUFXLEdBQUc7SUFDckI7SUFFT0MsWUFBWUMsUUFBK0IsRUFBUTtRQUN4RCxJQUFJLElBQUksQ0FBQ0EsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLQSxVQUFVO1lBQy9DLElBQUlDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNGLFFBQVEsR0FBRztnQkFDaEMsSUFBSSxDQUFDQSxRQUFRLENBQUNHLE9BQU8sQ0FBQ0MsQ0FBQUEsTUFBT0EsSUFBSVAsT0FBTztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0csUUFBUSxDQUFDSCxPQUFPO1lBQ3ZCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixXQUFXLEdBQUc7SUFDckI7SUFFT08sYUFBMEI7UUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQ1QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDcEMsT0FBTztRQUNUO1FBRUEsSUFBSSxJQUFJLENBQUNNLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ0MsV0FBVztRQUNsQjtRQUVBLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUlwQixzREFBSUEsQ0FBQyxJQUFJLENBQUNVLFFBQVEsRUFBRSxJQUFJLENBQUNJLFFBQVE7UUFDakQsSUFBSSxDQUFDTSxJQUFJLENBQUNFLFVBQVUs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LENBQUFBLHlCQUFBQSxRQUFRakQsYUFBYSxjQUFyQmlELG9DQUFBQSx5QkFBeUI7WUFDL0JBO1FBQWYsSUFBSSxDQUFDaEQsT0FBTyxHQUFHZ0QsQ0FBQUEsbUJBQUFBLFFBQVFoRCxPQUFPLGNBQWZnRCw4QkFBQUEsbUJBQW1CO1lBQ2ZBO1FBQW5CLElBQUksQ0FBQy9DLFdBQVcsR0FBRytDLENBQUFBLHVCQUFBQSxRQUFRL0MsV0FBVyxjQUFuQitDLGtDQUFBQSx1QkFBdUI7UUFDMUMsSUFBSSxDQUFDN0QsV0FBVyxHQUFHO0lBQ3JCO0FBK09GO0FBL1FhSixTQUNZa0UsZ0JBQWdCLFdBQVksMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9SZW5kZXJlci50cz9lMjc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlcmVyIGNvbXBvbmVudCBmb3IgM0QgcmVuZGVyaW5nIGRhdGFcbmltcG9ydCB7IE1lc2gsIEdyb3VwLCBCdWZmZXJHZW9tZXRyeSwgTWF0ZXJpYWwsIEFuaW1hdGlvbk1peGVyLCBBbmltYXRpb25DbGlwLCBBbmltYXRpb25BY3Rpb24sIEluc3RhbmNlZE1lc2gsIExvb3BSZXBlYXQsIExvb3BPbmNlLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVuZGVyT3B0aW9ucyB7XG4gIGNhc3RTaGFkb3c/OiBib29sZWFuO1xuICByZWNlaXZlU2hhZG93PzogYm9vbGVhbjtcbiAgZnJ1c3R1bUN1bGxlZD86IGJvb2xlYW47XG4gIHZpc2libGU/OiBib29sZWFuO1xuICByZW5kZXJPcmRlcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gRXhwbGljaXQgdHlwZSBpZGVudGlmaWVyXG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1JlbmRlcmVyJzsgLy8gSW5zdGFuY2UgaWRlbnRpZmllclxuICBwdWJsaWMgbWVzaDogTWVzaCB8IEdyb3VwIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBnZW9tZXRyeTogQnVmZmVyR2VvbWV0cnkgfCBudWxsID0gbnVsbDtcbiAgcHVibGljIG1hdGVyaWFsOiBNYXRlcmlhbCB8IE1hdGVyaWFsW10gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNhc3RTaGFkb3c6IGJvb2xlYW47XG4gIHB1YmxpYyByZWNlaXZlU2hhZG93OiBib29sZWFuO1xuICBwdWJsaWMgZnJ1c3R1bUN1bGxlZDogYm9vbGVhbjtcbiAgcHVibGljIHZpc2libGU6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJPcmRlcjogbnVtYmVyO1xuICBwdWJsaWMgbmVlZHNVcGRhdGU6IGJvb2xlYW47XG5cbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgcHVibGljIGFuaW1hdGlvbk1peGVyOiBBbmltYXRpb25NaXhlciB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgYW5pbWF0aW9uczogQW5pbWF0aW9uQ2xpcFtdID0gW107XG4gIHB1YmxpYyBjdXJyZW50QW5pbWF0aW9uOiBBbmltYXRpb25BY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvLyBJbnN0YW5jaW5nIHN1cHBvcnRcbiAgcHVibGljIGlzSW5zdGFuY2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoIHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBpbnN0YW5jZUlkOiBudW1iZXIgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBSZW5kZXJPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuY2FzdFNoYWRvdyA9IG9wdGlvbnMuY2FzdFNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IG9wdGlvbnMucmVjZWl2ZVNoYWRvdyA/PyB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IG9wdGlvbnMuZnJ1c3R1bUN1bGxlZCA/PyB0cnVlO1xuICAgIHRoaXMudmlzaWJsZSA9IG9wdGlvbnMudmlzaWJsZSA/PyB0cnVlO1xuICAgIHRoaXMucmVuZGVyT3JkZXIgPSBvcHRpb25zLnJlbmRlck9yZGVyID8/IDA7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0R2VvbWV0cnkoZ2VvbWV0cnk6IEJ1ZmZlckdlb21ldHJ5KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeSAhPT0gZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgc2V0TWF0ZXJpYWwobWF0ZXJpYWw6IE1hdGVyaWFsIHwgTWF0ZXJpYWxbXSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdGVyaWFsICYmIHRoaXMubWF0ZXJpYWwgIT09IG1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNZXNoKCk6IE1lc2ggfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMubWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm1lc2ggPSBuZXcgTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLm1lc2guY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgICB0aGlzLm1lc2gucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICB0aGlzLm1lc2guZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcbiAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICB0aGlzLm1lc2gucmVuZGVyT3JkZXIgPSB0aGlzLnJlbmRlck9yZGVyO1xuXG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLm1lc2g7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlTWVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIHNoYWRvdyBwcm9wZXJ0aWVzIGZvciBib3RoIE1lc2ggYW5kIEdyb3VwXG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgICAgdGhpcy5tZXNoLnJlY2VpdmVTaGFkb3cgPSB0aGlzLnJlY2VpdmVTaGFkb3c7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lc2ggaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgLy8gQXBwbHkgc2hhZG93IHByb3BlcnRpZXMgdG8gYWxsIG1lc2hlcyBpbiB0aGUgZ3JvdXBcbiAgICAgIHRoaXMubWVzaC50cmF2ZXJzZSgoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNoLmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgdGhpcy5tZXNoLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdGhpcy5tZXNoLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIGlmICh0aGlzLm5lZWRzVXBkYXRlICYmIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5tYXRlcmlhbCAmJiB0aGlzLm1lc2ggaW5zdGFuY2VvZiBNZXNoKSB7XG4gICAgICB0aGlzLm1lc2guZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICBpZiAodGhpcy5tZXNoKSB7XG4gICAgICB0aGlzLm1lc2gudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldENhc3RTaGFkb3coY2FzdFNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuY2FzdFNoYWRvdyA9IGNhc3RTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gY2FzdFNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFJlY2VpdmVTaGFkb3cocmVjZWl2ZVNoYWRvdzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHJlY2VpdmVTaGFkb3c7XG4gICAgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHRoaXMubWVzaC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMubWVzaCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICB0aGlzLm1lc2gudHJhdmVyc2UoKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gcmVjZWl2ZVNoYWRvdztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQW5pbWF0aW9uIG1ldGhvZHNcbiAgcHVibGljIHNldHVwQW5pbWF0aW9ucyhhbmltYXRpb25zOiBBbmltYXRpb25DbGlwW10pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubWVzaCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbmV3IEFuaW1hdGlvbk1peGVyKHRoaXMubWVzaCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHBsYXlBbmltYXRpb24obmFtZTogc3RyaW5nLCBsb29wOiBib29sZWFuID0gdHJ1ZSwgZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IEFuaW1hdGlvbkFjdGlvbiB8IG51bGwge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25NaXhlcikgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBjbGlwID0gdGhpcy5hbmltYXRpb25zLmZpbmQoY2xpcCA9PiBjbGlwLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghY2xpcCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLmZhZGVPdXQoZmFkZVRpbWUpO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IG5ldyBhbmltYXRpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFuaW1hdGlvbk1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG4gICAgYWN0aW9uLnNldExvb3AobG9vcCA/IExvb3BSZXBlYXQgOiBMb29wT25jZSwgbG9vcCA/IEluZmluaXR5IDogMSk7XG4gICAgYWN0aW9uLmZhZGVJbihmYWRlVGltZSk7XG4gICAgYWN0aW9uLnBsYXkoKTtcblxuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFjdGlvbjtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgcHVibGljIHN0b3BBbmltYXRpb24oZmFkZVRpbWU6IG51bWJlciA9IDAuMik6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5mYWRlT3V0KGZhZGVUaW1lKTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHVwZGF0ZUFuaW1hdGlvbnMoZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnN0YW5jaW5nIG1ldGhvZHNcbiAgcHVibGljIHNldHVwSW5zdGFuY2luZyhpbnN0YW5jZWRNZXNoOiBJbnN0YW5jZWRNZXNoLCBpbnN0YW5jZUlkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLmluc3RhbmNlZE1lc2ggPSBpbnN0YW5jZWRNZXNoO1xuICAgIHRoaXMuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWQ7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlSW5zdGFuY2VNYXRyaXgobWF0cml4OiBNYXRyaXg0KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdGhpcy5pbnN0YW5jZWRNZXNoICYmIHRoaXMuaW5zdGFuY2VJZCA+PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guc2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0SW5zdGFuY2VWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCAmJiB0aGlzLmluc3RhbmNlZE1lc2ggJiYgdGhpcy5pbnN0YW5jZUlkID49IDApIHtcbiAgICAgIC8vIEZvciBpbnN0YW5jZWQgbWVzaGVzLCB3ZSBjYW4gaGlkZSBpbnN0YW5jZXMgYnkgc2NhbGluZyB0aGVtIHRvIDBcbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICB0aGlzLmluc3RhbmNlZE1lc2guZ2V0TWF0cml4QXQodGhpcy5pbnN0YW5jZUlkLCBtYXRyaXgpO1xuICAgICAgXG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgbWF0cml4LnNjYWxlKG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5pbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KHRoaXMuaW5zdGFuY2VJZCwgbWF0cml4KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VkTWVzaC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2VNZXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1lc2gpIHtcbiAgICAgIGlmICh0aGlzLm1lc2gucGFyZW50KSB7XG4gICAgICAgIHRoaXMubWVzaC5wYXJlbnQucmVtb3ZlKHRoaXMubWVzaCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZU1lc2goKTtcblxuICAgIGlmICh0aGlzLmdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hdGVyaWFsKSkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmZvckVhY2gobWF0ID0+IG1hdC5kaXNwb3NlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25NaXhlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25NaXhlci5zdG9wQWxsQWN0aW9uKCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbk1peGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2VkTWVzaCA9IG51bGw7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgdGhpcy5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICB0aGlzLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlck9yZGVyID0gMDtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZUlkID0gLTE7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBjbG9uZSgpOiBSZW5kZXJlciB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgY2FzdFNoYWRvdzogdGhpcy5jYXN0U2hhZG93LFxuICAgICAgcmVjZWl2ZVNoYWRvdzogdGhpcy5yZWNlaXZlU2hhZG93LFxuICAgICAgZnJ1c3R1bUN1bGxlZDogdGhpcy5mcnVzdHVtQ3VsbGVkLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgcmVuZGVyT3JkZXI6IHRoaXMucmVuZGVyT3JkZXIsXG4gICAgfSk7XG5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9uZSB0aGUgYWN0dWFsIGdlb21ldHJ5L21hdGVyaWFsL21lc2ggYXMgdGhleSBzaG91bGQgYmUgc2hhcmVkXG4gICAgLy8gVGhlIGNsb25lZCBjb21wb25lbnQgd2lsbCBuZWVkIHRvIGhhdmUgaXRzIGdlb21ldHJ5IGFuZCBtYXRlcmlhbCBzZXQgc2VwYXJhdGVseVxuICAgIFxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1lc2giLCJHcm91cCIsIkFuaW1hdGlvbk1peGVyIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJDb21wb25lbnQiLCJSZW5kZXJlciIsInNldEdlb21ldHJ5IiwiZ2VvbWV0cnkiLCJkaXNwb3NlIiwibmVlZHNVcGRhdGUiLCJzZXRNYXRlcmlhbCIsIm1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIm1hdCIsImNyZWF0ZU1lc2giLCJtZXNoIiwiZGlzcG9zZU1lc2giLCJjYXN0U2hhZG93IiwicmVjZWl2ZVNoYWRvdyIsImZydXN0dW1DdWxsZWQiLCJ2aXNpYmxlIiwicmVuZGVyT3JkZXIiLCJ1cGRhdGVNZXNoIiwidHJhdmVyc2UiLCJjaGlsZCIsInNldFZpc2libGUiLCJzZXRDYXN0U2hhZG93Iiwic2V0UmVjZWl2ZVNoYWRvdyIsInNldHVwQW5pbWF0aW9ucyIsImFuaW1hdGlvbnMiLCJsZW5ndGgiLCJhbmltYXRpb25NaXhlciIsInBsYXlBbmltYXRpb24iLCJuYW1lIiwibG9vcCIsImZhZGVUaW1lIiwiY2xpcCIsImZpbmQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmFkZU91dCIsImFjdGlvbiIsImNsaXBBY3Rpb24iLCJzZXRMb29wIiwiSW5maW5pdHkiLCJmYWRlSW4iLCJwbGF5Iiwic3RvcEFuaW1hdGlvbiIsInVwZGF0ZUFuaW1hdGlvbnMiLCJkZWx0YVRpbWUiLCJ1cGRhdGUiLCJzZXR1cEluc3RhbmNpbmciLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VJZCIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJzZXRNYXRyaXhBdCIsImluc3RhbmNlTWF0cml4Iiwic2V0SW5zdGFuY2VWaXNpYmxlIiwiZ2V0TWF0cml4QXQiLCJzY2FsZSIsInBhcmVudCIsInJlbW92ZSIsInN0b3BBbGxBY3Rpb24iLCJyZXNldCIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Renderer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Shield.ts":
/*!**************************************!*\
  !*** ./src/ecs/components/Shield.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Shield: function() { return /* binding */ Shield; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n\nclass Shield extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /**\n   * Absorb damage with the shield. Returns the amount of damage that passed through.\n   */ absorbDamage(damage) {\n        if (this.currentShield <= 0) {\n            return damage; // No shield left, all damage passes through\n        }\n        const damageAbsorbed = Math.min(damage, this.currentShield);\n        this.currentShield -= damageAbsorbed;\n        this.lastDamageTime = Date.now();\n        this.isRegenerating = false;\n        // Return the damage that wasn't absorbed\n        return damage - damageAbsorbed;\n    }\n    /**\n   * Update shield regeneration based on delta time\n   */ update(deltaTime) {\n        if (this.currentShield >= this.maxShield) {\n            this.isRegenerating = false;\n            return;\n        }\n        const timeSinceLastDamage = (Date.now() - this.lastDamageTime) / 1000;\n        if (timeSinceLastDamage >= this.regenDelay) {\n            if (!this.isRegenerating) {\n                this.isRegenerating = true;\n            }\n            const regenAmount = this.regenRate * deltaTime;\n            this.currentShield = Math.min(this.maxShield, this.currentShield + regenAmount);\n        }\n    }\n    /**\n   * Get shield percentage (0-1)\n   */ getShieldPercentage() {\n        return this.maxShield > 0 ? this.currentShield / this.maxShield : 0;\n    }\n    /**\n   * Check if shield is at full capacity\n   */ isFullShield() {\n        return this.currentShield >= this.maxShield;\n    }\n    /**\n   * Check if shield is completely depleted\n   */ isShieldDepleted() {\n        return this.currentShield <= 0;\n    }\n    /**\n   * Instantly restore shield to full (for testing or special abilities)\n   */ restoreShield() {\n        this.currentShield = this.maxShield;\n        this.isRegenerating = false;\n    }\n    /**\n   * Set shield values (useful for multiplayer sync)\n   */ setShield(current, max) {\n        this.currentShield = Math.max(0, Math.min(max, current));\n        this.maxShield = max;\n    }\n    /**\n   * Reset shield to initial state (required by Component interface)\n   */ reset() {\n        this.currentShield = this.maxShield;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n        this.enabled = true;\n    }\n    constructor(maxShield = 200, regenRate = 20, regenDelay = 5){\n        super();\n        this.componentType = \"Shield\" // Instance identifier\n        ;\n        this.maxShield = maxShield;\n        this.currentShield = maxShield;\n        this.regenRate = regenRate;\n        this.regenDelay = regenDelay;\n        this.lastDamageTime = 0;\n        this.isRegenerating = false;\n    }\n}\nShield.componentType = \"Shield\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFFL0IsTUFBTUMsZUFBZUQsOENBQVNBO0lBb0JuQzs7R0FFQyxHQUNELGFBQW9CRyxNQUFjLEVBQVU7UUFDMUMsSUFBSSxJQUFJLENBQUNDLGFBQWEsSUFBSSxHQUFHO1lBQzNCLE9BQU9ELFFBQVEsNENBQTRDO1FBQzdEO1FBRUEsTUFBTUUsaUJBQWlCQyxLQUFLQyxHQUFHLENBQUNKLFFBQVEsSUFBSSxDQUFDQyxhQUFhO1FBQzFELElBQUksQ0FBQ0EsYUFBYSxJQUFJQztRQUN0QixJQUFJLENBQUNHLGNBQWMsR0FBR0MsS0FBS0MsR0FBRztRQUM5QixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUV0Qix5Q0FBeUM7UUFDekMsT0FBT1IsU0FBU0U7SUFDbEI7SUFFQTs7R0FFQyxHQUNELE9BQWNRLFNBQWlCLEVBQVE7UUFDckMsSUFBSSxJQUFJLENBQUNULGFBQWEsSUFBSSxJQUFJLENBQUNVLFNBQVMsRUFBRTtZQUN4QyxJQUFJLENBQUNILGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTUksc0JBQXNCLENBQUNOLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNGLGNBQWMsSUFBSTtRQUVqRSxJQUFJTyx1QkFBdUIsSUFBSSxDQUFDQyxVQUFVLEVBQUU7WUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0wsY0FBYyxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGNBQWMsR0FBRztZQUN4QjtZQUVBLE1BQU1NLGNBQWMsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1lBQ3JDLElBQUksQ0FBQ1QsYUFBYSxHQUFHRSxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDTyxTQUFTLEVBQUUsSUFBSSxDQUFDVixhQUFhLEdBQUdhO1FBQ3JFO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELHNCQUFxQztRQUNuQyxPQUFPLElBQUksQ0FBQ0gsU0FBUyxHQUFHLElBQUksSUFBSSxDQUFDVixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTLEdBQUc7SUFDcEU7SUFFQTs7R0FFQyxHQUNELGVBQStCO1FBQzdCLE9BQU8sSUFBSSxDQUFDVixhQUFhLElBQUksSUFBSSxDQUFDVSxTQUFTO0lBQzdDO0lBRUE7O0dBRUMsR0FDRCxtQkFBbUM7UUFDakMsT0FBTyxJQUFJLENBQUNWLGFBQWEsSUFBSTtJQUMvQjtJQUVBOztHQUVDLEdBQ0QsZ0JBQTZCO1FBQzNCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ1UsU0FBUztRQUNuQyxJQUFJLENBQUNILGNBQWMsR0FBRztJQUN4QjtJQUVBOztHQUVDLEdBQ0QsVUFBaUJhLE9BQWUsRUFBRUMsR0FBVyxFQUFRO1FBQ25ELElBQUksQ0FBQ3JCLGFBQWEsR0FBR0UsS0FBS21CLEdBQUcsQ0FBQyxHQUFHbkIsS0FBS0MsR0FBRyxDQUFDa0IsS0FBS0Q7UUFDL0MsSUFBSSxDQUFDVixTQUFTLEdBQUdXO0lBQ25CO0lBRUE7O0dBRUMsR0FDRCxRQUFxQjtRQUNuQixJQUFJLENBQUNyQixhQUFhLEdBQUcsSUFBSSxDQUFDVSxTQUFTO1FBQ25DLElBQUksQ0FBQ04sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2dCLE9BQU8sR0FBRztJQUNqQjtJQTdGQUMsWUFBWWQsWUFBb0IsR0FBRyxFQUFFSSxZQUFvQixFQUFFLEVBQUVGLGFBQXFCLENBQUMsQ0FBRTtRQUNuRixLQUFLO2FBVFNhLGdCQUFnQixTQUFVLHNCQUFzQjs7UUFVOUQsSUFBSSxDQUFDZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHVTtRQUNyQixJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ1IsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0csY0FBYyxHQUFHO0lBQ3hCO0FBc0ZGO0FBeEdhVixPQUNZNEIsZ0JBQWdCLFNBQVUsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9TaGllbGQudHM/MmM0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgU2hpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1NoaWVsZCc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdTaGllbGQnOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBtYXhTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIGN1cnJlbnRTaGllbGQ6IG51bWJlcjtcbiAgcHVibGljIHJlZ2VuUmF0ZTogbnVtYmVyOyAvLyBTaGllbGQgcmVnZW5lcmF0ZWQgcGVyIHNlY29uZFxuICBwdWJsaWMgcmVnZW5EZWxheTogbnVtYmVyOyAvLyBTZWNvbmRzIGJlZm9yZSByZWdlbiBzdGFydHNcbiAgcHVibGljIGxhc3REYW1hZ2VUaW1lOiBudW1iZXI7IC8vIFRpbWVzdGFtcCBvZiBsYXN0IGRhbWFnZSB0YWtlblxuICBwdWJsaWMgaXNSZWdlbmVyYXRpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IobWF4U2hpZWxkOiBudW1iZXIgPSAyMDAsIHJlZ2VuUmF0ZTogbnVtYmVyID0gMjAsIHJlZ2VuRGVsYXk6IG51bWJlciA9IDUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4U2hpZWxkO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IG1heFNoaWVsZDtcbiAgICB0aGlzLnJlZ2VuUmF0ZSA9IHJlZ2VuUmF0ZTtcbiAgICB0aGlzLnJlZ2VuRGVsYXkgPSByZWdlbkRlbGF5O1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBYnNvcmIgZGFtYWdlIHdpdGggdGhlIHNoaWVsZC4gUmV0dXJucyB0aGUgYW1vdW50IG9mIGRhbWFnZSB0aGF0IHBhc3NlZCB0aHJvdWdoLlxuICAgKi9cbiAgcHVibGljIGFic29yYkRhbWFnZShkYW1hZ2U6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA8PSAwKSB7XG4gICAgICByZXR1cm4gZGFtYWdlOyAvLyBObyBzaGllbGQgbGVmdCwgYWxsIGRhbWFnZSBwYXNzZXMgdGhyb3VnaFxuICAgIH1cblxuICAgIGNvbnN0IGRhbWFnZUFic29yYmVkID0gTWF0aC5taW4oZGFtYWdlLCB0aGlzLmN1cnJlbnRTaGllbGQpO1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCAtPSBkYW1hZ2VBYnNvcmJlZDtcbiAgICB0aGlzLmxhc3REYW1hZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhbWFnZSB0aGF0IHdhc24ndCBhYnNvcmJlZFxuICAgIHJldHVybiBkYW1hZ2UgLSBkYW1hZ2VBYnNvcmJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2hpZWxkIHJlZ2VuZXJhdGlvbiBiYXNlZCBvbiBkZWx0YSB0aW1lXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFNoaWVsZCA+PSB0aGlzLm1heFNoaWVsZCkge1xuICAgICAgdGhpcy5pc1JlZ2VuZXJhdGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3REYW1hZ2UgPSAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdERhbWFnZVRpbWUpIC8gMTAwMDtcbiAgICBcbiAgICBpZiAodGltZVNpbmNlTGFzdERhbWFnZSA+PSB0aGlzLnJlZ2VuRGVsYXkpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlZ2VuZXJhdGluZykge1xuICAgICAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVnZW5BbW91bnQgPSB0aGlzLnJlZ2VuUmF0ZSAqIGRlbHRhVGltZTtcbiAgICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWluKHRoaXMubWF4U2hpZWxkLCB0aGlzLmN1cnJlbnRTaGllbGQgKyByZWdlbkFtb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzaGllbGQgcGVyY2VudGFnZSAoMC0xKVxuICAgKi9cbiAgcHVibGljIGdldFNoaWVsZFBlcmNlbnRhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhTaGllbGQgPiAwID8gdGhpcy5jdXJyZW50U2hpZWxkIC8gdGhpcy5tYXhTaGllbGQgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNoaWVsZCBpcyBhdCBmdWxsIGNhcGFjaXR5XG4gICAqL1xuICBwdWJsaWMgaXNGdWxsU2hpZWxkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPj0gdGhpcy5tYXhTaGllbGQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2hpZWxkIGlzIGNvbXBsZXRlbHkgZGVwbGV0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NoaWVsZERlcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaGllbGQgPD0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50bHkgcmVzdG9yZSBzaGllbGQgdG8gZnVsbCAoZm9yIHRlc3Rpbmcgb3Igc3BlY2lhbCBhYmlsaXRpZXMpXG4gICAqL1xuICBwdWJsaWMgcmVzdG9yZVNoaWVsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTaGllbGQgPSB0aGlzLm1heFNoaWVsZDtcbiAgICB0aGlzLmlzUmVnZW5lcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHNoaWVsZCB2YWx1ZXMgKHVzZWZ1bCBmb3IgbXVsdGlwbGF5ZXIgc3luYylcbiAgICovXG4gIHB1YmxpYyBzZXRTaGllbGQoY3VycmVudDogbnVtYmVyLCBtYXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heCwgY3VycmVudCkpO1xuICAgIHRoaXMubWF4U2hpZWxkID0gbWF4O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHNoaWVsZCB0byBpbml0aWFsIHN0YXRlIChyZXF1aXJlZCBieSBDb21wb25lbnQgaW50ZXJmYWNlKVxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNoaWVsZCA9IHRoaXMubWF4U2hpZWxkO1xuICAgIHRoaXMubGFzdERhbWFnZVRpbWUgPSAwO1xuICAgIHRoaXMuaXNSZWdlbmVyYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiU2hpZWxkIiwiYWJzb3JiRGFtYWdlIiwiZGFtYWdlIiwiY3VycmVudFNoaWVsZCIsImRhbWFnZUFic29yYmVkIiwiTWF0aCIsIm1pbiIsImxhc3REYW1hZ2VUaW1lIiwiRGF0ZSIsIm5vdyIsImlzUmVnZW5lcmF0aW5nIiwidXBkYXRlIiwiZGVsdGFUaW1lIiwibWF4U2hpZWxkIiwidGltZVNpbmNlTGFzdERhbWFnZSIsInJlZ2VuRGVsYXkiLCJyZWdlbkFtb3VudCIsInJlZ2VuUmF0ZSIsImdldFNoaWVsZFBlcmNlbnRhZ2UiLCJpc0Z1bGxTaGllbGQiLCJpc1NoaWVsZERlcGxldGVkIiwicmVzdG9yZVNoaWVsZCIsInNldFNoaWVsZCIsImN1cnJlbnQiLCJtYXgiLCJyZXNldCIsImVuYWJsZWQiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Shield.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Tower.ts":
/*!*************************************!*\
  !*** ./src/ecs/components/Tower.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tower: function() { return /* binding */ Tower; }\n/* harmony export */ });\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Tower component for PVP home base towers\n\nclass Tower extends _Entity__WEBPACK_IMPORTED_MODULE_0__.Component {\n    canAttack(currentTime) {\n        if (!this.isActive || this.isDead || !this.currentTarget) {\n            return false;\n        }\n        return currentTime - this.lastAttackTime >= this.attackCooldown;\n    }\n    performAttack(currentTime) {\n        this.lastAttackTime = currentTime;\n    }\n    canSearchForTargets(currentTime) {\n        return currentTime - this.lastTargetSearchTime >= this.targetSearchCooldown;\n    }\n    updateTargetSearch(currentTime) {\n        this.lastTargetSearchTime = currentTime;\n    }\n    setTarget(targetEntityId) {\n        this.currentTarget = targetEntityId;\n    }\n    clearTarget() {\n        this.currentTarget = null;\n    }\n    die(currentTime) {\n        this.isDead = true;\n        this.isActive = false;\n        this.deathTime = currentTime;\n        this.clearTarget();\n    }\n    getDisplayName() {\n        return \"Tower \".concat(this.towerIndex + 1, \" (Owner: \").concat(this.ownerId, \")\");\n    }\n    reset() {\n        this.ownerId = \"\";\n        this.towerIndex = 0;\n        this.attackRange = 8;\n        this.attackDamage = 10;\n        this.attackCooldown = 1.5;\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20;\n        this.currentTarget = null;\n        this.targetSearchRange = 9;\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5;\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Tower(this.ownerId, this.towerIndex);\n        clone.attackRange = this.attackRange;\n        clone.attackDamage = this.attackDamage;\n        clone.attackCooldown = this.attackCooldown;\n        clone.lastAttackTime = this.lastAttackTime;\n        clone.projectileSpeed = this.projectileSpeed;\n        clone.currentTarget = this.currentTarget;\n        clone.targetSearchRange = this.targetSearchRange;\n        clone.lastTargetSearchTime = this.lastTargetSearchTime;\n        clone.targetSearchCooldown = this.targetSearchCooldown;\n        clone.isActive = this.isActive;\n        clone.isDead = this.isDead;\n        clone.deathTime = this.deathTime;\n        return clone;\n    }\n    constructor(ownerId = \"\", towerIndex = 0){\n        super();\n        this.componentType = \"Tower\";\n        this.ownerId = ownerId;\n        this.towerIndex = towerIndex;\n        // Combat configuration\n        this.attackRange = 10; // 10 unit attack range as specified\n        this.attackDamage = 10; // 10 damage per arrow as specified\n        this.attackCooldown = 1.5; // 1.5 seconds between shots\n        this.lastAttackTime = 0;\n        this.projectileSpeed = 20; // Speed of tower arrows\n        // Targeting configuration\n        this.currentTarget = null;\n        this.targetSearchRange = this.attackRange + 1; // Search slightly beyond attack range\n        this.lastTargetSearchTime = 0;\n        this.targetSearchCooldown = 0.5; // Search for targets every 0.5 seconds\n        // State\n        this.isActive = true;\n        this.isDead = false;\n        this.deathTime = 0;\n    }\n}\nTower.componentType = \"Tower\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJDQUEyQztBQUNMO0FBRS9CLE1BQU1DLGNBQWNELDhDQUFTQTtJQXNEM0JFLFVBQVVDLFdBQW1CLEVBQVc7UUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQ0MsUUFBUSxJQUFJLElBQUksQ0FBQ0MsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDeEQsT0FBTztRQUNUO1FBQ0EsT0FBTyxjQUFlLElBQUksQ0FBQ0MsY0FBYyxJQUFLLElBQUksQ0FBQ0MsY0FBYztJQUNuRTtJQUVPQyxjQUFjTixXQUFtQixFQUFRO1FBQzlDLElBQUksQ0FBQ0ksY0FBYyxHQUFHSjtJQUN4QjtJQUVPTyxvQkFBb0JQLFdBQW1CLEVBQVc7UUFDdkQsT0FBTyxjQUFlLElBQUksQ0FBQ1Esb0JBQW9CLElBQUssSUFBSSxDQUFDQyxvQkFBb0I7SUFDL0U7SUFFT0MsbUJBQW1CVixXQUFtQixFQUFRO1FBQ25ELElBQUksQ0FBQ1Esb0JBQW9CLEdBQUdSO0lBQzlCO0lBRU9XLFVBQVVDLGNBQTZCLEVBQVE7UUFDcEQsSUFBSSxDQUFDVCxhQUFhLEdBQUdTO0lBQ3ZCO0lBRU9DLGNBQW9CO1FBQ3pCLElBQUksQ0FBQ1YsYUFBYSxHQUFHO0lBQ3ZCO0lBRU9XLElBQUlkLFdBQW1CLEVBQVE7UUFDcEMsSUFBSSxDQUFDRSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNELFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNjLFNBQVMsR0FBR2Y7UUFDakIsSUFBSSxDQUFDYSxXQUFXO0lBQ2xCO0lBRU9HLGlCQUF5QjtRQUM5QixPQUFPLFNBQXdDLE9BQS9CLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEdBQUUsYUFBd0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQztJQUM5RDtJQUVPQyxRQUFjO1FBQ25CLElBQUksQ0FBQ0QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDRyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaEIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ2tCLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNuQixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDb0IsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDZixvQkFBb0IsR0FBRztRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDUyxPQUFPLEdBQUc7SUFDakI7SUFFT0MsUUFBZTtRQUNwQixNQUFNQSxRQUFRLElBQUkzQixNQUFNLElBQUksQ0FBQ29CLE9BQU8sRUFBRSxJQUFJLENBQUNELFVBQVU7UUFDckRRLE1BQU1MLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVc7UUFDcENLLE1BQU1KLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVk7UUFDdENJLE1BQU1wQixjQUFjLEdBQUcsSUFBSSxDQUFDQSxjQUFjO1FBQzFDb0IsTUFBTXJCLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWM7UUFDMUNxQixNQUFNSCxlQUFlLEdBQUcsSUFBSSxDQUFDQSxlQUFlO1FBQzVDRyxNQUFNdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUN4Q3NCLE1BQU1GLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCO1FBQ2hERSxNQUFNakIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERpQixNQUFNaEIsb0JBQW9CLEdBQUcsSUFBSSxDQUFDQSxvQkFBb0I7UUFDdERnQixNQUFNeEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUM5QndCLE1BQU12QixNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1FBQzFCdUIsTUFBTVYsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUztRQUNoQyxPQUFPVTtJQUNUO0lBbkdBQyxZQUNFUixVQUFrQixFQUFFLEVBQ3BCRCxhQUFxQixDQUFDLENBQ3RCO1FBQ0EsS0FBSzthQTVCU1UsZ0JBQWdCO1FBOEI5QixJQUFJLENBQUNULE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNELFVBQVUsR0FBR0E7UUFFbEIsdUJBQXVCO1FBQ3ZCLElBQUksQ0FBQ0csV0FBVyxHQUFHLElBQUksb0NBQW9DO1FBQzNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUksbUNBQW1DO1FBQzNELElBQUksQ0FBQ2hCLGNBQWMsR0FBRyxLQUFLLDRCQUE0QjtRQUN2RCxJQUFJLENBQUNELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNrQixlQUFlLEdBQUcsSUFBSSx3QkFBd0I7UUFFbkQsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ25CLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNvQixpQkFBaUIsR0FBRyxJQUFJLENBQUNILFdBQVcsR0FBRyxHQUFHLHNDQUFzQztRQUNyRixJQUFJLENBQUNaLG9CQUFvQixHQUFHO1FBQzVCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSyx1Q0FBdUM7UUFFeEUsUUFBUTtRQUNSLElBQUksQ0FBQ1IsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDYSxTQUFTLEdBQUc7SUFDbkI7QUEwRUY7QUE5SGFqQixNQUNZNkIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9lY3MvY29tcG9uZW50cy9Ub3dlci50cz9iNmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvd2VyIGNvbXBvbmVudCBmb3IgUFZQIGhvbWUgYmFzZSB0b3dlcnNcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4uL0VudGl0eSc7XG5cbmV4cG9ydCBjbGFzcyBUb3dlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUb3dlcic7XG4gIHB1YmxpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1Rvd2VyJztcbiAgXG4gIC8vIFRvd2VyIG93bmVyc2hpcCBhbmQgaWRlbnRpZmljYXRpb25cbiAgcHVibGljIG93bmVySWQ6IHN0cmluZzsgLy8gUGxheWVyIElEIHdobyBvd25zIHRoaXMgdG93ZXJcbiAgcHVibGljIHRvd2VySW5kZXg6IG51bWJlcjsgLy8gVG93ZXIgaW5kZXggKDAgZm9yIGZpcnN0IHBsYXllciwgMSBmb3Igc2Vjb25kLCBldGMuKVxuICBcbiAgLy8gQ29tYmF0IHByb3BlcnRpZXNcbiAgcHVibGljIGF0dGFja1JhbmdlOiBudW1iZXI7XG4gIHB1YmxpYyBhdHRhY2tEYW1hZ2U6IG51bWJlcjtcbiAgcHVibGljIGF0dGFja0Nvb2xkb3duOiBudW1iZXI7IC8vIFNlY29uZHMgYmV0d2VlbiBhdHRhY2tzXG4gIHB1YmxpYyBsYXN0QXR0YWNrVGltZTogbnVtYmVyO1xuICBwdWJsaWMgcHJvamVjdGlsZVNwZWVkOiBudW1iZXI7XG4gIFxuICAvLyBUYXJnZXRpbmdcbiAgcHVibGljIGN1cnJlbnRUYXJnZXQ6IG51bWJlciB8IG51bGw7IC8vIEVudGl0eSBJRCBvZiBjdXJyZW50IHRhcmdldFxuICBwdWJsaWMgdGFyZ2V0U2VhcmNoUmFuZ2U6IG51bWJlcjsgLy8gUmFuZ2UgdG8gc2VhcmNoIGZvciBuZXcgdGFyZ2V0c1xuICBwdWJsaWMgbGFzdFRhcmdldFNlYXJjaFRpbWU6IG51bWJlcjtcbiAgcHVibGljIHRhcmdldFNlYXJjaENvb2xkb3duOiBudW1iZXI7IC8vIEhvdyBvZnRlbiB0byBzZWFyY2ggZm9yIHRhcmdldHNcbiAgXG4gIC8vIFN0YXRlXG4gIHB1YmxpYyBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgcHVibGljIGlzRGVhZDogYm9vbGVhbjtcbiAgcHVibGljIGRlYXRoVGltZTogbnVtYmVyO1xuICBcbiAgY29uc3RydWN0b3IoXG4gICAgb3duZXJJZDogc3RyaW5nID0gJycsXG4gICAgdG93ZXJJbmRleDogbnVtYmVyID0gMFxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMub3duZXJJZCA9IG93bmVySWQ7XG4gICAgdGhpcy50b3dlckluZGV4ID0gdG93ZXJJbmRleDtcbiAgICBcbiAgICAvLyBDb21iYXQgY29uZmlndXJhdGlvblxuICAgIHRoaXMuYXR0YWNrUmFuZ2UgPSAxMDsgLy8gMTAgdW5pdCBhdHRhY2sgcmFuZ2UgYXMgc3BlY2lmaWVkXG4gICAgdGhpcy5hdHRhY2tEYW1hZ2UgPSAxMDsgLy8gMTAgZGFtYWdlIHBlciBhcnJvdyBhcyBzcGVjaWZpZWRcbiAgICB0aGlzLmF0dGFja0Nvb2xkb3duID0gMS41OyAvLyAxLjUgc2Vjb25kcyBiZXR3ZWVuIHNob3RzXG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDsgLy8gU3BlZWQgb2YgdG93ZXIgYXJyb3dzXG4gICAgXG4gICAgLy8gVGFyZ2V0aW5nIGNvbmZpZ3VyYXRpb25cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlICsgMTsgLy8gU2VhcmNoIHNsaWdodGx5IGJleW9uZCBhdHRhY2sgcmFuZ2VcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gMDtcbiAgICB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duID0gMC41OyAvLyBTZWFyY2ggZm9yIHRhcmdldHMgZXZlcnkgMC41IHNlY29uZHNcbiAgICBcbiAgICAvLyBTdGF0ZVxuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuaXNEZWFkID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSAwO1xuICB9XG4gIFxuICBwdWJsaWMgY2FuQXR0YWNrKGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc0RlYWQgfHwgIXRoaXMuY3VycmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QXR0YWNrVGltZSkgPj0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgfVxuICBcbiAgcHVibGljIHBlcmZvcm1BdHRhY2soY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuICBcbiAgcHVibGljIGNhblNlYXJjaEZvclRhcmdldHMoY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lKSA+PSB0aGlzLnRhcmdldFNlYXJjaENvb2xkb3duO1xuICB9XG4gIFxuICBwdWJsaWMgdXBkYXRlVGFyZ2V0U2VhcmNoKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRUYXJnZXQodGFyZ2V0RW50aXR5SWQ6IG51bWJlciB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRFbnRpdHlJZDtcbiAgfVxuICBcbiAgcHVibGljIGNsZWFyVGFyZ2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIH1cbiAgXG4gIHB1YmxpYyBkaWUoY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuaXNEZWFkID0gdHJ1ZTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5kZWF0aFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB0aGlzLmNsZWFyVGFyZ2V0KCk7XG4gIH1cbiAgXG4gIHB1YmxpYyBnZXREaXNwbGF5TmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgVG93ZXIgJHt0aGlzLnRvd2VySW5kZXggKyAxfSAoT3duZXI6ICR7dGhpcy5vd25lcklkfSlgO1xuICB9XG4gIFxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5vd25lcklkID0gJyc7XG4gICAgdGhpcy50b3dlckluZGV4ID0gMDtcbiAgICB0aGlzLmF0dGFja1JhbmdlID0gODtcbiAgICB0aGlzLmF0dGFja0RhbWFnZSA9IDEwO1xuICAgIHRoaXMuYXR0YWNrQ29vbGRvd24gPSAxLjU7XG4gICAgdGhpcy5sYXN0QXR0YWNrVGltZSA9IDA7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3BlZWQgPSAyMDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2UgPSA5O1xuICAgIHRoaXMubGFzdFRhcmdldFNlYXJjaFRpbWUgPSAwO1xuICAgIHRoaXMudGFyZ2V0U2VhcmNoQ29vbGRvd24gPSAwLjU7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5pc0RlYWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlYXRoVGltZSA9IDA7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfVxuICBcbiAgcHVibGljIGNsb25lKCk6IFRvd2VyIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUb3dlcih0aGlzLm93bmVySWQsIHRoaXMudG93ZXJJbmRleCk7XG4gICAgY2xvbmUuYXR0YWNrUmFuZ2UgPSB0aGlzLmF0dGFja1JhbmdlO1xuICAgIGNsb25lLmF0dGFja0RhbWFnZSA9IHRoaXMuYXR0YWNrRGFtYWdlO1xuICAgIGNsb25lLmF0dGFja0Nvb2xkb3duID0gdGhpcy5hdHRhY2tDb29sZG93bjtcbiAgICBjbG9uZS5sYXN0QXR0YWNrVGltZSA9IHRoaXMubGFzdEF0dGFja1RpbWU7XG4gICAgY2xvbmUucHJvamVjdGlsZVNwZWVkID0gdGhpcy5wcm9qZWN0aWxlU3BlZWQ7XG4gICAgY2xvbmUuY3VycmVudFRhcmdldCA9IHRoaXMuY3VycmVudFRhcmdldDtcbiAgICBjbG9uZS50YXJnZXRTZWFyY2hSYW5nZSA9IHRoaXMudGFyZ2V0U2VhcmNoUmFuZ2U7XG4gICAgY2xvbmUubGFzdFRhcmdldFNlYXJjaFRpbWUgPSB0aGlzLmxhc3RUYXJnZXRTZWFyY2hUaW1lO1xuICAgIGNsb25lLnRhcmdldFNlYXJjaENvb2xkb3duID0gdGhpcy50YXJnZXRTZWFyY2hDb29sZG93bjtcbiAgICBjbG9uZS5pc0FjdGl2ZSA9IHRoaXMuaXNBY3RpdmU7XG4gICAgY2xvbmUuaXNEZWFkID0gdGhpcy5pc0RlYWQ7XG4gICAgY2xvbmUuZGVhdGhUaW1lID0gdGhpcy5kZWF0aFRpbWU7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ29tcG9uZW50IiwiVG93ZXIiLCJjYW5BdHRhY2siLCJjdXJyZW50VGltZSIsImlzQWN0aXZlIiwiaXNEZWFkIiwiY3VycmVudFRhcmdldCIsImxhc3RBdHRhY2tUaW1lIiwiYXR0YWNrQ29vbGRvd24iLCJwZXJmb3JtQXR0YWNrIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsImxhc3RUYXJnZXRTZWFyY2hUaW1lIiwidGFyZ2V0U2VhcmNoQ29vbGRvd24iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJzZXRUYXJnZXQiLCJ0YXJnZXRFbnRpdHlJZCIsImNsZWFyVGFyZ2V0IiwiZGllIiwiZGVhdGhUaW1lIiwiZ2V0RGlzcGxheU5hbWUiLCJ0b3dlckluZGV4Iiwib3duZXJJZCIsInJlc2V0IiwiYXR0YWNrUmFuZ2UiLCJhdHRhY2tEYW1hZ2UiLCJwcm9qZWN0aWxlU3BlZWQiLCJ0YXJnZXRTZWFyY2hSYW5nZSIsImVuYWJsZWQiLCJjbG9uZSIsImNvbnN0cnVjdG9yIiwiY29tcG9uZW50VHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Tower.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/ecs/components/Transform.ts":
/*!*****************************************!*\
  !*** ./src/ecs/components/Transform.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transform: function() { return /* binding */ Transform; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Entity */ \"(app-pages-browser)/./src/ecs/Entity.ts\");\n// Transform component for position, rotation, and scale\n\n\nclass Transform extends _Entity__WEBPACK_IMPORTED_MODULE_1__.Component {\n    setPosition(x, y, z) {\n        this.position.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    setRotation(x, y, z) {\n        this.rotation.set(x, y, z);\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    setScale(x, y, z) {\n        this.scale.set(x, y, z);\n        this.markMatrixDirty();\n    }\n    translate(x, y, z) {\n        this.position.x += x;\n        this.position.y += y;\n        this.position.z += z;\n        this.markMatrixDirty();\n    }\n    rotate(x, y, z) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n        this.updateQuaternion();\n        this.markMatrixDirty();\n    }\n    lookAt(target) {\n        let up = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        const matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.lookAt(this.position, target, up);\n        this.quaternion.setFromRotationMatrix(matrix);\n        this.rotation.setFromQuaternion(this.quaternion);\n        this.markMatrixDirty();\n    }\n    getForward() {\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1);\n        forward.applyQuaternion(this.quaternion);\n        return forward;\n    }\n    getRight() {\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);\n        right.applyQuaternion(this.quaternion);\n        return right;\n    }\n    getUp() {\n        const up = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n        up.applyQuaternion(this.quaternion);\n        return up;\n    }\n    getWorldPosition() {\n        this.updateWorldMatrix();\n        const worldPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldPosition.setFromMatrixPosition(this.worldMatrix);\n        return worldPosition;\n    }\n    getWorldRotation() {\n        this.updateWorldMatrix();\n        const worldQuaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        worldQuaternion.setFromRotationMatrix(this.worldMatrix);\n        return worldQuaternion;\n    }\n    getWorldScale() {\n        this.updateWorldMatrix();\n        const worldScale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldScale.setFromMatrixScale(this.worldMatrix);\n        return worldScale;\n    }\n    updateMatrix() {\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixNeedsUpdate = false;\n    }\n    updateWorldMatrix() {\n        if (this.matrixNeedsUpdate) {\n            this.updateMatrix();\n        }\n        if (this.parent) {\n            this.parent.updateWorldMatrix();\n            this.worldMatrix.multiplyMatrices(this.parent.worldMatrix, this.matrix);\n        } else {\n            this.worldMatrix.copy(this.matrix);\n        }\n    }\n    addChild(child) {\n        if (child.parent) {\n            child.parent.removeChild(child);\n        }\n        child.parent = this;\n        this.children.push(child);\n    }\n    removeChild(child) {\n        const index = this.children.indexOf(child);\n        if (index !== -1) {\n            this.children.splice(index, 1);\n            child.parent = null;\n        }\n    }\n    removeFromParent() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n    }\n    updateQuaternion() {\n        this.quaternion.setFromEuler(this.rotation);\n    }\n    markMatrixDirty() {\n        this.matrixNeedsUpdate = true;\n        // Mark all children as dirty too\n        for (const child of this.children){\n            child.markMatrixDirty();\n        }\n    }\n    reset() {\n        // Ensure Vector3 objects are properly initialized\n        if (!this.position) {\n            this.position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        } else {\n            this.position.set(0, 0, 0);\n        }\n        if (!this.rotation) {\n            this.rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0);\n        } else {\n            this.rotation.set(0, 0, 0);\n        }\n        if (!this.scale) {\n            this.scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        } else {\n            this.scale.set(1, 1, 1);\n        }\n        if (!this.quaternion) {\n            this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        } else {\n            this.quaternion.set(0, 0, 0, 1);\n        }\n        if (!this.matrix) {\n            this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.matrix.identity();\n        }\n        if (!this.worldMatrix) {\n            this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        } else {\n            this.worldMatrix.identity();\n        }\n        this.matrixNeedsUpdate = true;\n        // Clear parent-child relationships\n        this.removeFromParent();\n        while(this.children.length > 0){\n            this.removeChild(this.children[0]);\n        }\n        this.enabled = true;\n    }\n    clone() {\n        const clone = new Transform(this.position, this.rotation, this.scale);\n        clone.quaternion.copy(this.quaternion);\n        return clone;\n    }\n    constructor(position = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), rotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Euler(0, 0, 0), scale = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)){\n        super();\n        this.componentType = \"Transform\" // Instance identifier\n        ;\n        this.matrixNeedsUpdate = true;\n        // Parent-child relationships\n        this.parent = null;\n        this.children = [];\n        this.position = position.clone();\n        this.rotation = rotation.clone();\n        this.scale = scale.clone();\n        this.quaternion = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        this.matrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.worldMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.updateQuaternion();\n    }\n}\nTransform.componentType = \"Transform\" // Explicit type identifier\n;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9lY3MvY29tcG9uZW50cy9UcmFuc2Zvcm0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsd0RBQXdEO0FBQ29CO0FBQ3RDO0FBRS9CLE1BQU1LLGtCQUFrQkQsOENBQVNBO0lBa0MvQkUsWUFBWUMsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT0MsWUFBWU4sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN4RCxJQUFJLENBQUNLLFFBQVEsQ0FBQ0gsR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUN4QixJQUFJLENBQUNNLGdCQUFnQjtRQUNyQixJQUFJLENBQUNILGVBQWU7SUFDdEI7SUFFT0ksU0FBU1QsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNyRCxJQUFJLENBQUNRLEtBQUssQ0FBQ04sR0FBRyxDQUFDSixHQUFHQyxHQUFHQztRQUNyQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT00sVUFBVVgsQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUN0RCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0QsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNHLGVBQWU7SUFDdEI7SUFFT08sT0FBT1osQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVMsRUFBUTtRQUNuRCxJQUFJLENBQUNLLFFBQVEsQ0FBQ1AsQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNPLFFBQVEsQ0FBQ04sQ0FBQyxJQUFJQTtRQUNuQixJQUFJLENBQUNNLFFBQVEsQ0FBQ0wsQ0FBQyxJQUFJQTtRQUNuQixJQUFJ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QkFBZ0IsWUFBYSxzQkFBc0I7O2FBUzVEcEIsb0JBQW9CO1FBRTNCLDZCQUE2QjthQUN0QkMsU0FBMkI7YUFDM0JNLFdBQXdCLEVBQUU7UUFTL0IsSUFBSSxDQUFDMUMsUUFBUSxHQUFHQSxTQUFTcUQsS0FBSztRQUM5QixJQUFJLENBQUNqRCxRQUFRLEdBQUdBLFNBQVNpRCxLQUFLO1FBQzlCLElBQUksQ0FBQzlDLEtBQUssR0FBR0EsTUFBTThDLEtBQUs7UUFDeEIsSUFBSSxDQUFDdkMsVUFBVSxHQUFHLElBQUl0Qiw0REFBVUE7UUFDaEMsSUFBSSxDQUFDcUIsTUFBTSxHQUFHLElBQUlwQix5REFBT0E7UUFDekIsSUFBSSxDQUFDa0MsV0FBVyxHQUFHLElBQUlsQyx5REFBT0E7UUFFOUIsSUFBSSxDQUFDWSxnQkFBZ0I7SUFDdkI7QUE0TEY7QUE1TmFWLFVBQ1k0RCxnQkFBZ0IsWUFBYSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybS50cz9mY2JhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zZm9ybSBjb21wb25lbnQgZm9yIHBvc2l0aW9uLCByb3RhdGlvbiwgYW5kIHNjYWxlXG5pbXBvcnQgeyBWZWN0b3IzLCBFdWxlciwgUXVhdGVybmlvbiwgTWF0cml4NCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuLi9FbnRpdHknO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBjb21wb25lbnRUeXBlID0gJ1RyYW5zZm9ybSc7IC8vIEV4cGxpY2l0IHR5cGUgaWRlbnRpZmllclxuICBwdWJsaWMgcmVhZG9ubHkgY29tcG9uZW50VHlwZSA9ICdUcmFuc2Zvcm0nOyAvLyBJbnN0YW5jZSBpZGVudGlmaWVyXG4gIHB1YmxpYyBwb3NpdGlvbjogVmVjdG9yMztcbiAgcHVibGljIHJvdGF0aW9uOiBFdWxlcjtcbiAgcHVibGljIHNjYWxlOiBWZWN0b3IzO1xuICBwdWJsaWMgcXVhdGVybmlvbjogUXVhdGVybmlvbjtcblxuICAvLyBDYWNoZWQgbWF0cmljZXMgZm9yIHBlcmZvcm1hbmNlXG4gIHB1YmxpYyBtYXRyaXg6IE1hdHJpeDQ7XG4gIHB1YmxpYyB3b3JsZE1hdHJpeDogTWF0cml4NDtcbiAgcHVibGljIG1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAvLyBQYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICBwdWJsaWMgcGFyZW50OiBUcmFuc2Zvcm0gfCBudWxsID0gbnVsbDtcbiAgcHVibGljIGNoaWxkcmVuOiBUcmFuc2Zvcm1bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMCwgMCksXG4gICAgcm90YXRpb246IEV1bGVyID0gbmV3IEV1bGVyKDAsIDAsIDApLFxuICAgIHNjYWxlOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMSwgMSwgMSlcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24uY2xvbmUoKTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUuY2xvbmUoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRQb3NpdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRSb3RhdGlvbih4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy51cGRhdGVRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRTY2FsZSh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zY2FsZS5zZXQoeCwgeSwgeik7XG4gICAgdGhpcy5tYXJrTWF0cml4RGlydHkoKTtcbiAgfVxuXG4gIHB1YmxpYyB0cmFuc2xhdGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24ueCArPSB4O1xuICAgIHRoaXMucG9zaXRpb24ueSArPSB5O1xuICAgIHRoaXMucG9zaXRpb24ueiArPSB6O1xuICAgIHRoaXMubWFya01hdHJpeERpcnR5KCk7XG4gIH1cblxuICBwdWJsaWMgcm90YXRlKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJvdGF0aW9uLnggKz0geDtcbiAgICB0aGlzLnJvdGF0aW9uLnkgKz0geTtcbiAgICB0aGlzLnJvdGF0aW9uLnogKz0gejtcbiAgICB0aGlzLnVwZGF0ZVF1YXRlcm5pb24oKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGxvb2tBdCh0YXJnZXQ6IFZlY3RvcjMsIHVwOiBWZWN0b3IzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCkpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIG1hdHJpeC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGFyZ2V0LCB1cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLm1hcmtNYXRyaXhEaXJ0eSgpO1xuICB9XG5cbiAgcHVibGljIGdldEZvcndhcmQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbiAgICBmb3J3YXJkLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG5cbiAgcHVibGljIGdldFJpZ2h0KCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgcmlnaHQuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldFVwKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgdXAuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHVwO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUG9zaXRpb24oKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkUm90YXRpb24oKTogUXVhdGVybmlvbiB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgd29ybGRRdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0aGlzLndvcmxkTWF0cml4KTtcbiAgICByZXR1cm4gd29ybGRRdWF0ZXJuaW9uO1xuICB9XG5cbiAgcHVibGljIGdldFdvcmxkU2NhbGUoKTogVmVjdG9yMyB7XG4gICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHRoaXMud29ybGRNYXRyaXgpO1xuICAgIHJldHVybiB3b3JsZFNjYWxlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZU1hdHJpeCgpOiB2b2lkIHtcbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZVdvcmxkTWF0cml4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLm1hdHJpeE5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICAgIHRoaXMud29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC53b3JsZE1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhZGRDaGlsZChjaGlsZDogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlRnJvbVBhcmVudCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUXVhdGVybmlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMucm90YXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrTWF0cml4RGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5tYXRyaXhOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXG4gICAgLy8gTWFyayBhbGwgY2hpbGRyZW4gYXMgZGlydHkgdG9vXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5tYXJrTWF0cml4RGlydHkoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgLy8gRW5zdXJlIFZlY3RvcjMgb2JqZWN0cyBhcmUgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIXRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5yb3RhdGlvbikge1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IG5ldyBFdWxlcigwLCAwLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5zY2FsZSA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjYWxlLnNldCgxLCAxLCAxKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLnF1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIFxuICAgIGlmICghdGhpcy5tYXRyaXgpIHtcbiAgICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCF0aGlzLndvcmxkTWF0cml4KSB7XG4gICAgICB0aGlzLndvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3JsZE1hdHJpeC5pZGVudGl0eSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBDbGVhciBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAgIHRoaXMucmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvbmUoKTogVHJhbnNmb3JtIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBUcmFuc2Zvcm0odGhpcy5wb3NpdGlvbiwgdGhpcy5yb3RhdGlvbiwgdGhpcy5zY2FsZSk7XG4gICAgY2xvbmUucXVhdGVybmlvbi5jb3B5KHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkV1bGVyIiwiUXVhdGVybmlvbiIsIk1hdHJpeDQiLCJDb21wb25lbnQiLCJUcmFuc2Zvcm0iLCJzZXRQb3NpdGlvbiIsIngiLCJ5IiwieiIsInBvc2l0aW9uIiwic2V0IiwibWFya01hdHJpeERpcnR5Iiwic2V0Um90YXRpb24iLCJyb3RhdGlvbiIsInVwZGF0ZVF1YXRlcm5pb24iLCJzZXRTY2FsZSIsInNjYWxlIiwidHJhbnNsYXRlIiwicm90YXRlIiwibG9va0F0IiwidGFyZ2V0IiwidXAiLCJtYXRyaXgiLCJxdWF0ZXJuaW9uIiwic2V0RnJvbVJvdGF0aW9uTWF0cml4Iiwic2V0RnJvbVF1YXRlcm5pb24iLCJnZXRGb3J3YXJkIiwiZm9yd2FyZCIsImFwcGx5UXVhdGVybmlvbiIsImdldFJpZ2h0IiwicmlnaHQiLCJnZXRVcCIsImdldFdvcmxkUG9zaXRpb24iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsIndvcmxkUG9zaXRpb24iLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJ3b3JsZE1hdHJpeCIsImdldFdvcmxkUm90YXRpb24iLCJ3b3JsZFF1YXRlcm5pb24iLCJnZXRXb3JsZFNjYWxlIiwid29ybGRTY2FsZSIsInNldEZyb21NYXRyaXhTY2FsZSIsInVwZGF0ZU1hdHJpeCIsImNvbXBvc2UiLCJtYXRyaXhOZWVkc1VwZGF0ZSIsInBhcmVudCIsIm11bHRpcGx5TWF0cmljZXMiLCJjb3B5IiwiYWRkQ2hpbGQiLCJjaGlsZCIsInJlbW92ZUNoaWxkIiwiY2hpbGRyZW4iLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwicmVtb3ZlRnJvbVBhcmVudCIsInNldEZyb21FdWxlciIsInJlc2V0IiwiaWRlbnRpdHkiLCJsZW5ndGgiLCJlbmFibGVkIiwiY2xvbmUiLCJjb25zdHJ1Y3RvciIsImNvbXBvbmVudFR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/ecs/components/Transform.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CameraSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CameraSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraSystem: function() { return /* binding */ CameraSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/utils/MathUtils */ \"(app-pages-browser)/./src/utils/MathUtils.ts\");\n// Camera system for third-person camera controls\n\n\n\n\nclass CameraSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setTarget(entity) {\n        this.target = entity;\n    }\n    setConfig(config) {\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.spherical.radius = this.config.distance;\n    }\n    update(entities, deltaTime) {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) return;\n        // Handle mouse input for camera rotation\n        this.handleMouseInput();\n        // Update target position\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        // Calculate camera position based on spherical coordinates\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        // Smooth camera movement\n        this.currentPosition.lerp(this.targetPosition, this.config.smoothing);\n        this.currentLookAt.lerp(this.targetLookAt, this.config.smoothing);\n        // Update camera\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    handleMouseInput() {\n        const mouseDelta = this.inputManager.getMouseDelta();\n        // Only rotate camera when right mouse button is held down\n        if ((mouseDelta.x !== 0 || mouseDelta.y !== 0) && this.isRightMouseDown) {\n            // Update spherical coordinates based on mouse movement\n            this.spherical.theta -= mouseDelta.x * this.config.mouseSensitivity;\n            this.spherical.phi -= mouseDelta.y * this.config.mouseSensitivity; // Inverted Y for natural camera feel\n            // Clamp phi to prevent camera flipping\n            this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.phi, this.config.minPolarAngle, this.config.maxPolarAngle);\n            // Normalize theta\n            this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(this.spherical.theta);\n        }\n    }\n    setupEventListeners() {\n        // Mouse button events for camera rotation\n        this.inputManager.on(\"mouseDown\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = true;\n            }\n        });\n        this.inputManager.on(\"mouseUp\", (param)=>{\n            let { button } = param;\n            if (button === 2) {\n                this.isRightMouseDown = false;\n            }\n        });\n        // Mouse wheel for zoom - only add listener once\n        if (!this.wheelListenerAdded) {\n            this.inputManager.on(\"wheel\", (param)=>{\n                let { deltaY } = param;\n                this.spherical.radius += deltaY * 0.01;\n                this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(this.spherical.radius, 2, this.config.maxDistance);\n            });\n            this.wheelListenerAdded = true;\n        }\n    }\n    setupInitialPosition() {\n        this.currentPosition.setFromSpherical(this.spherical);\n        this.currentLookAt.set(0, this.config.height, 0);\n        this.targetPosition.copy(this.currentPosition);\n        this.targetLookAt.copy(this.currentLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    // Utility methods\n    getCameraDirection() {\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        return direction;\n    }\n    getCameraRight() {\n        const direction = this.getCameraDirection();\n        const right = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        right.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\n        right.normalize();\n        return right;\n    }\n    getCameraForward() {\n        const right = this.getCameraRight();\n        const forward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        forward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), right);\n        forward.normalize();\n        return forward;\n    }\n    getDistance() {\n        return this.spherical.radius;\n    }\n    setDistance(distance) {\n        this.spherical.radius = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(distance, 2, this.config.maxDistance);\n    }\n    getHorizontalAngle() {\n        return this.spherical.theta;\n    }\n    getVerticalAngle() {\n        return this.spherical.phi;\n    }\n    setAngles(horizontal, vertical) {\n        this.spherical.theta = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.normalizeAngle(horizontal);\n        this.spherical.phi = _utils_MathUtils__WEBPACK_IMPORTED_MODULE_3__.MathUtils.clamp(vertical, this.config.minPolarAngle, this.config.maxPolarAngle);\n    }\n    resetCamera() {\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3;\n        this.spherical.theta = 0;\n        this.setupInitialPosition();\n    }\n    snapToTarget() {\n        if (!this.target) return;\n        const targetTransform = this.target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform || !targetTransform.position) return;\n        // Safety check: ensure position is properly initialized\n        if (targetTransform.position.x === undefined || targetTransform.position.y === undefined || targetTransform.position.z === undefined) {\n            console.warn(\"CameraSystem: Target position is not properly initialized, skipping snapToTarget\");\n            return;\n        }\n        this.targetLookAt.copy(targetTransform.position);\n        this.targetLookAt.y += this.config.height;\n        this.targetPosition.setFromSpherical(this.spherical);\n        this.targetPosition.add(this.targetLookAt);\n        this.currentPosition.copy(this.targetPosition);\n        this.currentLookAt.copy(this.targetLookAt);\n        this.camera.position.copy(this.currentPosition);\n        this.camera.lookAt(this.currentLookAt);\n    }\n    getCamera() {\n        return this.camera;\n    }\n    constructor(camera, inputManager, config){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform\n        ];\n        this.target = null;\n        // Camera configuration\n        this.config = {\n            distance: 10,\n            height: 5,\n            mouseSensitivity: 0.005,\n            smoothing: 0.1,\n            minPolarAngle: Math.PI / 3.5,\n            maxPolarAngle: Math.PI / 2.5,\n            maxDistance: 11.5\n        };\n        // Camera state\n        this.spherical = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Spherical(10, Math.PI / 3, 0);\n        this.targetPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.currentLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.targetLookAt = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        // Mouse state for camera rotation\n        this.isRightMouseDown = false;\n        this.wheelListenerAdded = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.priority = 900; // Run late, after movement\n        if (config) {\n            this.config = {\n                ...this.config,\n                ...config\n            };\n        }\n        this.spherical.radius = this.config.distance;\n        this.spherical.phi = Math.PI / 3; // Start at 60 degrees\n        this.spherical.theta = 0;\n        this.setupEventListeners();\n        this.setupInitialPosition();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NhbWVyYVN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlEQUFpRDtBQUM2QjtBQUN4QztBQUVpQjtBQUVUO0FBWXZDLE1BQU1LLHFCQUFxQkgsK0NBQU1BO0lBOEMvQkksVUFBVUMsTUFBYyxFQUFRO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHRDtJQUNoQjtJQUVPRSxVQUFVQyxNQUE2QixFQUFRO1FBQ3BELElBQUksQ0FBQ0EsTUFBTSxHQUFHO1lBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07WUFBRSxHQUFHQSxNQUFNO1FBQUM7UUFDMUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtJQUM5QztJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQyxJQUFJLENBQUNSLE1BQU0sRUFBRTtRQUVsQixNQUFNUyxrQkFBa0IsSUFBSSxDQUFDVCxNQUFNLENBQUNVLFlBQVksQ0FBQ2YsZ0VBQVNBO1FBQzFELElBQUksQ0FBQ2MsaUJBQWlCO1FBRXRCLHlDQUF5QztRQUN6QyxJQUFJLENBQUNFLGdCQUFnQjtRQUVyQix5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxZQUFZLENBQUNDLElBQUksQ0FBQ0osZ0JBQWdCSyxRQUFRO1FBQy9DLElBQUksQ0FBQ0YsWUFBWSxDQUFDRyxDQUFDLElBQUksSUFBSSxDQUFDYixNQUFNLENBQUNjLE1BQU07UUFFekMsMkRBQTJEO1FBQzNELElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNmLFNBQVM7UUFDbkQsSUFBSSxDQUFDYyxjQUFjLENBQUNFLEdBQUcsQ0FBQyxJQUFJLENBQUNQLFlBQVk7UUFFekMseUJBQXlCO1FBQ3pCLElBQUksQ0FBQ1EsZUFBZSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDSixjQUFjLEVBQUUsSUFB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R0FBR0E7UUFDcEIsSUFBSSxDQUFDOEMsUUFBUSxHQUFHLEtBQUssMkJBQTJCO1FBRWhELElBQUl2RSxRQUFRO1lBQ1YsSUFBSSxDQUFDQSxNQUFNLEdBQUc7Z0JBQUUsR0FBRyxJQUFJLENBQUNBLE1BQU07Z0JBQUUsR0FBR0EsTUFBTTtZQUFDO1FBQzVDO1FBRUEsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sR0FBRyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csUUFBUTtRQUM1QyxJQUFJLENBQUNGLFNBQVMsQ0FBQzhCLEdBQUcsR0FBRzhCLEtBQUtDLEVBQUUsR0FBRyxHQUFHLHNCQUFzQjtRQUN4RCxJQUFJLENBQUM3RCxTQUFTLENBQUM0QixLQUFLLEdBQUc7UUFFdkIsSUFBSSxDQUFDTyxtQkFBbUI7UUFDeEIsSUFBSSxDQUFDTSxvQkFBb0I7SUFDM0I7QUFpTEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ2FtZXJhU3lzdGVtLnRzP2NkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FtZXJhIHN5c3RlbSBmb3IgdGhpcmQtcGVyc29uIGNhbWVyYSBjb250cm9sc1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEsIFNwaGVyaWNhbCwgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IElucHV0TWFuYWdlciB9IGZyb20gJ0AvY29yZS9JbnB1dE1hbmFnZXInO1xuaW1wb3J0IHsgTWF0aFV0aWxzIH0gZnJvbSAnQC91dGlscy9NYXRoVXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbWVyYUNvbmZpZyB7XG4gIGRpc3RhbmNlOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBtb3VzZVNlbnNpdGl2aXR5OiBudW1iZXI7XG4gIHNtb290aGluZzogbnVtYmVyO1xuICBtaW5Qb2xhckFuZ2xlOiBudW1iZXI7XG4gIG1heFBvbGFyQW5nbGU6IG51bWJlcjtcbiAgbWF4RGlzdGFuY2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENhbWVyYVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtXTtcbiAgcHJpdmF0ZSBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhO1xuICBwcml2YXRlIGlucHV0TWFuYWdlcjogSW5wdXRNYW5hZ2VyO1xuICBwcml2YXRlIHRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gIFxuICAvLyBDYW1lcmEgY29uZmlndXJhdGlvblxuICBwcml2YXRlIGNvbmZpZzogQ2FtZXJhQ29uZmlnID0ge1xuICAgIGRpc3RhbmNlOiAxMCxcbiAgICBoZWlnaHQ6IDUsXG4gICAgbW91c2VTZW5zaXRpdml0eTogMC4wMDUsIC8vIEluY3JlYXNlZCBmb3IgYmV0dGVyIHJlc3BvbnNpdmVuZXNzXG4gICAgc21vb3RoaW5nOiAwLjEsXG4gICAgbWluUG9sYXJBbmdsZTogTWF0aC5QSSAvIDMuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBnb2luZyBhYm92ZSBob3Jpem9uXG4gICAgbWF4UG9sYXJBbmdsZTogTWF0aC5QSSAvIDIuNSwgLy8gUHJldmVudCBjYW1lcmEgZnJvbSBsb29raW5nIHVuZGVybmVhdGggdGhlIG1hcFxuICAgIG1heERpc3RhbmNlOiAxMS41LFxuICB9O1xuXG4gIC8vIENhbWVyYSBzdGF0ZVxuICBwcml2YXRlIHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWwoMTAsIE1hdGguUEkgLyAzLCAwKTtcbiAgcHJpdmF0ZSB0YXJnZXRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgY3VycmVudFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSBjdXJyZW50TG9va0F0ID0gbmV3IFZlY3RvcjMoKTtcbiAgcHJpdmF0ZSB0YXJnZXRMb29rQXQgPSBuZXcgVmVjdG9yMygpO1xuICBcbiAgLy8gTW91c2Ugc3RhdGUgZm9yIGNhbWVyYSByb3RhdGlvblxuICBwcml2YXRlIGlzUmlnaHRNb3VzZURvd24gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3aGVlbExpc3RlbmVyQWRkZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhLCBpbnB1dE1hbmFnZXI6IElucHV0TWFuYWdlciwgY29uZmlnPzogUGFydGlhbDxDYW1lcmFDb25maWc+KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IGlucHV0TWFuYWdlcjtcbiAgICB0aGlzLnByaW9yaXR5ID0gOTAwOyAvLyBSdW4gbGF0ZSwgYWZ0ZXIgbW92ZW1lbnRcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH07XG4gICAgfVxuXG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7IC8vIFN0YXJ0IGF0IDYwIGRlZ3JlZXNcbiAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IDA7XG5cbiAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldHVwSW5pdGlhbFBvc2l0aW9uKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0VGFyZ2V0KGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgdGhpcy50YXJnZXQgPSBlbnRpdHk7XG4gIH1cblxuICBwdWJsaWMgc2V0Q29uZmlnKGNvbmZpZzogUGFydGlhbDxDYW1lcmFDb25maWc+KTogdm9pZCB7XG4gICAgdGhpcy5jb25maWcgPSB7IC4uLnRoaXMuY29uZmlnLCAuLi5jb25maWcgfTtcbiAgICB0aGlzLnNwaGVyaWNhbC5yYWRpdXMgPSB0aGlzLmNvbmZpZy5kaXN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHJldHVybjtcblxuICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRoaXMudGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSByZXR1cm47XG5cbiAgICAvLyBIYW5kbGUgbW91c2UgaW5wdXQgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaGFuZGxlTW91c2VJbnB1dCgpO1xuXG4gICAgLy8gVXBkYXRlIHRhcmdldCBwb3NpdGlvblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIC8vIENhbGN1bGF0ZSBjYW1lcmEgcG9zaXRpb24gYmFzZWQgb24gc3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5zZXRGcm9tU3BoZXJpY2FsKHRoaXMuc3BoZXJpY2FsKTtcbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uLmFkZCh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICAvLyBTbW9vdGggY2FtZXJhIG1vdmVtZW50XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24ubGVycCh0aGlzLnRhcmdldFBvc2l0aW9uLCB0aGlzLmNvbmZpZy5zbW9vdGhpbmcpO1xuICAgIHRoaXMuY3VycmVudExvb2tBdC5sZXJwKHRoaXMudGFyZ2V0TG9va0F0LCB0aGlzLmNvbmZpZy5zbW9vdGhpbmcpO1xuXG4gICAgLy8gVXBkYXRlIGNhbWVyYVxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVNb3VzZUlucHV0KCk6IHZvaWQge1xuICAgIGNvbnN0IG1vdXNlRGVsdGEgPSB0aGlzLmlucHV0TWFuYWdlci5nZXRNb3VzZURlbHRhKCk7XG4gICAgXG4gICAgLy8gT25seSByb3RhdGUgY2FtZXJhIHdoZW4gcmlnaHQgbW91c2UgYnV0dG9uIGlzIGhlbGQgZG93blxuICAgIGlmICgobW91c2VEZWx0YS54ICE9PSAwIHx8IG1vdXNlRGVsdGEueSAhPT0gMCkgJiYgdGhpcy5pc1JpZ2h0TW91c2VEb3duKSB7XG4gICAgICAvLyBVcGRhdGUgc3BoZXJpY2FsIGNvb3JkaW5hdGVzIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50XG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSAtPSBtb3VzZURlbHRhLnggKiB0aGlzLmNvbmZpZy5tb3VzZVNlbnNpdGl2aXR5O1xuICAgICAgdGhpcy5zcGhlcmljYWwucGhpIC09IG1vdXNlRGVsdGEueSAqIHRoaXMuY29uZmlnLm1vdXNlU2Vuc2l0aXZpdHk7IC8vIEludmVydGVkIFkgZm9yIG5hdHVyYWwgY2FtZXJhIGZlZWxcblxuICAgICAgLy8gQ2xhbXAgcGhpIHRvIHByZXZlbnQgY2FtZXJhIGZsaXBwaW5nXG4gICAgICB0aGlzLnNwaGVyaWNhbC5waGkgPSBNYXRoVXRpbHMuY2xhbXAoXG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnBoaSxcbiAgICAgICAgdGhpcy5jb25maWcubWluUG9sYXJBbmdsZSxcbiAgICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICAgKTtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZXRhXG4gICAgICB0aGlzLnNwaGVyaWNhbC50aGV0YSA9IE1hdGhVdGlscy5ub3JtYWxpemVBbmdsZSh0aGlzLnNwaGVyaWNhbC50aGV0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIE1vdXNlIGJ1dHRvbiBldmVudHMgZm9yIGNhbWVyYSByb3RhdGlvblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZURvd24nLCAoeyBidXR0b24gfSkgPT4ge1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMikgeyAvLyBSaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgdGhpcy5pc1JpZ2h0TW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaW5wdXRNYW5hZ2VyLm9uKCdtb3VzZVVwJywgKHsgYnV0dG9uIH0pID0+IHtcbiAgICAgIGlmIChidXR0b24gPT09IDIpIHsgLy8gUmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICAgIHRoaXMuaXNSaWdodE1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTW91c2Ugd2hlZWwgZm9yIHpvb20gLSBvbmx5IGFkZCBsaXN0ZW5lciBvbmNlXG4gICAgaWYgKCF0aGlzLndoZWVsTGlzdGVuZXJBZGRlZCkge1xuICAgICAgdGhpcy5pbnB1dE1hbmFnZXIub24oJ3doZWVsJywgKHsgZGVsdGFZIH0pID0+IHtcbiAgICAgICAgdGhpcy5zcGhlcmljYWwucmFkaXVzICs9IGRlbHRhWSAqIDAuMDE7XG4gICAgICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcCh0aGlzLnNwaGVyaWNhbC5yYWRpdXMsIDIsIHRoaXMuY29uZmlnLm1heERpc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy53aGVlbExpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJbml0aWFsUG9zaXRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy5jdXJyZW50TG9va0F0LnNldCgwLCB0aGlzLmNvbmZpZy5oZWlnaHQsIDApO1xuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uY29weSh0aGlzLmN1cnJlbnRQb3NpdGlvbik7XG4gICAgdGhpcy50YXJnZXRMb29rQXQuY29weSh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICAgIFxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLmNvcHkodGhpcy5jdXJyZW50UG9zaXRpb24pO1xuICAgIHRoaXMuY2FtZXJhLmxvb2tBdCh0aGlzLmN1cnJlbnRMb29rQXQpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBnZXRDYW1lcmFEaXJlY3Rpb24oKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2FtZXJhUmlnaHQoKTogVmVjdG9yMyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRDYW1lcmFEaXJlY3Rpb24oKTtcbiAgICBjb25zdCByaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgcmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpO1xuICAgIHJpZ2h0Lm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiByaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmFGb3J3YXJkKCk6IFZlY3RvcjMge1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5nZXRDYW1lcmFSaWdodCgpO1xuICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCByaWdodCk7XG4gICAgZm9yd2FyZC5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXREaXN0YW5jZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC5yYWRpdXM7XG4gIH1cblxuICBwdWJsaWMgc2V0RGlzdGFuY2UoZGlzdGFuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc3BoZXJpY2FsLnJhZGl1cyA9IE1hdGhVdGlscy5jbGFtcChkaXN0YW5jZSwgMiwgdGhpcy5jb25maWcubWF4RGlzdGFuY2UpO1xuICB9XG5cbiAgcHVibGljIGdldEhvcml6b250YWxBbmdsZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnNwaGVyaWNhbC50aGV0YTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRWZXJ0aWNhbEFuZ2xlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc3BoZXJpY2FsLnBoaTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRBbmdsZXMoaG9yaXpvbnRhbDogbnVtYmVyLCB2ZXJ0aWNhbDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSBNYXRoVXRpbHMubm9ybWFsaXplQW5nbGUoaG9yaXpvbnRhbCk7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aFV0aWxzLmNsYW1wKFxuICAgICAgdmVydGljYWwsXG4gICAgICB0aGlzLmNvbmZpZy5taW5Qb2xhckFuZ2xlLFxuICAgICAgdGhpcy5jb25maWcubWF4UG9sYXJBbmdsZVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXRDYW1lcmEoKTogdm9pZCB7XG4gICAgdGhpcy5zcGhlcmljYWwucmFkaXVzID0gdGhpcy5jb25maWcuZGlzdGFuY2U7XG4gICAgdGhpcy5zcGhlcmljYWwucGhpID0gTWF0aC5QSSAvIDM7XG4gICAgdGhpcy5zcGhlcmljYWwudGhldGEgPSAwO1xuICAgIHRoaXMuc2V0dXBJbml0aWFsUG9zaXRpb24oKTtcbiAgfVxuXG4gIHB1YmxpYyBzbmFwVG9UYXJnZXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gU2FmZXR5IGNoZWNrOiBlbnN1cmUgcG9zaXRpb24gaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWRcbiAgICBpZiAodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnggPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnkgPT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgdGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uLnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKCdDYW1lcmFTeXN0ZW06IFRhcmdldCBwb3NpdGlvbiBpcyBub3QgcHJvcGVybHkgaW5pdGlhbGl6ZWQsIHNraXBwaW5nIHNuYXBUb1RhcmdldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudGFyZ2V0TG9va0F0LmNvcHkodGFyZ2V0VHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB0aGlzLnRhcmdldExvb2tBdC55ICs9IHRoaXMuY29uZmlnLmhlaWdodDtcblxuICAgIHRoaXMudGFyZ2V0UG9zaXRpb24uc2V0RnJvbVNwaGVyaWNhbCh0aGlzLnNwaGVyaWNhbCk7XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbi5hZGQodGhpcy50YXJnZXRMb29rQXQpO1xuXG4gICAgdGhpcy5jdXJyZW50UG9zaXRpb24uY29weSh0aGlzLnRhcmdldFBvc2l0aW9uKTtcbiAgICB0aGlzLmN1cnJlbnRMb29rQXQuY29weSh0aGlzLnRhcmdldExvb2tBdCk7XG5cbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5jb3B5KHRoaXMuY3VycmVudFBvc2l0aW9uKTtcbiAgICB0aGlzLmNhbWVyYS5sb29rQXQodGhpcy5jdXJyZW50TG9va0F0KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogUGVyc3BlY3RpdmVDYW1lcmEge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlNwaGVyaWNhbCIsIlZlY3RvcjMiLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJNYXRoVXRpbHMiLCJDYW1lcmFTeXN0ZW0iLCJzZXRUYXJnZXQiLCJlbnRpdHkiLCJ0YXJnZXQiLCJzZXRDb25maWciLCJjb25maWciLCJzcGhlcmljYWwiLCJyYWRpdXMiLCJkaXN0YW5jZSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwidGFyZ2V0VHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwiaGFuZGxlTW91c2VJbnB1dCIsInRhcmdldExvb2tBdCIsImNvcHkiLCJwb3NpdGlvbiIsInkiLCJoZWlnaHQiLCJ0YXJnZXRQb3NpdGlvbiIsInNldEZyb21TcGhlcmljYWwiLCJhZGQiLCJjdXJyZW50UG9zaXRpb24iLCJsZXJwIiwic21vb3RoaW5nIiwiY3VycmVudExvb2tBdCIsImNhbWVyYSIsImxvb2tBdCIsIm1vdXNlRGVsdGEiLCJpbnB1dE1hbmFnZXIiLCJnZXRNb3VzZURlbHRhIiwieCIsImlzUmlnaHRNb3VzZURvd24iLCJ0aGV0YSIsIm1vdXNlU2Vuc2l0aXZpdHkiLCJwaGkiLCJjbGFtcCIsIm1pblBvbGFyQW5nbGUiLCJtYXhQb2xhckFuZ2xlIiwibm9ybWFsaXplQW5nbGUiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwib24iLCJidXR0b24iLCJ3aGVlbExpc3RlbmVyQWRkZWQiLCJkZWx0YVkiLCJtYXhEaXN0YW5jZSIsInNldHVwSW5pdGlhbFBvc2l0aW9uIiwic2V0IiwiZ2V0Q2FtZXJhRGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJnZXRDYW1lcmFSaWdodCIsInJpZ2h0IiwiY3Jvc3NWZWN0b3JzIiwibm9ybWFsaXplIiwiZ2V0Q2FtZXJhRm9yd2FyZCIsImZvcndhcmQiLCJnZXREaXN0YW5jZSIsInNldERpc3RhbmNlIiwiZ2V0SG9yaXpvbnRhbEFuZ2xlIiwiZ2V0VmVydGljYWxBbmdsZSIsInNldEFuZ2xlcyIsImhvcml6b250YWwiLCJ2ZXJ0aWNhbCIsInJlc2V0Q2FtZXJhIiwiTWF0aCIsIlBJIiwic25hcFRvVGFyZ2V0IiwidW5kZWZpbmVkIiwieiIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0Q2FtZXJhIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CameraSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CollisionSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/CollisionSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionSystem: function() { return /* binding */ CollisionSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/utils/SpatialHash */ \"(app-pages-browser)/./src/utils/SpatialHash.ts\");\n// Collision system for efficient collision detection and response\n\n\n\n\n\n\nclass CollisionSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for trigger detection and broad phase\n        this.updateSpatialHash(entities);\n        this.detectCollisions(entities);\n        this.processCollisionCallbacks();\n        // Also resolve collisions in update() to ensure immediate response\n        this.resolveCollisions();\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics collision response\n        this.resolveCollisions();\n    }\n    updateSpatialHash(entities) {\n        // Update spatial hash with current entity positions\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) {\n                this.spatialHash.remove(entity);\n                continue;\n            }\n            // Update collider bounds\n            collider.updateBounds(transform.getWorldPosition());\n            // Update spatial hash\n            this.spatialHash.update(entity, collider.bounds);\n        }\n    }\n    detectCollisions(entities) {\n        this.collisionPairs.length = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        const processedPairs = new Set();\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const collider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            if (!transform.enabled || !collider.enabled) continue;\n            // Query spatial hash for potential collisions\n            const candidates = this.spatialHash.query(collider.bounds);\n            for (const candidate of candidates){\n                const otherEntity = candidate.entity;\n                // Skip self\n                if (entity.id === otherEntity.id) continue;\n                // Create unique pair key (smaller ID first)\n                const pairKey = entity.id < otherEntity.id ? \"\".concat(entity.id, \"-\").concat(otherEntity.id) : \"\".concat(otherEntity.id, \"-\").concat(entity.id);\n                // Skip if already processed this pair\n                if (processedPairs.has(pairKey)) continue;\n                processedPairs.add(pairKey);\n                const otherTransform = otherEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const otherCollider = otherEntity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n                if (!(otherTransform === null || otherTransform === void 0 ? void 0 : otherTransform.enabled) || !(otherCollider === null || otherCollider === void 0 ? void 0 : otherCollider.enabled)) continue;\n                // Check if colliders can collide\n                if (!collider.canCollideWith(otherCollider)) continue;\n                this.collisionChecks++;\n                // Precise collision detection\n                if (collider.intersects(otherCollider, transform.getWorldPosition(), otherTransform.getWorldPosition())) {\n                    this.actualCollisions++;\n                    // Debug logging for pillar collisions\n                    if (collider.layer === 2 && otherCollider.layer === 16 || collider.layer === 16 && otherCollider.layer === 2) {\n                        console.log(\"\\uD83D\\uDD0D Pillar collision detected between entities \".concat(entity.id, \" and \").concat(otherEntity.id));\n                    }\n                    const pair = {\n                        entityA: entity,\n                        entityB: otherEntity,\n                        colliderA: collider,\n                        colliderB: otherCollider\n                    };\n                    this.collisionPairs.push(pair);\n                }\n            }\n        }\n    }\n    processCollisionCallbacks() {\n        const currentCollisions = new Map();\n        // Process current collisions\n        for (const pair of this.collisionPairs){\n            const pairKey = pair.entityA.id < pair.entityB.id ? \"\".concat(pair.entityA.id, \"-\").concat(pair.entityB.id) : \"\".concat(pair.entityB.id, \"-\").concat(pair.entityA.id);\n            currentCollisions.set(pairKey, pair);\n            // Check if this is a new collision\n            if (!this.activeCollisions.has(pairKey)) {\n                // New collision - trigger enter events\n                this.triggerCollisionEnter(pair);\n            } else {\n                // Ongoing collision - trigger stay events\n                this.triggerCollisionStay(pair);\n            }\n        }\n        // Check for collisions that ended\n        this.activeCollisions.forEach((pair, pairKey)=>{\n            if (!currentCollisions.has(pairKey)) {\n                // Collision ended - trigger exit events\n                this.triggerCollisionExit(pair);\n            }\n        });\n        // Update active collisions\n        this.activeCollisions = currentCollisions;\n    }\n    triggerCollisionEnter(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerEnter, _pair_colliderA, _pair_colliderB_onTriggerEnter, _pair_colliderB;\n            (_pair_colliderA_onTriggerEnter = (_pair_colliderA = pair.colliderA).onTriggerEnter) === null || _pair_colliderA_onTriggerEnter === void 0 ? void 0 : _pair_colliderA_onTriggerEnter.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerEnter = (_pair_colliderB = pair.colliderB).onTriggerEnter) === null || _pair_colliderB_onTriggerEnter === void 0 ? void 0 : _pair_colliderB_onTriggerEnter.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionEnter, _pair_colliderA1, _pair_colliderB_onCollisionEnter, _pair_colliderB1;\n            (_pair_colliderA_onCollisionEnter = (_pair_colliderA1 = pair.colliderA).onCollisionEnter) === null || _pair_colliderA_onCollisionEnter === void 0 ? void 0 : _pair_colliderA_onCollisionEnter.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionEnter = (_pair_colliderB1 = pair.colliderB).onCollisionEnter) === null || _pair_colliderB_onCollisionEnter === void 0 ? void 0 : _pair_colliderB_onCollisionEnter.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionStay(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerStay, _pair_colliderA, _pair_colliderB_onTriggerStay, _pair_colliderB;\n            (_pair_colliderA_onTriggerStay = (_pair_colliderA = pair.colliderA).onTriggerStay) === null || _pair_colliderA_onTriggerStay === void 0 ? void 0 : _pair_colliderA_onTriggerStay.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerStay = (_pair_colliderB = pair.colliderB).onTriggerStay) === null || _pair_colliderB_onTriggerStay === void 0 ? void 0 : _pair_colliderB_onTriggerStay.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionStay, _pair_colliderA1, _pair_colliderB_onCollisionStay, _pair_colliderB1;\n            (_pair_colliderA_onCollisionStay = (_pair_colliderA1 = pair.colliderA).onCollisionStay) === null || _pair_colliderA_onCollisionStay === void 0 ? void 0 : _pair_colliderA_onCollisionStay.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionStay = (_pair_colliderB1 = pair.colliderB).onCollisionStay) === null || _pair_colliderB_onCollisionStay === void 0 ? void 0 : _pair_colliderB_onCollisionStay.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    triggerCollisionExit(pair) {\n        if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n            var // Trigger events\n            _pair_colliderA_onTriggerExit, _pair_colliderA, _pair_colliderB_onTriggerExit, _pair_colliderB;\n            (_pair_colliderA_onTriggerExit = (_pair_colliderA = pair.colliderA).onTriggerExit) === null || _pair_colliderA_onTriggerExit === void 0 ? void 0 : _pair_colliderA_onTriggerExit.call(_pair_colliderA, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onTriggerExit = (_pair_colliderB = pair.colliderB).onTriggerExit) === null || _pair_colliderB_onTriggerExit === void 0 ? void 0 : _pair_colliderB_onTriggerExit.call(_pair_colliderB, pair.colliderA, pair.entityA);\n        } else {\n            var // Collision events\n            _pair_colliderA_onCollisionExit, _pair_colliderA1, _pair_colliderB_onCollisionExit, _pair_colliderB1;\n            (_pair_colliderA_onCollisionExit = (_pair_colliderA1 = pair.colliderA).onCollisionExit) === null || _pair_colliderA_onCollisionExit === void 0 ? void 0 : _pair_colliderA_onCollisionExit.call(_pair_colliderA1, pair.colliderB, pair.entityB);\n            (_pair_colliderB_onCollisionExit = (_pair_colliderB1 = pair.colliderB).onCollisionExit) === null || _pair_colliderB_onCollisionExit === void 0 ? void 0 : _pair_colliderB_onCollisionExit.call(_pair_colliderB1, pair.colliderA, pair.entityA);\n        }\n    }\n    resolveCollisions() {\n        // Resolve physical collisions (non-trigger)\n        for (const pair of this.collisionPairs){\n            if (pair.colliderA.isTrigger || pair.colliderB.isTrigger) {\n                continue; // Skip triggers\n            }\n            this.resolveCollision(pair);\n        }\n    }\n    resolveCollision(pair) {\n        const transformA = pair.entityA.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const transformB = pair.entityB.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const posA = transformA.getWorldPosition();\n        const posB = transformB.getWorldPosition();\n        // Calculate separation vector with safety checks\n        if (!posA || !posA.clone || !posB || !posB.clone) {\n            console.warn(\"CollisionSystem: Invalid positions for collision resolution\", {\n                posA,\n                posB\n            });\n            return;\n        }\n        const separation = posA.clone().sub(posB);\n        const distance = separation.length();\n        if (distance === 0) {\n            // Objects are at exact same position, separate along Y axis\n            separation.set(0, 1, 0);\n        } else {\n            separation.normalize();\n        }\n        // Calculate required separation distance\n        let requiredSeparation = 0;\n        if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"sphere\") {\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"sphere\" && pair.colliderB.type === \"cylinder\") {\n            // Player (sphere) vs Pillar (cylinder) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else if (pair.colliderA.type === \"cylinder\" && pair.colliderB.type === \"sphere\") {\n            // Pillar (cylinder) vs Player (sphere) collision\n            requiredSeparation = pair.colliderA.radius + pair.colliderB.radius;\n        } else {\n            // For other shapes, use a simple approximation\n            const radiusA = this.getApproximateRadius(pair.colliderA);\n            const radiusB = this.getApproximateRadius(pair.colliderB);\n            requiredSeparation = radiusA + radiusB;\n        }\n        const overlap = requiredSeparation - distance;\n        if (overlap > 0) {\n            // Debug logging for pillar collisions\n            if (pair.colliderA.layer === 2 && pair.colliderB.layer === 16 || pair.colliderA.layer === 16 && pair.colliderB.layer === 2) {\n                console.log(\"\\uD83C\\uDFDB️ Pillar collision detected! Distance: \".concat(distance.toFixed(2), \", Required: \").concat(requiredSeparation.toFixed(2), \", Overlap: \").concat(overlap.toFixed(2)));\n            }\n            // For static objects (like pillars), apply stronger separation to prevent penetration\n            let separationMultiplier = 1.0;\n            if (pair.colliderA.isStatic || pair.colliderB.isStatic) {\n                separationMultiplier = 1.1; // 10% extra separation for static objects\n            }\n            // Separate objects - use enhanced separation for static objects\n            const separationVector = separation.multiplyScalar(overlap * separationMultiplier);\n            // Check if entities have Movement components for intelligent separation distribution\n            const movementA = pair.entityA.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            const movementB = pair.entityB.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Determine separation distribution based on Movement components and static status\n            let separationFactorA = 0.5; // Default: split separation equally\n            let separationFactorB = 0.5;\n            if (pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // A is static, B moves - B takes all separation\n                separationFactorA = 0;\n                separationFactorB = 1;\n            } else if (!pair.colliderA.isStatic && pair.colliderB.isStatic) {\n                // B is static, A moves - A takes all separation\n                separationFactorA = 1;\n                separationFactorB = 0;\n            } else if (!pair.colliderA.isStatic && !pair.colliderB.isStatic) {\n                // Both non-static - check for PVP scenario (both players)\n                const isPlayerA = pair.colliderA.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER;\n                const isPlayerB = pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.PLAYER || pair.colliderB.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.CollisionLayer.ENEMY;\n                if (isPlayerA && isPlayerB) {\n                    // PVP collision: check canMove property for fair collision resolution\n                    const canMoveA = movementA ? movementA.canMove : false;\n                    const canMoveB = movementB ? movementB.canMove : false;\n                    if (canMoveA && canMoveB) {\n                        // Both players can move - equal distribution for fair gameplay\n                        separationFactorA = 0.5;\n                        separationFactorB = 0.5;\n                    } else if (canMoveA && !canMoveB) {\n                        // Only A can move (local player), B is position-synced (remote player)\n                        separationFactorA = 1.0;\n                        separationFactorB = 0.0;\n                    } else if (!canMoveA && canMoveB) {\n                        // Only B can move (local player), A is position-synced (remote player)\n                        separationFactorA = 0.0;\n                        separationFactorB = 1.0;\n                    } else {\n                        // Neither can move - no separation (shouldn't happen in PVP)\n                        separationFactorA = 0.0;\n                        separationFactorB = 0.0;\n                    }\n                } else {\n                    // Non-PVP collision - distribute based on Movement components\n                    if (movementA && !movementB) {\n                        // A has Movement, B doesn't\n                        separationFactorA = 0.8;\n                        separationFactorB = 0.2;\n                    } else if (!movementA && movementB) {\n                        // B has Movement, A doesn't\n                        separationFactorA = 0.2;\n                        separationFactorB = 0.8;\n                    }\n                // If both have Movement or neither has Movement, use equal distribution (0.5, 0.5)\n                }\n            }\n            // Apply separation with calculated factors\n            if (separationFactorA > 0 && separationVector && separationVector.clone) {\n                const separationA = separationVector.clone().multiplyScalar(separationFactorA);\n                transformA.translate(separationA.x, separationA.y, separationA.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementA && pair.colliderB.isStatic && movementA.velocity && movementA.velocity.clone && separation && separation.clone) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementA.velocity.clone().projectOnVector(separation.clone().negate());\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementA.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n            if (separationFactorB > 0) {\n                const separationB = separationVector.clone().multiplyScalar(-separationFactorB);\n                transformB.translate(separationB.x, separationB.y, separationB.z);\n                // Also stop movement velocity for player when hitting static objects\n                if (movementB && pair.colliderA.isStatic) {\n                    // Project velocity to remove component towards the static object\n                    const velocityTowardsStatic = movementB.velocity.clone().projectOnVector(separation);\n                    if (velocityTowardsStatic.length() > 0) {\n                        movementB.velocity.sub(velocityTowardsStatic);\n                    }\n                }\n            }\n        }\n    }\n    getApproximateRadius(collider) {\n        switch(collider.type){\n            case \"sphere\":\n                return collider.radius;\n            case \"box\":\n                return Math.max(collider.size.x, collider.size.y, collider.size.z) * 0.5;\n            case \"capsule\":\n            case \"cylinder\":\n                return Math.max(collider.radius, collider.height * 0.5);\n            default:\n                return 0.5;\n        }\n    }\n    // Utility methods for other systems\n    queryColliders(bounds) {\n        const entries = this.spatialHash.query(bounds);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersRadius(center, radius) {\n        const entries = this.spatialHash.queryRadius(center, radius);\n        return entries.map((entry)=>entry.entity);\n    }\n    queryCollidersPoint(point) {\n        const entries = this.spatialHash.queryPoint(point);\n        return entries.map((entry)=>entry.entity);\n    }\n    getCollidersInLayer(layer, bounds) {\n        const candidates = bounds ? this.spatialHash.query(bounds) : Array.from(this.spatialHash[\"entityCells\"].keys()).map((id)=>{\n            const entries = this.spatialHash.query(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3().setFromCenterAndSize(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1000, 1000, 1000)));\n            return entries.find((e)=>e.entity.id === id);\n        }).filter(Boolean);\n        return candidates.filter((entry)=>{\n            const collider = entry.entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider);\n            return collider && collider.layer === layer;\n        }).map((entry)=>entry.entity);\n    }\n    // Performance and debugging\n    getPerformanceStats() {\n        return {\n            collisionChecks: this.collisionChecks,\n            actualCollisions: this.actualCollisions,\n            activeCollisions: this.activeCollisions.size,\n            spatialHashStats: this.spatialHash.getStats()\n        };\n    }\n    onEntityRemoved(entity) {\n        // Clean up spatial hash when entity is removed\n        this.spatialHash.remove(entity);\n        // Remove from active collisions\n        const keysToRemove = [];\n        this.activeCollisions.forEach((pair, key)=>{\n            if (pair.entityA.id === entity.id || pair.entityB.id === entity.id) {\n                keysToRemove.push(key);\n            }\n        });\n        for (const key of keysToRemove){\n            this.activeCollisions.delete(key);\n        }\n    }\n    onDisable() {\n        this.spatialHash.clear();\n        this.activeCollisions.clear();\n        this.collisionPairs.length = 0;\n    }\n    constructor(cellSize = 5){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_4__.Collider\n        ];\n        this.collisionPairs = [];\n        this.activeCollisions = new Map() // Track ongoing collisions\n        ;\n        // Performance tracking\n        this.lastUpdateTime = 0;\n        this.collisionChecks = 0;\n        this.actualCollisions = 0;\n        this.priority = 15; // Run before movement but after input\n        this.spatialHash = new _utils_SpatialHash__WEBPACK_IMPORTED_MODULE_5__.SpatialHash(cellSize);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbGxpc2lvblN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsa0VBQWtFO0FBQ1o7QUFDVDtBQUVVO0FBQ0Y7QUFDZ0I7QUFDbkI7QUFTM0MsTUFBTVEsd0JBQXdCTixzREFBYUE7SUFpQnpDTyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDhEQUE4RDtRQUM5RCxJQUFJLENBQUNDLGlCQUFpQixDQUFDRjtRQUN2QixJQUFJLENBQUNHLGdCQUFnQixDQUFDSDtRQUN0QixJQUFJLENBQUNJLHlCQUF5QjtRQUM5QixtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUI7SUFDeEI7SUFFT0MsWUFBWU4sUUFBa0IsRUFBRU8sY0FBc0IsRUFBUTtRQUNuRSw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDRixpQkFBaUI7SUFDeEI7SUFFUUgsa0JBQWtCRixRQUFrQixFQUFRO1FBQ2xELG9EQUFvRDtRQUNwRCxLQUFLLE1BQU1RLFVBQVVSLFNBQVU7WUFDN0IsTUFBTVMsWUFBWUQsT0FBT0UsWUFBWSxDQUFDakIsZ0VBQVNBO1lBQy9DLE1BQU1rQixXQUFXSCxPQUFPRSxZQUFZLENBQUNmLDhEQUFRQTtZQUU3QyxJQUFJLENBQUNjLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxNQUFNLENBQUNOO2dCQUN4QjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCRyxTQUFTSSxZQUFZLENBQUNOLFVBQVVPLGdCQUFnQjtZQUVoRCxzQkFBc0I7WUFDdEIsSUFBSSxDQUFDSCxXQUFXLENBQUNkLE1BQU0sQ0FBQ1MsUUFBUUcsU0FBU00sTUFBTTtRQUNqRDtJQUNGO0lBRVFkLGlCQUFpQkgsUUFBa0IsRUFBUTtRQUNqRCxJQUFJLENBQUNrQixjQUFjLENBQUNDLE1BQU0sR0FBRztRQUM3QixJQUFJLENBQUNDLGVBQWUsR0FB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QUF5QixFQUFFO1FBQ2pDLElBQUksQ0FBQ25GLGdCQUFnQixDQUFDRyxPQUFPLENBQUMsQ0FBQ1osTUFBTTZGO1lBQ25DLElBQUk3RixLQUFLQyxPQUFPLENBQUNaLEVBQUUsS0FBS3BCLE9BQU9vQixFQUFFLElBQUlXLEtBQUtFLE9BQU8sQ0FBQ2IsRUFBRSxLQUFLcEIsT0FBT29CLEVBQUUsRUFBRTtnQkFDbEV1RyxhQUFhdkYsSUFBSSxDQUFDd0Y7WUFDcEI7UUFDRjtRQUVBLEtBQUssTUFBTUEsT0FBT0QsYUFBYztZQUM5QixJQUFJLENBQUNuRixnQkFBZ0IsQ0FBQ3FGLE1BQU0sQ0FBQ0Q7UUFDL0I7SUFDRjtJQUVPRSxZQUFrQjtRQUN2QixJQUFJLENBQUN6SCxXQUFXLENBQUMwSCxLQUFLO1FBQ3RCLElBQUksQ0FBQ3ZGLGdCQUFnQixDQUFDdUYsS0FBSztRQUMzQixJQUFJLENBQUNySCxjQUFjLENBQUNDLE1BQU0sR0FBRztJQUMvQjtJQTFaQXFILFlBQVlDLFdBQW1CLENBQUMsQ0FBRTtRQUNoQyxLQUFLO2FBWFNDLHFCQUFxQjtZQUFDakosZ0VBQVNBO1lBQUVFLDhEQUFRQTtTQUFDO2FBRWxEdUIsaUJBQWtDLEVBQUU7YUFDcEM4QixtQkFBbUIsSUFBSUYsTUFBOEIsMkJBQTJCOztRQUV4Rix1QkFBdUI7YUFDZjZGLGlCQUFpQjthQUNqQnZILGtCQUFrQjthQUNsQkMsbUJBQW1CO1FBSXpCLElBQUksQ0FBQ3VILFFBQVEsR0FBRyxJQUFJLHNDQUFzQztRQUMxRCxJQUFJLENBQUMvSCxXQUFXLEdBQUcsSUFBSWhCLDJEQUFXQSxDQUFDNEk7SUFDckM7QUF1WkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ29sbGlzaW9uU3lzdGVtLnRzP2M5ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29sbGlzaW9uIHN5c3RlbSBmb3IgZWZmaWNpZW50IGNvbGxpc2lvbiBkZXRlY3Rpb24gYW5kIHJlc3BvbnNlXG5pbXBvcnQgeyBWZWN0b3IzLCBCb3gzIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IFBoeXNpY3NTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBDb2xsaWRlciwgQ29sbGlzaW9uTGF5ZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0NvbGxpZGVyJztcbmltcG9ydCB7IFNwYXRpYWxIYXNoIH0gZnJvbSAnQC91dGlscy9TcGF0aWFsSGFzaCc7XG5cbmludGVyZmFjZSBDb2xsaXNpb25QYWlyIHtcbiAgZW50aXR5QTogRW50aXR5O1xuICBlbnRpdHlCOiBFbnRpdHk7XG4gIGNvbGxpZGVyQTogQ29sbGlkZXI7XG4gIGNvbGxpZGVyQjogQ29sbGlkZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBDb2xsaXNpb25TeXN0ZW0gZXh0ZW5kcyBQaHlzaWNzU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIENvbGxpZGVyXTtcbiAgcHJpdmF0ZSBzcGF0aWFsSGFzaDogU3BhdGlhbEhhc2g7XG4gIHByaXZhdGUgY29sbGlzaW9uUGFpcnM6IENvbGxpc2lvblBhaXJbXSA9IFtdO1xuICBwcml2YXRlIGFjdGl2ZUNvbGxpc2lvbnMgPSBuZXcgTWFwPHN0cmluZywgQ29sbGlzaW9uUGFpcj4oKTsgLy8gVHJhY2sgb25nb2luZyBjb2xsaXNpb25zXG4gIFxuICAvLyBQZXJmb3JtYW5jZSB0cmFja2luZ1xuICBwcml2YXRlIGxhc3RVcGRhdGVUaW1lID0gMDtcbiAgcHJpdmF0ZSBjb2xsaXNpb25DaGVja3MgPSAwO1xuICBwcml2YXRlIGFjdHVhbENvbGxpc2lvbnMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGNlbGxTaXplOiBudW1iZXIgPSA1KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTU7IC8vIFJ1biBiZWZvcmUgbW92ZW1lbnQgYnV0IGFmdGVyIGlucHV0XG4gICAgdGhpcy5zcGF0aWFsSGFzaCA9IG5ldyBTcGF0aWFsSGFzaChjZWxsU2l6ZSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHJ1bnMgZXZlcnkgZnJhbWUgZm9yIHRyaWdnZXIgZGV0ZWN0aW9uIGFuZCBicm9hZCBwaGFzZVxuICAgIHRoaXMudXBkYXRlU3BhdGlhbEhhc2goZW50aXRpZXMpO1xuICAgIHRoaXMuZGV0ZWN0Q29sbGlzaW9ucyhlbnRpdGllcyk7XG4gICAgdGhpcy5wcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk7XG4gICAgLy8gQWxzbyByZXNvbHZlIGNvbGxpc2lvbnMgaW4gdXBkYXRlKCkgdG8gZW5zdXJlIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBmaXhlZFVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGZpeGVkRGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHJ1bnMgYXQgZml4ZWQgdGltZXN0ZXAgZm9yIHBoeXNpY3MgY29sbGlzaW9uIHJlc3BvbnNlXG4gICAgdGhpcy5yZXNvbHZlQ29sbGlzaW9ucygpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTcGF0aWFsSGFzaChlbnRpdGllczogRW50aXR5W10pOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgc3BhdGlhbCBoYXNoIHdpdGggY3VycmVudCBlbnRpdHkgcG9zaXRpb25zXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBjb2xsaWRlciA9IGVudGl0eS5nZXRDb21wb25lbnQoQ29sbGlkZXIpITtcblxuICAgICAgaWYgKCF0cmFuc2Zvcm0uZW5hYmxlZCB8fCAhY29sbGlkZXIuZW5hYmxlZCkge1xuICAgICAgICB0aGlzLnNwYXRpYWxIYXNoLnJlbW92ZShlbnRpdHkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGNvbGxpZGVyIGJvdW5kc1xuICAgICAgY29sbGlkZXIudXBkYXRlQm91bmRzKHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCkpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3BhdGlhbCBoYXNoXG4gICAgICB0aGlzLnNwYXRpYWxIYXNoLnVwZGF0ZShlbnRpdHksIGNvbGxpZGVyLmJvdW5kcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXRlY3RDb2xsaXNpb25zKGVudGl0aWVzOiBFbnRpdHlbXSk6IHZvaWQge1xuICAgIHRoaXMuY29sbGlzaW9uUGFpcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvbGxpc2lvbkNoZWNrcyA9IDA7XG4gICAgdGhpcy5hY3R1YWxDb2xsaXNpb25zID0gMDtcblxuICAgIGNvbnN0IHByb2Nlc3NlZFBhaXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pITtcbiAgICAgIGNvbnN0IGNvbGxpZGVyID0gZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcikhO1xuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFjb2xsaWRlci5lbmFibGVkKSBjb250aW51ZTtcblxuICAgICAgLy8gUXVlcnkgc3BhdGlhbCBoYXNoIGZvciBwb3RlbnRpYWwgY29sbGlzaW9uc1xuICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuc3BhdGlhbEhhc2gucXVlcnkoY29sbGlkZXIuYm91bmRzKTtcblxuICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xuICAgICAgICBjb25zdCBvdGhlckVudGl0eSA9IGNhbmRpZGF0ZS5lbnRpdHk7XG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIHNlbGZcbiAgICAgICAgaWYgKGVudGl0eS5pZCA9PT0gb3RoZXJFbnRpdHkuaWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIENyZWF0ZSB1bmlxdWUgcGFpciBrZXkgKHNtYWxsZXIgSUQgZmlyc3QpXG4gICAgICAgIGNvbnN0IHBhaXJLZXkgPSBlbnRpdHkuaWQgPCBvdGhlckVudGl0eS5pZCA/IFxuICAgICAgICAgIGAke2VudGl0eS5pZH0tJHtvdGhlckVudGl0eS5pZH1gIDogXG4gICAgICAgICAgYCR7b3RoZXJFbnRpdHkuaWR9LSR7ZW50aXR5LmlkfWA7XG5cbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IHByb2Nlc3NlZCB0aGlzIHBhaXJcbiAgICAgICAgaWYgKHByb2Nlc3NlZFBhaXJzLmhhcyhwYWlyS2V5KSkgY29udGludWU7XG4gICAgICAgIHByb2Nlc3NlZFBhaXJzLmFkZChwYWlyS2V5KTtcblxuICAgICAgICBjb25zdCBvdGhlclRyYW5zZm9ybSA9IG90aGVyRW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgICBjb25zdCBvdGhlckNvbGxpZGVyID0gb3RoZXJFbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcblxuICAgICAgICBpZiAoIW90aGVyVHJhbnNmb3JtPy5lbmFibGVkIHx8ICFvdGhlckNvbGxpZGVyPy5lbmFibGVkKSBjb250aW51ZTtcblxuICAgICAgICAvLyBDaGVjayBpZiBjb2xsaWRlcnMgY2FuIGNvbGxpZGVcbiAgICAgICAgaWYgKCFjb2xsaWRlci5jYW5Db2xsaWRlV2l0aChvdGhlckNvbGxpZGVyKSkgY29udGludWU7XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25DaGVja3MrKztcblxuICAgICAgICAvLyBQcmVjaXNlIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgaWYgKGNvbGxpZGVyLmludGVyc2VjdHMob3RoZXJDb2xsaWRlciwgdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKSwgb3RoZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpKSkge1xuICAgICAgICAgIHRoaXMuYWN0dWFsQ29sbGlzaW9ucysrO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERlYnVnIGxvZ2dpbmcgZm9yIHBpbGxhciBjb2xsaXNpb25zXG4gICAgICAgICAgaWYgKChjb2xsaWRlci5sYXllciA9PT0gMiAmJiBvdGhlckNvbGxpZGVyLmxheWVyID09PSAxNikgfHwgXG4gICAgICAgICAgICAgIChjb2xsaWRlci5sYXllciA9PT0gMTYgJiYgb3RoZXJDb2xsaWRlci5sYXllciA9PT0gMikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFBpbGxhciBjb2xsaXNpb24gZGV0ZWN0ZWQgYmV0d2VlbiBlbnRpdGllcyAke2VudGl0eS5pZH0gYW5kICR7b3RoZXJFbnRpdHkuaWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhaXI6IENvbGxpc2lvblBhaXIgPSB7XG4gICAgICAgICAgICBlbnRpdHlBOiBlbnRpdHksXG4gICAgICAgICAgICBlbnRpdHlCOiBvdGhlckVudGl0eSxcbiAgICAgICAgICAgIGNvbGxpZGVyQTogY29sbGlkZXIsXG4gICAgICAgICAgICBjb2xsaWRlckI6IG90aGVyQ29sbGlkZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdGhpcy5jb2xsaXNpb25QYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRDb2xsaXNpb25zID0gbmV3IE1hcDxzdHJpbmcsIENvbGxpc2lvblBhaXI+KCk7XG5cbiAgICAvLyBQcm9jZXNzIGN1cnJlbnQgY29sbGlzaW9uc1xuICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLmNvbGxpc2lvblBhaXJzKSB7XG4gICAgICBjb25zdCBwYWlyS2V5ID0gcGFpci5lbnRpdHlBLmlkIDwgcGFpci5lbnRpdHlCLmlkID8gXG4gICAgICAgIGAke3BhaXIuZW50aXR5QS5pZH0tJHtwYWlyLmVudGl0eUIuaWR9YCA6IFxuICAgICAgICBgJHtwYWlyLmVudGl0eUIuaWR9LSR7cGFpci5lbnRpdHlBLmlkfWA7XG5cbiAgICAgIGN1cnJlbnRDb2xsaXNpb25zLnNldChwYWlyS2V5LCBwYWlyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyBjb2xsaXNpb25cbiAgICAgIGlmICghdGhpcy5hY3RpdmVDb2xsaXNpb25zLmhhcyhwYWlyS2V5KSkge1xuICAgICAgICAvLyBOZXcgY29sbGlzaW9uIC0gdHJpZ2dlciBlbnRlciBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmdvaW5nIGNvbGxpc2lvbiAtIHRyaWdnZXIgc3RheSBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uU3RheShwYWlyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29sbGlzaW9ucyB0aGF0IGVuZGVkXG4gICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmZvckVhY2goKHBhaXIsIHBhaXJLZXkpID0+IHtcbiAgICAgIGlmICghY3VycmVudENvbGxpc2lvbnMuaGFzKHBhaXJLZXkpKSB7XG4gICAgICAgIC8vIENvbGxpc2lvbiBlbmRlZCAtIHRyaWdnZXIgZXhpdCBldmVudHNcbiAgICAgICAgdGhpcy50cmlnZ2VyQ29sbGlzaW9uRXhpdChwYWlyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgY29sbGlzaW9uc1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucyA9IGN1cnJlbnRDb2xsaXNpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyQ29sbGlzaW9uRW50ZXIocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25UcmlnZ2VyRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckVudGVyPy4ocGFpci5jb2xsaWRlckEsIHBhaXIuZW50aXR5QSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbGxpc2lvbiBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uQ29sbGlzaW9uRW50ZXI/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25TdGF5KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlclN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25TdGF5Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvblN0YXk/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJDb2xsaXNpb25FeGl0KHBhaXI6IENvbGxpc2lvblBhaXIpOiB2b2lkIHtcbiAgICBpZiAocGFpci5jb2xsaWRlckEuaXNUcmlnZ2VyIHx8IHBhaXIuY29sbGlkZXJCLmlzVHJpZ2dlcikge1xuICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgIHBhaXIuY29sbGlkZXJBLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQiwgcGFpci5lbnRpdHlCKTtcbiAgICAgIHBhaXIuY29sbGlkZXJCLm9uVHJpZ2dlckV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29sbGlzaW9uIGV2ZW50c1xuICAgICAgcGFpci5jb2xsaWRlckEub25Db2xsaXNpb25FeGl0Py4ocGFpci5jb2xsaWRlckIsIHBhaXIuZW50aXR5Qik7XG4gICAgICBwYWlyLmNvbGxpZGVyQi5vbkNvbGxpc2lvbkV4aXQ/LihwYWlyLmNvbGxpZGVyQSwgcGFpci5lbnRpdHlBKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb25zKCk6IHZvaWQge1xuICAgIC8vIFJlc29sdmUgcGh5c2ljYWwgY29sbGlzaW9ucyAobm9uLXRyaWdnZXIpXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuY29sbGlzaW9uUGFpcnMpIHtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1RyaWdnZXIgfHwgcGFpci5jb2xsaWRlckIuaXNUcmlnZ2VyKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIHRyaWdnZXJzXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzb2x2ZUNvbGxpc2lvbihwYWlyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVDb2xsaXNpb24ocGFpcjogQ29sbGlzaW9uUGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHRyYW5zZm9ybUEgPSBwYWlyLmVudGl0eUEuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IHRyYW5zZm9ybUIgPSBwYWlyLmVudGl0eUIuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuXG4gICAgY29uc3QgcG9zQSA9IHRyYW5zZm9ybUEuZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBvc0IgPSB0cmFuc2Zvcm1CLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgIC8vIENhbGN1bGF0ZSBzZXBhcmF0aW9uIHZlY3RvciB3aXRoIHNhZmV0eSBjaGVja3NcbiAgICBpZiAoIXBvc0EgfHwgIXBvc0EuY2xvbmUgfHwgIXBvc0IgfHwgIXBvc0IuY2xvbmUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ29sbGlzaW9uU3lzdGVtOiBJbnZhbGlkIHBvc2l0aW9ucyBmb3IgY29sbGlzaW9uIHJlc29sdXRpb24nLCB7IHBvc0EsIHBvc0IgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlcGFyYXRpb24gPSBwb3NBLmNsb25lKCkuc3ViKHBvc0IpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gc2VwYXJhdGlvbi5sZW5ndGgoKTtcblxuICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgLy8gT2JqZWN0cyBhcmUgYXQgZXhhY3Qgc2FtZSBwb3NpdGlvbiwgc2VwYXJhdGUgYWxvbmcgWSBheGlzXG4gICAgICBzZXBhcmF0aW9uLnNldCgwLCAxLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VwYXJhdGlvbi5ub3JtYWxpemUoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgcmVxdWlyZWQgc2VwYXJhdGlvbiBkaXN0YW5jZVxuICAgIGxldCByZXF1aXJlZFNlcGFyYXRpb24gPSAwO1xuICAgIFxuICAgIGlmIChwYWlyLmNvbGxpZGVyQS50eXBlID09PSAnc3BoZXJlJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnc3BoZXJlJykge1xuICAgICAgcmVxdWlyZWRTZXBhcmF0aW9uID0gcGFpci5jb2xsaWRlckEucmFkaXVzICsgcGFpci5jb2xsaWRlckIucmFkaXVzO1xuICAgIH0gZWxzZSBpZiAocGFpci5jb2xsaWRlckEudHlwZSA9PT0gJ3NwaGVyZScgJiYgcGFpci5jb2xsaWRlckIudHlwZSA9PT0gJ2N5bGluZGVyJykge1xuICAgICAgLy8gUGxheWVyIChzcGhlcmUpIHZzIFBpbGxhciAoY3lsaW5kZXIpIGNvbGxpc2lvblxuICAgICAgcmVxdWlyZWRTZXBhcmF0aW9uID0gcGFpci5jb2xsaWRlckEucmFkaXVzICsgcGFpci5jb2xsaWRlckIucmFkaXVzO1xuICAgIH0gZWxzZSBpZiAocGFpci5jb2xsaWRlckEudHlwZSA9PT0gJ2N5bGluZGVyJyAmJiBwYWlyLmNvbGxpZGVyQi50eXBlID09PSAnc3BoZXJlJykge1xuICAgICAgLy8gUGlsbGFyIChjeWxpbmRlcikgdnMgUGxheWVyIChzcGhlcmUpIGNvbGxpc2lvblxuICAgICAgcmVxdWlyZWRTZXBhcmF0aW9uID0gcGFpci5jb2xsaWRlckEucmFkaXVzICsgcGFpci5jb2xsaWRlckIucmFkaXVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igb3RoZXIgc2hhcGVzLCB1c2UgYSBzaW1wbGUgYXBwcm94aW1hdGlvblxuICAgICAgY29uc3QgcmFkaXVzQSA9IHRoaXMuZ2V0QXBwcm94aW1hdGVSYWRpdXMocGFpci5jb2xsaWRlckEpO1xuICAgICAgY29uc3QgcmFkaXVzQiA9IHRoaXMuZ2V0QXBwcm94aW1hdGVSYWRpdXMocGFpci5jb2xsaWRlckIpO1xuICAgICAgcmVxdWlyZWRTZXBhcmF0aW9uID0gcmFkaXVzQSArIHJhZGl1c0I7XG4gICAgfVxuXG4gICAgY29uc3Qgb3ZlcmxhcCA9IHJlcXVpcmVkU2VwYXJhdGlvbiAtIGRpc3RhbmNlO1xuICAgIGlmIChvdmVybGFwID4gMCkge1xuICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3IgcGlsbGFyIGNvbGxpc2lvbnNcbiAgICAgIGlmICgocGFpci5jb2xsaWRlckEubGF5ZXIgPT09IDIgJiYgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IDE2KSB8fCBcbiAgICAgICAgICAocGFpci5jb2xsaWRlckEubGF5ZXIgPT09IDE2ICYmIHBhaXIuY29sbGlkZXJCLmxheWVyID09PSAyKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+Pm++4jyBQaWxsYXIgY29sbGlzaW9uIGRldGVjdGVkISBEaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgUmVxdWlyZWQ6ICR7cmVxdWlyZWRTZXBhcmF0aW9uLnRvRml4ZWQoMil9LCBPdmVybGFwOiAke292ZXJsYXAudG9GaXhlZCgyKX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRm9yIHN0YXRpYyBvYmplY3RzIChsaWtlIHBpbGxhcnMpLCBhcHBseSBzdHJvbmdlciBzZXBhcmF0aW9uIHRvIHByZXZlbnQgcGVuZXRyYXRpb25cbiAgICAgIGxldCBzZXBhcmF0aW9uTXVsdGlwbGllciA9IDEuMDtcbiAgICAgIGlmIChwYWlyLmNvbGxpZGVyQS5pc1N0YXRpYyB8fCBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICBzZXBhcmF0aW9uTXVsdGlwbGllciA9IDEuMTsgLy8gMTAlIGV4dHJhIHNlcGFyYXRpb24gZm9yIHN0YXRpYyBvYmplY3RzXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNlcGFyYXRlIG9iamVjdHMgLSB1c2UgZW5oYW5jZWQgc2VwYXJhdGlvbiBmb3Igc3RhdGljIG9iamVjdHNcbiAgICAgIGNvbnN0IHNlcGFyYXRpb25WZWN0b3IgPSBzZXBhcmF0aW9uLm11bHRpcGx5U2NhbGFyKG92ZXJsYXAgKiBzZXBhcmF0aW9uTXVsdGlwbGllcik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGVudGl0aWVzIGhhdmUgTW92ZW1lbnQgY29tcG9uZW50cyBmb3IgaW50ZWxsaWdlbnQgc2VwYXJhdGlvbiBkaXN0cmlidXRpb25cbiAgICAgIGNvbnN0IG1vdmVtZW50QSA9IHBhaXIuZW50aXR5QS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgY29uc3QgbW92ZW1lbnRCID0gcGFpci5lbnRpdHlCLmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBzZXBhcmF0aW9uIGRpc3RyaWJ1dGlvbiBiYXNlZCBvbiBNb3ZlbWVudCBjb21wb25lbnRzIGFuZCBzdGF0aWMgc3RhdHVzXG4gICAgICBsZXQgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjU7IC8vIERlZmF1bHQ6IHNwbGl0IHNlcGFyYXRpb24gZXF1YWxseVxuICAgICAgbGV0IHNlcGFyYXRpb25GYWN0b3JCID0gMC41O1xuICAgICAgXG4gICAgICBpZiAocGFpci5jb2xsaWRlckEuaXNTdGF0aWMgJiYgIXBhaXIuY29sbGlkZXJCLmlzU3RhdGljKSB7XG4gICAgICAgIC8vIEEgaXMgc3RhdGljLCBCIG1vdmVzIC0gQiB0YWtlcyBhbGwgc2VwYXJhdGlvblxuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDA7XG4gICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoIXBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmIHBhaXIuY29sbGlkZXJCLmlzU3RhdGljKSB7XG4gICAgICAgIC8vIEIgaXMgc3RhdGljLCBBIG1vdmVzIC0gQSB0YWtlcyBhbGwgc2VwYXJhdGlvblxuICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDE7XG4gICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoIXBhaXIuY29sbGlkZXJBLmlzU3RhdGljICYmICFwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYykge1xuICAgICAgICAvLyBCb3RoIG5vbi1zdGF0aWMgLSBjaGVjayBmb3IgUFZQIHNjZW5hcmlvIChib3RoIHBsYXllcnMpXG4gICAgICAgIGNvbnN0IGlzUGxheWVyQSA9IHBhaXIuY29sbGlkZXJBLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVI7XG4gICAgICAgIGNvbnN0IGlzUGxheWVyQiA9IHBhaXIuY29sbGlkZXJCLmxheWVyID09PSBDb2xsaXNpb25MYXllci5QTEFZRVIgfHwgcGFpci5jb2xsaWRlckIubGF5ZXIgPT09IENvbGxpc2lvbkxheWVyLkVORU1ZO1xuICAgICAgICBcbiAgICAgICAgaWYgKGlzUGxheWVyQSAmJiBpc1BsYXllckIpIHtcbiAgICAgICAgICAvLyBQVlAgY29sbGlzaW9uOiBjaGVjayBjYW5Nb3ZlIHByb3BlcnR5IGZvciBmYWlyIGNvbGxpc2lvbiByZXNvbHV0aW9uXG4gICAgICAgICAgY29uc3QgY2FuTW92ZUEgPSBtb3ZlbWVudEEgPyBtb3ZlbWVudEEuY2FuTW92ZSA6IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNhbk1vdmVCID0gbW92ZW1lbnRCID8gbW92ZW1lbnRCLmNhbk1vdmUgOiBmYWxzZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2FuTW92ZUEgJiYgY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIEJvdGggcGxheWVycyBjYW4gbW92ZSAtIGVxdWFsIGRpc3RyaWJ1dGlvbiBmb3IgZmFpciBnYW1lcGxheVxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjU7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuNTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNhbk1vdmVBICYmICFjYW5Nb3ZlQikge1xuICAgICAgICAgICAgLy8gT25seSBBIGNhbiBtb3ZlIChsb2NhbCBwbGF5ZXIpLCBCIGlzIHBvc2l0aW9uLXN5bmNlZCAocmVtb3RlIHBsYXllcilcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JBID0gMS4wO1xuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckIgPSAwLjA7XG4gICAgICAgICAgfSBlbHNlIGlmICghY2FuTW92ZUEgJiYgY2FuTW92ZUIpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgQiBjYW4gbW92ZSAobG9jYWwgcGxheWVyKSwgQSBpcyBwb3NpdGlvbi1zeW5jZWQgKHJlbW90ZSBwbGF5ZXIpXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDAuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMS4wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOZWl0aGVyIGNhbiBtb3ZlIC0gbm8gc2VwYXJhdGlvbiAoc2hvdWxkbid0IGhhcHBlbiBpbiBQVlApXG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDAuMDtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC4wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb24tUFZQIGNvbGxpc2lvbiAtIGRpc3RyaWJ1dGUgYmFzZWQgb24gTW92ZW1lbnQgY29tcG9uZW50c1xuICAgICAgICAgIGlmIChtb3ZlbWVudEEgJiYgIW1vdmVtZW50Qikge1xuICAgICAgICAgICAgLy8gQSBoYXMgTW92ZW1lbnQsIEIgZG9lc24ndFxuICAgICAgICAgICAgc2VwYXJhdGlvbkZhY3RvckEgPSAwLjg7XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQiA9IDAuMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFtb3ZlbWVudEEgJiYgbW92ZW1lbnRCKSB7XG4gICAgICAgICAgICAvLyBCIGhhcyBNb3ZlbWVudCwgQSBkb2Vzbid0XG4gICAgICAgICAgICBzZXBhcmF0aW9uRmFjdG9yQSA9IDAuMjtcbiAgICAgICAgICAgIHNlcGFyYXRpb25GYWN0b3JCID0gMC44O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBib3RoIGhhdmUgTW92ZW1lbnQgb3IgbmVpdGhlciBoYXMgTW92ZW1lbnQsIHVzZSBlcXVhbCBkaXN0cmlidXRpb24gKDAuNSwgMC41KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHNlcGFyYXRpb24gd2l0aCBjYWxjdWxhdGVkIGZhY3RvcnNcbiAgICAgIGlmIChzZXBhcmF0aW9uRmFjdG9yQSA+IDAgJiYgc2VwYXJhdGlvblZlY3RvciAmJiBzZXBhcmF0aW9uVmVjdG9yLmNsb25lKSB7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb25BID0gc2VwYXJhdGlvblZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHNlcGFyYXRpb25GYWN0b3JBKTtcbiAgICAgICAgdHJhbnNmb3JtQS50cmFuc2xhdGUoc2VwYXJhdGlvbkEueCwgc2VwYXJhdGlvbkEueSwgc2VwYXJhdGlvbkEueik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIHN0b3AgbW92ZW1lbnQgdmVsb2NpdHkgZm9yIHBsYXllciB3aGVuIGhpdHRpbmcgc3RhdGljIG9iamVjdHNcbiAgICAgICAgaWYgKG1vdmVtZW50QSAmJiBwYWlyLmNvbGxpZGVyQi5pc1N0YXRpYyAmJiBtb3ZlbWVudEEudmVsb2NpdHkgJiYgbW92ZW1lbnRBLnZlbG9jaXR5LmNsb25lICYmIHNlcGFyYXRpb24gJiYgc2VwYXJhdGlvbi5jbG9uZSkge1xuICAgICAgICAgIC8vIFByb2plY3QgdmVsb2NpdHkgdG8gcmVtb3ZlIGNvbXBvbmVudCB0b3dhcmRzIHRoZSBzdGF0aWMgb2JqZWN0XG4gICAgICAgICAgY29uc3QgdmVsb2NpdHlUb3dhcmRzU3RhdGljID0gbW92ZW1lbnRBLnZlbG9jaXR5LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKHNlcGFyYXRpb24uY2xvbmUoKS5uZWdhdGUoKSk7XG4gICAgICAgICAgaWYgKHZlbG9jaXR5VG93YXJkc1N0YXRpYy5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgIG1vdmVtZW50QS52ZWxvY2l0eS5zdWIodmVsb2NpdHlUb3dhcmRzU3RhdGljKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHNlcGFyYXRpb25GYWN0b3JCID4gMCkge1xuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQiA9IHNlcGFyYXRpb25WZWN0b3IuY2xvbmUoKS5tdWx0aXBseVNjYWxhcigtc2VwYXJhdGlvbkZhY3RvckIpO1xuICAgICAgICB0cmFuc2Zvcm1CLnRyYW5zbGF0ZShzZXBhcmF0aW9uQi54LCBzZXBhcmF0aW9uQi55LCBzZXBhcmF0aW9uQi56KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsc28gc3RvcCBtb3ZlbWVudCB2ZWxvY2l0eSBmb3IgcGxheWVyIHdoZW4gaGl0dGluZyBzdGF0aWMgb2JqZWN0c1xuICAgICAgICBpZiAobW92ZW1lbnRCICYmIHBhaXIuY29sbGlkZXJBLmlzU3RhdGljKSB7XG4gICAgICAgICAgLy8gUHJvamVjdCB2ZWxvY2l0eSB0byByZW1vdmUgY29tcG9uZW50IHRvd2FyZHMgdGhlIHN0YXRpYyBvYmplY3RcbiAgICAgICAgICBjb25zdCB2ZWxvY2l0eVRvd2FyZHNTdGF0aWMgPSBtb3ZlbWVudEIudmVsb2NpdHkuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3Ioc2VwYXJhdGlvbik7XG4gICAgICAgICAgaWYgKHZlbG9jaXR5VG93YXJkc1N0YXRpYy5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgICAgIG1vdmVtZW50Qi52ZWxvY2l0eS5zdWIodmVsb2NpdHlUb3dhcmRzU3RhdGljKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEFwcHJveGltYXRlUmFkaXVzKGNvbGxpZGVyOiBDb2xsaWRlcik6IG51bWJlciB7XG4gICAgc3dpdGNoIChjb2xsaWRlci50eXBlKSB7XG4gICAgICBjYXNlICdzcGhlcmUnOlxuICAgICAgICByZXR1cm4gY29sbGlkZXIucmFkaXVzO1xuICAgICAgY2FzZSAnYm94JzpcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNvbGxpZGVyLnNpemUueCwgY29sbGlkZXIuc2l6ZS55LCBjb2xsaWRlci5zaXplLnopICogMC41O1xuICAgICAgY2FzZSAnY2Fwc3VsZSc6XG4gICAgICBjYXNlICdjeWxpbmRlcic6XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjb2xsaWRlci5yYWRpdXMsIGNvbGxpZGVyLmhlaWdodCAqIDAuNSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMC41O1xuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3Igb3RoZXIgc3lzdGVtc1xuICBwdWJsaWMgcXVlcnlDb2xsaWRlcnMoYm91bmRzOiBCb3gzKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KGJvdW5kcyk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgcXVlcnlDb2xsaWRlcnNSYWRpdXMoY2VudGVyOiBWZWN0b3IzLCByYWRpdXM6IG51bWJlcik6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeVJhZGl1cyhjZW50ZXIsIHJhZGl1cyk7XG4gICAgcmV0dXJuIGVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgcXVlcnlDb2xsaWRlcnNQb2ludChwb2ludDogVmVjdG9yMyk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeVBvaW50KHBvaW50KTtcbiAgICByZXR1cm4gZW50cmllcy5tYXAoZW50cnkgPT4gZW50cnkuZW50aXR5KTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb2xsaWRlcnNJbkxheWVyKGxheWVyOiBDb2xsaXNpb25MYXllciwgYm91bmRzPzogQm94Myk6IEVudGl0eVtdIHtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gYm91bmRzID8gdGhpcy5zcGF0aWFsSGFzaC5xdWVyeShib3VuZHMpIDogQXJyYXkuZnJvbSh0aGlzLnNwYXRpYWxIYXNoWydlbnRpdHlDZWxscyddLmtleXMoKSkubWFwKGlkID0+IHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSB0aGlzLnNwYXRpYWxIYXNoLnF1ZXJ5KG5ldyBCb3gzKCkuc2V0RnJvbUNlbnRlckFuZFNpemUobmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoMTAwMCwgMTAwMCwgMTAwMCkpKTtcbiAgICAgIHJldHVybiBlbnRyaWVzLmZpbmQoZSA9PiBlLmVudGl0eS5pZCA9PT0gaWQpO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKSBhcyBhbnlbXTtcblxuICAgIHJldHVybiBjYW5kaWRhdGVzXG4gICAgICAuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSBlbnRyeS5lbnRpdHkuZ2V0Q29tcG9uZW50KENvbGxpZGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbGxpZGVyICYmIGNvbGxpZGVyLmxheWVyID09PSBsYXllcjtcbiAgICAgIH0pXG4gICAgICAubWFwKGVudHJ5ID0+IGVudHJ5LmVudGl0eSk7XG4gIH1cblxuICAvLyBQZXJmb3JtYW5jZSBhbmQgZGVidWdnaW5nXG4gIHB1YmxpYyBnZXRQZXJmb3JtYW5jZVN0YXRzKCk6IHtcbiAgICBjb2xsaXNpb25DaGVja3M6IG51bWJlcjtcbiAgICBhY3R1YWxDb2xsaXNpb25zOiBudW1iZXI7XG4gICAgYWN0aXZlQ29sbGlzaW9uczogbnVtYmVyO1xuICAgIHNwYXRpYWxIYXNoU3RhdHM6IGFueTtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbGxpc2lvbkNoZWNrczogdGhpcy5jb2xsaXNpb25DaGVja3MsXG4gICAgICBhY3R1YWxDb2xsaXNpb25zOiB0aGlzLmFjdHVhbENvbGxpc2lvbnMsXG4gICAgICBhY3RpdmVDb2xsaXNpb25zOiB0aGlzLmFjdGl2ZUNvbGxpc2lvbnMuc2l6ZSxcbiAgICAgIHNwYXRpYWxIYXNoU3RhdHM6IHRoaXMuc3BhdGlhbEhhc2guZ2V0U3RhdHMoKVxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgb25FbnRpdHlSZW1vdmVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgc3BhdGlhbCBoYXNoIHdoZW4gZW50aXR5IGlzIHJlbW92ZWRcbiAgICB0aGlzLnNwYXRpYWxIYXNoLnJlbW92ZShlbnRpdHkpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSBjb2xsaXNpb25zXG4gICAgY29uc3Qga2V5c1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdO1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5mb3JFYWNoKChwYWlyLCBrZXkpID0+IHtcbiAgICAgIGlmIChwYWlyLmVudGl0eUEuaWQgPT09IGVudGl0eS5pZCB8fCBwYWlyLmVudGl0eUIuaWQgPT09IGVudGl0eS5pZCkge1xuICAgICAgICBrZXlzVG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXNUb1JlbW92ZSkge1xuICAgICAgdGhpcy5hY3RpdmVDb2xsaXNpb25zLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkRpc2FibGUoKTogdm9pZCB7XG4gICAgdGhpcy5zcGF0aWFsSGFzaC5jbGVhcigpO1xuICAgIHRoaXMuYWN0aXZlQ29sbGlzaW9ucy5jbGVhcigpO1xuICAgIHRoaXMuY29sbGlzaW9uUGFpcnMubGVuZ3RoID0gMDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJCb3gzIiwiUGh5c2ljc1N5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIlNwYXRpYWxIYXNoIiwiQ29sbGlzaW9uU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJ1cGRhdGVTcGF0aWFsSGFzaCIsImRldGVjdENvbGxpc2lvbnMiLCJwcm9jZXNzQ29sbGlzaW9uQ2FsbGJhY2tzIiwicmVzb2x2ZUNvbGxpc2lvbnMiLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwiZW50aXR5IiwidHJhbnNmb3JtIiwiZ2V0Q29tcG9uZW50IiwiY29sbGlkZXIiLCJlbmFibGVkIiwic3BhdGlhbEhhc2giLCJyZW1vdmUiLCJ1cGRhdGVCb3VuZHMiLCJnZXRXb3JsZFBvc2l0aW9uIiwiYm91bmRzIiwiY29sbGlzaW9uUGFpcnMiLCJsZW5ndGgiLCJjb2xsaXNpb25DaGVja3MiLCJhY3R1YWxDb2xsaXNpb25zIiwicHJvY2Vzc2VkUGFpcnMiLCJTZXQiLCJjYW5kaWRhdGVzIiwicXVlcnkiLCJjYW5kaWRhdGUiLCJvdGhlckVudGl0eSIsImlkIiwicGFpcktleSIsImhhcyIsImFkZCIsIm90aGVyVHJhbnNmb3JtIiwib3RoZXJDb2xsaWRlciIsImNhbkNvbGxpZGVXaXRoIiwiaW50ZXJzZWN0cyIsImxheWVyIiwiY29uc29sZSIsImxvZyIsInBhaXIiLCJlbnRpdHlBIiwiZW50aXR5QiIsImNvbGxpZGVyQSIsImNvbGxpZGVyQiIsInB1c2giLCJjdXJyZW50Q29sbGlzaW9ucyIsIk1hcCIsInNldCIsImFjdGl2ZUNvbGxpc2lvbnMiLCJ0cmlnZ2VyQ29sbGlzaW9uRW50ZXIiLCJ0cmlnZ2VyQ29sbGlzaW9uU3RheSIsImZvckVhY2giLCJ0cmlnZ2VyQ29sbGlzaW9uRXhpdCIsImlzVHJpZ2dlciIsIm9uVHJpZ2dlckVudGVyIiwib25Db2xsaXNpb25FbnRlciIsIm9uVHJpZ2dlclN0YXkiLCJvbkNvbGxpc2lvblN0YXkiLCJvblRyaWdnZXJFeGl0Iiwib25Db2xsaXNpb25FeGl0IiwicmVzb2x2ZUNvbGxpc2lvbiIsInRyYW5zZm9ybUEiLCJ0cmFuc2Zvcm1CIiwicG9zQSIsInBvc0IiLCJjbG9uZSIsIndhcm4iLCJzZXBhcmF0aW9uIiwic3ViIiwiZGlzdGFuY2UiLCJub3JtYWxpemUiLCJyZXF1aXJlZFNlcGFyYXRpb24iLCJ0eXBlIiwicmFkaXVzIiwicmFkaXVzQSIsImdldEFwcHJveGltYXRlUmFkaXVzIiwicmFkaXVzQiIsIm92ZXJsYXAiLCJ0b0ZpeGVkIiwic2VwYXJhdGlvbk11bHRpcGxpZXIiLCJpc1N0YXRpYyIsInNlcGFyYXRpb25WZWN0b3IiLCJtdWx0aXBseVNjYWxhciIsIm1vdmVtZW50QSIsIm1vdmVtZW50QiIsInNlcGFyYXRpb25GYWN0b3JBIiwic2VwYXJhdGlvbkZhY3RvckIiLCJpc1BsYXllckEiLCJQTEFZRVIiLCJpc1BsYXllckIiLCJFTkVNWSIsImNhbk1vdmVBIiwiY2FuTW92ZSIsImNhbk1vdmVCIiwic2VwYXJhdGlvbkEiLCJ0cmFuc2xhdGUiLCJ4IiwieSIsInoiLCJ2ZWxvY2l0eSIsInZlbG9jaXR5VG93YXJkc1N0YXRpYyIsInByb2plY3RPblZlY3RvciIsIm5lZ2F0ZSIsInNlcGFyYXRpb25CIiwiTWF0aCIsIm1heCIsInNpemUiLCJoZWlnaHQiLCJxdWVyeUNvbGxpZGVycyIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsInF1ZXJ5Q29sbGlkZXJzUmFkaXVzIiwiY2VudGVyIiwicXVlcnlSYWRpdXMiLCJxdWVyeUNvbGxpZGVyc1BvaW50IiwicG9pbnQiLCJxdWVyeVBvaW50IiwiZ2V0Q29sbGlkZXJzSW5MYXllciIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJzZXRGcm9tQ2VudGVyQW5kU2l6ZSIsImZpbmQiLCJlIiwiZmlsdGVyIiwiQm9vbGVhbiIsImdldFBlcmZvcm1hbmNlU3RhdHMiLCJzcGF0aWFsSGFzaFN0YXRzIiwiZ2V0U3RhdHMiLCJvbkVudGl0eVJlbW92ZWQiLCJrZXlzVG9SZW1vdmUiLCJrZXkiLCJkZWxldGUiLCJvbkRpc2FibGUiLCJjbGVhciIsImNvbnN0cnVjdG9yIiwiY2VsbFNpemUiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJsYXN0VXBkYXRlVGltZSIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CollisionSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/CombatSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/CombatSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CombatSystem: function() { return /* binding */ CombatSystem; }\n/* harmony export */ });\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Shield */ \"(app-pages-browser)/./src/ecs/components/Shield.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/core/DamageCalculator */ \"(app-pages-browser)/./src/core/DamageCalculator.ts\");\n/* harmony import */ var _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/DamageNumberManager */ \"(app-pages-browser)/./src/utils/DamageNumberManager.ts\");\n// Combat system for handling damage, healing, and combat mechanics\n\n\n\n\n\n\n\n\n\nclass CombatSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_0__.System {\n    // Set callback for routing enemy damage to multiplayer server\n    setEnemyDamageCallback(callback) {\n        this.onEnemyDamageCallback = callback;\n    }\n    // Set callback for routing player damage to multiplayer server (PVP)\n    setPlayerDamageCallback(callback) {\n        this.onPlayerDamageCallback = callback;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000;\n        // Update health components (regeneration, invulnerability timers)\n        this.updateHealthComponents(entities, deltaTime, currentTime);\n        // Process damage queue\n        this.processDamageQueue(currentTime);\n        // Process heal queue\n        this.processHealQueue(currentTime);\n        // Handle death and respawn\n        this.handleDeathAndRespawn(entities, currentTime);\n        // Cleanup old damage numbers\n        this.damageNumberManager.cleanup();\n        // Clear processed queues\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n    }\n    updateHealthComponents(entities, deltaTime, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            // Skip if required Health component is missing\n            if (!health || !health.enabled) continue;\n            // Update health component (handles regeneration and invulnerability)\n            health.update(deltaTime, currentTime);\n            // Update shield component if it exists\n            const shield = entity.getComponent(_ecs_components_Shield__WEBPACK_IMPORTED_MODULE_2__.Shield);\n            if (shield) {\n                shield.update(deltaTime);\n            }\n            // Update freeze status for enemies\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (enemy) {\n                enemy.updateFreezeStatus(currentTime);\n            }\n        }\n    }\n    processDamageQueue(currentTime) {\n        for (const damageEvent of this.damageQueue){\n            this.applyDamage(damageEvent, currentTime);\n        }\n    }\n    processHealQueue(currentTime) {\n        for (const healEvent of this.healQueue){\n            this.applyHealing(healEvent, currentTime);\n        }\n    }\n    applyDamage(damageEvent, currentTime) {\n        const { target, damage: baseDamage, source, damageType } = damageEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Debug: Log all damage events for charge damage\n        if (damageType === \"charge\") {\n            const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(target.id, \")\");\n            console.log(\"⚔️ CombatSystem processing charge damage: \".concat(baseDamage, \" to \").concat(entityType, \", source: \").concat(source === null || source === void 0 ? void 0 : source.id, \", hasPlayerCallback: \").concat(!!this.onPlayerDamageCallback));\n        }\n        // Check if target is an enemy - if so, route damage through multiplayer\n        const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy && this.onEnemyDamageCallback) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route enemy damage through multiplayer server instead of applying locally\n            console.log(\"\\uD83C\\uDF10 Routing \".concat(actualDamage, \" damage to enemy \").concat(target.id, \" through multiplayer server\"));\n            this.onEnemyDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            // Log for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            console.log(\"\\uD83D\\uDCA5 \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (routed to server)\"));\n            return; // Don't apply damage locally for enemies\n        }\n        // Check if target is a player in PVP mode - if so, route damage through multiplayer\n        // Also prevent self-damage in PVP (source hitting themselves)\n        if (!enemy && this.onPlayerDamageCallback && source && source.id !== target.id) {\n            // Calculate actual damage with critical hit mechanics\n            const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n            const actualDamage = damageResult.damage;\n            // Route player damage through multiplayer server for PVP\n            console.log(\"⚔️ Routing \".concat(actualDamage, \" PVP damage to player \").concat(target.id, \" through multiplayer server\"));\n            this.onPlayerDamageCallback(target.id.toString(), actualDamage);\n            // Still create local damage numbers for immediate visual feedback\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    position.y += 1.5;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType || \"pvp\");\n                } else {\n                    console.warn(\"⚠️ Skipping PVP damage number creation - invalid position:\", position);\n                }\n            }\n            // Log for debugging\n            const sourceName = source ? \"Player \".concat(source.id) : \"Unknown\";\n            const targetName = \"Player \".concat(target.id);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            console.log(\"⚔️ \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" PVP \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (routed to server)\"));\n            return; // Don't apply damage locally for PVP players\n        }\n        // For non-enemies (like players in non-PVP mode), apply damage locally as before\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(baseDamage);\n        const actualDamage = damageResult.damage;\n        // Apply damage (pass entity so Health can use Shield component)\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Only create damage number if position is valid\n                if (position && position.x !== undefined && position.y !== undefined && position.z !== undefined) {\n                    // Offset slightly above the target\n                    position.y += 3;\n                    this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n                } else {\n                    console.warn(\"⚠️ Skipping damage number creation - invalid position:\", position);\n                }\n            }\n            // Log damage for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            const critText = damageResult.isCritical ? \" CRITICAL\" : \"\";\n            console.log(\"\\uD83D\\uDCA5 \".concat(sourceName, \" dealt \").concat(actualDamage).concat(critText, \" \").concat(damageType || \"damage\", \" to \").concat(targetName, \" (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            // Check if target died\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            // Trigger damage effects\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n    }\n    applyHealing(healEvent, currentTime) {\n        const { target, amount, source } = healEvent;\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return;\n        // Apply healing\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            // Log healing for debugging\n            const sourceName = source ? \"Entity \".concat(source.id) : \"Unknown\";\n            const targetName = this.getEntityDisplayName(target);\n            console.log(\"\\uD83D\\uDC9A \".concat(sourceName, \" healed \").concat(targetName, \" for \").concat(amount, \" HP (\").concat(health.currentHealth, \"/\").concat(health.maxHealth, \" HP)\"));\n            // Trigger healing effects\n            this.triggerHealingEffects(target, amount, source);\n        }\n    }\n    handleEntityDeath(entity, killer, currentTime) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            enemy.die(currentTime || Date.now() / 1000);\n            this.enemiesKilled++;\n            console.log(\"\\uD83D\\uDC80 \".concat(enemy.getDisplayName(), \" has been defeated!\"));\n            // Award experience to killer if it's a player\n            if (killer) {\n                this.awardExperience(killer, enemy.experienceReward);\n            }\n            // Trigger death effects\n            this.triggerDeathEffects(entity, killer);\n        }\n        this.deadEntities.push(entity);\n    }\n    handleDeathAndRespawn(entities, currentTime) {\n        for (const entity of entities){\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n            const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n            if (!health || !enemy) continue;\n            // Handle respawn for enemies\n            if (enemy.isDead && enemy.canRespawnNow(currentTime)) {\n                this.respawnEnemy(entity, enemy, health);\n            }\n        }\n    }\n    respawnEnemy(entity, enemy, health) {\n        // Respawn the enemy\n        enemy.respawn();\n        health.revive();\n        console.log(\"\\uD83D\\uDD04 \".concat(enemy.getDisplayName(), \" has respawned!\"));\n        // Trigger respawn effects\n        this.triggerRespawnEffects(entity);\n    }\n    triggerDamageEffects(target, damage, source, damageType, isCritical) {\n        // This can be extended to trigger particle effects, screen shake, etc.\n        // For now, we'll just handle basic effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            // Could trigger damage number popup, blood effects, etc.\n            // For now, just log the position where damage occurred\n            const critText = isCritical ? \" (CRITICAL)\" : \"\";\n            console.log(\"\\uD83C\\uDFAF Damage effect\".concat(critText, \" at position:\"), transform.position);\n        }\n        // Handle special projectile effects\n        if (damageType === \"projectile\" && source) {\n            var _sourceRenderer_mesh_userData, _sourceRenderer_mesh;\n            const sourceRenderer = source.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            if (sourceRenderer === null || sourceRenderer === void 0 ? void 0 : (_sourceRenderer_mesh = sourceRenderer.mesh) === null || _sourceRenderer_mesh === void 0 ? void 0 : (_sourceRenderer_mesh_userData = _sourceRenderer_mesh.userData) === null || _sourceRenderer_mesh_userData === void 0 ? void 0 : _sourceRenderer_mesh_userData.isBarrageArrow) {\n                console.log(\"\\uD83C\\uDFF9 Barrage arrow hit detected, applying slow effect to target \".concat(target.id));\n                const targetMovement = target.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_6__.Movement);\n                if (targetMovement) {\n                    targetMovement.slow(5000, 0.5); // 5 seconds, 50% speed\n                    console.log(\"\\uD83D\\uDC0C Applied 50% slow for 5 seconds to target \".concat(target.id));\n                }\n            }\n        }\n    }\n    triggerHealingEffects(target, amount, source) {\n        // This can be extended to trigger healing particle effects\n        const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"✨ Healing effect at position:\", transform.position);\n        }\n    }\n    triggerDeathEffects(entity, killer) {\n        // This can be extended to trigger death animations, loot drops, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"\\uD83D\\uDC80 Death effect at position:\", transform.position);\n        }\n    }\n    triggerRespawnEffects(entity) {\n        // This can be extended to trigger respawn animations, effects, etc.\n        const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n        if (transform) {\n            console.log(\"\\uD83C\\uDF1F Respawn effect at position:\", transform.position);\n        }\n    }\n    awardExperience(entity, experience) {\n        // This would integrate with a progression system\n        console.log(\"⭐ Entity \".concat(entity.id, \" gained \").concat(experience, \" experience!\"));\n    }\n    getEntityDisplayName(entity) {\n        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_3__.Enemy);\n        if (enemy) {\n            return enemy.getDisplayName();\n        }\n        // Could check for other components that provide names\n        return \"Entity \".concat(entity.id);\n    }\n    // Public API for other systems to queue damage and healing\n    queueDamage(target, damage, source, damageType) {\n        this.damageQueue.push({\n            target,\n            damage,\n            source,\n            damageType,\n            timestamp: Date.now() / 1000\n        });\n    }\n    queueHealing(target, amount, source) {\n        this.healQueue.push({\n            target,\n            amount,\n            source,\n            timestamp: Date.now() / 1000\n        });\n    }\n    // Immediate damage/healing (bypasses queue)\n    dealDamageImmediate(target, damage, source, damageType) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        // Calculate actual damage with critical hit mechanics\n        const damageResult = (0,_core_DamageCalculator__WEBPACK_IMPORTED_MODULE_7__.calculateDamage)(damage);\n        const actualDamage = damageResult.damage;\n        const currentTime = Date.now() / 1000;\n        const damageDealt = health.takeDamage(actualDamage, currentTime, target);\n        if (damageDealt) {\n            this.totalDamageDealt += actualDamage;\n            // Create damage number at target position\n            const transform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_4__.Transform);\n            if (transform) {\n                const position = transform.getWorldPosition();\n                // Offset slightly above the target\n                position.y += 1.5;\n                this.damageNumberManager.addDamageNumber(actualDamage, damageResult.isCritical, position, damageType);\n            }\n            if (health.isDead) {\n                this.handleEntityDeath(target, source, currentTime);\n            }\n            this.triggerDamageEffects(target, actualDamage, source, damageType, damageResult.isCritical);\n        }\n        return damageDealt;\n    }\n    healImmediate(target, amount, source) {\n        const health = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        if (!health || !health.enabled) return false;\n        const healingDone = health.heal(amount);\n        if (healingDone) {\n            this.totalHealingDone += amount;\n            this.triggerHealingEffects(target, amount, source);\n        }\n        return healingDone;\n    }\n    // Utility methods\n    isEntityDead(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.isDead : false;\n    }\n    getEntityHealthRatio(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? health.getHealthRatio() : 0;\n    }\n    canEntityTakeDamage(entity) {\n        const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health);\n        return health ? !health.isDead && !health.isInvulnerable : false;\n    }\n    // Statistics and debugging\n    getCombatStats() {\n        return {\n            totalDamageDealt: this.totalDamageDealt,\n            totalHealingDone: this.totalHealingDone,\n            enemiesKilled: this.enemiesKilled,\n            queuedDamageEvents: this.damageQueue.length,\n            queuedHealEvents: this.healQueue.length\n        };\n    }\n    resetStats() {\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n    }\n    // Damage numbers management\n    getDamageNumbers() {\n        return this.damageNumberManager.getDamageNumbers();\n    }\n    removeDamageNumber(id) {\n        this.damageNumberManager.removeDamageNumber(id);\n    }\n    onDisable() {\n        this.damageQueue.length = 0;\n        this.healQueue.length = 0;\n        this.deadEntities.length = 0;\n        this.damageNumberManager.clear();\n        this.resetStats();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_1__.Health\n        ];\n        this.damageQueue = [];\n        this.healQueue = [];\n        this.deadEntities = [];\n        // Combat statistics\n        this.totalDamageDealt = 0;\n        this.totalHealingDone = 0;\n        this.enemiesKilled = 0;\n        this.world = world;\n        this.damageNumberManager = new _utils_DamageNumberManager__WEBPACK_IMPORTED_MODULE_8__.DamageNumberManager();\n        this.priority = 25; // Run after collision detection\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbWJhdFN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsbUVBQW1FO0FBQzdCO0FBRVc7QUFDQTtBQUNGO0FBQ1E7QUFDRjtBQUNBO0FBRW1CO0FBQ047QUFpQjNELE1BQU1TLHFCQUFxQlQsK0NBQU1BO0lBMEJ0Qyw4REFBOEQ7SUFDdkRVLHVCQUF1QkMsUUFBbUQsRUFBUTtRQUN2RixJQUFJLENBQUNDLHFCQUFxQixHQUFHRDtJQUMvQjtJQUVBLHFFQUFxRTtJQUM5REUsd0JBQXdCRixRQUFvRCxFQUFRO1FBQ3pGLElBQUksQ0FBQ0csc0JBQXNCLEdBQUdIO0lBQ2hDO0lBRU9JLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsTUFBTUMsY0FBY0MsS0FBS0MsR0FBRyxLQUFLO1FBRWpDLGtFQUFrRTtRQUNsRSxJQUFJLENBQUNDLHNCQUFzQixDQUFDTCxVQUFVQyxXQUFXQztRQUVqRCx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDSSxrQkFBa0IsQ0FBQ0o7UUFFeEIscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0ssZ0JBQWdCLENBQUNMO1FBRXRCLDJCQUEyQjtRQUMzQixJQUFJLENBQUNNLHFCQUFxQixDQUFDUixVQUFVRTtRQUVyQyw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDTyxtQkFBbUIsQ0FBQ0MsT0FBTztRQUVoQyx5QkFBeUI7UUFDekIsSUFBSSxDQUFDQyxXQUFXLENBQUNDLE1BQU0sR0FBRztRQUMxQixJQUFJLENBQUNDLFNBQVMsQ0FBQ0QsTUFBTSxHQUFHO1FBQ3hCLElBQUksQ0FBQ0UsWUFBWSxDQUFDRixNQUFNLEdBQUc7SUFDN0I7SUFFUVAsdUJBQXVCTCxRQUFrQixFQUFFQyxTQUFpQixFQUFFQyxXQUFtQixFQUFRO1FBQy9GLEtBQUssTUFBTWEsVUFBVWYsU0FBVTtZQUM3QixNQUFNZ0IsU0FBU0QsT0FBT0UsWUFBWSxDQUFDaEMsMERBQU1BO1lBRXpD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SSxDQUFDM0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDUyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNJLGFBQWEsR0FBRztJQUN2QjtJQUVBLDRCQUE0QjtJQUNyQitCLG1CQUFtQjtRQUN4QixPQUFPLElBQUksQ0FBQzFGLG1CQUFtQixDQUFDMEYsZ0JBQWdCO0lBQ2xEO0lBRU9DLG1CQUFtQm5FLEVBQVUsRUFBUTtRQUMxQyxJQUFJLENBQUN4QixtQkFBbUIsQ0FBQzJGLGtCQUFrQixDQUFDbkU7SUFDOUM7SUFFT29FLFlBQWtCO1FBQ3ZCLElBQUksQ0FBQzFGLFdBQVcsQ0FBQ0MsTUFBTSxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsU0FBUyxDQUFDRCxNQUFNLEdBQUc7UUFDeEIsSUFBSSxDQUFDRSxZQUFZLENBQUNGLE1BQU0sR0FBRztRQUMzQixJQUFJLENBQUNILG1CQUFtQixDQUFDNkYsS0FBSztRQUM5QixJQUFJLENBQUNKLFVBQVU7SUFDakI7SUFwZUFLLFlBQVlDLEtBQVksQ0FBRTtRQUN4QixLQUFLO2FBbkJTQyxxQkFBcUI7WUFBQ3hILDBEQUFNQTtTQUFDO2FBRXJDMEIsY0FBNkIsRUFBRTthQUMvQkUsWUFBeUIsRUFBRTthQUMzQkMsZUFBeUIsRUFBRTtRQUduQyxvQkFBb0I7YUFDWnlDLG1CQUFtQjthQUNuQlMsbUJBQW1CO2FBQ25CSSxnQkFBZ0I7UUFVdEIsSUFBSSxDQUFDb0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQy9GLG1CQUFtQixHQUFHLElBQUlqQiwyRUFBbUJBO1FBQ2xELElBQUksQ0FBQ2tILFFBQVEsR0FBRyxJQUFJLGdDQUFnQztJQUN0RDtBQWdlRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9Db21iYXRTeXN0ZW0udHM/YTYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21iYXQgc3lzdGVtIGZvciBoYW5kbGluZyBkYW1hZ2UsIGhlYWxpbmcsIGFuZCBjb21iYXQgbWVjaGFuaWNzXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IFNoaWVsZCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvU2hpZWxkJztcbmltcG9ydCB7IEVuZW15IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9FbmVteSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvUmVuZGVyZXInO1xuaW1wb3J0IHsgTW92ZW1lbnQgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL01vdmVtZW50JztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgY2FsY3VsYXRlRGFtYWdlLCBEYW1hZ2VSZXN1bHQgfSBmcm9tICdAL2NvcmUvRGFtYWdlQ2FsY3VsYXRvcic7XG5pbXBvcnQgeyBEYW1hZ2VOdW1iZXJNYW5hZ2VyIH0gZnJvbSAnQC91dGlscy9EYW1hZ2VOdW1iZXJNYW5hZ2VyJztcblxuaW50ZXJmYWNlIERhbWFnZUV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGRhbWFnZTogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIGRhbWFnZVR5cGU/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgSGVhbEV2ZW50IHtcbiAgdGFyZ2V0OiBFbnRpdHk7XG4gIGFtb3VudDogbnVtYmVyO1xuICBzb3VyY2U/OiBFbnRpdHk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQ29tYmF0U3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtIZWFsdGhdO1xuICBwcml2YXRlIHdvcmxkOiBXb3JsZDtcbiAgcHJpdmF0ZSBkYW1hZ2VRdWV1ZTogRGFtYWdlRXZlbnRbXSA9IFtdO1xuICBwcml2YXRlIGhlYWxRdWV1ZTogSGVhbEV2ZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBkZWFkRW50aXRpZXM6IEVudGl0eVtdID0gW107XG4gIHByaXZhdGUgZGFtYWdlTnVtYmVyTWFuYWdlcjogRGFtYWdlTnVtYmVyTWFuYWdlcjtcbiAgXG4gIC8vIENvbWJhdCBzdGF0aXN0aWNzXG4gIHByaXZhdGUgdG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gIHByaXZhdGUgdG90YWxIZWFsaW5nRG9uZSA9IDA7XG4gIHByaXZhdGUgZW5lbWllc0tpbGxlZCA9IDA7XG5cbiAgLy8gTXVsdGlwbGF5ZXIgZGFtYWdlIGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvbkVuZW15RGFtYWdlQ2FsbGJhY2s/OiAoZW5lbXlJZDogc3RyaW5nLCBkYW1hZ2U6IG51bWJlcikgPT4gdm9pZDtcbiAgXG4gIC8vIFBWUCBkYW1hZ2UgY2FsbGJhY2sgZm9yIHJvdXRpbmcgcGxheWVyIGRhbWFnZSB0byBzZXJ2ZXJcbiAgcHJpdmF0ZSBvblBsYXllckRhbWFnZUNhbGxiYWNrPzogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlciA9IG5ldyBEYW1hZ2VOdW1iZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5wcmlvcml0eSA9IDI1OyAvLyBSdW4gYWZ0ZXIgY29sbGlzaW9uIGRldGVjdGlvblxuICB9XG5cbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIGVuZW15IGRhbWFnZSB0byBtdWx0aXBsYXllciBzZXJ2ZXJcbiAgcHVibGljIHNldEVuZW15RGFtYWdlQ2FsbGJhY2soY2FsbGJhY2s6IChlbmVteUlkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgLy8gU2V0IGNhbGxiYWNrIGZvciByb3V0aW5nIHBsYXllciBkYW1hZ2UgdG8gbXVsdGlwbGF5ZXIgc2VydmVyIChQVlApXG4gIHB1YmxpYyBzZXRQbGF5ZXJEYW1hZ2VDYWxsYmFjayhjYWxsYmFjazogKHBsYXllcklkOiBzdHJpbmcsIGRhbWFnZTogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuXG4gICAgLy8gVXBkYXRlIGhlYWx0aCBjb21wb25lbnRzIChyZWdlbmVyYXRpb24sIGludnVsbmVyYWJpbGl0eSB0aW1lcnMpXG4gICAgdGhpcy51cGRhdGVIZWFsdGhDb21wb25lbnRzKGVudGl0aWVzLCBkZWx0YVRpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIFByb2Nlc3MgZGFtYWdlIHF1ZXVlXG4gICAgdGhpcy5wcm9jZXNzRGFtYWdlUXVldWUoY3VycmVudFRpbWUpO1xuXG4gICAgLy8gUHJvY2VzcyBoZWFsIHF1ZXVlXG4gICAgdGhpcy5wcm9jZXNzSGVhbFF1ZXVlKGN1cnJlbnRUaW1lKTtcblxuICAgIC8vIEhhbmRsZSBkZWF0aCBhbmQgcmVzcGF3blxuICAgIHRoaXMuaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzLCBjdXJyZW50VGltZSk7XG5cbiAgICAvLyBDbGVhbnVwIG9sZCBkYW1hZ2UgbnVtYmVyc1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhbnVwKCk7XG5cbiAgICAvLyBDbGVhciBwcm9jZXNzZWQgcXVldWVzXG4gICAgdGhpcy5kYW1hZ2VRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhbFF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZWFkRW50aXRpZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlSGVhbHRoQ29tcG9uZW50cyhlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyLCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBIZWFsdGggY29tcG9uZW50IGlzIG1pc3NpbmdcbiAgICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgY29udGludWU7XG5cbiAgICAgIC8vIFVwZGF0ZSBoZWFsdGggY29tcG9uZW50IChoYW5kbGVzIHJlZ2VuZXJhdGlvbiBhbmQgaW52dWxuZXJhYmlsaXR5KVxuICAgICAgaGVhbHRoLnVwZGF0ZShkZWx0YVRpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgLy8gVXBkYXRlIHNoaWVsZCBjb21wb25lbnQgaWYgaXQgZXhpc3RzXG4gICAgICBjb25zdCBzaGllbGQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFNoaWVsZCk7XG4gICAgICBpZiAoc2hpZWxkKSB7XG4gICAgICAgIHNoaWVsZC51cGRhdGUoZGVsdGFUaW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGZyZWV6ZSBzdGF0dXMgZm9yIGVuZW1pZXNcbiAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBpZiAoZW5lbXkpIHtcbiAgICAgICAgZW5lbXkudXBkYXRlRnJlZXplU3RhdHVzKGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NEYW1hZ2VRdWV1ZShjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBkYW1hZ2VFdmVudCBvZiB0aGlzLmRhbWFnZVF1ZXVlKSB7XG4gICAgICB0aGlzLmFwcGx5RGFtYWdlKGRhbWFnZUV2ZW50LCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzSGVhbFF1ZXVlKGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGhlYWxFdmVudCBvZiB0aGlzLmhlYWxRdWV1ZSkge1xuICAgICAgdGhpcy5hcHBseUhlYWxpbmcoaGVhbEV2ZW50LCBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBseURhbWFnZShkYW1hZ2VFdmVudDogRGFtYWdlRXZlbnQsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHRhcmdldCwgZGFtYWdlOiBiYXNlRGFtYWdlLCBzb3VyY2UsIGRhbWFnZVR5cGUgfSA9IGRhbWFnZUV2ZW50O1xuICAgIFxuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybjtcblxuICAgIC8vIERlYnVnOiBMb2cgYWxsIGRhbWFnZSBldmVudHMgZm9yIGNoYXJnZSBkYW1hZ2VcbiAgICBpZiAoZGFtYWdlVHlwZSA9PT0gJ2NoYXJnZScpIHtcbiAgICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICBjb25zdCBlbnRpdHlUeXBlID0gZW5lbXkgPyBgRW5lbXkoJHtlbmVteS5nZXREaXNwbGF5TmFtZSgpfSlgIDogYFBsYXllcigke3RhcmdldC5pZH0pYDtcbiAgICAgIGNvbnNvbGUubG9nKGDimpTvuI8gQ29tYmF0U3lzdGVtIHByb2Nlc3NpbmcgY2hhcmdlIGRhbWFnZTogJHtiYXNlRGFtYWdlfSB0byAke2VudGl0eVR5cGV9LCBzb3VyY2U6ICR7c291cmNlPy5pZH0sIGhhc1BsYXllckNhbGxiYWNrOiAkeyEhdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrfWApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbiBlbmVteSAtIGlmIHNvLCByb3V0ZSBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllclxuICAgIGNvbnN0IGVuZW15ID0gdGFyZ2V0LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15ICYmIHRoaXMub25FbmVteURhbWFnZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICAgIGNvbnN0IGRhbWFnZVJlc3VsdDogRGFtYWdlUmVzdWx0ID0gY2FsY3VsYXRlRGFtYWdlKGJhc2VEYW1hZ2UpO1xuICAgICAgY29uc3QgYWN0dWFsRGFtYWdlID0gZGFtYWdlUmVzdWx0LmRhbWFnZTtcbiAgICAgIFxuICAgICAgLy8gUm91dGUgZW5lbXkgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXIgc2VydmVyIGluc3RlYWQgb2YgYXBwbHlpbmcgbG9jYWxseVxuICAgICAgY29uc29sZS5sb2coYPCfjJAgUm91dGluZyAke2FjdHVhbERhbWFnZX0gZGFtYWdlIHRvIGVuZW15ICR7dGFyZ2V0LmlkfSB0aHJvdWdoIG11bHRpcGxheWVyIHNlcnZlcmApO1xuICAgICAgdGhpcy5vbkVuZW15RGFtYWdlQ2FsbGJhY2sodGFyZ2V0LmlkLnRvU3RyaW5nKCksIGFjdHVhbERhbWFnZSk7XG4gICAgICBcbiAgICAgIC8vIFN0aWxsIGNyZWF0ZSBsb2NhbCBkYW1hZ2UgbnVtYmVycyBmb3IgaW1tZWRpYXRlIHZpc3VhbCBmZWVkYmFja1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgY29uc29sZS5sb2coYPCfkqUgJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKHJvdXRlZCB0byBzZXJ2ZXIpYCk7XG4gICAgICBcbiAgICAgIHJldHVybjsgLy8gRG9uJ3QgYXBwbHkgZGFtYWdlIGxvY2FsbHkgZm9yIGVuZW1pZXNcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYSBwbGF5ZXIgaW4gUFZQIG1vZGUgLSBpZiBzbywgcm91dGUgZGFtYWdlIHRocm91Z2ggbXVsdGlwbGF5ZXJcbiAgICAvLyBBbHNvIHByZXZlbnQgc2VsZi1kYW1hZ2UgaW4gUFZQIChzb3VyY2UgaGl0dGluZyB0aGVtc2VsdmVzKVxuICAgIGlmICghZW5lbXkgJiYgdGhpcy5vblBsYXllckRhbWFnZUNhbGxiYWNrICYmIHNvdXJjZSAmJiBzb3VyY2UuaWQgIT09IHRhcmdldC5pZCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBkYW1hZ2Ugd2l0aCBjcml0aWNhbCBoaXQgbWVjaGFuaWNzXG4gICAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIFJvdXRlIHBsYXllciBkYW1hZ2UgdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXIgZm9yIFBWUFxuICAgICAgY29uc29sZS5sb2coYOKalO+4jyBSb3V0aW5nICR7YWN0dWFsRGFtYWdlfSBQVlAgZGFtYWdlIHRvIHBsYXllciAke3RhcmdldC5pZH0gdGhyb3VnaCBtdWx0aXBsYXllciBzZXJ2ZXJgKTtcbiAgICAgIHRoaXMub25QbGF5ZXJEYW1hZ2VDYWxsYmFjayh0YXJnZXQuaWQudG9TdHJpbmcoKSwgYWN0dWFsRGFtYWdlKTtcbiAgICAgIFxuICAgICAgLy8gU3RpbGwgY3JlYXRlIGxvY2FsIGRhbWFnZSBudW1iZXJzIGZvciBpbW1lZGlhdGUgdmlzdWFsIGZlZWRiYWNrXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgZGFtYWdlIG51bWJlciBpZiBwb3NpdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAocG9zaXRpb24gJiYgcG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIHBvc2l0aW9uLnkgIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi56ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3NpdGlvbi55ICs9IDEuNTtcbiAgICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgICAgYWN0dWFsRGFtYWdlLFxuICAgICAgICAgICAgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGRhbWFnZVR5cGUgfHwgJ3B2cCdcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFNraXBwaW5nIFBWUCBkYW1hZ2UgbnVtYmVyIGNyZWF0aW9uIC0gaW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTG9nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgUGxheWVyICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gYFBsYXllciAke3RhcmdldC5pZH1gO1xuICAgICAgY29uc3QgY3JpdFRleHQgPSBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCA/ICcgQ1JJVElDQUwnIDogJyc7XG4gICAgICBjb25zb2xlLmxvZyhg4pqU77iPICR7c291cmNlTmFtZX0gZGVhbHQgJHthY3R1YWxEYW1hZ2V9JHtjcml0VGV4dH0gUFZQICR7ZGFtYWdlVHlwZSB8fCAnZGFtYWdlJ30gdG8gJHt0YXJnZXROYW1lfSAocm91dGVkIHRvIHNlcnZlcilgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuOyAvLyBEb24ndCBhcHBseSBkYW1hZ2UgbG9jYWxseSBmb3IgUFZQIHBsYXllcnNcbiAgICB9XG5cbiAgICAvLyBGb3Igbm9uLWVuZW1pZXMgKGxpa2UgcGxheWVycyBpbiBub24tUFZQIG1vZGUpLCBhcHBseSBkYW1hZ2UgbG9jYWxseSBhcyBiZWZvcmVcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShiYXNlRGFtYWdlKTtcbiAgICBjb25zdCBhY3R1YWxEYW1hZ2UgPSBkYW1hZ2VSZXN1bHQuZGFtYWdlO1xuXG4gICAgLy8gQXBwbHkgZGFtYWdlIChwYXNzIGVudGl0eSBzbyBIZWFsdGggY2FuIHVzZSBTaGllbGQgY29tcG9uZW50KVxuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGRhbWFnZSBudW1iZXIgaWYgcG9zaXRpb24gaXMgdmFsaWRcbiAgICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLnggIT09IHVuZGVmaW5lZCAmJiBwb3NpdGlvbi55ICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24ueiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gT2Zmc2V0IHNsaWdodGx5IGFib3ZlIHRoZSB0YXJnZXRcbiAgICAgICAgICBwb3NpdGlvbi55ICs9IDM7XG4gICAgICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmFkZERhbWFnZU51bWJlcihcbiAgICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICAgIGRhbWFnZVJlc3VsdC5pc0NyaXRpY2FsLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBTa2lwcGluZyBkYW1hZ2UgbnVtYmVyIGNyZWF0aW9uIC0gaW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTG9nIGRhbWFnZSBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zdCBzb3VyY2VOYW1lID0gc291cmNlID8gYEVudGl0eSAke3NvdXJjZS5pZH1gIDogJ1Vua25vd24nO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRoaXMuZ2V0RW50aXR5RGlzcGxheU5hbWUodGFyZ2V0KTtcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwgPyAnIENSSVRJQ0FMJyA6ICcnO1xuICAgICAgY29uc29sZS5sb2coYPCfkqUgJHtzb3VyY2VOYW1lfSBkZWFsdCAke2FjdHVhbERhbWFnZX0ke2NyaXRUZXh0fSAke2RhbWFnZVR5cGUgfHwgJ2RhbWFnZSd9IHRvICR7dGFyZ2V0TmFtZX0gKCR7aGVhbHRoLmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoLm1heEhlYWx0aH0gSFApYCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBkaWVkXG4gICAgICBpZiAoaGVhbHRoLmlzRGVhZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUVudGl0eURlYXRoKHRhcmdldCwgc291cmNlLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgZGFtYWdlIGVmZmVjdHNcbiAgICAgIHRoaXMudHJpZ2dlckRhbWFnZUVmZmVjdHModGFyZ2V0LCBhY3R1YWxEYW1hZ2UsIHNvdXJjZSwgZGFtYWdlVHlwZSwgZGFtYWdlUmVzdWx0LmlzQ3JpdGljYWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlIZWFsaW5nKGhlYWxFdmVudDogSGVhbEV2ZW50LCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgeyB0YXJnZXQsIGFtb3VudCwgc291cmNlIH0gPSBoZWFsRXZlbnQ7XG4gICAgXG4gICAgY29uc3QgaGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIGlmICghaGVhbHRoIHx8ICFoZWFsdGguZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQXBwbHkgaGVhbGluZ1xuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICBcbiAgICAgIC8vIExvZyBoZWFsaW5nIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBzb3VyY2UgPyBgRW50aXR5ICR7c291cmNlLmlkfWAgOiAnVW5rbm93bic7XG4gICAgICBjb25zdCB0YXJnZXROYW1lID0gdGhpcy5nZXRFbnRpdHlEaXNwbGF5TmFtZSh0YXJnZXQpO1xuICAgICAgY29uc29sZS5sb2coYPCfkpogJHtzb3VyY2VOYW1lfSBoZWFsZWQgJHt0YXJnZXROYW1lfSBmb3IgJHthbW91bnR9IEhQICgke2hlYWx0aC5jdXJyZW50SGVhbHRofS8ke2hlYWx0aC5tYXhIZWFsdGh9IEhQKWApO1xuXG4gICAgICAvLyBUcmlnZ2VyIGhlYWxpbmcgZWZmZWN0c1xuICAgICAgdGhpcy50cmlnZ2VySGVhbGluZ0VmZmVjdHModGFyZ2V0LCBhbW91bnQsIHNvdXJjZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFbnRpdHlEZWF0aChlbnRpdHk6IEVudGl0eSwga2lsbGVyPzogRW50aXR5LCBjdXJyZW50VGltZT86IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgXG4gICAgaWYgKGVuZW15KSB7XG4gICAgICBlbmVteS5kaWUoY3VycmVudFRpbWUgfHwgRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgdGhpcy5lbmVtaWVzS2lsbGVkKys7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn5KAICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIGJlZW4gZGVmZWF0ZWQhYCk7XG4gICAgICBcbiAgICAgIC8vIEF3YXJkIGV4cGVyaWVuY2UgdG8ga2lsbGVyIGlmIGl0J3MgYSBwbGF5ZXJcbiAgICAgIGlmIChraWxsZXIpIHtcbiAgICAgICAgdGhpcy5hd2FyZEV4cGVyaWVuY2Uoa2lsbGVyLCBlbmVteS5leHBlcmllbmNlUmV3YXJkKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJpZ2dlciBkZWF0aCBlZmZlY3RzXG4gICAgICB0aGlzLnRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5LCBraWxsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZGVhZEVudGl0aWVzLnB1c2goZW50aXR5KTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlRGVhdGhBbmRSZXNwYXduKGVudGl0aWVzOiBFbnRpdHlbXSwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICBjb25zdCBlbmVteSA9IGVudGl0eS5nZXRDb21wb25lbnQoRW5lbXkpO1xuICAgICAgXG4gICAgICBpZiAoIWhlYWx0aCB8fCAhZW5lbXkpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBIYW5kbGUgcmVzcGF3biBmb3IgZW5lbWllc1xuICAgICAgaWYgKGVuZW15LmlzRGVhZCAmJiBlbmVteS5jYW5SZXNwYXduTm93KGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLnJlc3Bhd25FbmVteShlbnRpdHksIGVuZW15LCBoZWFsdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzcGF3bkVuZW15KGVudGl0eTogRW50aXR5LCBlbmVteTogRW5lbXksIGhlYWx0aDogSGVhbHRoKTogdm9pZCB7XG4gICAgLy8gUmVzcGF3biB0aGUgZW5lbXlcbiAgICBlbmVteS5yZXNwYXduKCk7XG4gICAgaGVhbHRoLnJldml2ZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SEICR7ZW5lbXkuZ2V0RGlzcGxheU5hbWUoKX0gaGFzIHJlc3Bhd25lZCFgKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIHJlc3Bhd24gZWZmZWN0c1xuICAgIHRoaXMudHJpZ2dlclJlc3Bhd25FZmZlY3RzKGVudGl0eSk7XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEYW1hZ2VFZmZlY3RzKHRhcmdldDogRW50aXR5LCBkYW1hZ2U6IG51bWJlciwgc291cmNlPzogRW50aXR5LCBkYW1hZ2VUeXBlPzogc3RyaW5nLCBpc0NyaXRpY2FsPzogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcGFydGljbGUgZWZmZWN0cywgc2NyZWVuIHNoYWtlLCBldGMuXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCBoYW5kbGUgYmFzaWMgZWZmZWN0c1xuICAgIFxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAvLyBDb3VsZCB0cmlnZ2VyIGRhbWFnZSBudW1iZXIgcG9wdXAsIGJsb29kIGVmZmVjdHMsIGV0Yy5cbiAgICAgIC8vIEZvciBub3csIGp1c3QgbG9nIHRoZSBwb3NpdGlvbiB3aGVyZSBkYW1hZ2Ugb2NjdXJyZWRcbiAgICAgIGNvbnN0IGNyaXRUZXh0ID0gaXNDcml0aWNhbCA/ICcgKENSSVRJQ0FMKScgOiAnJztcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIERhbWFnZSBlZmZlY3Qke2NyaXRUZXh0fSBhdCBwb3NpdGlvbjpgLCB0cmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGVjaWFsIHByb2plY3RpbGUgZWZmZWN0c1xuICAgIGlmIChkYW1hZ2VUeXBlID09PSAncHJvamVjdGlsZScgJiYgc291cmNlKSB7XG4gICAgICBjb25zdCBzb3VyY2VSZW5kZXJlciA9IHNvdXJjZS5nZXRDb21wb25lbnQoUmVuZGVyZXIpO1xuICAgICAgaWYgKHNvdXJjZVJlbmRlcmVyPy5tZXNoPy51c2VyRGF0YT8uaXNCYXJyYWdlQXJyb3cpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCfj7kgQmFycmFnZSBhcnJvdyBoaXQgZGV0ZWN0ZWQsIGFwcGx5aW5nIHNsb3cgZWZmZWN0IHRvIHRhcmdldCAke3RhcmdldC5pZH1gKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TW92ZW1lbnQgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgaWYgKHRhcmdldE1vdmVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0TW92ZW1lbnQuc2xvdyg1MDAwLCAwLjUpOyAvLyA1IHNlY29uZHMsIDUwJSBzcGVlZFxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5CMIEFwcGxpZWQgNTAlIHNsb3cgZm9yIDUgc2Vjb25kcyB0byB0YXJnZXQgJHt0YXJnZXQuaWR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQ6IEVudGl0eSwgYW1vdW50OiBudW1iZXIsIHNvdXJjZT86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgaGVhbGluZyBwYXJ0aWNsZSBlZmZlY3RzXG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinKggSGVhbGluZyBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJEZWF0aEVmZmVjdHMoZW50aXR5OiBFbnRpdHksIGtpbGxlcj86IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgZGVhdGggYW5pbWF0aW9ucywgbG9vdCBkcm9wcywgZXRjLlxuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+SgCBEZWF0aCBlZmZlY3QgYXQgcG9zaXRpb246YCwgdHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZXNwYXduRWZmZWN0cyhlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIC8vIFRoaXMgY2FuIGJlIGV4dGVuZGVkIHRvIHRyaWdnZXIgcmVzcGF3biBhbmltYXRpb25zLCBlZmZlY3RzLCBldGMuXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn4yfIFJlc3Bhd24gZWZmZWN0IGF0IHBvc2l0aW9uOmAsIHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhd2FyZEV4cGVyaWVuY2UoZW50aXR5OiBFbnRpdHksIGV4cGVyaWVuY2U6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFRoaXMgd291bGQgaW50ZWdyYXRlIHdpdGggYSBwcm9ncmVzc2lvbiBzeXN0ZW1cbiAgICBjb25zb2xlLmxvZyhg4q2QIEVudGl0eSAke2VudGl0eS5pZH0gZ2FpbmVkICR7ZXhwZXJpZW5jZX0gZXhwZXJpZW5jZSFgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RW50aXR5RGlzcGxheU5hbWUoZW50aXR5OiBFbnRpdHkpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgaWYgKGVuZW15KSB7XG4gICAgICByZXR1cm4gZW5lbXkuZ2V0RGlzcGxheU5hbWUoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ291bGQgY2hlY2sgZm9yIG90aGVyIGNvbXBvbmVudHMgdGhhdCBwcm92aWRlIG5hbWVzXG4gICAgcmV0dXJuIGBFbnRpdHkgJHtlbnRpdHkuaWR9YDtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUEkgZm9yIG90aGVyIHN5c3RlbXMgdG8gcXVldWUgZGFtYWdlIGFuZCBoZWFsaW5nXG4gIHB1YmxpYyBxdWV1ZURhbWFnZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLnB1c2goe1xuICAgICAgdGFyZ2V0LFxuICAgICAgZGFtYWdlLFxuICAgICAgc291cmNlLFxuICAgICAgZGFtYWdlVHlwZSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSAvIDEwMDBcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBxdWV1ZUhlYWxpbmcoXG4gICAgdGFyZ2V0OiBFbnRpdHksIFxuICAgIGFtb3VudDogbnVtYmVyLCBcbiAgICBzb3VyY2U/OiBFbnRpdHlcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5oZWFsUXVldWUucHVzaCh7XG4gICAgICB0YXJnZXQsXG4gICAgICBhbW91bnQsXG4gICAgICBzb3VyY2UsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCkgLyAxMDAwXG4gICAgfSk7XG4gIH1cblxuICAvLyBJbW1lZGlhdGUgZGFtYWdlL2hlYWxpbmcgKGJ5cGFzc2VzIHF1ZXVlKVxuICBwdWJsaWMgZGVhbERhbWFnZUltbWVkaWF0ZShcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgZGFtYWdlOiBudW1iZXIsIFxuICAgIHNvdXJjZT86IEVudGl0eSwgXG4gICAgZGFtYWdlVHlwZT86IHN0cmluZ1xuICApOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgaWYgKCFoZWFsdGggfHwgIWhlYWx0aC5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWN0dWFsIGRhbWFnZSB3aXRoIGNyaXRpY2FsIGhpdCBtZWNoYW5pY3NcbiAgICBjb25zdCBkYW1hZ2VSZXN1bHQ6IERhbWFnZVJlc3VsdCA9IGNhbGN1bGF0ZURhbWFnZShkYW1hZ2UpO1xuICAgIGNvbnN0IGFjdHVhbERhbWFnZSA9IGRhbWFnZVJlc3VsdC5kYW1hZ2U7XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gaGVhbHRoLnRha2VEYW1hZ2UoYWN0dWFsRGFtYWdlLCBjdXJyZW50VGltZSwgdGFyZ2V0KTtcbiAgICBcbiAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCArPSBhY3R1YWxEYW1hZ2U7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBkYW1hZ2UgbnVtYmVyIGF0IHRhcmdldCBwb3NpdGlvblxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIE9mZnNldCBzbGlnaHRseSBhYm92ZSB0aGUgdGFyZ2V0XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gMS41O1xuICAgICAgICB0aGlzLmRhbWFnZU51bWJlck1hbmFnZXIuYWRkRGFtYWdlTnVtYmVyKFxuICAgICAgICAgIGFjdHVhbERhbWFnZSxcbiAgICAgICAgICBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBkYW1hZ2VUeXBlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW50aXR5RGVhdGgodGFyZ2V0LCBzb3VyY2UsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy50cmlnZ2VyRGFtYWdlRWZmZWN0cyh0YXJnZXQsIGFjdHVhbERhbWFnZSwgc291cmNlLCBkYW1hZ2VUeXBlLCBkYW1hZ2VSZXN1bHQuaXNDcml0aWNhbCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYW1hZ2VEZWFsdDtcbiAgfVxuXG4gIHB1YmxpYyBoZWFsSW1tZWRpYXRlKFxuICAgIHRhcmdldDogRW50aXR5LCBcbiAgICBhbW91bnQ6IG51bWJlciwgXG4gICAgc291cmNlPzogRW50aXR5XG4gICk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoIWhlYWx0aCB8fCAhaGVhbHRoLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGhlYWxpbmdEb25lID0gaGVhbHRoLmhlYWwoYW1vdW50KTtcbiAgICBcbiAgICBpZiAoaGVhbGluZ0RvbmUpIHtcbiAgICAgIHRoaXMudG90YWxIZWFsaW5nRG9uZSArPSBhbW91bnQ7XG4gICAgICB0aGlzLnRyaWdnZXJIZWFsaW5nRWZmZWN0cyh0YXJnZXQsIGFtb3VudCwgc291cmNlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWxpbmdEb25lO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzXG4gIHB1YmxpYyBpc0VudGl0eURlYWQoZW50aXR5OiBFbnRpdHkpOiBib29sZWFuIHtcbiAgICBjb25zdCBoZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgcmV0dXJuIGhlYWx0aCA/IGhlYWx0aC5pc0RlYWQgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRFbnRpdHlIZWFsdGhSYXRpbyhlbnRpdHk6IEVudGl0eSk6IG51bWJlciB7XG4gICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIHJldHVybiBoZWFsdGggPyBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSA6IDA7XG4gIH1cblxuICBwdWJsaWMgY2FuRW50aXR5VGFrZURhbWFnZShlbnRpdHk6IEVudGl0eSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICByZXR1cm4gaGVhbHRoID8gKCFoZWFsdGguaXNEZWFkICYmICFoZWFsdGguaXNJbnZ1bG5lcmFibGUpIDogZmFsc2U7XG4gIH1cblxuICAvLyBTdGF0aXN0aWNzIGFuZCBkZWJ1Z2dpbmdcbiAgcHVibGljIGdldENvbWJhdFN0YXRzKCk6IHtcbiAgICB0b3RhbERhbWFnZURlYWx0OiBudW1iZXI7XG4gICAgdG90YWxIZWFsaW5nRG9uZTogbnVtYmVyO1xuICAgIGVuZW1pZXNLaWxsZWQ6IG51bWJlcjtcbiAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IG51bWJlcjtcbiAgICBxdWV1ZWRIZWFsRXZlbnRzOiBudW1iZXI7XG4gIH0ge1xuICAgIHJldHVybiB7XG4gICAgICB0b3RhbERhbWFnZURlYWx0OiB0aGlzLnRvdGFsRGFtYWdlRGVhbHQsXG4gICAgICB0b3RhbEhlYWxpbmdEb25lOiB0aGlzLnRvdGFsSGVhbGluZ0RvbmUsXG4gICAgICBlbmVtaWVzS2lsbGVkOiB0aGlzLmVuZW1pZXNLaWxsZWQsXG4gICAgICBxdWV1ZWREYW1hZ2VFdmVudHM6IHRoaXMuZGFtYWdlUXVldWUubGVuZ3RoLFxuICAgICAgcXVldWVkSGVhbEV2ZW50czogdGhpcy5oZWFsUXVldWUubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMudG90YWxEYW1hZ2VEZWFsdCA9IDA7XG4gICAgdGhpcy50b3RhbEhlYWxpbmdEb25lID0gMDtcbiAgICB0aGlzLmVuZW1pZXNLaWxsZWQgPSAwO1xuICB9XG5cbiAgLy8gRGFtYWdlIG51bWJlcnMgbWFuYWdlbWVudFxuICBwdWJsaWMgZ2V0RGFtYWdlTnVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VOdW1iZXJNYW5hZ2VyLmdldERhbWFnZU51bWJlcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVEYW1hZ2VOdW1iZXIoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5yZW1vdmVEYW1hZ2VOdW1iZXIoaWQpO1xuICB9XG5cbiAgcHVibGljIG9uRGlzYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFsUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlYWRFbnRpdGllcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVyTWFuYWdlci5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRTdGF0cygpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiU3lzdGVtIiwiSGVhbHRoIiwiU2hpZWxkIiwiRW5lbXkiLCJUcmFuc2Zvcm0iLCJSZW5kZXJlciIsIk1vdmVtZW50IiwiY2FsY3VsYXRlRGFtYWdlIiwiRGFtYWdlTnVtYmVyTWFuYWdlciIsIkNvbWJhdFN5c3RlbSIsInNldEVuZW15RGFtYWdlQ2FsbGJhY2siLCJjYWxsYmFjayIsIm9uRW5lbXlEYW1hZ2VDYWxsYmFjayIsInNldFBsYXllckRhbWFnZUNhbGxiYWNrIiwib25QbGF5ZXJEYW1hZ2VDYWxsYmFjayIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwidXBkYXRlSGVhbHRoQ29tcG9uZW50cyIsInByb2Nlc3NEYW1hZ2VRdWV1ZSIsInByb2Nlc3NIZWFsUXVldWUiLCJoYW5kbGVEZWF0aEFuZFJlc3Bhd24iLCJkYW1hZ2VOdW1iZXJNYW5hZ2VyIiwiY2xlYW51cCIsImRhbWFnZVF1ZXVlIiwibGVuZ3RoIiwiaGVhbFF1ZXVlIiwiZGVhZEVudGl0aWVzIiwiZW50aXR5IiwiaGVhbHRoIiwiZ2V0Q29tcG9uZW50IiwiZW5hYmxlZCIsInNoaWVsZCIsImVuZW15IiwidXBkYXRlRnJlZXplU3RhdHVzIiwiZGFtYWdlRXZlbnQiLCJhcHBseURhbWFnZSIsImhlYWxFdmVudCIsImFwcGx5SGVhbGluZyIsInRhcmdldCIsImRhbWFnZSIsImJhc2VEYW1hZ2UiLCJzb3VyY2UiLCJkYW1hZ2VUeXBlIiwiZW50aXR5VHlwZSIsImdldERpc3BsYXlOYW1lIiwiaWQiLCJjb25zb2xlIiwibG9nIiwiZGFtYWdlUmVzdWx0IiwiYWN0dWFsRGFtYWdlIiwidG9TdHJpbmciLCJ0cmFuc2Zvcm0iLCJwb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJ5IiwiYWRkRGFtYWdlTnVtYmVyIiwiaXNDcml0aWNhbCIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiZ2V0RW50aXR5RGlzcGxheU5hbWUiLCJjcml0VGV4dCIsIngiLCJ1bmRlZmluZWQiLCJ6Iiwid2FybiIsImRhbWFnZURlYWx0IiwidGFrZURhbWFnZSIsInRvdGFsRGFtYWdlRGVhbHQiLCJjdXJyZW50SGVhbHRoIiwibWF4SGVhbHRoIiwiaXNEZWFkIiwiaGFuZGxlRW50aXR5RGVhdGgiLCJ0cmlnZ2VyRGFtYWdlRWZmZWN0cyIsImFtb3VudCIsImhlYWxpbmdEb25lIiwiaGVhbCIsInRvdGFsSGVhbGluZ0RvbmUiLCJ0cmlnZ2VySGVhbGluZ0VmZmVjdHMiLCJraWxsZXIiLCJkaWUiLCJlbmVtaWVzS2lsbGVkIiwiYXdhcmRFeHBlcmllbmNlIiwiZXhwZXJpZW5jZVJld2FyZCIsInRyaWdnZXJEZWF0aEVmZmVjdHMiLCJwdXNoIiwiY2FuUmVzcGF3bk5vdyIsInJlc3Bhd25FbmVteSIsInJlc3Bhd24iLCJyZXZpdmUiLCJ0cmlnZ2VyUmVzcGF3bkVmZmVjdHMiLCJzb3VyY2VSZW5kZXJlciIsIm1lc2giLCJ1c2VyRGF0YSIsImlzQmFycmFnZUFycm93IiwidGFyZ2V0TW92ZW1lbnQiLCJzbG93IiwiZXhwZXJpZW5jZSIsInF1ZXVlRGFtYWdlIiwidGltZXN0YW1wIiwicXVldWVIZWFsaW5nIiwiZGVhbERhbWFnZUltbWVkaWF0ZSIsImhlYWxJbW1lZGlhdGUiLCJpc0VudGl0eURlYWQiLCJnZXRFbnRpdHlIZWFsdGhSYXRpbyIsImdldEhlYWx0aFJhdGlvIiwiY2FuRW50aXR5VGFrZURhbWFnZSIsImlzSW52dWxuZXJhYmxlIiwiZ2V0Q29tYmF0U3RhdHMiLCJxdWV1ZWREYW1hZ2VFdmVudHMiLCJxdWV1ZWRIZWFsRXZlbnRzIiwicmVzZXRTdGF0cyIsImdldERhbWFnZU51bWJlcnMiLCJyZW1vdmVEYW1hZ2VOdW1iZXIiLCJvbkRpc2FibGUiLCJjbGVhciIsImNvbnN0cnVjdG9yIiwid29ybGQiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJwcmlvcml0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/CombatSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ControlSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/ControlSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControlSystem: function() { return /* binding */ ControlSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _CombatSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CombatSystem */ \"(app-pages-browser)/./src/systems/CombatSystem.ts\");\n/* harmony import */ var _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/components/dragon/weapons */ \"(app-pages-browser)/./src/components/dragon/weapons.ts\");\n/* harmony import */ var _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/components/weapons/DeflectBarrier */ \"(app-pages-browser)/./src/components/weapons/DeflectBarrier.ts\");\n/* harmony import */ var _components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/components/weapons/FrostNovaManager */ \"(app-pages-browser)/./src/components/weapons/FrostNovaManager.tsx\");\n/* harmony import */ var _components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/projectiles/CobraShotManager */ \"(app-pages-browser)/./src/components/projectiles/CobraShotManager.tsx\");\n/* harmony import */ var _components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/projectiles/ViperStingManager */ \"(app-pages-browser)/./src/components/projectiles/ViperStingManager.tsx\");\n// Control system for player input handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass ControlSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setPlayer(entity) {\n        this.playerEntity = entity;\n    }\n    update(entities, deltaTime) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n        if (!playerTransform || !playerMovement) return;\n        // Update debuff states first\n        if (typeof playerMovement.updateDebuffs === \"function\") {\n            playerMovement.updateDebuffs();\n        } else {\n            console.warn(\"⚠️ Player Movement component missing updateDebuffs method:\", playerMovement);\n        }\n        // Handle weapon switching\n        this.handleWeaponSwitching();\n        // Handle dash movement first (overrides regular movement)\n        this.handleDashMovement(playerMovement, playerTransform);\n        // Handle charge movement (overrides regular movement)\n        this.handleChargeMovement(playerMovement, playerTransform);\n        // Handle player movement input (only if not dashing, charging, or frozen)\n        if (!playerMovement.isDashing && !playerMovement.isCharging && !playerMovement.isFrozen) {\n            this.handleMovementInput(playerMovement);\n        }\n        // Handle combat input\n        this.handleCombatInput(playerTransform);\n        // Update deflect barrier position if active\n        this.updateDeflectBarrier(playerTransform);\n    }\n    handleMovementInput(movement) {\n        if (!this.playerEntity) return;\n        const playerTransform = this.playerEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!playerTransform) return;\n        // Check for double-tap dashes first (before processing regular movement)\n        this.checkForDashInput(movement, playerTransform);\n        // Get input direction\n        const inputDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        let hasInput = false;\n        // WASD movement\n        if (this.inputManager.isKeyPressed(\"w\")) {\n            inputDirection.z -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"s\")) {\n            inputDirection.z += 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"a\")) {\n            inputDirection.x -= 1;\n            hasInput = true;\n        }\n        if (this.inputManager.isKeyPressed(\"d\")) {\n            inputDirection.x += 1;\n            hasInput = true;\n        }\n        // Normalize diagonal movement\n        if (inputDirection.length() > 0) {\n            inputDirection.normalize();\n        }\n        // Convert input to world space based on camera orientation\n        if (hasInput) {\n            const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(cameraDirection);\n            // Get camera's right vector\n            const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n            // Get camera's forward vector (projected on XZ plane)\n            const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n            // Transform input direction to world space\n            const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            worldDirection.addScaledVector(cameraRight, inputDirection.x);\n            worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n            worldDirection.normalize();\n            movement.setMoveDirection(worldDirection, 1.0);\n        } else {\n            movement.setMoveDirection(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0), 0);\n        }\n        // Handle jumping\n        if (this.inputManager.isKeyPressed(\" \")) {\n            movement.jump();\n        }\n    }\n    handleWeaponSwitching() {\n        const currentTime = Date.now() / 1000;\n        // Prevent rapid weapon switching\n        if (currentTime - this.lastWeaponSwitchTime < this.weaponSwitchCooldown) {\n            return;\n        }\n        // Handle weapon switching with number keys\n        if (this.inputManager.isKeyPressed(\"1\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.DIVINITY; // Default sword subclass\n                this.fireRate = this.swordFireRate; // Use sword-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                this.swordComboStep = 1; // Reset combo when switching to sword\n                console.log(\"\\uD83D\\uDDE1️ Switched to Sword\");\n            }\n        } else if (this.inputManager.isKeyPressed(\"2\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL; // Default bow subclass\n                this.fireRate = 0.225; // Bow fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                console.log(\"\\uD83C\\uDFF9 Switched to Bow\");\n            }\n        } else if (this.inputManager.isKeyPressed(\"3\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.CHAOS; // Default scythe subclass\n                this.fireRate = this.scytheFireRate; // Use scythe fire rate (0.5s)\n                this.lastWeaponSwitchTime = currentTime;\n                console.log(\"⚡ Switched to Scythe\");\n            }\n        } else if (this.inputManager.isKeyPressed(\"4\")) {\n            if (this.currentWeapon !== _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n                this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES;\n                this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.FROST; // Default sabres subclass\n                this.fireRate = this.sabresFireRate; // Use sabres-specific fire rate\n                this.lastWeaponSwitchTime = currentTime;\n                console.log(\"⚔️ Switched to Sabres\");\n            }\n        }\n    }\n    handleCombatInput(playerTransform) {\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            this.handleBowInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            this.handleScytheInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            this.handleSwordInput(playerTransform);\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SABRES) {\n            this.handleSabresInput(playerTransform);\n        }\n    }\n    handleBowInput(playerTransform) {\n        // Handle Viper Sting ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isViperStingCharging && !this.isCharging) {\n            this.performViperSting(playerTransform);\n        }\n        // Handle Barrage ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\")) {\n            console.log(\"\\uD83C\\uDFF9 Q key pressed for Barrage!\", {\n                isBarrageCharging: this.isBarrageCharging,\n                isCharging: this.isCharging,\n                isViperStingCharging: this.isViperStingCharging\n            });\n            if (!this.isBarrageCharging && !this.isCharging && !this.isViperStingCharging) {\n                this.performBarrage(playerTransform);\n            }\n        }\n        // Handle Cobra Shot ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\")) {\n            console.log(\"\\uD83D\\uDC0D E key pressed for Cobra Shot!\", {\n                isCharging: this.isCharging,\n                isViperStingCharging: this.isViperStingCharging,\n                isBarrageCharging: this.isBarrageCharging,\n                isCobraShotCharging: this.isCobraShotCharging,\n                currentWeapon: this.currentWeapon\n            });\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.performCobraShot(playerTransform);\n            }\n        }\n        // Handle bow charging and firing\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging && !this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\"\\uD83C\\uDFF9 Started charging bow\");\n            }\n            // Increase charge progress (could be time-based)\n            if (!this.isViperStingCharging && !this.isBarrageCharging && !this.isCobraShotCharging) {\n                this.chargeProgress = Math.min(this.chargeProgress + 0.0125, 1.0); // BOW CHARGE SPEED\n            }\n        } else if (this.isCharging) {\n            // Check if any ability is charging - if so, cancel the regular bow shot\n            if (this.isViperStingCharging || this.isBarrageCharging || this.isCobraShotCharging) {\n                console.log(\"\\uD83C\\uDFF9 Cancelling regular bow shot due to ability charging\");\n                this.isCharging = false;\n                this.chargeProgress = 0;\n                return;\n            }\n            // Store charge progress before resetting for visual effects\n            const finalChargeProgress = this.chargeProgress;\n            // Release the bow\n            this.fireProjectile(playerTransform);\n            this.isCharging = false;\n            this.chargeProgress = 0;\n            // Trigger visual effects callback with the stored charge progress\n            this.triggerBowReleaseEffects(finalChargeProgress);\n        }\n    }\n    handleScytheInput(playerTransform) {\n        // Handle scythe left click for EntropicBolt\n        if (this.inputManager.isMouseButtonPressed(0)) {\n            if (!this.isCharging) {\n                this.isCharging = true;\n                this.chargeProgress = 0;\n                console.log(\"⚡ Started charging scythe (spinning)\");\n            }\n            // Increase charge progress continuously for spinning animation (no cap)\n            this.chargeProgress += 0.03; // Continuously increase for spinning\n            // Fire EntropicBolt projectiles continuously while spinning\n            this.fireEntropicBoltProjectile(playerTransform);\n        } else if (this.isCharging) {\n            // Stop spinning when mouse is released\n            console.log(\"⚡ Stopped charging scythe (spinning)\");\n            this.isCharging = false;\n            this.chargeProgress = 0;\n        }\n        // Handle CrossentropyBolt ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isCharging) {\n            this.fireCrossentropyBoltAbility(playerTransform);\n        }\n        // Handle Reanimate ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isCharging) {\n            this.performReanimateAbility(playerTransform);\n        }\n        // Handle Frost Nova ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isCharging) {\n            this.performFrostNovaAbility(playerTransform);\n        }\n    }\n    fireProjectile(playerTransform) {\n        // Rate limiting - prevent spam clicking\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.fireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction (same as camera direction since dragon faces camera)\n        // This ensures arrows fire outward from where the dragon is facing\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation to account for restricted camera bounds\n        // Since camera can't look down much due to bounds, we add a fixed downward angle\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        // Create a rotation matrix to apply the downward angle around the camera's right axis\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Perfect shot timing constants\n        const perfectShotMinThreshold = 0.7; // 85% charge\n        const perfectShotMaxThreshold = 0.98; // 95% charge\n        const isPerfectShot = this.chargeProgress >= perfectShotMinThreshold && this.chargeProgress <= perfectShotMaxThreshold;\n        // Check if bow is fully charged for special projectile\n        if (this.chargeProgress >= 1.0) {\n            console.log(\"\\uD83C\\uDFF9 Firing CHARGED ARROW with full charge: \".concat(this.chargeProgress));\n            this.createChargedArrowProjectile(playerTransform.position.clone(), direction);\n        } else if (isPerfectShot) {\n            console.log(\"✨ Firing PERFECT SHOT with charge: \".concat(this.chargeProgress));\n            this.createPerfectShotProjectile(playerTransform.position.clone(), direction);\n        } else {\n            // Debug: Log the firing angle to verify it's changing with camera rotation\n            const angle = Math.atan2(direction.x, direction.z);\n            console.log(\"\\uD83E\\uDDED Firing \".concat(this.currentWeapon, \" at angle: \").concat((angle * 180 / Math.PI).toFixed(1), \"\\xb0\"));\n            this.createProjectile(playerTransform.position.clone(), direction);\n        }\n    }\n    fireEntropicBoltProjectile(playerTransform) {\n        // Rate limiting - use new scythe rate (0.5 seconds)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.scytheFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        const spinStatus = this.isCharging ? \" (SPINNING)\" : \"\";\n        console.log(\"⚡ Firing EntropicBolt\".concat(spinStatus, \" - charge: \").concat(this.chargeProgress.toFixed(2), \" - rate: \").concat(this.scytheFireRate, \"s\"));\n        this.createEntropicBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    fireCrossentropyBoltAbility(playerTransform) {\n        // Rate limiting - use CrossentropyBolt rate (1 per second)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCrossentropyTime < this.crossentropyFireRate) {\n            return;\n        }\n        this.lastCrossentropyTime = currentTime;\n        // Get dragon's facing direction\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply downward angle compensation (same as bow projectiles)\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        console.log(\"⚔️ Firing CrossentropyBolt ability (R key) - rate: \".concat(this.crossentropyFireRate, \"s\"));\n        this.createCrossentropyBoltProjectile(playerTransform.position.clone(), direction);\n    }\n    createProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            console.log(\"\\uD83C\\uDFF9 No valid targets found, skipping projectile creation\");\n            return;\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create projectile using the ProjectileSystem with current weapon config\n        const projectileConfig = {\n            speed: 25,\n            damage: 10,\n            lifetime: 3,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createProjectile(this.world, spawnPosition, direction, this.playerEntity.id, projectileConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"regular_arrow\", spawnPosition, direction, projectileConfig);\n        }\n    }\n    createEntropicBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if there are any valid targets in the world before creating projectiles\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider\n        ]);\n        const validTargets = potentialTargets.filter((target)=>{\n            var _target_getComponent;\n            return target.id !== this.playerEntity.id && // Not the player itself\n            !((_target_getComponent = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health)) === null || _target_getComponent === void 0 ? void 0 : _target_getComponent.isDead // Not dead\n            );\n        });\n        // In multiplayer mode, only create projectiles if there are valid targets or if we need to broadcast to other players\n        const hasValidTargets = validTargets.length > 0;\n        const shouldBroadcast = this.onProjectileCreatedCallback !== undefined;\n        if (!hasValidTargets && !shouldBroadcast) {\n            console.log(\"⚡ No valid targets found, skipping EntropicBolt creation\");\n            return;\n        }\n        // Check if player has enough mana (15 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastEntropicBolt()) {\n            console.log(\"⚡ Not enough mana to cast Entropic Bolt (requires 15 mana)\");\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(10);\n            console.log(\"⚡ Consumed 15 mana for Entropic Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create EntropicBolt projectile using the new method\n        const entropicConfig = {\n            speed: 20,\n            damage: 20,\n            lifetime: 5,\n            piercing: true,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createEntropicBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, entropicConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"entropic_bolt\", spawnPosition, direction, entropicConfig);\n        }\n    }\n    createCrossentropyBoltProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Check if player has enough mana (40 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCrossentropyBolt()) {\n            console.log(\"⚔️ Not enough mana to cast Crossentropy Bolt (requires 40 mana)\");\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(40);\n            console.log(\"⚔️ Consumed 40 mana for Crossentropy Bolt\");\n        }\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.75; // Slightly higher\n        // Create CrossentropyBolt projectile using the existing method\n        const crossentropyConfig = {\n            speed: 15,\n            damage: 90,\n            lifetime: 5,\n            piercing: true,\n            explosive: false,\n            explosionRadius: 0,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createCrossentropyBoltProjectile(this.world, spawnPosition, direction, this.playerEntity.id, crossentropyConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"crossentropy_bolt\", spawnPosition, direction, crossentropyConfig);\n        }\n    }\n    performReanimateAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Rate limiting - prevent spam casting (1 second cooldown)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastReanimateTime < 1.0) {\n            console.log(\"\\uD83E\\uDE78 Reanimate on cooldown - please wait\");\n            return;\n        }\n        this.lastReanimateTime = currentTime;\n        // Check if player has enough mana (20 mana cost - doubled from 10)\n        const gameUI = window.gameUI;\n        const currentMana = gameUI ? gameUI.getCurrentMana() : 0;\n        if (gameUI && !gameUI.canCastReanimate()) {\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            const manaBefore = gameUI.getCurrentMana();\n            gameUI.consumeMana(20);\n            const manaAfter = gameUI.getCurrentMana();\n            console.log(\"\\uD83E\\uDE78 Reanimate mana consumption - Before: \".concat(manaBefore, \", After: \").concat(manaAfter, \", Consumed: \").concat(manaBefore - manaAfter));\n        }\n        // Always trigger the visual effect first, regardless of healing success\n        console.log(\"\\uD83C\\uDF3F Reanimate ability activated - triggering visual effects\");\n        this.triggerReanimateEffect(playerTransform);\n        // Get player's health component and heal for 20 HP (doubled from 10)\n        const healthComponent = this.playerEntity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n        if (healthComponent) {\n            const didHeal = healthComponent.heal(20); // REANIMATE HEAL AMOUNT\n            if (didHeal) {\n                console.log(\"\\uD83E\\uDE78 Reanimate healed player for 20 HP. Current health: \".concat(healthComponent.currentHealth, \"/\").concat(healthComponent.maxHealth));\n            } else {\n                console.log(\"\\uD83E\\uDE78 Reanimate cast successfully but player already at full health\");\n            }\n        }\n    }\n    triggerReanimateEffect(playerTransform) {\n        // Trigger the visual healing effect\n        console.log(\"\\uD83C\\uDF3F Triggering Reanimate healing effect\");\n        if (this.onReanimateCallback) {\n            this.onReanimateCallback();\n        }\n        const playerPosition = playerTransform.position;\n        console.log(\"\\uD83C\\uDF3F Healing effect at position: \".concat(playerPosition.x.toFixed(2), \", \").concat(playerPosition.y.toFixed(2), \", \").concat(playerPosition.z.toFixed(2)));\n    }\n    performFrostNovaAbility(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFrostNovaTime < this.frostNovaFireRate) {\n            console.log(\"❄️ Frost Nova on cooldown for \".concat((this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough mana (25 mana cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastFrostNova()) {\n            console.log(\"❄️ Not enough mana to cast Frost Nova (requires 25 mana)\");\n            return;\n        }\n        // Consume mana\n        if (gameUI) {\n            gameUI.consumeMana(25);\n            console.log(\"❄️ Consumed 25 mana for Frost Nova\");\n        }\n        this.lastFrostNovaTime = currentTime;\n        console.log(\"❄️ Frost Nova ability activated!\");\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Trigger Frost Nova callback for visual effects\n        if (this.onFrostNovaCallback) {\n            this.onFrostNovaCallback(playerPosition, direction);\n        }\n        // Find all enemies within 5 unit radius and freeze them (reduced from 8)\n        this.freezeEnemiesInRadius(playerPosition, 6.0, currentTime);\n        // Trigger global frost nova visual effect\n        (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.triggerGlobalFrostNova)(playerPosition);\n    }\n    performCobraShot(playerTransform) {\n        if (!this.playerEntity) return;\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastCobraShotTime < this.cobraShotFireRate) {\n            console.log(\"\\uD83D\\uDC0D Cobra Shot on cooldown for \".concat((this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastCobraShot()) {\n            console.log(\"\\uD83D\\uDC0D Not enough energy to cast Cobra Shot (requires 40 energy)\");\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n            console.log(\"\\uD83D\\uDC0D Consumed 40 energy for Cobra Shot\");\n        }\n        console.log(\"\\uD83D\\uDC0D Cobra Shot activated - starting charge!\");\n        this.isCobraShotCharging = true;\n        this.cobraShotChargeProgress = 0;\n        this.lastCobraShotTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 750; // 0.75 second charge time (between Viper Sting and Barrage)\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.cobraShotChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.cobraShotChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireCobraShot(playerTransform);\n                this.isCobraShotCharging = false;\n                this.cobraShotChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireCobraShot(playerTransform) {\n        console.log(\"\\uD83D\\uDC0D Firing Cobra Shot projectile!\");\n        // Get player position and direction (same as other projectiles)\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 1; // Shoot from chest level like Viper Sting\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Cobra Shot damage is handled by CobraShotManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage (similar to Viper Sting)\n        // Trigger Cobra Shot callback for visual effects\n        if (this.onCobraShotCallback) {\n            this.onCobraShotCallback(spawnPosition, direction);\n        }\n        // Trigger global cobra shot with proper positioning (handles local visual effects and damage)\n        (0,_components_projectiles_CobraShotManager__WEBPACK_IMPORTED_MODULE_12__.triggerGlobalCobraShot)(spawnPosition, direction);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"cobra_shot_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 29,\n                lifetime: 8,\n                venomDuration: 6\n            });\n        }\n    }\n    freezeEnemiesInRadius(centerPosition, radius, currentTime) {\n        // Get all entities in the world\n        const allEntities = this.world.getAllEntities();\n        let frozenCount = 0;\n        let damagedPlayers = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n            // Skip self\n            if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const entityPosition = entityTransform.position;\n            const distance = centerPosition.distanceTo(entityPosition);\n            // Check if entity is within freeze radius\n            if (distance <= radius) {\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                if (enemy) {\n                    // This is an enemy - freeze it (single player mode)\n                    enemy.freeze(6.0, currentTime);\n                    frozenCount++;\n                    console.log(\"❄️ Frozen enemy at distance \".concat(distance.toFixed(2), \" units\"));\n                    // Add frozen visual effect for this enemy\n                    (0,_components_weapons_FrostNovaManager__WEBPACK_IMPORTED_MODULE_11__.addGlobalFrozenEnemy)(entity.id.toString(), entityPosition);\n                } else {\n                    // This is likely another player in PVP mode - deal damage and freeze\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        const frostNovaDamage = 50; // Frost Nova damage\n                        combatSystem.queueDamage(entity, frostNovaDamage, this.playerEntity, \"frost_nova\");\n                        damagedPlayers++;\n                        console.log(\"❄️ Frost Nova hit player \".concat(entity.id, \" for \").concat(frostNovaDamage, \" damage at distance \").concat(distance.toFixed(2), \" units\"));\n                        // Broadcast freeze effect to the target player so they get frozen on their end\n                        if (this.onDebuffCallback) {\n                            console.log(\"❄️ Broadcasting freeze effect to PVP player \".concat(entity.id));\n                            console.log(\"\\uD83D\\uDD0D Debug: Calling debuff callback with entityId=\".concat(entity.id, \", type=frozen, duration=3000\"));\n                            this.onDebuffCallback(entity.id, \"frozen\", 6000, entityPosition);\n                            console.log(\"✅ Debug: Debuff callback completed\");\n                        } else {\n                            console.warn(\"⚠️ Debug: onDebuffCallback is not set!\");\n                        }\n                    }\n                }\n            }\n        });\n        if (frozenCount > 0) {\n            console.log(\"❄️ Frost Nova froze \".concat(frozenCount, \" enemies within \").concat(radius, \" unit radius\"));\n        }\n        if (damagedPlayers > 0) {\n            console.log(\"❄️ Frost Nova damaged \".concat(damagedPlayers, \" players within \").concat(radius, \" unit radius\"));\n        }\n    }\n    createChargedArrowProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create charged arrow projectile - more powerful than regular arrows\n        const chargedArrowConfig = {\n            speed: 35,\n            damage: 50,\n            lifetime: 5,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        };\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, chargedArrowConfig);\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"charged_arrow\", spawnPosition, direction, chargedArrowConfig);\n        }\n    }\n    createPerfectShotProjectile(position, direction) {\n        if (!this.playerEntity) return;\n        // Offset projectile spawn position slightly forward to avoid collision with player\n        const spawnPosition = position.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        spawnPosition.y += 0.5; // Slightly higher\n        // Create perfect shot projectile - enhanced charged arrow with special effects\n        this.projectileSystem.createChargedArrowProjectile(this.world, spawnPosition, direction, this.playerEntity.id, {\n            speed: 40,\n            damage: 75,\n            lifetime: 6,\n            piercing: true,\n            explosive: false,\n            subclass: this.currentSubclass,\n            level: this.currentLevel,\n            opacity: 1.0\n        });\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"perfect_shot\", spawnPosition, direction, {\n                speed: 40,\n                damage: 75,\n                lifetime: 6,\n                piercing: true,\n                subclass: this.currentSubclass,\n                level: this.currentLevel,\n                opacity: 1.0\n            });\n        }\n        console.log(\"✨ Perfect shot projectile created with enhanced stats!\");\n    }\n    // Methods to configure weapon for testing\n    setWeaponSubclass(subclass) {\n        this.currentSubclass = subclass;\n        console.log(\"\\uD83C\\uDFF9 Weapon subclass changed to: \".concat(subclass));\n    }\n    // Method to set bow release callback\n    setBowReleaseCallback(callback) {\n        this.onBowReleaseCallback = callback;\n    }\n    setDivineStormCallback(callback) {\n        this.onDivineStormCallback = callback;\n    }\n    setProjectileCreatedCallback(callback) {\n        this.onProjectileCreatedCallback = callback;\n    }\n    setViperStingCallback(callback) {\n        this.onViperStingCallback = callback;\n    }\n    setBarrageCallback(callback) {\n        this.onBarrageCallback = callback;\n    }\n    setReanimateCallback(callback) {\n        this.onReanimateCallback = callback;\n    }\n    setFrostNovaCallback(callback) {\n        this.onFrostNovaCallback = callback;\n    }\n    setCobraShotCallback(callback) {\n        this.onCobraShotCallback = callback;\n    }\n    setChargeCallback(callback) {\n        this.onChargeCallback = callback;\n    }\n    setDeflectCallback(callback) {\n        this.onDeflectCallback = callback;\n    }\n    setDebuffCallback(callback) {\n        this.onDebuffCallback = callback;\n    }\n    // Method to trigger bow release effects\n    triggerBowReleaseEffects(finalChargeProgress) {\n        if (this.onBowReleaseCallback) {\n            // Check if this was a perfect shot\n            const perfectShotMinThreshold = 0.8; // 85% charge\n            const perfectShotMaxThreshold = 0.98; // 95% charge\n            const isPerfectShot = finalChargeProgress >= perfectShotMinThreshold && finalChargeProgress <= perfectShotMaxThreshold;\n            this.onBowReleaseCallback(finalChargeProgress, isPerfectShot);\n        }\n    }\n    setWeaponLevel(level) {\n        this.currentLevel = level;\n        console.log(\"⬆️ Weapon level changed to: \".concat(level));\n    }\n    getCurrentWeaponConfig() {\n        return {\n            weapon: this.currentWeapon,\n            subclass: this.currentSubclass,\n            level: this.currentLevel\n        };\n    }\n    // Getters for weapon state (for UI/rendering)\n    getCurrentWeapon() {\n        return this.currentWeapon;\n    }\n    getCurrentSubclass() {\n        return this.currentSubclass;\n    }\n    isWeaponCharging() {\n        return this.isCharging;\n    }\n    getChargeProgress() {\n        return this.chargeProgress;\n    }\n    isViperStingChargingActive() {\n        return this.isViperStingCharging;\n    }\n    getViperStingChargeProgress() {\n        return this.viperStingChargeProgress;\n    }\n    isBarrageChargingActive() {\n        return this.isBarrageCharging;\n    }\n    getBarrageChargeProgress() {\n        return this.barrageChargeProgress;\n    }\n    isCobraShotChargingActive() {\n        return this.isCobraShotCharging;\n    }\n    getCobraShotChargeProgress() {\n        return this.cobraShotChargeProgress;\n    }\n    isWeaponSwinging() {\n        return this.isSwinging;\n    }\n    // Sword-specific getters\n    getSwordComboStep() {\n        return this.swordComboStep;\n    }\n    isDivineStormActive() {\n        return this.isDivineStorming;\n    }\n    isChargeActive() {\n        return this.isSwordCharging;\n    }\n    isDeflectActive() {\n        return this.isDeflecting;\n    }\n    handleSwordInput(playerTransform) {\n        // Handle sword melee attacks\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging && !this.isDivineStorming && !this.isSwordCharging && !this.isDeflecting) {\n            this.performSwordMeleeAttack(playerTransform);\n        }\n        // Handle Divine Storm ability with 'R' key\n        if (this.inputManager.isKeyPressed(\"r\") && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging && !this.isDeflecting) {\n            this.performDivineStorm(playerTransform);\n        }\n        // Handle Charge ability with 'E' key\n        if (this.inputManager.isKeyPressed(\"e\") && !this.isSwordCharging && !this.isDivineStorming && !this.isSwinging && !this.isDeflecting) {\n            this.performCharge(playerTransform);\n        }\n        // Handle Deflect ability with 'Q' key\n        if (this.inputManager.isKeyPressed(\"q\") && !this.isDeflecting && !this.isDivineStorming && !this.isSwinging && !this.isSwordCharging) {\n            this.performDeflect(playerTransform);\n        }\n        // Check for combo reset\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastSwordAttackTime > this.swordComboResetTime) {\n            this.swordComboStep = 1;\n        }\n    }\n    performSwordMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sword-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.swordFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        this.lastSwordAttackTime = currentTime;\n        console.log(\"\\uD83D\\uDDE1️ Sword melee attack - Combo step \".concat(this.swordComboStep));\n        // Set swinging state - completion will be handled by sword component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player\n        this.performMeleeDamage(playerTransform);\n    // Note: Swing completion and combo advancement is now handled by onSwordSwingComplete callback\n    }\n    // Called by sword component when swing animation completes\n    onSwordSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\"\\uD83D\\uDDE1️ Sword swing completed - was combo step \".concat(this.swordComboStep));\n        // Reset swinging state\n        this.isSwinging = false;\n        // Advance combo step for next attack\n        this.swordComboStep = this.swordComboStep % 3 + 1;\n        console.log(\"\\uD83D\\uDDE1️ Next combo step will be: \".concat(this.swordComboStep));\n    }\n    handleSabresInput(playerTransform) {\n        // Handle left click for dual sabre attack\n        if (this.inputManager.isMouseButtonPressed(0) && !this.isSwinging) {\n            this.performSabresMeleeAttack(playerTransform);\n        }\n    }\n    performSabresMeleeAttack(playerTransform) {\n        // Rate limiting - prevent spam clicking (use sabres-specific fire rate)\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastFireTime < this.sabresFireRate) {\n            return;\n        }\n        this.lastFireTime = currentTime;\n        console.log(\"⚔️ Sabres dual attack initiated\");\n        // Set swinging state - completion will be handled by sabres component callback\n        this.isSwinging = true;\n        // Perform melee damage in a cone in front of player (dual attack)\n        this.performSabresMeleeDamage(playerTransform);\n    }\n    // Called by sabres component when swing animation completes\n    onSabresSwingComplete() {\n        if (!this.isSwinging) return; // Prevent multiple calls\n        console.log(\"⚔️ Sabres dual swing completed\");\n        // Reset swinging state\n        this.isSwinging = false;\n    }\n    performSabresMeleeDamage(playerTransform) {\n        const currentTime = Date.now() / 1000;\n        // Get all entities that could be damaged\n        const allEntities = this.world.getAllEntities();\n        const potentialTargets = allEntities.filter((entity)=>entity.hasComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health) && entity.hasComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform) && entity !== this.playerEntity);\n        // SABRES DAMAGE\n        const attackRange = 4; // Slightly longer range than sword\n        const attackAngle = Math.PI / 2.5; // 60 degree cone (wider than sword)\n        const leftSabreDamage = 19; // Damage per sabre\n        const rightSabreDamage = 23;\n        // Get camera direction for attack direction\n        const attackDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(attackDirection);\n        attackDirection.normalize();\n        let hitCount = 0;\n        for (const target of potentialTargets){\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!targetTransform || !targetHealth || targetHealth.isDead) continue;\n            // Calculate direction to target\n            const directionToTarget = targetTransform.position.clone().sub(playerTransform.position);\n            const distanceToTarget = directionToTarget.length();\n            // Check if target is within range\n            if (distanceToTarget > attackRange) continue;\n            // Check if target is within attack cone\n            directionToTarget.normalize();\n            const dotProduct = attackDirection.dot(directionToTarget);\n            const angleToTarget = Math.acos(Math.max(-1, Math.min(1, dotProduct)));\n            if (angleToTarget > attackAngle / 2) continue;\n            // Target is within range and cone - apply damage from both sabres\n            const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n            if (combatSystem) {\n                // Left sabre hit (immediate)\n                combatSystem.queueDamage(target, leftSabreDamage, this.playerEntity || undefined);\n                // Right sabre hit (with small delay)\n                setTimeout(()=>{\n                    if (!targetHealth.isDead) {\n                        combatSystem.queueDamage(target, rightSabreDamage, this.playerEntity || undefined);\n                    }\n                }, 100); // 100ms delay between sabre hits\n                hitCount++;\n                console.log(\"⚔️ Sabres hit target at distance \".concat(distanceToTarget.toFixed(2), \" for \").concat(leftSabreDamage + rightSabreDamage, \" total damage\"));\n            }\n        }\n        if (hitCount === 0) {\n            console.log(\"⚔️ Sabres attack missed - no targets in range\");\n        } else {\n            console.log(\"⚔️ Sabres attack hit \".concat(hitCount, \" target(s)\"));\n        }\n    }\n    performMeleeDamage(playerTransform) {\n        // Get all entities in the world to check for enemies\n        const allEntities = this.world.getAllEntities();\n        const playerPosition = playerTransform.position;\n        // Get player facing direction (camera direction)\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Melee attack parameters - increased for PVP combat\n        const meleeRange = 4.9; // Increased attack range for PVP\n        const meleeAngle = Math.PI / 2; // 120 degree cone (60 degrees each side)\n        // Base damage values based on combo step - works for all subclasses\n        let baseDamage = 25; // Base sword damage\n        // Combo damage scaling\n        switch(this.swordComboStep){\n            case 1:\n                baseDamage = 25;\n                break;\n            case 2:\n                baseDamage = 30;\n                break;\n            case 3:\n                baseDamage = 40;\n                break; // Finisher does more damage\n        }\n        // Get combat system to apply damage\n        const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n        // Track enemies hit for rage generation\n        let enemiesHit = 0;\n        allEntities.forEach((entity)=>{\n            var _this_playerEntity;\n            // Check if entity has enemy component and health\n            const enemyTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const enemyHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            if (!enemyTransform || !enemyHealth || entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n            const enemyPosition = enemyTransform.position;\n            const toEnemy = enemyPosition.clone().sub(playerPosition);\n            const distance = toEnemy.length();\n            // Debug logging for PVP hit detection\n            console.log(\"\\uD83C\\uDFAF PVP Sword check - Entity \".concat(entity.id, \": Player pos (\").concat(playerPosition.x.toFixed(2), \", \").concat(playerPosition.y.toFixed(2), \", \").concat(playerPosition.z.toFixed(2), \"), Enemy pos (\").concat(enemyPosition.x.toFixed(2), \", \").concat(enemyPosition.y.toFixed(2), \", \").concat(enemyPosition.z.toFixed(2), \"), Distance: \").concat(distance.toFixed(2), \", Range: \").concat(meleeRange));\n            // Check if enemy is within range\n            if (distance <= meleeRange) {\n                // Check if enemy is within attack cone\n                toEnemy.normalize();\n                const angle = direction.angleTo(toEnemy);\n                const angleDegrees = angle * 180 / Math.PI;\n                const maxAngleDegrees = meleeAngle / 2 * 180 / Math.PI;\n                console.log(\"\\uD83C\\uDFAF PVP Sword angle check - Entity \".concat(entity.id, \": Angle \").concat(angleDegrees.toFixed(1), \"\\xb0, Max angle: \").concat(maxAngleDegrees.toFixed(1), \"\\xb0\"));\n                if (angle <= meleeAngle / 2) {\n                    // Enemy is within attack cone - deal damage through combat system\n                    console.log(\"\\uD83D\\uDDE1️ PVP Sword hit confirmed! Entity \".concat(entity.id, \" at distance \").concat(distance.toFixed(2), \", angle \").concat(angleDegrees.toFixed(1), \"\\xb0\"));\n                    if (combatSystem && this.playerEntity) {\n                        // Queue damage through combat system (which will route to multiplayer for enemies)\n                        combatSystem.queueDamage(entity, baseDamage, this.playerEntity, \"melee\");\n                        console.log(\"\\uD83D\\uDCA5 Queued \".concat(baseDamage, \" melee damage to entity \").concat(entity.id, \" (combo step \").concat(this.swordComboStep, \")\"));\n                        enemiesHit++;\n                    }\n                } else {\n                    console.log(\"❌ PVP Sword missed - Entity \".concat(entity.id, \" outside attack cone (\").concat(angleDegrees.toFixed(1), \"\\xb0 > \").concat(maxAngleDegrees.toFixed(1), \"\\xb0)\"));\n                }\n            } else {\n                console.log(\"❌ PVP Sword missed - Entity \".concat(entity.id, \" out of range (\").concat(distance.toFixed(2), \" > \").concat(meleeRange, \")\"));\n            }\n        });\n        // Generate rage only if we hit enemies (5 rage per hit, max 5 per swing)\n        if (enemiesHit > 0) {\n            const gameUI = window.gameUI;\n            if (gameUI) {\n                const rageBefore = gameUI.getCurrentRage ? gameUI.getCurrentRage() : \"unknown\";\n                const rageToGain = Math.min(enemiesHit * 5, 5); // 5 rage per hit, max 5 per swing\n                gameUI.gainRage(rageToGain);\n                const rageAfter = gameUI.getCurrentRage ? gameUI.getCurrentRage() : \"unknown\";\n                console.log(\"\\uD83D\\uDDE1️ Gained \".concat(rageToGain, \" rage from hitting \").concat(enemiesHit, \" enemies with sword combo \").concat(this.swordComboStep, \" - Rage: \").concat(rageBefore, \" → \").concat(rageAfter));\n            }\n        }\n    }\n    checkForDashInput(movement, transform) {\n        // Check for double-tap on movement keys\n        const dashDirections = [\n            {\n                key: \"w\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)\n            },\n            {\n                key: \"s\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1)\n            },\n            {\n                key: \"a\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-1, 0, 0)\n            },\n            {\n                key: \"d\",\n                direction: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0)\n            } // Right\n        ];\n        for (const { key, direction } of dashDirections){\n            if (this.inputManager.checkDoubleTap(key)) {\n                // Debug: Log the double tap detection\n                const debugInfo = this.inputManager.getDoubleTapDebugInfo(key);\n                console.log(\"\\uD83D\\uDD0D Double tap detected for key '\".concat(key.toUpperCase(), \"':\"), debugInfo);\n                // Convert input direction to world space based on camera orientation\n                const worldDirection = this.getWorldSpaceDirection(direction);\n                // Attempt to start dash\n                const currentTime = Date.now() / 1000; // Convert to seconds\n                const dashStarted = movement.startDash(worldDirection, transform.position, currentTime);\n                if (dashStarted) {\n                    console.log(\"\\uD83C\\uDFC3 Dash started in direction: \".concat(key.toUpperCase()));\n                    // Reset the double-tap state to prevent multiple dashes\n                    this.inputManager.resetDoubleTap(key);\n                } else {\n                    console.warn(\"❌ Dash failed to start for key: \".concat(key.toUpperCase()));\n                }\n                break; // Only process one dash per frame\n            }\n        }\n    }\n    handleDashMovement(movement, transform) {\n        if (!movement.isDashing) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        const dashResult = movement.updateDash(currentTime);\n        if (dashResult.newPosition) {\n            // Apply bounds checking (similar to old implementation)\n            const MAX_DASH_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = dashResult.newPosition.length();\n            if (distanceFromOrigin <= MAX_DASH_BOUNDS) {\n                transform.position.copy(dashResult.newPosition);\n            } else {\n                // Cancel dash if it would move too far from origin\n                console.warn(\"Dash cancelled: would move too far from origin (\".concat(distanceFromOrigin.toFixed(2), \" > \").concat(MAX_DASH_BOUNDS, \")\"));\n                movement.cancelDash();\n            }\n        }\n        if (dashResult.isComplete) {\n            console.log(\"\\uD83C\\uDFC1 Dash completed\");\n        }\n    }\n    handleChargeMovement(movement, transform) {\n        if (!movement.isCharging) return;\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        // Check if charge was stopped by collision\n        if (this.chargeStoppedByCollision) {\n            movement.cancelCharge();\n            return;\n        }\n        const chargeResult = movement.updateCharge(currentTime);\n        if (chargeResult.newPosition) {\n            // Apply bounds checking\n            const MAX_CHARGE_BOUNDS = 29; // Maximum distance from origin (matches map boundary)\n            const distanceFromOrigin = chargeResult.newPosition.length();\n            // Check for pillar collision\n            const pillarCollision = this.checkPillarCollision(chargeResult.newPosition);\n            if (distanceFromOrigin > MAX_CHARGE_BOUNDS) {\n                // Cancel charge if it would move too far from origin\n                console.warn(\"Charge cancelled: would move too far from origin (\".concat(distanceFromOrigin.toFixed(2), \" > \").concat(MAX_CHARGE_BOUNDS, \")\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (pillarCollision.hasCollision) {\n                // Cancel charge if it would collide with a pillar\n                console.warn(\"Charge cancelled: would collide with pillar at [\".concat(pillarCollision.pillarCenter.toArray().join(\", \"), \"]\"));\n                movement.cancelCharge();\n                // Notify sword component that charge was cancelled\n                this.onChargeComplete();\n            } else if (!this.chargeStoppedByCollision) {\n                // Only update position if not stopped by collision\n                transform.position.copy(chargeResult.newPosition);\n            }\n        }\n        if (chargeResult.isComplete || this.chargeStoppedByCollision) {\n            console.log(\"⚔️ Charge movement completed\");\n            // Notify sword component that charge is complete\n            this.onChargeComplete();\n        }\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    getWorldSpaceDirection(inputDirection) {\n        // Get camera direction vectors\n        const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(cameraDirection);\n        // Get camera's right vector\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(cameraDirection, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Get camera's forward vector (projected on XZ plane)\n        const cameraForward = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraForward.crossVectors(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0), cameraRight).normalize();\n        // Transform input direction to world space\n        const worldDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        worldDirection.addScaledVector(cameraRight, inputDirection.x);\n        worldDirection.addScaledVector(cameraForward, -inputDirection.z);\n        worldDirection.normalize();\n        return worldDirection;\n    }\n    performDivineStorm(playerTransform) {\n        // Check if player has enough rage (minimum 20 rage required)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastDivineStorm()) {\n            console.log(\"⚡ Not enough rage to cast Divine Storm (requires minimum 20 rage)\");\n            return;\n        }\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDivineStormTime < this.divineStormCooldown) {\n            console.log(\"⏰ Divine Storm on cooldown for \".concat((this.divineStormCooldown - (currentTime - this.lastDivineStormTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Get current rage amount and consume ALL rage\n        const currentRage = gameUI ? gameUI.getCurrentRage() : 40; // Fallback to 20 if gameUI not available\n        if (gameUI) {\n            gameUI.consumeAllRage(); // Consume all rage instead of just 20\n            console.log(\"⚡ Consumed \".concat(currentRage, \" rage for Divine Storm\"));\n        }\n        // Calculate extended duration: base 4 seconds + 1 second per 10 rage consumed\n        const baseStormDuration = 1000; // 4 seconds base\n        const bonusDuration = Math.floor(currentRage / 10) * 500; // 1 second per 10 rage\n        const totalDivineStormDuration = baseStormDuration + bonusDuration;\n        console.log(\"⚡ Divine Storm activated! Duration: \".concat(totalDivineStormDuration / 1000, \"s (base: 4s + bonus: \").concat(bonusDuration / 1000, \"s from \").concat(currentRage, \" rage)\"));\n        this.isDivineStorming = true;\n        this.lastDivineStormTime = currentTime;\n        // Trigger Divine Storm callback for multiplayer\n        if (this.onDivineStormCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDivineStormCallback(playerTransform.position.clone(), direction, totalDivineStormDuration);\n        }\n        // Divine Storm lasts for calculated duration\n        setTimeout(()=>{\n            this.isDivineStorming = false;\n            console.log(\"⚡ Divine Storm completed\");\n        }, totalDivineStormDuration);\n    }\n    performCharge(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastChargeTime < this.chargeCooldown) {\n            console.log(\"⏰ Charge on cooldown for \".concat((this.chargeCooldown - (currentTime - this.lastChargeTime)).toFixed(1), \"s\"));\n            return;\n        }\n        console.log(\"⚔️ Charge activated!\");\n        this.isSwordCharging = true;\n        this.lastChargeTime = currentTime;\n        // Reset collision tracking for new charge\n        this.chargeStoppedByCollision = false;\n        // Trigger Charge callback for multiplayer\n        if (this.onChargeCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onChargeCallback(playerTransform.position.clone(), direction);\n        }\n        // Gain rage for using charge ability (+20 rage)\n        const gameUI = window.gameUI;\n        if (gameUI) {\n            gameUI.gainRage(20);\n            console.log(\"⚔️ Gained 20 rage from using Charge ability\");\n        }\n        // Start the charge movement using the separate charge system\n        if (this.playerEntity) {\n            const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (playerMovement) {\n                // Get charge direction from camera\n                const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(direction);\n                direction.y = 0; // Keep movement horizontal\n                direction.normalize();\n                // Start charge with 10.5 distance (separate from dash system)\n                const chargeStarted = playerMovement.startCharge(direction, playerTransform.position, currentTime);\n                if (chargeStarted) {\n                    console.log(\"⚔️ Charge movement started with 10.5 distance\");\n                    // Schedule charge damage detection during movement\n                    this.scheduleChargeDamage(playerTransform, direction, currentTime);\n                } else {\n                    console.warn(\"⚔️ Charge failed to start (already charging or dashing)\");\n                }\n            }\n        }\n    }\n    // Schedule damage detection during charge movement\n    scheduleChargeDamage(playerTransform, chargeDirection, startTime) {\n        const chargeDuration = 0.75; // Charge lasts about 1.5 seconds\n        const damageCheckInterval = 50; // Check for damage every 50ms for better collision detection\n        const chargeDamage = 40; // High damage for charge ability\n        const chargeRadius = 2.5; // Damage radius around player during charge\n        // Reset charge hit tracking\n        this.chargeHitEntities.clear();\n        this.chargeStoppedByCollision = false;\n        const damageInterval = setInterval(()=>{\n            const currentTime = Date.now() / 1000;\n            // Stop if charge is complete, cancelled, or stopped by collision\n            if (!this.isSwordCharging || currentTime - startTime > chargeDuration || this.chargeStoppedByCollision) {\n                clearInterval(damageInterval);\n                return;\n            }\n            // Get all entities in the world to check for damage\n            const allEntities = this.world.getAllEntities();\n            const playerPosition = playerTransform.position;\n            let hitSomething = false;\n            // Debug: Log all entities in the world during charge\n            console.log(\"\\uD83D\\uDD0D Charge collision check - Total entities in world: \".concat(allEntities.length));\n            // ENHANCED: Also check against server player positions directly as a fallback\n            // This ensures we don't miss collisions due to entity sync issues\n            const serverPlayers = window.pvpPlayers || new Map();\n            const localSocketId = window.localSocketId;\n            console.log(\"\\uD83D\\uDD0D Also checking \".concat(serverPlayers.size, \" server players directly for collision\"));\n            serverPlayers.forEach((serverPlayer, playerId)=>{\n                // Skip self\n                if (playerId === localSocketId) return;\n                // Skip already hit players (use hash of player ID for tracking)\n                const playerIdHash = playerId.length * 1000 + playerId.charCodeAt(0);\n                if (this.chargeHitEntities.has(playerIdHash)) return;\n                const serverPlayerPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(serverPlayer.position.x, serverPlayer.position.y, serverPlayer.position.z);\n                const distance = playerPosition.distanceTo(serverPlayerPos);\n                const stopDistance = 0.9 + 1.0; // Player collision radius + buffer\n                console.log(\"\\uD83D\\uDD0D Direct server player check - \".concat(playerId, \": distance=\").concat(distance.toFixed(2), \", stopDistance=\").concat(stopDistance.toFixed(2)));\n                if (distance <= stopDistance && serverPlayer.health > 0) {\n                    console.log(\"⚔️ Direct server collision detected with player \".concat(playerId, \"!\"));\n                    this.chargeHitEntities.add(playerIdHash);\n                    hitSomething = true;\n                    // Apply damage through PVP system if available\n                    if (this.onProjectileCreatedCallback) {\n                        this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                            damage: chargeDamage,\n                            targetId: playerId,\n                            hitPosition: {\n                                x: serverPlayerPos.x,\n                                y: serverPlayerPos.y,\n                                z: serverPlayerPos.z\n                            }\n                        });\n                    }\n                }\n            });\n            allEntities.forEach((entity)=>{\n                var _this_playerEntity;\n                // Skip self\n                if (entity.id === ((_this_playerEntity = this.playerEntity) === null || _this_playerEntity === void 0 ? void 0 : _this_playerEntity.id)) return;\n                // Skip already hit entities\n                if (this.chargeHitEntities.has(entity.id)) return;\n                // Check if entity has transform and health (could be enemy or player)\n                const entityTransform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n                const entityHealth = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n                const entityCollider = entity.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_7__.Collider);\n                // Debug: Log entity details\n                const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                console.log(\"\\uD83D\\uDD0D Checking entity \".concat(entity.id, \" (\").concat(entityType, \"): transform=\").concat(!!entityTransform, \", health=\").concat(!!entityHealth, \", collider=\").concat(!!entityCollider, \", isDead=\").concat(entityHealth === null || entityHealth === void 0 ? void 0 : entityHealth.isDead));\n                if (!entityTransform || !entityHealth || entityHealth.isDead) return;\n                const entityPosition = entityTransform.position;\n                const distance = playerPosition.distanceTo(entityPosition);\n                // Check if entity is within charge damage radius\n                // In PVP, we want to stop just before hitting the enemy, not overlap with them\n                const stopDistance = entityCollider ? entityCollider.radius + 1.0 : chargeRadius; // Stop 1 unit away from enemy edge\n                // Debug: Log position and distance information\n                console.log(\"\\uD83D\\uDD0D Entity \".concat(entity.id, \" (\").concat(entityType, \"): playerPos=[\").concat(playerPosition.x.toFixed(2), \", \").concat(playerPosition.y.toFixed(2), \", \").concat(playerPosition.z.toFixed(2), \"], entityPos=[\").concat(entityPosition.x.toFixed(2), \", \").concat(entityPosition.y.toFixed(2), \", \").concat(entityPosition.z.toFixed(2), \"], distance=\").concat(distance.toFixed(2), \", stopDistance=\").concat(stopDistance.toFixed(2), \", colliderRadius=\").concat((entityCollider === null || entityCollider === void 0 ? void 0 : entityCollider.radius) || \"none\"));\n                if (distance <= stopDistance) {\n                    // Mark as hit to prevent multiple hits\n                    this.chargeHitEntities.add(entity.id);\n                    hitSomething = true;\n                    // Apply damage through combat system\n                    const combatSystem = this.world.getSystem(_CombatSystem__WEBPACK_IMPORTED_MODULE_8__.CombatSystem);\n                    if (combatSystem && this.playerEntity) {\n                        combatSystem.queueDamage(entity, chargeDamage, this.playerEntity, \"charge\");\n                        const enemy = entity.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_5__.Enemy);\n                        const entityType = enemy ? \"Enemy(\".concat(enemy.getDisplayName(), \")\") : \"Player(\".concat(entity.id, \")\");\n                        console.log(\"⚔️ Charge hit \".concat(entityType, \" for \").concat(chargeDamage, \" damage at distance \").concat(distance.toFixed(2)));\n                        // Broadcast charge attack for PVP (includes damage and animation)\n                        if (this.onProjectileCreatedCallback) {\n                            this.onProjectileCreatedCallback(\"sword_charge_hit\", playerPosition.clone(), chargeDirection.clone(), {\n                                damage: chargeDamage,\n                                targetId: entity.id,\n                                hitPosition: {\n                                    x: entityPosition.x,\n                                    y: entityPosition.y,\n                                    z: entityPosition.z\n                                }\n                            });\n                        }\n                    }\n                }\n            });\n            // In PVP mode, stop charge when hitting something\n            if (hitSomething) {\n                console.log(\"⚔️ Charge stopped by collision - ending charge movement\");\n                this.chargeStoppedByCollision = true;\n                // Stop the charge movement immediately\n                if (this.playerEntity) {\n                    const playerMovement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                    if (playerMovement) {\n                        playerMovement.cancelCharge();\n                    }\n                }\n                // Clear the damage interval immediately to prevent further hits\n                clearInterval(damageInterval);\n                // Trigger charge completion\n                this.onChargeComplete();\n            }\n        }, damageCheckInterval);\n    }\n    // Called by sword component when Charge completes\n    onChargeComplete() {\n        console.log(\"⚔️ Charge completed\");\n        this.isSwordCharging = false;\n    }\n    performDeflect(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastDeflectTime < this.deflectCooldown) {\n            console.log(\"⏰ Deflect on cooldown for \".concat((this.deflectCooldown - (currentTime - this.lastDeflectTime)).toFixed(1), \"s\"));\n            return;\n        }\n        console.log(\"\\uD83D\\uDEE1️ Deflect activated!\");\n        this.isDeflecting = true;\n        this.lastDeflectTime = currentTime;\n        // Trigger Deflect callback for multiplayer\n        if (this.onDeflectCallback) {\n            const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            this.camera.getWorldDirection(direction);\n            direction.normalize();\n            this.onDeflectCallback(playerTransform.position.clone(), direction);\n        }\n        // Set up deflect barrier that blocks damage and reflects projectiles\n        this.setupDeflectBarrier(playerTransform);\n        // Auto-complete deflect after duration\n        setTimeout(()=>{\n            this.onDeflectComplete();\n        }, this.deflectDuration * 1000);\n    }\n    performViperSting(playerTransform) {\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastViperStingTime < this.viperStingFireRate) {\n            console.log(\"⏰ Viper Sting on cooldown for \".concat((this.viperStingFireRate - (currentTime - this.lastViperStingTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (60 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastViperSting()) {\n            console.log(\"\\uD83D\\uDC0D Not enough energy to cast Viper Sting (requires 60 energy)\");\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(60);\n            console.log(\"\\uD83D\\uDC0D Consumed 60 energy for Viper Sting\");\n        }\n        console.log(\"\\uD83D\\uDC0D Viper Sting activated - starting charge!\");\n        this.isViperStingCharging = true;\n        this.viperStingChargeProgress = 0;\n        this.lastViperStingTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 1000; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.viperStingChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.viperStingChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireViperSting(playerTransform);\n                this.isViperStingCharging = false;\n                this.viperStingChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireViperSting(playerTransform) {\n        console.log(\"\\uD83D\\uDC0D Firing Viper Sting projectile!\");\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 0.75; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        direction.normalize();\n        // Apply same downward angle compensation as other projectiles\n        const compensationAngle = Math.PI / 6; // 30 degrees downward compensation\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        // Apply rotation around the right axis to tilt the direction downward\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Offset spawn position slightly forward to avoid collision with player\n        const spawnPosition = playerPosition.clone();\n        spawnPosition.add(direction.clone().multiplyScalar(1)); // 1 unit forward\n        // Note: Viper Sting damage is handled by ViperStingManager, not ECS projectiles\n        // This prevents duplicate projectiles and damage\n        // Trigger Viper Sting callback for visual effects\n        if (this.onViperStingCallback) {\n            this.onViperStingCallback(playerPosition, direction);\n        }\n        // Trigger the global Viper Sting manager for visual effects\n        const success = (0,_components_projectiles_ViperStingManager__WEBPACK_IMPORTED_MODULE_13__.triggerGlobalViperSting)();\n        if (success) {\n            console.log(\"\\uD83D\\uDC0D Viper Sting visual effects successfully triggered!\");\n        }\n        // Broadcast projectile creation to other players\n        if (this.onProjectileCreatedCallback) {\n            this.onProjectileCreatedCallback(\"viper_sting_projectile\", spawnPosition, direction, {\n                speed: 16,\n                damage: 61,\n                lifetime: 5,\n                isReturning: false\n            });\n        }\n    }\n    performBarrage(playerTransform) {\n        console.log(\"\\uD83C\\uDFF9 performBarrage called!\");\n        // Check cooldown\n        const currentTime = Date.now() / 1000;\n        if (currentTime - this.lastBarrageTime < this.barrageFireRate) {\n            console.log(\"⏰ Barrage on cooldown for \".concat((this.barrageFireRate - (currentTime - this.lastBarrageTime)).toFixed(1), \"s\"));\n            return;\n        }\n        // Check if player has enough energy (40 energy cost)\n        const gameUI = window.gameUI;\n        if (gameUI && !gameUI.canCastBarrage()) {\n            console.log(\"\\uD83C\\uDFF9 Not enough energy to cast Barrage (requires 40 energy)\");\n            return;\n        }\n        // Consume energy\n        if (gameUI) {\n            gameUI.consumeEnergy(40);\n            console.log(\"\\uD83C\\uDFF9 Consumed 40 energy for Barrage\");\n        }\n        console.log(\"\\uD83C\\uDFF9 Barrage activated - starting charge!\");\n        this.isBarrageCharging = true;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = currentTime;\n        // Start charging animation\n        const chargeStartTime = Date.now();\n        const chargeDuration = 500; // 1 second charge time\n        const chargeInterval = setInterval(()=>{\n            const elapsed = Date.now() - chargeStartTime;\n            this.barrageChargeProgress = Math.min(elapsed / chargeDuration, 1.0);\n            if (this.barrageChargeProgress >= 1.0) {\n                clearInterval(chargeInterval);\n                this.fireBarrage(playerTransform);\n                this.isBarrageCharging = false;\n                this.barrageChargeProgress = 0;\n            }\n        }, 16); // ~60fps updates\n    }\n    fireBarrage(playerTransform) {\n        console.log(\"\\uD83C\\uDFF9 Firing Barrage projectiles!\");\n        // Get player position and direction\n        const playerPosition = playerTransform.getWorldPosition();\n        playerPosition.y += 1; // Shoot from chest level\n        const direction = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.camera.getWorldDirection(direction);\n        // Apply same downward compensation as projectile system\n        const compensationAngle = Math.PI / 6; // 30 degrees\n        const cameraRight = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        cameraRight.crossVectors(direction, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0)).normalize();\n        const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        rotationMatrix.makeRotationAxis(cameraRight, compensationAngle);\n        direction.applyMatrix4(rotationMatrix);\n        direction.normalize();\n        // Create 5 arrows: center (0°), left (15°, 30°), right (-15°, -30°) using proper ECS projectiles\n        const angles = [\n            0,\n            Math.PI / 12,\n            -Math.PI / 12,\n            Math.PI / 6,\n            -Math.PI / 6\n        ]; // 0°, 15°, -15°, 30°, -30°\n        angles.forEach((angle)=>{\n            // Rotate the base direction by the specified angle around the Y axis\n            const projectileDirection = direction.clone();\n            const rotationMatrix = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Matrix4().makeRotationY(angle);\n            projectileDirection.applyMatrix4(rotationMatrix);\n            projectileDirection.normalize();\n            // Offset spawn position slightly forward to avoid collision with player\n            const spawnPosition = playerPosition.clone();\n            spawnPosition.add(projectileDirection.clone().multiplyScalar(1)); // 1 unit forward\n            // Create proper ECS projectile entity\n            const projectileConfig = {\n                speed: 22,\n                damage: 30,\n                lifetime: 8,\n                piercing: false,\n                subclass: this.currentSubclass,\n                level: 1,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, spawnPosition, projectileDirection, this.playerEntity.id, projectileConfig);\n            // Mark as barrage arrow for visual identification\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_6__.Renderer);\n            if (renderer === null || renderer === void 0 ? void 0 : renderer.mesh) {\n                renderer.mesh.userData.isBarrageArrow = true;\n                renderer.mesh.userData.isRegularArrow = false; // Override regular arrow marking\n            }\n            // Broadcast projectile creation to other players\n            if (this.onProjectileCreatedCallback) {\n                this.onProjectileCreatedCallback(\"barrage_projectile\", spawnPosition, projectileDirection, projectileConfig);\n            }\n            console.log(\"\\uD83C\\uDFF9 Created Barrage arrow \".concat(projectileEntity.id, \" at angle \").concat((angle * 180 / Math.PI).toFixed(1), \"\\xb0\"));\n        });\n        // Trigger Barrage callback for additional visual effects if needed\n        if (this.onBarrageCallback) {\n            this.onBarrageCallback(playerPosition, direction);\n        }\n        console.log(\"\\uD83C\\uDFF9 Barrage successfully fired with 5 ECS projectiles!\");\n    }\n    setupDeflectBarrier(playerTransform) {\n        // Activate the deflect barrier\n        const playerPosition = playerTransform.getWorldPosition();\n        const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n        // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n        if (this.playerEntity) {\n            const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            if (movement && movement.inputStrength > 0.1) {\n                // Player is actively moving - use movement direction (same as DragonRenderer)\n                const moveDir = movement.moveDirection;\n                if (moveDir.length() > 0.1) {\n                    const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                    playerRotation.y = moveAngle;\n                }\n            } else {\n                // Not moving - use camera direction (same as DragonRenderer fallback)\n                const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                this.camera.getWorldDirection(cameraDirection);\n                playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n            }\n        }\n        this.deflectBarrier.activate(playerPosition, playerRotation, this.playerEntity || undefined);\n    }\n    updateDeflectBarrier(playerTransform) {\n        // Update deflect barrier position if it's active\n        if (this.deflectBarrier.isBarrierActive()) {\n            const playerPosition = playerTransform.getWorldPosition();\n            const playerRotation = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\n            // Use SAME rotation logic as DragonRenderer for consistency with visual shield\n            if (this.playerEntity) {\n                const movement = this.playerEntity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n                if (movement && movement.inputStrength > 0.1) {\n                    // Player is actively moving - use movement direction (same as DragonRenderer)\n                    const moveDir = movement.moveDirection;\n                    if (moveDir.length() > 0.1) {\n                        const moveAngle = Math.atan2(moveDir.x, moveDir.z);\n                        playerRotation.y = moveAngle;\n                    }\n                } else {\n                    // Not moving - use camera direction (same as DragonRenderer fallback)\n                    const cameraDirection = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                    this.camera.getWorldDirection(cameraDirection);\n                    playerRotation.y = Math.atan2(cameraDirection.x, cameraDirection.z);\n                }\n            }\n            // Update barrier position to follow player\n            this.deflectBarrier.updatePosition(playerPosition, playerRotation);\n        }\n    }\n    // Called by sword component when Deflect completes\n    onDeflectComplete() {\n        console.log(\"\\uD83D\\uDEE1️ Deflect completed\");\n        this.isDeflecting = false;\n        this.deflectBarrier.deactivate();\n    }\n    // Public methods to get cooldown information for UI\n    getWeaponSwitchCooldown() {\n        const currentTime = Date.now() / 1000;\n        return {\n            current: Math.max(0, this.weaponSwitchCooldown - (currentTime - this.lastWeaponSwitchTime)),\n            max: this.weaponSwitchCooldown\n        };\n    }\n    getAbilityCooldowns() {\n        const currentTime = Date.now() / 1000;\n        const cooldowns = {};\n        if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SWORD) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.deflectCooldown - (currentTime - this.lastDeflectTime)),\n                max: this.deflectCooldown,\n                isActive: this.isDeflecting\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.chargeCooldown - (currentTime - this.lastChargeTime)),\n                max: this.chargeCooldown,\n                isActive: this.isSwordCharging\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.divineStormCooldown - (currentTime - this.lastDivineStormTime)),\n                max: this.divineStormCooldown,\n                isActive: this.isDivineStorming\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, this.barrageFireRate - (currentTime - this.lastBarrageTime)),\n                max: this.barrageFireRate,\n                isActive: this.isBarrageCharging\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.cobraShotFireRate - (currentTime - this.lastCobraShotTime)),\n                max: this.cobraShotFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.viperStingFireRate - (currentTime - this.lastViperStingTime)),\n                max: this.viperStingFireRate,\n                isActive: this.isViperStingCharging\n            };\n        } else if (this.currentWeapon === _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.SCYTHE) {\n            cooldowns[\"Q\"] = {\n                current: Math.max(0, 1.0 - (currentTime - this.lastReanimateTime)),\n                max: 1.0,\n                isActive: false\n            };\n            cooldowns[\"E\"] = {\n                current: Math.max(0, this.frostNovaFireRate - (currentTime - this.lastFrostNovaTime)),\n                max: this.frostNovaFireRate,\n                isActive: false\n            };\n            cooldowns[\"R\"] = {\n                current: Math.max(0, this.crossentropyFireRate - (currentTime - this.lastCrossentropyTime)),\n                max: this.crossentropyFireRate,\n                isActive: false\n            };\n        }\n        return cooldowns;\n    }\n    constructor(camera, inputManager, world, projectileSystem){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        this.playerEntity = null;\n        // Rate limiting for projectile firing\n        this.lastFireTime = 0;\n        this.lastCrossentropyTime = 0 // Separate tracking for CrossentropyBolt\n        ;\n        this.lastReanimateTime = 0 // Separate tracking for Reanimate ability\n        ;\n        this.lastViperStingTime = 0;\n        this.lastFrostNovaTime = 0 // Separate tracking for Frost Nova ability\n        ;\n        this.lastCobraShotTime = 0 // Separate tracking for Cobra Shot ability\n        ;\n        this.fireRate = 0.225 // Default for bow\n        ;\n        this.swordFireRate = 0.75 // Slower rate for sword attacks (800ms between attacks)\n        ;\n        this.sabresFireRate = 0.6 // Sabres dual attack rate (600ms between attacks)\n        ;\n        this.scytheFireRate = 0.33 // EntropicBolt rate (0.5s cooldown)\n        ;\n        this.crossentropyFireRate = 1.0 // CrossentropyBolt rate (1 per second)\n        ;\n        this.viperStingFireRate = 2.0 // Viper Sting rate (2 seconds cooldown)\n        ;\n        this.reanimateFireRate = 1.5 // Reanimate rate (2 seconds cooldown)\n        ;\n        this.frostNovaFireRate = 12.0 // Frost Nova rate (12 seconds cooldown)\n        ;\n        this.cobraShotFireRate = 2.0 // Cobra Shot rate (2 seconds cooldown)\n        ;\n        // Current weapon configuration\n        this.currentWeapon = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponType.BOW // Default weapon\n        ;\n        this.currentSubclass = _components_dragon_weapons__WEBPACK_IMPORTED_MODULE_9__.WeaponSubclass.ELEMENTAL // Default for bow\n        ;\n        this.currentLevel = 1;\n        // Weapon-specific states\n        this.isCharging = false;\n        this.chargeProgress = 0;\n        this.isSwinging = false;\n        // Viper Sting charging state\n        this.isViperStingCharging = false;\n        this.viperStingChargeProgress = 0;\n        // Barrage charging state\n        this.isBarrageCharging = false;\n        this.barrageChargeProgress = 0;\n        this.lastBarrageTime = 0;\n        this.barrageFireRate = 5.0 // 5 second cooldown (keeping as requested)\n        ;\n        // Cobra Shot charging state\n        this.isCobraShotCharging = false;\n        this.cobraShotChargeProgress = 0;\n        // Sword-specific states\n        this.swordComboStep = 1;\n        this.lastSwordAttackTime = 0;\n        this.swordComboResetTime = 1 // Reset combo after 2.0 seconds\n        ;\n        // Divine Storm ability state\n        this.isDivineStorming = false;\n        this.lastDivineStormTime = 0;\n        this.divineStormCooldown = 10.0 // 8 second cooldown\n        ;\n        // Charge ability state\n        this.isSwordCharging = false;\n        this.lastChargeTime = 0;\n        this.chargeCooldown = 8.0 // 8 second cooldown\n        ;\n        // Deflect ability state\n        this.isDeflecting = false;\n        this.lastDeflectTime = 0;\n        this.deflectCooldown = 8.0 // 8 second cooldown\n        ;\n        this.deflectDuration = 3.0 // 3 second duration\n        ;\n        this.lastWeaponSwitchTime = 0;\n        this.weaponSwitchCooldown = 3 // 200ms cooldown to prevent rapid switching\n        ;\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        // Track charge hit entities to prevent multiple hits and enable collision stopping\n        this.chargeHitEntities = new Set();\n        this.chargeStoppedByCollision = false;\n        this.camera = camera;\n        this.inputManager = inputManager;\n        this.world = world;\n        this.projectileSystem = projectileSystem;\n        this.deflectBarrier = new _components_weapons_DeflectBarrier__WEBPACK_IMPORTED_MODULE_10__.DeflectBarrier(world);\n        this.priority = 5; // Run early for input handling\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0NvbnRyb2xTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBQ2M7QUFHbkI7QUFFaUI7QUFDRjtBQUNKO0FBQ0Y7QUFDTTtBQUNBO0FBSVA7QUFDMkI7QUFDSjtBQUNnQztBQUNsQjtBQUNFO0FBRTlFLE1BQU1pQixzQkFBc0JmLCtDQUFNQTtJQXNIaENnQixVQUFVQyxNQUFjLEVBQVE7UUFDckMsSUFBSSxDQUFDQyxZQUFZLEdBQUdEO0lBQ3RCO0lBRU9FLE9BQU9DLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQ0gsWUFBWSxFQUFFO1FBRXhCLE1BQU1JLGtCQUFrQixJQUFJLENBQUNKLFlBQVksQ0FBQ0ssWUFBWSxDQUFDdEIsZ0VBQVNBO1FBQ2hFLE1BQU11QixpQkFBaUIsSUFBSSxDQUFDTixZQUFZLENBQUNLLFlBQVksQ0FBQ3JCLDhEQUFRQTtRQUU5RCxJQUFJLENBQUNvQixtQkFBbUIsQ0FBQ0UsZ0JBQWdCO1FBRXpDLDZCQUE2QjtRQUM3QixJQUFJLE9BQU9BLGVBQWVDLGFBQWEsS0FBSyxZQUFZO1lBQ3RERCxlQUFlQyxhQUFhO1FBQzlCLE9BQU87WUFDTEMsUUFBUUMsSUFBSSxDQUFDLDhEQUE4REg7UUFDN0U7UUFFQSwwQkFBMEI7UUFDMUIsSUFBSSxDQUFDSSxxQkFBcUI7UUFFMUIsMERBQTBEO1FBQzFELElBQUksQ0FBQ0Msa0JBQWtCLENBQUNMLGdCQUFnQkY7UUFFeEMsc0RBQXNEO1FBQ3RELElBQUksQ0FBQ1Esb0JBQW9CLENBQUNOLGdCQUFnQkY7UUFFMUMsMEVBQTBFO1FBQzFFLElBQUksQ0FBQ0UsZUFBZU8sU0FBUyxJQUFJLENBQUNQLGVBQWVRLFVBQVUsSUFBSSxDQUFDUixlQUFlUyxRQUFRLEVBQUU7WUFDdkYsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ1Y7UUFDM0I7UUFFQSxzQkFBc0I7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d0I7YUFDaEJqSCxpQkFBNEI7YUFDNUIrTCxzQkFBc0I7YUFDdEJDLHNCQUFzQixFQUFHLGdDQUFnQzs7UUFFakUsNkJBQTZCO2FBQ3JCVixtQkFBbUI7YUFDbkJ5RixzQkFBc0I7YUFDdEJDLHNCQUFzQixLQUFNLG9CQUFvQjs7UUFFeEQsdUJBQXVCO2FBQ2Z4RixrQkFBa0I7YUFDbEIrRixpQkFBaUI7YUFDakJDLGlCQUFpQixJQUFLLG9CQUFvQjs7UUFFbEQsd0JBQXdCO2FBQ2hCOUYsZUFBZTthQUNmNkgsa0JBQWtCO2FBQ2xCQyxrQkFBa0IsSUFBSyxvQkFBb0I7O2FBQzNDRyxrQkFBa0IsSUFBSyxvQkFBb0I7O2FBMkgzQ25VLHVCQUF1QjthQUN2QkMsdUJBQXVCLEVBQUcsNENBQTRDOztRQWd1QzlFLHVEQUF1RDthQUN0QytRLG1CQUFtQjtZQUNsQyxJQUFJOVUseURBQU9BLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDbkIsSUFBSUEseURBQU9BLENBQUMsQ0FBQyxNQUFNLEdBQUc7WUFDdEIsSUFBSUEseURBQU9BLENBQUMsTUFBTSxHQUFHLEtBQVMsZUFBZTtTQUM5QzthQUNnQmlWLGdCQUFnQixJQUFLLDhCQUE4Qjs7UUFzSnBFLG1GQUFtRjthQUMzRXNCLG9CQUFvQixJQUFJZ0U7YUFDeEJ0RywyQkFBMkI7UUFqL0NqQyxJQUFJLENBQUMvUSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUCxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ2tGLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN1QixnQkFBZ0IsR0FBR0E7UUFDeEIsSUFBSSxDQUFDc1EsY0FBYyxHQUFHLElBQUk5WSwrRUFBY0EsQ0FBQ2lIO1FBQ3pDLElBQUksQ0FBQzJTLFFBQVEsR0FBRyxHQUFHLCtCQUErQjtJQUNwRDtBQTIvREYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvQ29udHJvbFN5c3RlbS50cz8yYzI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbnRyb2wgc3lzdGVtIGZvciBwbGF5ZXIgaW5wdXQgaGFuZGxpbmdcbmltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDQgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IE1vdmVtZW50IH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Nb3ZlbWVudCc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBFbmVteSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvRW5lbXknO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcbmltcG9ydCB7IENvbGxpZGVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBJbnB1dE1hbmFnZXIgfSBmcm9tICdAL2NvcmUvSW5wdXRNYW5hZ2VyJztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgUHJvamVjdGlsZVN5c3RlbSB9IGZyb20gJy4vUHJvamVjdGlsZVN5c3RlbSc7XG5pbXBvcnQgeyBDb21iYXRTeXN0ZW0gfSBmcm9tICcuL0NvbWJhdFN5c3RlbSc7XG5pbXBvcnQgeyBXZWFwb25TdWJjbGFzcywgV2VhcG9uVHlwZSB9IGZyb20gJ0AvY29tcG9uZW50cy9kcmFnb24vd2VhcG9ucyc7XG5pbXBvcnQgeyBEZWZsZWN0QmFycmllciB9IGZyb20gJ0AvY29tcG9uZW50cy93ZWFwb25zL0RlZmxlY3RCYXJyaWVyJztcbmltcG9ydCB7IHRyaWdnZXJHbG9iYWxGcm9zdE5vdmEsIGFkZEdsb2JhbEZyb3plbkVuZW15IH0gZnJvbSAnQC9jb21wb25lbnRzL3dlYXBvbnMvRnJvc3ROb3ZhTWFuYWdlcic7XG5pbXBvcnQgeyB0cmlnZ2VyR2xvYmFsQ29icmFTaG90IH0gZnJvbSAnQC9jb21wb25lbnRzL3Byb2plY3RpbGVzL0NvYnJhU2hvdE1hbmFnZXInO1xuaW1wb3J0IHsgdHJpZ2dlckdsb2JhbFZpcGVyU3RpbmcgfSBmcm9tICdAL2NvbXBvbmVudHMvcHJvamVjdGlsZXMvVmlwZXJTdGluZ01hbmFnZXInO1xuXG5leHBvcnQgY2xhc3MgQ29udHJvbFN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBNb3ZlbWVudF07XG4gIHByaXZhdGUgaW5wdXRNYW5hZ2VyOiBJbnB1dE1hbmFnZXI7XG4gIHByaXZhdGUgY2FtZXJhOiBQZXJzcGVjdGl2ZUNhbWVyYTtcbiAgcHJpdmF0ZSB3b3JsZDogV29ybGQ7XG4gIHByaXZhdGUgcHJvamVjdGlsZVN5c3RlbTogUHJvamVjdGlsZVN5c3RlbTtcbiAgcHJpdmF0ZSBwbGF5ZXJFbnRpdHk6IEVudGl0eSB8IG51bGwgPSBudWxsO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIGJvdyByZWxlYXNlIGVmZmVjdHNcbiAgcHJpdmF0ZSBvbkJvd1JlbGVhc2VDYWxsYmFjaz86IChmaW5hbFByb2dyZXNzOiBudW1iZXIsIGlzUGVyZmVjdFNob3Q/OiBib29sZWFuKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIERpdmluZSBTdG9ybSBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EaXZpbmVTdG9ybUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMsIGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgcHJvamVjdGlsZSBjcmVhdGlvblxuICBwcml2YXRlIG9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaz86IChwcm9qZWN0aWxlVHlwZTogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBjb25maWc6IGFueSkgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBWaXBlciBTdGluZyBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25WaXBlclN0aW5nQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBCYXJyYWdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkJhcnJhZ2VDYWxsYmFjaz86IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIFJlYW5pbWF0ZSBoZWFsaW5nIGVmZmVjdFxuICBwcml2YXRlIG9uUmVhbmltYXRlQ2FsbGJhY2s/OiAoKSA9PiB2b2lkO1xuICBcbiAgLy8gQ2FsbGJhY2sgZm9yIEZyb3N0IE5vdmEgYWN0aXZhdGlvblxuICBwcml2YXRlIG9uRnJvc3ROb3ZhQ2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBDb2JyYSBTaG90IGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNvYnJhU2hvdENhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgQ2hhcmdlIGFjdGl2YXRpb25cbiAgcHJpdmF0ZSBvbkNoYXJnZUNhbGxiYWNrPzogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQ7XG4gIFxuICAvLyBDYWxsYmFjayBmb3IgRGVmbGVjdCBhY3RpdmF0aW9uXG4gIHByaXZhdGUgb25EZWZsZWN0Q2FsbGJhY2s/OiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgZGVidWZmIGVmZmVjdHMgaW4gUFZQXG4gIHByaXZhdGUgb25EZWJ1ZmZDYWxsYmFjaz86ICh0YXJnZXRFbnRpdHlJZDogbnVtYmVyLCBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnLCBkdXJhdGlvbjogbnVtYmVyLCBwb3NpdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIFJhdGUgbGltaXRpbmcgZm9yIHByb2plY3RpbGUgZmlyaW5nXG4gIHByaXZhdGUgbGFzdEZpcmVUaW1lID0gMDtcbiAgcHJpdmF0ZSBsYXN0Q3Jvc3NlbnRyb3B5VGltZSA9IDA7IC8vIFNlcGFyYXRlIHRyYWNraW5nIGZvciBDcm9zc2VudHJvcHlCb2x0XG4gIHByaXZhdGUgbGFzdFJlYW5pbWF0ZVRpbWUgPSAwOyAvLyBTZXBhcmF0ZSB0cmFja2luZyBmb3IgUmVhbmltYXRlIGFiaWxpdHlcbiAgcHJpdmF0ZSBsYXN0VmlwZXJTdGluZ1RpbWUgPSAwO1xuICBwcml2YXRlIGxhc3RGcm9zdE5vdmFUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIEZyb3N0IE5vdmEgYWJpbGl0eVxuICBwcml2YXRlIGxhc3RDb2JyYVNob3RUaW1lID0gMDsgLy8gU2VwYXJhdGUgdHJhY2tpbmcgZm9yIENvYnJhIFNob3QgYWJpbGl0eVxuICBwcml2YXRlIGZpcmVSYXRlID0gMC4yMjU7IC8vIERlZmF1bHQgZm9yIGJvd1xuICBwcml2YXRlIHN3b3JkRmlyZVJhdGUgPSAwLjc1OyAvLyBTbG93ZXIgcmF0ZSBmb3Igc3dvcmQgYXR0YWNrcyAoODAwbXMgYmV0d2VlbiBhdHRhY2tzKVxuICBwcml2YXRlIHNhYnJlc0ZpcmVSYXRlID0gMC42OyAvLyBTYWJyZXMgZHVhbCBhdHRhY2sgcmF0ZSAoNjAwbXMgYmV0d2VlbiBhdHRhY2tzKVxuICBwcml2YXRlIHNjeXRoZUZpcmVSYXRlID0gMC4zMzsgLy8gRW50cm9waWNCb2x0IHJhdGUgKDAuNXMgY29vbGRvd24pXG4gIHByaXZhdGUgY3Jvc3NlbnRyb3B5RmlyZVJhdGUgPSAxLjA7IC8vIENyb3NzZW50cm9weUJvbHQgcmF0ZSAoMSBwZXIgc2Vjb25kKVxuICBwcml2YXRlIHZpcGVyU3RpbmdGaXJlUmF0ZSA9IDIuMDsgLy8gVmlwZXIgU3RpbmcgcmF0ZSAoMiBzZWNvbmRzIGNvb2xkb3duKVxuICBwcml2YXRlIHJlYW5pbWF0ZUZpcmVSYXRlID0gMS41OyAvLyBSZWFuaW1hdGUgcmF0ZSAoMiBzZWNvbmRzIGNvb2xkb3duKVxuICBwcml2YXRlIGZyb3N0Tm92YUZpcmVSYXRlID0gMTIuMDsgLy8gRnJvc3QgTm92YSByYXRlICgxMiBzZWNvbmRzIGNvb2xkb3duKVxuICBwcml2YXRlIGNvYnJhU2hvdEZpcmVSYXRlID0gMi4wOyAvLyBDb2JyYSBTaG90IHJhdGUgKDIgc2Vjb25kcyBjb29sZG93bilcbiAgXG4gIC8vIEN1cnJlbnQgd2VhcG9uIGNvbmZpZ3VyYXRpb25cbiAgcHJpdmF0ZSBjdXJyZW50V2VhcG9uOiBXZWFwb25UeXBlID0gV2VhcG9uVHlwZS5CT1c7IC8vIERlZmF1bHQgd2VhcG9uXG4gIHByaXZhdGUgY3VycmVudFN1YmNsYXNzOiBXZWFwb25TdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkVMRU1FTlRBTDsgLy8gRGVmYXVsdCBmb3IgYm93XG4gIHByaXZhdGUgY3VycmVudExldmVsID0gMTtcbiAgXG4gIC8vIFdlYXBvbi1zcGVjaWZpYyBzdGF0ZXNcbiAgcHJpdmF0ZSBpc0NoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBwcml2YXRlIGlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgXG4gIC8vIFZpcGVyIFN0aW5nIGNoYXJnaW5nIHN0YXRlXG4gIHByaXZhdGUgaXNWaXBlclN0aW5nQ2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSB2aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICBcbiAgLy8gQmFycmFnZSBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzQmFycmFnZUNoYXJnaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgcHJpdmF0ZSBsYXN0QmFycmFnZVRpbWUgPSAwO1xuICBwcml2YXRlIGJhcnJhZ2VGaXJlUmF0ZSA9IDUuMDsgLy8gNSBzZWNvbmQgY29vbGRvd24gKGtlZXBpbmcgYXMgcmVxdWVzdGVkKVxuICBcbiAgLy8gQ29icmEgU2hvdCBjaGFyZ2luZyBzdGF0ZVxuICBwcml2YXRlIGlzQ29icmFTaG90Q2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gIFxuICAvLyBTd29yZC1zcGVjaWZpYyBzdGF0ZXNcbiAgcHJpdmF0ZSBzd29yZENvbWJvU3RlcDogMSB8IDIgfCAzID0gMTtcbiAgcHJpdmF0ZSBsYXN0U3dvcmRBdHRhY2tUaW1lID0gMDtcbiAgcHJpdmF0ZSBzd29yZENvbWJvUmVzZXRUaW1lID0gMTsgLy8gUmVzZXQgY29tYm8gYWZ0ZXIgMi4wIHNlY29uZHNcbiAgXG4gIC8vIERpdmluZSBTdG9ybSBhYmlsaXR5IHN0YXRlXG4gIHByaXZhdGUgaXNEaXZpbmVTdG9ybWluZyA9IGZhbHNlO1xuICBwcml2YXRlIGxhc3REaXZpbmVTdG9ybVRpbWUgPSAwO1xuICBwcml2YXRlIGRpdmluZVN0b3JtQ29vbGRvd24gPSAxMC4wOyAvLyA4IHNlY29uZCBjb29sZG93blxuICBcbiAgLy8gQ2hhcmdlIGFiaWxpdHkgc3RhdGVcbiAgcHJpdmF0ZSBpc1N3b3JkQ2hhcmdpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0Q2hhcmdlVGltZSA9IDA7XG4gIHByaXZhdGUgY2hhcmdlQ29vbGRvd24gPSA4LjA7IC8vIDggc2Vjb25kIGNvb2xkb3duXG4gIFxuICAvLyBEZWZsZWN0IGFiaWxpdHkgc3RhdGVcbiAgcHJpdmF0ZSBpc0RlZmxlY3RpbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBsYXN0RGVmbGVjdFRpbWUgPSAwO1xuICBwcml2YXRlIGRlZmxlY3RDb29sZG93biA9IDguMDsgLy8gOCBzZWNvbmQgY29vbGRvd25cbiAgcHJpdmF0ZSBkZWZsZWN0RHVyYXRpb24gPSAzLjA7IC8vIDMgc2Vjb25kIGR1cmF0aW9uXG4gIHByaXZhdGUgZGVmbGVjdEJhcnJpZXI6IERlZmxlY3RCYXJyaWVyO1xuICBjb25zdHJ1Y3RvcihcbiAgICBjYW1lcmE6IFBlcnNwZWN0aXZlQ2FtZXJhLCBcbiAgICBpbnB1dE1hbmFnZXI6IElucHV0TWFuYWdlciwgXG4gICAgd29ybGQ6IFdvcmxkLFxuICAgIHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW1cbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmlucHV0TWFuYWdlciA9IGlucHV0TWFuYWdlcjtcbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtID0gcHJvamVjdGlsZVN5c3RlbTtcbiAgICB0aGlzLmRlZmxlY3RCYXJyaWVyID0gbmV3IERlZmxlY3RCYXJyaWVyKHdvcmxkKTtcbiAgICB0aGlzLnByaW9yaXR5ID0gNTsgLy8gUnVuIGVhcmx5IGZvciBpbnB1dCBoYW5kbGluZ1xuICB9XG5cbiAgcHVibGljIHNldFBsYXllcihlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIHRoaXMucGxheWVyRW50aXR5ID0gZW50aXR5O1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcGxheWVyVHJhbnNmb3JtID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgY29uc3QgcGxheWVyTW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgIFxuICAgIGlmICghcGxheWVyVHJhbnNmb3JtIHx8ICFwbGF5ZXJNb3ZlbWVudCkgcmV0dXJuO1xuXG4gICAgLy8gVXBkYXRlIGRlYnVmZiBzdGF0ZXMgZmlyc3RcbiAgICBpZiAodHlwZW9mIHBsYXllck1vdmVtZW50LnVwZGF0ZURlYnVmZnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsYXllck1vdmVtZW50LnVwZGF0ZURlYnVmZnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUGxheWVyIE1vdmVtZW50IGNvbXBvbmVudCBtaXNzaW5nIHVwZGF0ZURlYnVmZnMgbWV0aG9kOicsIHBsYXllck1vdmVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgd2VhcG9uIHN3aXRjaGluZ1xuICAgIHRoaXMuaGFuZGxlV2VhcG9uU3dpdGNoaW5nKCk7XG5cbiAgICAvLyBIYW5kbGUgZGFzaCBtb3ZlbWVudCBmaXJzdCAob3ZlcnJpZGVzIHJlZ3VsYXIgbW92ZW1lbnQpXG4gICAgdGhpcy5oYW5kbGVEYXNoTW92ZW1lbnQocGxheWVyTW92ZW1lbnQsIHBsYXllclRyYW5zZm9ybSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhcmdlIG1vdmVtZW50IChvdmVycmlkZXMgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmhhbmRsZUNoYXJnZU1vdmVtZW50KHBsYXllck1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gSGFuZGxlIHBsYXllciBtb3ZlbWVudCBpbnB1dCAob25seSBpZiBub3QgZGFzaGluZywgY2hhcmdpbmcsIG9yIGZyb3plbilcbiAgICBpZiAoIXBsYXllck1vdmVtZW50LmlzRGFzaGluZyAmJiAhcGxheWVyTW92ZW1lbnQuaXNDaGFyZ2luZyAmJiAhcGxheWVyTW92ZW1lbnQuaXNGcm96ZW4pIHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZW1lbnRJbnB1dChwbGF5ZXJNb3ZlbWVudCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBjb21iYXQgaW5wdXRcbiAgICB0aGlzLmhhbmRsZUNvbWJhdElucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGRlZmxlY3QgYmFycmllciBwb3NpdGlvbiBpZiBhY3RpdmVcbiAgICB0aGlzLnVwZGF0ZURlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1vdmVtZW50SW5wdXQobW92ZW1lbnQ6IE1vdmVtZW50KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuXG4gICAgY29uc3QgcGxheWVyVHJhbnNmb3JtID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgaWYgKCFwbGF5ZXJUcmFuc2Zvcm0pIHJldHVybjtcblxuICAgIC8vIENoZWNrIGZvciBkb3VibGUtdGFwIGRhc2hlcyBmaXJzdCAoYmVmb3JlIHByb2Nlc3NpbmcgcmVndWxhciBtb3ZlbWVudClcbiAgICB0aGlzLmNoZWNrRm9yRGFzaElucHV0KG1vdmVtZW50LCBwbGF5ZXJUcmFuc2Zvcm0pO1xuXG4gICAgLy8gR2V0IGlucHV0IGRpcmVjdGlvblxuICAgIGNvbnN0IGlucHV0RGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgbGV0IGhhc0lucHV0ID0gZmFsc2U7XG5cbiAgICAvLyBXQVNEIG1vdmVtZW50XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgndycpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi56IC09IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3MnKSkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ueiArPSAxO1xuICAgICAgaGFzSW5wdXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdhJykpIHtcbiAgICAgIGlucHV0RGlyZWN0aW9uLnggLT0gMTtcbiAgICAgIGhhc0lucHV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZCcpKSB7XG4gICAgICBpbnB1dERpcmVjdGlvbi54ICs9IDE7XG4gICAgICBoYXNJbnB1dCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIGRpYWdvbmFsIG1vdmVtZW50XG4gICAgaWYgKGlucHV0RGlyZWN0aW9uLmxlbmd0aCgpID4gMCkge1xuICAgICAgaW5wdXREaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnB1dCB0byB3b3JsZCBzcGFjZSBiYXNlZCBvbiBjYW1lcmEgb3JpZW50YXRpb25cbiAgICBpZiAoaGFzSW5wdXQpIHtcbiAgICAgIGNvbnN0IGNhbWVyYURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FtZXJhJ3MgcmlnaHQgdmVjdG9yXG4gICAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoY2FtZXJhRGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW1lcmEncyBmb3J3YXJkIHZlY3RvciAocHJvamVjdGVkIG9uIFhaIHBsYW5lKVxuICAgICAgY29uc3QgY2FtZXJhRm9yd2FyZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjYW1lcmFGb3J3YXJkLmNyb3NzVmVjdG9ycyhuZXcgVmVjdG9yMygwLCAxLCAwKSwgY2FtZXJhUmlnaHQpLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlXG4gICAgICBjb25zdCB3b3JsZERpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB3b3JsZERpcmVjdGlvbi5hZGRTY2FsZWRWZWN0b3IoY2FtZXJhUmlnaHQsIGlucHV0RGlyZWN0aW9uLngpO1xuICAgICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYUZvcndhcmQsIC1pbnB1dERpcmVjdGlvbi56KTtcbiAgICAgIHdvcmxkRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBtb3ZlbWVudC5zZXRNb3ZlRGlyZWN0aW9uKHdvcmxkRGlyZWN0aW9uLCAxLjApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlbWVudC5zZXRNb3ZlRGlyZWN0aW9uKG5ldyBWZWN0b3IzKDAsIDAsIDApLCAwKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUganVtcGluZ1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJyAnKSkgeyAvLyBTcGFjZWJhclxuICAgICAgbW92ZW1lbnQuanVtcCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbGFzdFdlYXBvblN3aXRjaFRpbWUgPSAwO1xuICBwcml2YXRlIHdlYXBvblN3aXRjaENvb2xkb3duID0gMzsgLy8gMjAwbXMgY29vbGRvd24gdG8gcHJldmVudCByYXBpZCBzd2l0Y2hpbmdcblxuICBwcml2YXRlIGhhbmRsZVdlYXBvblN3aXRjaGluZygpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIC8vIFByZXZlbnQgcmFwaWQgd2VhcG9uIHN3aXRjaGluZ1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPCB0aGlzLndlYXBvblN3aXRjaENvb2xkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHdlYXBvbiBzd2l0Y2hpbmcgd2l0aCBudW1iZXIga2V5c1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJzEnKSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiAhPT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNXT1JEO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkRJVklOSVRZOyAvLyBEZWZhdWx0IHN3b3JkIHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSB0aGlzLnN3b3JkRmlyZVJhdGU7IC8vIFVzZSBzd29yZC1zcGVjaWZpYyBmaXJlIHJhdGVcbiAgICAgICAgdGhpcy5sYXN0V2VhcG9uU3dpdGNoVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gMTsgLy8gUmVzZXQgY29tYm8gd2hlbiBzd2l0Y2hpbmcgdG8gc3dvcmRcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfl6HvuI8gU3dpdGNoZWQgdG8gU3dvcmQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnMicpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLkJPVykge1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLkJPVztcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5FTEVNRU5UQUw7IC8vIERlZmF1bHQgYm93IHN1YmNsYXNzXG4gICAgICAgIHRoaXMuZmlyZVJhdGUgPSAwLjIyNTsgLy8gQm93IGZpcmUgcmF0ZVxuICAgICAgICB0aGlzLmxhc3RXZWFwb25Td2l0Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4+5IFN3aXRjaGVkIHRvIEJvdycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCczJykpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gIT09IFdlYXBvblR5cGUuU0NZVEhFKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFdlYXBvbiA9IFdlYXBvblR5cGUuU0NZVEhFO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IFdlYXBvblN1YmNsYXNzLkNIQU9TOyAvLyBEZWZhdWx0IHNjeXRoZSBzdWJjbGFzc1xuICAgICAgICB0aGlzLmZpcmVSYXRlID0gdGhpcy5zY3l0aGVGaXJlUmF0ZTsgLy8gVXNlIHNjeXRoZSBmaXJlIHJhdGUgKDAuNXMpXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoSBTd2l0Y2hlZCB0byBTY3l0aGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnNCcpKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50V2VhcG9uICE9PSBXZWFwb25UeXBlLlNBQlJFUykge1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWFwb24gPSBXZWFwb25UeXBlLlNBQlJFUztcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2xhc3MgPSBXZWFwb25TdWJjbGFzcy5GUk9TVDsgLy8gRGVmYXVsdCBzYWJyZXMgc3ViY2xhc3NcbiAgICAgICAgdGhpcy5maXJlUmF0ZSA9IHRoaXMuc2FicmVzRmlyZVJhdGU7IC8vIFVzZSBzYWJyZXMtc3BlY2lmaWMgZmlyZSByYXRlXG4gICAgICAgIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KalO+4jyBTd2l0Y2hlZCB0byBTYWJyZXMnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUNvbWJhdElucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5CT1cpIHtcbiAgICAgIHRoaXMuaGFuZGxlQm93SW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TQ1lUSEUpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2N5dGhlSW5wdXQocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFdlYXBvbiA9PT0gV2VhcG9uVHlwZS5TV09SRCkge1xuICAgICAgdGhpcy5oYW5kbGVTd29yZElucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU0FCUkVTKSB7XG4gICAgICB0aGlzLmhhbmRsZVNhYnJlc0lucHV0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVCb3dJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBWaXBlciBTdGluZyBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1WaXBlclN0aW5nKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBCYXJyYWdlIGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+PuSBRIGtleSBwcmVzc2VkIGZvciBCYXJyYWdlIScsIHtcbiAgICAgICAgaXNCYXJyYWdlQ2hhcmdpbmc6IHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcsXG4gICAgICAgIGlzQ2hhcmdpbmc6IHRoaXMuaXNDaGFyZ2luZyxcbiAgICAgICAgaXNWaXBlclN0aW5nQ2hhcmdpbmc6IHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmdcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmlzQmFycmFnZUNoYXJnaW5nICYmICF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgQ29icmEgU2hvdCBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSkge1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gRSBrZXkgcHJlc3NlZCBmb3IgQ29icmEgU2hvdCEnLCB7XG4gICAgICAgIGlzQ2hhcmdpbmc6IHRoaXMuaXNDaGFyZ2luZyxcbiAgICAgICAgaXNWaXBlclN0aW5nQ2hhcmdpbmc6IHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcsXG4gICAgICAgIGlzQmFycmFnZUNoYXJnaW5nOiB0aGlzLmlzQmFycmFnZUNoYXJnaW5nLFxuICAgICAgICBpc0NvYnJhU2hvdENoYXJnaW5nOiB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcsXG4gICAgICAgIGN1cnJlbnRXZWFwb246IHRoaXMuY3VycmVudFdlYXBvblxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuaXNDaGFyZ2luZyAmJiAhdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMucGVyZm9ybUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgYm93IGNoYXJnaW5nIGFuZCBmaXJpbmdcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkpIHsgLy8gTGVmdCBtb3VzZSBidXR0b24gaGVsZFxuICAgICAgaWYgKCF0aGlzLmlzQ2hhcmdpbmcgJiYgIXRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgJiYgIXRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgJiYgIXRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZykge1xuICAgICAgICB0aGlzLmlzQ2hhcmdpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfj7kgU3RhcnRlZCBjaGFyZ2luZyBib3cnKTtcbiAgICAgIH1cbiAgICAgIC8vIEluY3JlYXNlIGNoYXJnZSBwcm9ncmVzcyAoY291bGQgYmUgdGltZS1iYXNlZClcbiAgICAgIGlmICghdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyAmJiAhdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyAmJiAhdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLmNoYXJnZVByb2dyZXNzICsgMC4wMTI1LCAxLjApOyAvLyBCT1cgQ0hBUkdFIFNQRUVEXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIC8vIENoZWNrIGlmIGFueSBhYmlsaXR5IGlzIGNoYXJnaW5nIC0gaWYgc28sIGNhbmNlbCB0aGUgcmVndWxhciBib3cgc2hvdFxuICAgICAgaWYgKHRoaXMuaXNWaXBlclN0aW5nQ2hhcmdpbmcgfHwgdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZyB8fCB0aGlzLmlzQ29icmFTaG90Q2hhcmdpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfj7kgQ2FuY2VsbGluZyByZWd1bGFyIGJvdyBzaG90IGR1ZSB0byBhYmlsaXR5IGNoYXJnaW5nJyk7XG4gICAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdG9yZSBjaGFyZ2UgcHJvZ3Jlc3MgYmVmb3JlIHJlc2V0dGluZyBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICAgIGNvbnN0IGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPSB0aGlzLmNoYXJnZVByb2dyZXNzO1xuICAgICAgXG4gICAgICAvLyBSZWxlYXNlIHRoZSBib3dcbiAgICAgIHRoaXMuZmlyZVByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICBcbiAgICAgIC8vIFRyaWdnZXIgdmlzdWFsIGVmZmVjdHMgY2FsbGJhY2sgd2l0aCB0aGUgc3RvcmVkIGNoYXJnZSBwcm9ncmVzc1xuICAgICAgdGhpcy50cmlnZ2VyQm93UmVsZWFzZUVmZmVjdHMoZmluYWxDaGFyZ2VQcm9ncmVzcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTY3l0aGVJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBzY3l0aGUgbGVmdCBjbGljayBmb3IgRW50cm9waWNCb2x0XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzTW91c2VCdXR0b25QcmVzc2VkKDApKSB7IC8vIExlZnQgbW91c2UgYnV0dG9uIGhlbGRcbiAgICAgIGlmICghdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICAgIHRoaXMuaXNDaGFyZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgICBjb25zb2xlLmxvZygn4pqhIFN0YXJ0ZWQgY2hhcmdpbmcgc2N5dGhlIChzcGlubmluZyknKTtcbiAgICAgIH1cbiAgICAgIC8vIEluY3JlYXNlIGNoYXJnZSBwcm9ncmVzcyBjb250aW51b3VzbHkgZm9yIHNwaW5uaW5nIGFuaW1hdGlvbiAobm8gY2FwKVxuICAgICAgdGhpcy5jaGFyZ2VQcm9ncmVzcyArPSAwLjAzOyAvLyBDb250aW51b3VzbHkgaW5jcmVhc2UgZm9yIHNwaW5uaW5nXG4gICAgICBcbiAgICAgIC8vIEZpcmUgRW50cm9waWNCb2x0IHByb2plY3RpbGVzIGNvbnRpbnVvdXNseSB3aGlsZSBzcGlubmluZ1xuICAgICAgdGhpcy5maXJlRW50cm9waWNCb2x0UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICAvLyBTdG9wIHNwaW5uaW5nIHdoZW4gbW91c2UgaXMgcmVsZWFzZWRcbiAgICAgIGNvbnNvbGUubG9nKCfimqEgU3RvcHBlZCBjaGFyZ2luZyBzY3l0aGUgKHNwaW5uaW5nKScpO1xuICAgICAgdGhpcy5pc0NoYXJnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENyb3NzZW50cm9weUJvbHQgYWJpbGl0eSB3aXRoICdSJyBrZXlcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNLZXlQcmVzc2VkKCdyJykgJiYgIXRoaXMuaXNDaGFyZ2luZykge1xuICAgICAgdGhpcy5maXJlQ3Jvc3NlbnRyb3B5Qm9sdEFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIFJlYW5pbWF0ZSBhYmlsaXR5IHdpdGggJ1EnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3EnKSAmJiAhdGhpcy5pc0NoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1SZWFuaW1hdGVBYmlsaXR5KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBGcm9zdCBOb3ZhIGFiaWxpdHkgd2l0aCAnRScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgnZScpICYmICF0aGlzLmlzQ2hhcmdpbmcpIHtcbiAgICAgIHRoaXMucGVyZm9ybUZyb3N0Tm92YUFiaWxpdHkocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZpcmVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZ1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RmlyZVRpbWUgPCB0aGlzLmZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gR2V0IGRyYWdvbidzIGZhY2luZyBkaXJlY3Rpb24gKHNhbWUgYXMgY2FtZXJhIGRpcmVjdGlvbiBzaW5jZSBkcmFnb24gZmFjZXMgY2FtZXJhKVxuICAgIC8vIFRoaXMgZW5zdXJlcyBhcnJvd3MgZmlyZSBvdXR3YXJkIGZyb20gd2hlcmUgdGhlIGRyYWdvbiBpcyBmYWNpbmdcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IGRvd253YXJkIGFuZ2xlIGNvbXBlbnNhdGlvbiB0byBhY2NvdW50IGZvciByZXN0cmljdGVkIGNhbWVyYSBib3VuZHNcbiAgICAvLyBTaW5jZSBjYW1lcmEgY2FuJ3QgbG9vayBkb3duIG11Y2ggZHVlIHRvIGJvdW5kcywgd2UgYWRkIGEgZml4ZWQgZG93bndhcmQgYW5nbGVcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIFxuICAgIC8vIENyZWF0ZSBhIHJvdGF0aW9uIG1hdHJpeCB0byBhcHBseSB0aGUgZG93bndhcmQgYW5nbGUgYXJvdW5kIHRoZSBjYW1lcmEncyByaWdodCBheGlzXG4gICAgY29uc3QgY2FtZXJhUmlnaHQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYVJpZ2h0LmNyb3NzVmVjdG9ycyhkaXJlY3Rpb24sIG5ldyBWZWN0b3IzKDAsIDEsIDApKS5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBBcHBseSByb3RhdGlvbiBhcm91bmQgdGhlIHJpZ2h0IGF4aXMgdG8gdGlsdCB0aGUgZGlyZWN0aW9uIGRvd253YXJkXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gUGVyZmVjdCBzaG90IHRpbWluZyBjb25zdGFudHNcbiAgICBjb25zdCBwZXJmZWN0U2hvdE1pblRocmVzaG9sZCA9IDAuNzsgLy8gODUlIGNoYXJnZVxuICAgIGNvbnN0IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkID0gMC45ODsgLy8gOTUlIGNoYXJnZVxuICAgIGNvbnN0IGlzUGVyZmVjdFNob3QgPSB0aGlzLmNoYXJnZVByb2dyZXNzID49IHBlcmZlY3RTaG90TWluVGhyZXNob2xkICYmIHRoaXMuY2hhcmdlUHJvZ3Jlc3MgPD0gcGVyZmVjdFNob3RNYXhUaHJlc2hvbGQ7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYm93IGlzIGZ1bGx5IGNoYXJnZWQgZm9yIHNwZWNpYWwgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLmNoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgY29uc29sZS5sb2coYPCfj7kgRmlyaW5nIENIQVJHRUQgQVJST1cgd2l0aCBmdWxsIGNoYXJnZTogJHt0aGlzLmNoYXJnZVByb2dyZXNzfWApO1xuICAgICAgdGhpcy5jcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAoaXNQZXJmZWN0U2hvdCkge1xuICAgICAgY29uc29sZS5sb2coYOKcqCBGaXJpbmcgUEVSRkVDVCBTSE9UIHdpdGggY2hhcmdlOiAke3RoaXMuY2hhcmdlUHJvZ3Jlc3N9YCk7XG4gICAgICB0aGlzLmNyZWF0ZVBlcmZlY3RTaG90UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVidWc6IExvZyB0aGUgZmlyaW5nIGFuZ2xlIHRvIHZlcmlmeSBpdCdzIGNoYW5naW5nIHdpdGggY2FtZXJhIHJvdGF0aW9uXG4gICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56KTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn6etIEZpcmluZyAke3RoaXMuY3VycmVudFdlYXBvbn0gYXQgYW5nbGU6ICR7KGFuZ2xlICogMTgwIC8gTWF0aC5QSSkudG9GaXhlZCgxKX3CsGApO1xuICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aWxlKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZmlyZUVudHJvcGljQm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gdXNlIG5ldyBzY3l0aGUgcmF0ZSAoMC41IHNlY29uZHMpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc2N5dGhlRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBHZXQgZHJhZ29uJ3MgZmFjaW5nIGRpcmVjdGlvblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIChzYW1lIGFzIGJvdyBwcm9qZWN0aWxlcylcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgc3BpblN0YXR1cyA9IHRoaXMuaXNDaGFyZ2luZyA/ICcgKFNQSU5OSU5HKScgOiAnJztcbiAgICBjb25zb2xlLmxvZyhg4pqhIEZpcmluZyBFbnRyb3BpY0JvbHQke3NwaW5TdGF0dXN9IC0gY2hhcmdlOiAke3RoaXMuY2hhcmdlUHJvZ3Jlc3MudG9GaXhlZCgyKX0gLSByYXRlOiAke3RoaXMuc2N5dGhlRmlyZVJhdGV9c2ApO1xuICAgIFxuICAgIHRoaXMuY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZShwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUNyb3NzZW50cm9weUJvbHRBYmlsaXR5KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHVzZSBDcm9zc2VudHJvcHlCb2x0IHJhdGUgKDEgcGVyIHNlY29uZClcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdENyb3NzZW50cm9weVRpbWUgPCB0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdENyb3NzZW50cm9weVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBHZXQgZHJhZ29uJ3MgZmFjaW5nIGRpcmVjdGlvblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQXBwbHkgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIChzYW1lIGFzIGJvdyBwcm9qZWN0aWxlcylcbiAgICBjb25zdCBjb21wZW5zYXRpb25BbmdsZSA9IE1hdGguUEkgLyA2OyAvLyAzMCBkZWdyZWVzIGRvd253YXJkIGNvbXBlbnNhdGlvblxuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYOKalO+4jyBGaXJpbmcgQ3Jvc3NlbnRyb3B5Qm9sdCBhYmlsaXR5IChSIGtleSkgLSByYXRlOiAke3RoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGV9c2ApO1xuICAgIFxuICAgIHRoaXMuY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHZhbGlkIHRhcmdldHMgaW4gdGhlIHdvcmxkIGJlZm9yZSBjcmVhdGluZyBwcm9qZWN0aWxlc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuICAgIGNvbnN0IHZhbGlkVGFyZ2V0cyA9IHBvdGVudGlhbFRhcmdldHMuZmlsdGVyKHRhcmdldCA9PiBcbiAgICAgIHRhcmdldC5pZCAhPT0gdGhpcy5wbGF5ZXJFbnRpdHkhLmlkICYmIC8vIE5vdCB0aGUgcGxheWVyIGl0c2VsZlxuICAgICAgIXRhcmdldC5nZXRDb21wb25lbnQoSGVhbHRoKT8uaXNEZWFkIC8vIE5vdCBkZWFkXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbiBtdWx0aXBsYXllciBtb2RlLCBvbmx5IGNyZWF0ZSBwcm9qZWN0aWxlcyBpZiB0aGVyZSBhcmUgdmFsaWQgdGFyZ2V0cyBvciBpZiB3ZSBuZWVkIHRvIGJyb2FkY2FzdCB0byBvdGhlciBwbGF5ZXJzXG4gICAgY29uc3QgaGFzVmFsaWRUYXJnZXRzID0gdmFsaWRUYXJnZXRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc2hvdWxkQnJvYWRjYXN0ID0gdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2sgIT09IHVuZGVmaW5lZDtcbiAgICBcbiAgICBpZiAoIWhhc1ZhbGlkVGFyZ2V0cyAmJiAhc2hvdWxkQnJvYWRjYXN0KSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+PuSBObyB2YWxpZCB0YXJnZXRzIGZvdW5kLCBza2lwcGluZyBwcm9qZWN0aWxlIGNyZWF0aW9uJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjU7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBwcm9qZWN0aWxlIHVzaW5nIHRoZSBQcm9qZWN0aWxlU3lzdGVtIHdpdGggY3VycmVudCB3ZWFwb24gY29uZmlnXG4gICAgY29uc3QgcHJvamVjdGlsZUNvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAyNSxcbiAgICAgIGRhbWFnZTogMTAsIC8vIEFycm93IGRhbWFnZSBzaG91bGQgYmUgMTBcbiAgICAgIGxpZmV0aW1lOiAzLFxuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlUHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygncmVndWxhcl9hcnJvdycsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgcHJvamVjdGlsZUNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSB2YWxpZCB0YXJnZXRzIGluIHRoZSB3b3JsZCBiZWZvcmUgY3JlYXRpbmcgcHJvamVjdGlsZXNcbiAgICBjb25zdCBwb3RlbnRpYWxUYXJnZXRzID0gdGhpcy53b3JsZC5xdWVyeUVudGl0aWVzKFtUcmFuc2Zvcm0sIEhlYWx0aCwgQ29sbGlkZXJdKTtcbiAgICBjb25zdCB2YWxpZFRhcmdldHMgPSBwb3RlbnRpYWxUYXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gXG4gICAgICB0YXJnZXQuaWQgIT09IHRoaXMucGxheWVyRW50aXR5IS5pZCAmJiAvLyBOb3QgdGhlIHBsYXllciBpdHNlbGZcbiAgICAgICF0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCk/LmlzRGVhZCAvLyBOb3QgZGVhZFxuICAgICk7XG4gICAgXG4gICAgLy8gSW4gbXVsdGlwbGF5ZXIgbW9kZSwgb25seSBjcmVhdGUgcHJvamVjdGlsZXMgaWYgdGhlcmUgYXJlIHZhbGlkIHRhcmdldHMgb3IgaWYgd2UgbmVlZCB0byBicm9hZGNhc3QgdG8gb3RoZXIgcGxheWVyc1xuICAgIGNvbnN0IGhhc1ZhbGlkVGFyZ2V0cyA9IHZhbGlkVGFyZ2V0cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHNob3VsZEJyb2FkY2FzdCA9IHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrICE9PSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKCFoYXNWYWxpZFRhcmdldHMgJiYgIXNob3VsZEJyb2FkY2FzdCkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBObyB2YWxpZCB0YXJnZXRzIGZvdW5kLCBza2lwcGluZyBFbnRyb3BpY0JvbHQgY3JlYXRpb24nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMTUgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RFbnRyb3BpY0JvbHQoKSkge1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCBFbnRyb3BpYyBCb2x0IChyZXF1aXJlcyAxNSBtYW5hKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoMTApO1xuICAgICAgY29uc29sZS5sb2coJ+KaoSBDb25zdW1lZCAxNSBtYW5hIGZvciBFbnRyb3BpYyBCb2x0Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjc1OyAvLyBTbGlnaHRseSBoaWdoZXJcbiAgICBcbiAgICAvLyBDcmVhdGUgRW50cm9waWNCb2x0IHByb2plY3RpbGUgdXNpbmcgdGhlIG5ldyBtZXRob2RcbiAgICBjb25zdCBlbnRyb3BpY0NvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAyMCwgLy8gRmFzdGVyIHRoYW4gQ3Jvc3NlbnRyb3B5Qm9sdFxuICAgICAgZGFtYWdlOiAyMCwgLy8gRW50cm9waWNCb2x0IGRhbWFnZVxuICAgICAgbGlmZXRpbWU6IDUsIC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICAgIHBpZXJjaW5nOiB0cnVlLCAvLyBTY3l0aGUgcHJvamVjdGlsZXMgY2FuIHBpZXJjZVxuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gTm8gZXhwbG9zaW9uIGVmZmVjdFxuICAgICAgZXhwbG9zaW9uUmFkaXVzOiAwLCAvLyBObyBleHBsb3Npb24gcmFkaXVzXG4gICAgICBzdWJjbGFzczogdGhpcy5jdXJyZW50U3ViY2xhc3MsXG4gICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICBvcGFjaXR5OiAxLjBcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIGVudHJvcGljQ29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnZW50cm9waWNfYm9sdCcsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwgZW50cm9waWNDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMyk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBwbGF5ZXIgaGFzIGVub3VnaCBtYW5hICg0MCBtYW5hIGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdENyb3NzZW50cm9weUJvbHQoKSkge1xuICAgICAgY29uc29sZS5sb2coJ+KalO+4jyBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCBDcm9zc2VudHJvcHkgQm9sdCAocmVxdWlyZXMgNDAgbWFuYSknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDQwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ29uc3VtZWQgNDAgbWFuYSBmb3IgQ3Jvc3NlbnRyb3B5IEJvbHQnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDAuNzU7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBDcm9zc2VudHJvcHlCb2x0IHByb2plY3RpbGUgdXNpbmcgdGhlIGV4aXN0aW5nIG1ldGhvZFxuICAgIGNvbnN0IGNyb3NzZW50cm9weUNvbmZpZyA9IHtcbiAgICAgIHNwZWVkOiAxNSwgLy8gU2xvd2VyIHRoYW4gRW50cm9waWNCb2x0XG4gICAgICBkYW1hZ2U6IDkwLCAvLyBIaWdoZXIgZGFtYWdlIGZvciBSIGFiaWxpdHlcbiAgICAgIGxpZmV0aW1lOiA1LCAvLyBMb25nZXIgbGlmZXRpbWVcbiAgICAgIHBpZXJjaW5nOiB0cnVlLCAvLyBTY3l0aGUgcHJvamVjdGlsZXMgY2FuIHBpZXJjZVxuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gRGlzYWJsZWQgZXhwbG9zaW9uIGVmZmVjdCBmb3IgcGVyZm9ybWFuY2VcbiAgICAgIGV4cGxvc2lvblJhZGl1czogMCwgLy8gTm8gZXhwbG9zaW9uIHJhZGl1c1xuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUoXG4gICAgICB0aGlzLndvcmxkLFxuICAgICAgc3Bhd25Qb3NpdGlvbixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRoaXMucGxheWVyRW50aXR5LmlkLFxuICAgICAgY3Jvc3NlbnRyb3B5Q29uZmlnXG4gICAgKTtcbiAgICBcbiAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgaWYgKHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnY3Jvc3NlbnRyb3B5X2JvbHQnLCBzcGF3blBvc2l0aW9uLCBkaXJlY3Rpb24sIGNyb3NzZW50cm9weUNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtUmVhbmltYXRlQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcHJldmVudCBzcGFtIGNhc3RpbmcgKDEgc2Vjb25kIGNvb2xkb3duKVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0UmVhbmltYXRlVGltZSA8IDEuMCkge1xuICAgICAgY29uc29sZS5sb2coJ/CfqbggUmVhbmltYXRlIG9uIGNvb2xkb3duIC0gcGxlYXNlIHdhaXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVhbmltYXRlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIG1hbmEgKDIwIG1hbmEgY29zdCAtIGRvdWJsZWQgZnJvbSAxMClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGNvbnN0IGN1cnJlbnRNYW5hID0gZ2FtZVVJID8gZ2FtZVVJLmdldEN1cnJlbnRNYW5hKCkgOiAwO1xuICAgIFxuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0UmVhbmltYXRlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29uc3VtZSBtYW5hXG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgY29uc3QgbWFuYUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgZ2FtZVVJLmNvbnN1bWVNYW5hKDIwKTtcbiAgICAgIGNvbnN0IG1hbmFBZnRlciA9IGdhbWVVSS5nZXRDdXJyZW50TWFuYSgpO1xuICAgICAgY29uc29sZS5sb2coYPCfqbggUmVhbmltYXRlIG1hbmEgY29uc3VtcHRpb24gLSBCZWZvcmU6ICR7bWFuYUJlZm9yZX0sIEFmdGVyOiAke21hbmFBZnRlcn0sIENvbnN1bWVkOiAke21hbmFCZWZvcmUgLSBtYW5hQWZ0ZXJ9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFsd2F5cyB0cmlnZ2VyIHRoZSB2aXN1YWwgZWZmZWN0IGZpcnN0LCByZWdhcmRsZXNzIG9mIGhlYWxpbmcgc3VjY2Vzc1xuICAgIGNvbnNvbGUubG9nKCfwn4y/IFJlYW5pbWF0ZSBhYmlsaXR5IGFjdGl2YXRlZCAtIHRyaWdnZXJpbmcgdmlzdWFsIGVmZmVjdHMnKTtcbiAgICB0aGlzLnRyaWdnZXJSZWFuaW1hdGVFZmZlY3QocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyJ3MgaGVhbHRoIGNvbXBvbmVudCBhbmQgaGVhbCBmb3IgMjAgSFAgKGRvdWJsZWQgZnJvbSAxMClcbiAgICBjb25zdCBoZWFsdGhDb21wb25lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICBpZiAoaGVhbHRoQ29tcG9uZW50KSB7XG4gICAgICBjb25zdCBkaWRIZWFsID0gaGVhbHRoQ29tcG9uZW50LmhlYWwoMjApOyAvLyBSRUFOSU1BVEUgSEVBTCBBTU9VTlRcbiAgICAgIGlmIChkaWRIZWFsKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn6m4IFJlYW5pbWF0ZSBoZWFsZWQgcGxheWVyIGZvciAyMCBIUC4gQ3VycmVudCBoZWFsdGg6ICR7aGVhbHRoQ29tcG9uZW50LmN1cnJlbnRIZWFsdGh9LyR7aGVhbHRoQ29tcG9uZW50Lm1heEhlYWx0aH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn6m4IFJlYW5pbWF0ZSBjYXN0IHN1Y2Nlc3NmdWxseSBidXQgcGxheWVyIGFscmVhZHkgYXQgZnVsbCBoZWFsdGgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyaWdnZXJSZWFuaW1hdGVFZmZlY3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBUcmlnZ2VyIHRoZSB2aXN1YWwgaGVhbGluZyBlZmZlY3RcbiAgICBjb25zb2xlLmxvZygn8J+MvyBUcmlnZ2VyaW5nIFJlYW5pbWF0ZSBoZWFsaW5nIGVmZmVjdCcpO1xuICAgIFxuICAgIGlmICh0aGlzLm9uUmVhbmltYXRlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25SZWFuaW1hdGVDYWxsYmFjaygpO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBjb25zb2xlLmxvZyhg8J+MvyBIZWFsaW5nIGVmZmVjdCBhdCBwb3NpdGlvbjogJHtwbGF5ZXJQb3NpdGlvbi54LnRvRml4ZWQoMil9LCAke3BsYXllclBvc2l0aW9uLnkudG9GaXhlZCgyKX0sICR7cGxheWVyUG9zaXRpb24uei50b0ZpeGVkKDIpfWApO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRnJvc3ROb3ZhQWJpbGl0eShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSA8IHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinYTvuI8gRnJvc3QgTm92YSBvbiBjb29sZG93biBmb3IgJHsodGhpcy5mcm9zdE5vdmFGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggbWFuYSAoMjUgbWFuYSBjb3N0KVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3RGcm9zdE5vdmEoKSkge1xuICAgICAgY29uc29sZS5sb2coJ+KdhO+4jyBOb3QgZW5vdWdoIG1hbmEgdG8gY2FzdCBGcm9zdCBOb3ZhIChyZXF1aXJlcyAyNSBtYW5hKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb25zdW1lIG1hbmFcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZU1hbmEoMjUpO1xuICAgICAgY29uc29sZS5sb2coJ+KdhO+4jyBDb25zdW1lZCAyNSBtYW5hIGZvciBGcm9zdCBOb3ZhJyk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGFzdEZyb3N0Tm92YVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4p2E77iPIEZyb3N0IE5vdmEgYWJpbGl0eSBhY3RpdmF0ZWQhJyk7XG4gICAgXG4gICAgLy8gR2V0IHBsYXllciBwb3NpdGlvbiBhbmQgZGlyZWN0aW9uXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBGcm9zdCBOb3ZhIGNhbGxiYWNrIGZvciB2aXN1YWwgZWZmZWN0c1xuICAgIGlmICh0aGlzLm9uRnJvc3ROb3ZhQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Gcm9zdE5vdmFDYWxsYmFjayhwbGF5ZXJQb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluZCBhbGwgZW5lbWllcyB3aXRoaW4gNSB1bml0IHJhZGl1cyBhbmQgZnJlZXplIHRoZW0gKHJlZHVjZWQgZnJvbSA4KVxuICAgIHRoaXMuZnJlZXplRW5lbWllc0luUmFkaXVzKHBsYXllclBvc2l0aW9uLCA2LjAsIGN1cnJlbnRUaW1lKTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIGdsb2JhbCBmcm9zdCBub3ZhIHZpc3VhbCBlZmZlY3RcbiAgICB0cmlnZ2VyR2xvYmFsRnJvc3ROb3ZhKHBsYXllclBvc2l0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybUNvYnJhU2hvdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wbGF5ZXJFbnRpdHkpIHJldHVybjtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q29icmFTaG90VGltZSA8IHRoaXMuY29icmFTaG90RmlyZVJhdGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5CNIENvYnJhIFNob3Qgb24gY29vbGRvd24gZm9yICR7KHRoaXMuY29icmFTaG90RmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RDb2JyYVNob3RUaW1lKSkudG9GaXhlZCgxKX1zYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg0MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0Q29icmFTaG90KCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5CNIE5vdCBlbm91Z2ggZW5lcmd5IHRvIGNhc3QgQ29icmEgU2hvdCAocmVxdWlyZXMgNDAgZW5lcmd5KScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNDApO1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gQ29uc3VtZWQgNDAgZW5lcmd5IGZvciBDb2JyYSBTaG90Jyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ/CfkI0gQ29icmEgU2hvdCBhY3RpdmF0ZWQgLSBzdGFydGluZyBjaGFyZ2UhJyk7XG4gICAgdGhpcy5pc0NvYnJhU2hvdENoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RDb2JyYVNob3RUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gU3RhcnQgY2hhcmdpbmcgYW5pbWF0aW9uXG4gICAgY29uc3QgY2hhcmdlU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBjaGFyZ2VEdXJhdGlvbiA9IDc1MDsgLy8gMC43NSBzZWNvbmQgY2hhcmdlIHRpbWUgKGJldHdlZW4gVmlwZXIgU3RpbmcgYW5kIEJhcnJhZ2UpXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID49IDEuMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGNoYXJnZUludGVydmFsKTtcbiAgICAgICAgdGhpcy5maXJlQ29icmFTaG90KHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzID0gMDtcbiAgICAgIH1cbiAgICB9LCAxNik7IC8vIH42MGZwcyB1cGRhdGVzXG4gIH1cblxuICBwcml2YXRlIGZpcmVDb2JyYVNob3QocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+QjSBGaXJpbmcgQ29icmEgU2hvdCBwcm9qZWN0aWxlIScpO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvbiAoc2FtZSBhcyBvdGhlciBwcm9qZWN0aWxlcylcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAxOyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsIGxpa2UgVmlwZXIgU3RpbmdcbiAgICBcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIGFzIG90aGVyIHByb2plY3RpbGVzXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgXG4gICAgLy8gTm90ZTogQ29icmEgU2hvdCBkYW1hZ2UgaXMgaGFuZGxlZCBieSBDb2JyYVNob3RNYW5hZ2VyLCBub3QgRUNTIHByb2plY3RpbGVzXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBkdXBsaWNhdGUgcHJvamVjdGlsZXMgYW5kIGRhbWFnZSAoc2ltaWxhciB0byBWaXBlciBTdGluZylcbiAgICBcbiAgICAvLyBUcmlnZ2VyIENvYnJhIFNob3QgY2FsbGJhY2sgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgaWYgKHRoaXMub25Db2JyYVNob3RDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkNvYnJhU2hvdENhbGxiYWNrKHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyaWdnZXIgZ2xvYmFsIGNvYnJhIHNob3Qgd2l0aCBwcm9wZXIgcG9zaXRpb25pbmcgKGhhbmRsZXMgbG9jYWwgdmlzdWFsIGVmZmVjdHMgYW5kIGRhbWFnZSlcbiAgICB0cmlnZ2VyR2xvYmFsQ29icmFTaG90KHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2NvYnJhX3Nob3RfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwge1xuICAgICAgICBzcGVlZDogMTYsIC8vIENvbnNpc3RlbnQgc3BlZWQgZm9yIFBWUFxuICAgICAgICBkYW1hZ2U6IDI5LCAvLyBVc2UgY29uc2lzdGVudCBkYW1hZ2UgdmFsdWVcbiAgICAgICAgbGlmZXRpbWU6IDgsXG4gICAgICAgIHZlbm9tRHVyYXRpb246IDZcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZnJlZXplRW5lbWllc0luUmFkaXVzKGNlbnRlclBvc2l0aW9uOiBWZWN0b3IzLCByYWRpdXM6IG51bWJlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkXG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSB0aGlzLndvcmxkLmdldEFsbEVudGl0aWVzKCk7XG4gICAgbGV0IGZyb3plbkNvdW50ID0gMDtcbiAgICBsZXQgZGFtYWdlZFBsYXllcnMgPSAwO1xuICAgIFxuICAgIGFsbEVudGl0aWVzLmZvckVhY2goZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IGVudGl0eVRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IGVudGl0eUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIFxuICAgICAgaWYgKCFlbnRpdHlUcmFuc2Zvcm0gfHwgIWVudGl0eUhlYWx0aCB8fCBlbnRpdHlIZWFsdGguaXNEZWFkKSByZXR1cm47XG4gICAgICBcbiAgICAgIC8vIFNraXAgc2VsZlxuICAgICAgaWYgKGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVudGl0eVBvc2l0aW9uID0gZW50aXR5VHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjZW50ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKGVudGl0eVBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGlzIHdpdGhpbiBmcmVlemUgcmFkaXVzXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcmFkaXVzKSB7XG4gICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZW5lbXkpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVuZW15IC0gZnJlZXplIGl0IChzaW5nbGUgcGxheWVyIG1vZGUpXG4gICAgICAgICAgZW5lbXkuZnJlZXplKDYuMCwgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGZyb3plbkNvdW50Kys7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKdhO+4jyBGcm96ZW4gZW5lbXkgYXQgZGlzdGFuY2UgJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSB1bml0c2ApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFkZCBmcm96ZW4gdmlzdWFsIGVmZmVjdCBmb3IgdGhpcyBlbmVteVxuICAgICAgICAgIGFkZEdsb2JhbEZyb3plbkVuZW15KGVudGl0eS5pZC50b1N0cmluZygpLCBlbnRpdHlQb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYW5vdGhlciBwbGF5ZXIgaW4gUFZQIG1vZGUgLSBkZWFsIGRhbWFnZSBhbmQgZnJlZXplXG4gICAgICAgICAgY29uc3QgY29tYmF0U3lzdGVtID0gdGhpcy53b3JsZC5nZXRTeXN0ZW0oQ29tYmF0U3lzdGVtKTtcbiAgICAgICAgICBpZiAoY29tYmF0U3lzdGVtICYmIHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICAgICAgICBjb25zdCBmcm9zdE5vdmFEYW1hZ2UgPSA1MDsgLy8gRnJvc3QgTm92YSBkYW1hZ2VcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIGZyb3N0Tm92YURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHksICdmcm9zdF9ub3ZhJyk7XG4gICAgICAgICAgICBkYW1hZ2VkUGxheWVycysrO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKdhO+4jyBGcm9zdCBOb3ZhIGhpdCBwbGF5ZXIgJHtlbnRpdHkuaWR9IGZvciAke2Zyb3N0Tm92YURhbWFnZX0gZGFtYWdlIGF0IGRpc3RhbmNlICR7ZGlzdGFuY2UudG9GaXhlZCgyKX0gdW5pdHNgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQnJvYWRjYXN0IGZyZWV6ZSBlZmZlY3QgdG8gdGhlIHRhcmdldCBwbGF5ZXIgc28gdGhleSBnZXQgZnJvemVuIG9uIHRoZWlyIGVuZFxuICAgICAgICAgICAgaWYgKHRoaXMub25EZWJ1ZmZDYWxsYmFjaykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4p2E77iPIEJyb2FkY2FzdGluZyBmcmVlemUgZWZmZWN0IHRvIFBWUCBwbGF5ZXIgJHtlbnRpdHkuaWR9YCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIERlYnVnOiBDYWxsaW5nIGRlYnVmZiBjYWxsYmFjayB3aXRoIGVudGl0eUlkPSR7ZW50aXR5LmlkfSwgdHlwZT1mcm96ZW4sIGR1cmF0aW9uPTMwMDBgKTtcbiAgICAgICAgICAgICAgdGhpcy5vbkRlYnVmZkNhbGxiYWNrKGVudGl0eS5pZCwgJ2Zyb3plbicsIDYwMDAsIGVudGl0eVBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBEZWJ1ZzogRGVidWZmIGNhbGxiYWNrIGNvbXBsZXRlZGApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gRGVidWc6IG9uRGVidWZmQ2FsbGJhY2sgaXMgbm90IHNldCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAoZnJvemVuQ291bnQgPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4p2E77iPIEZyb3N0IE5vdmEgZnJvemUgJHtmcm96ZW5Db3VudH0gZW5lbWllcyB3aXRoaW4gJHtyYWRpdXN9IHVuaXQgcmFkaXVzYCk7XG4gICAgfVxuICAgIGlmIChkYW1hZ2VkUGxheWVycyA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKGDinYTvuI8gRnJvc3QgTm92YSBkYW1hZ2VkICR7ZGFtYWdlZFBsYXllcnN9IHBsYXllcnMgd2l0aGluICR7cmFkaXVzfSB1bml0IHJhZGl1c2ApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBsYXllckVudGl0eSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIE9mZnNldCBwcm9qZWN0aWxlIHNwYXduIHBvc2l0aW9uIHNsaWdodGx5IGZvcndhcmQgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggcGxheWVyXG4gICAgY29uc3Qgc3Bhd25Qb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCk7XG4gICAgc3Bhd25Qb3NpdGlvbi5hZGQoZGlyZWN0aW9uLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoMSkpOyAvLyAxIHVuaXQgZm9yd2FyZFxuICAgIHNwYXduUG9zaXRpb24ueSArPSAwLjU7IC8vIFNsaWdodGx5IGhpZ2hlclxuICAgIFxuICAgIC8vIENyZWF0ZSBjaGFyZ2VkIGFycm93IHByb2plY3RpbGUgLSBtb3JlIHBvd2VyZnVsIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBjb25zdCBjaGFyZ2VkQXJyb3dDb25maWcgPSB7XG4gICAgICBzcGVlZDogMzUsIC8vIEZhc3RlciB0aGFuIHJlZ3VsYXIgYXJyb3dzICgyNSlcbiAgICAgIGRhbWFnZTogNTAsIC8vIE11Y2ggaGlnaGVyIGRhbWFnZSB0aGFuIHJlZ3VsYXIgYXJyb3dzICgxMClcbiAgICAgIGxpZmV0aW1lOiA1LCAvLyBMb25nZXIgbGlmZXRpbWUgdGhhbiByZWd1bGFyIGFycm93cyAoMylcbiAgICAgIHBpZXJjaW5nOiB0cnVlLCAvLyBDaGFyZ2VkIGFycm93cyBjYW4gcGllcmNlIHRocm91Z2ggZW5lbWllc1xuICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gTm8gZXhwbG9zaW9uLCBidXQgY291bGQgYWRkIHNwZWNpYWwgZWZmZWN0c1xuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsLFxuICAgICAgb3BhY2l0eTogMS4wXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnByb2plY3RpbGVTeXN0ZW0uY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICAgIHRoaXMud29ybGQsXG4gICAgICBzcGF3blBvc2l0aW9uLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGhpcy5wbGF5ZXJFbnRpdHkuaWQsXG4gICAgICBjaGFyZ2VkQXJyb3dDb25maWdcbiAgICApO1xuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdjaGFyZ2VkX2Fycm93Jywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCBjaGFyZ2VkQXJyb3dDb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlUGVyZmVjdFNob3RQcm9qZWN0aWxlKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxheWVyRW50aXR5KSByZXR1cm47XG4gICAgXG4gICAgLy8gT2Zmc2V0IHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgc3Bhd25Qb3NpdGlvbi55ICs9IDAuNTsgLy8gU2xpZ2h0bHkgaGlnaGVyXG4gICAgXG4gICAgLy8gQ3JlYXRlIHBlcmZlY3Qgc2hvdCBwcm9qZWN0aWxlIC0gZW5oYW5jZWQgY2hhcmdlZCBhcnJvdyB3aXRoIHNwZWNpYWwgZWZmZWN0c1xuICAgIHRoaXMucHJvamVjdGlsZVN5c3RlbS5jcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlKFxuICAgICAgdGhpcy53b3JsZCxcbiAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICB0aGlzLnBsYXllckVudGl0eS5pZCxcbiAgICAgIHtcbiAgICAgICAgc3BlZWQ6IDQwLCAvLyBGYXN0ZXIgdGhhbiByZWd1bGFyIGNoYXJnZWQgYXJyb3dzICgzNSlcbiAgICAgICAgZGFtYWdlOiA3NSwgLy8gSGlnaGVyIGRhbWFnZSB0aGFuIHJlZ3VsYXIgY2hhcmdlZCBhcnJvd3MgKDUwKVxuICAgICAgICBsaWZldGltZTogNiwgLy8gTG9uZ2VyIGxpZmV0aW1lIHRoYW4gcmVndWxhciBjaGFyZ2VkIGFycm93cyAoNSlcbiAgICAgICAgcGllcmNpbmc6IHRydWUsIC8vIFBlcmZlY3Qgc2hvdHMgY2FuIHBpZXJjZSB0aHJvdWdoIGVuZW1pZXNcbiAgICAgICAgZXhwbG9zaXZlOiBmYWxzZSwgLy8gTm8gZXhwbG9zaW9uLCBidXQgaGFzIHNwZWNpYWwgdmlzdWFsIGVmZmVjdHNcbiAgICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfVxuICAgICk7XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IHByb2plY3RpbGUgY3JlYXRpb24gdG8gb3RoZXIgcGxheWVyc1xuICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ3BlcmZlY3Rfc2hvdCcsIHNwYXduUG9zaXRpb24sIGRpcmVjdGlvbiwge1xuICAgICAgICBzcGVlZDogNDAsXG4gICAgICAgIGRhbWFnZTogNzUsXG4gICAgICAgIGxpZmV0aW1lOiA2LFxuICAgICAgICBwaWVyY2luZzogdHJ1ZSxcbiAgICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgICBsZXZlbDogdGhpcy5jdXJyZW50TGV2ZWwsXG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGDinKggUGVyZmVjdCBzaG90IHByb2plY3RpbGUgY3JlYXRlZCB3aXRoIGVuaGFuY2VkIHN0YXRzIWApO1xuICB9XG5cbiAgLy8gTWV0aG9kcyB0byBjb25maWd1cmUgd2VhcG9uIGZvciB0ZXN0aW5nXG4gIHB1YmxpYyBzZXRXZWFwb25TdWJjbGFzcyhzdWJjbGFzczogV2VhcG9uU3ViY2xhc3MpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTdWJjbGFzcyA9IHN1YmNsYXNzO1xuICAgIGNvbnNvbGUubG9nKGDwn4+5IFdlYXBvbiBzdWJjbGFzcyBjaGFuZ2VkIHRvOiAke3N1YmNsYXNzfWApO1xuICB9XG5cbiAgLy8gTWV0aG9kIHRvIHNldCBib3cgcmVsZWFzZSBjYWxsYmFja1xuICBwdWJsaWMgc2V0Qm93UmVsZWFzZUNhbGxiYWNrKGNhbGxiYWNrOiAoZmluYWxQcm9ncmVzczogbnVtYmVyLCBpc1BlcmZlY3RTaG90PzogYm9vbGVhbikgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Cb3dSZWxlYXNlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldERpdmluZVN0b3JtQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBkdXJhdGlvbjogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRpdmluZVN0b3JtQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldFByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2s6IChwcm9qZWN0aWxlVHlwZTogc3RyaW5nLCBwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzLCBjb25maWc6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRWaXBlclN0aW5nQ2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgcHVibGljIHNldEJhcnJhZ2VDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQmFycmFnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBwdWJsaWMgc2V0UmVhbmltYXRlQ2FsbGJhY2soY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uUmVhbmltYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldEZyb3N0Tm92YUNhbGxiYWNrKGNhbGxiYWNrOiAocG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Gcm9zdE5vdmFDYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIFxuICBwdWJsaWMgc2V0Q29icmFTaG90Q2FsbGJhY2soY2FsbGJhY2s6IChwb3NpdGlvbjogVmVjdG9yMywgZGlyZWN0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNvYnJhU2hvdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRDaGFyZ2VDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhcmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuICBcbiAgcHVibGljIHNldERlZmxlY3RDYWxsYmFjayhjYWxsYmFjazogKHBvc2l0aW9uOiBWZWN0b3IzLCBkaXJlY3Rpb246IFZlY3RvcjMpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uRGVmbGVjdENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXREZWJ1ZmZDYWxsYmFjayhjYWxsYmFjazogKHRhcmdldEVudGl0eUlkOiBudW1iZXIsIGRlYnVmZlR5cGU6ICdmcm96ZW4nIHwgJ3Nsb3dlZCcsIGR1cmF0aW9uOiBudW1iZXIsIHBvc2l0aW9uOiBWZWN0b3IzKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkRlYnVmZkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICAvLyBNZXRob2QgdG8gdHJpZ2dlciBib3cgcmVsZWFzZSBlZmZlY3RzXG4gIHByaXZhdGUgdHJpZ2dlckJvd1JlbGVhc2VFZmZlY3RzKGZpbmFsQ2hhcmdlUHJvZ3Jlc3M6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLm9uQm93UmVsZWFzZUNhbGxiYWNrKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyBhIHBlcmZlY3Qgc2hvdFxuICAgICAgY29uc3QgcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgPSAwLjg7IC8vIDg1JSBjaGFyZ2VcbiAgICAgIGNvbnN0IHBlcmZlY3RTaG90TWF4VGhyZXNob2xkID0gMC45ODsgLy8gOTUlIGNoYXJnZVxuICAgICAgY29uc3QgaXNQZXJmZWN0U2hvdCA9IGZpbmFsQ2hhcmdlUHJvZ3Jlc3MgPj0gcGVyZmVjdFNob3RNaW5UaHJlc2hvbGQgJiYgZmluYWxDaGFyZ2VQcm9ncmVzcyA8PSBwZXJmZWN0U2hvdE1heFRocmVzaG9sZDtcbiAgICAgIFxuICAgICAgdGhpcy5vbkJvd1JlbGVhc2VDYWxsYmFjayhmaW5hbENoYXJnZVByb2dyZXNzLCBpc1BlcmZlY3RTaG90KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0V2VhcG9uTGV2ZWwobGV2ZWw6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgY29uc29sZS5sb2coYOKshu+4jyBXZWFwb24gbGV2ZWwgY2hhbmdlZCB0bzogJHtsZXZlbH1gKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDdXJyZW50V2VhcG9uQ29uZmlnKCk6IHsgd2VhcG9uOiBXZWFwb25UeXBlOyBzdWJjbGFzczogV2VhcG9uU3ViY2xhc3M7IGxldmVsOiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlYXBvbjogdGhpcy5jdXJyZW50V2VhcG9uLFxuICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgbGV2ZWw6IHRoaXMuY3VycmVudExldmVsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEdldHRlcnMgZm9yIHdlYXBvbiBzdGF0ZSAoZm9yIFVJL3JlbmRlcmluZylcbiAgcHVibGljIGdldEN1cnJlbnRXZWFwb24oKTogV2VhcG9uVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFdlYXBvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDdXJyZW50U3ViY2xhc3MoKTogV2VhcG9uU3ViY2xhc3Mge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdWJjbGFzcztcbiAgfVxuXG4gIHB1YmxpYyBpc1dlYXBvbkNoYXJnaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jaGFyZ2VQcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBpc1ZpcGVyU3RpbmdDaGFyZ2luZ0FjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRWaXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3M7XG4gIH1cblxuICBwdWJsaWMgaXNCYXJyYWdlQ2hhcmdpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmc7XG4gIH1cblxuICBwdWJsaWMgZ2V0QmFycmFnZUNoYXJnZVByb2dyZXNzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzQ29icmFTaG90Q2hhcmdpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb2JyYVNob3RDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb2JyYVNob3RDaGFyZ2VQcm9ncmVzcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvYnJhU2hvdENoYXJnZVByb2dyZXNzO1xuICB9XG5cbiAgcHVibGljIGlzV2VhcG9uU3dpbmdpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNTd2luZ2luZztcbiAgfVxuXG4gIC8vIFN3b3JkLXNwZWNpZmljIGdldHRlcnNcbiAgcHVibGljIGdldFN3b3JkQ29tYm9TdGVwKCk6IDEgfCAyIHwgMyB7XG4gICAgcmV0dXJuIHRoaXMuc3dvcmRDb21ib1N0ZXA7XG4gIH1cblxuICBwdWJsaWMgaXNEaXZpbmVTdG9ybUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0RpdmluZVN0b3JtaW5nO1xuICB9XG5cbiAgcHVibGljIGlzQ2hhcmdlQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzU3dvcmRDaGFyZ2luZztcbiAgfVxuXG4gIHB1YmxpYyBpc0RlZmxlY3RBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZWZsZWN0aW5nO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTd29yZElucHV0KHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIHN3b3JkIG1lbGVlIGF0dGFja3NcbiAgICBpZiAodGhpcy5pbnB1dE1hbmFnZXIuaXNNb3VzZUJ1dHRvblByZXNzZWQoMCkgJiYgIXRoaXMuaXNTd2luZ2luZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dvcmRDaGFyZ2luZyAmJiAhdGhpcy5pc0RlZmxlY3RpbmcpIHsgLy8gTGVmdCBtb3VzZSBidXR0b25cbiAgICAgIHRoaXMucGVyZm9ybVN3b3JkTWVsZWVBdHRhY2socGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIERpdmluZSBTdG9ybSBhYmlsaXR5IHdpdGggJ1InIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ3InKSAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtRGl2aW5lU3Rvcm0ocGxheWVyVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIENoYXJnZSBhYmlsaXR5IHdpdGggJ0UnIGtleVxuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc0tleVByZXNzZWQoJ2UnKSAmJiAhdGhpcy5pc1N3b3JkQ2hhcmdpbmcgJiYgIXRoaXMuaXNEaXZpbmVTdG9ybWluZyAmJiAhdGhpcy5pc1N3aW5naW5nICYmICF0aGlzLmlzRGVmbGVjdGluZykge1xuICAgICAgdGhpcy5wZXJmb3JtQ2hhcmdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBEZWZsZWN0IGFiaWxpdHkgd2l0aCAnUScga2V5XG4gICAgaWYgKHRoaXMuaW5wdXRNYW5hZ2VyLmlzS2V5UHJlc3NlZCgncScpICYmICF0aGlzLmlzRGVmbGVjdGluZyAmJiAhdGhpcy5pc0RpdmluZVN0b3JtaW5nICYmICF0aGlzLmlzU3dpbmdpbmcgJiYgIXRoaXMuaXNTd29yZENoYXJnaW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1EZWZsZWN0KHBsYXllclRyYW5zZm9ybSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGZvciBjb21ibyByZXNldFxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0U3dvcmRBdHRhY2tUaW1lID4gdGhpcy5zd29yZENvbWJvUmVzZXRUaW1lKSB7XG4gICAgICB0aGlzLnN3b3JkQ29tYm9TdGVwID0gMTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1Td29yZE1lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHN3b3JkLXNwZWNpZmljIGZpcmUgcmF0ZSlcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGlmIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEZpcmVUaW1lIDwgdGhpcy5zd29yZEZpcmVSYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGFzdEZpcmVUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy5sYXN0U3dvcmRBdHRhY2tUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCfl6HvuI8gU3dvcmQgbWVsZWUgYXR0YWNrIC0gQ29tYm8gc3RlcCAke3RoaXMuc3dvcmRDb21ib1N0ZXB9YCk7XG4gICAgXG4gICAgLy8gU2V0IHN3aW5naW5nIHN0YXRlIC0gY29tcGxldGlvbiB3aWxsIGJlIGhhbmRsZWQgYnkgc3dvcmQgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIG1lbGVlIGRhbWFnZSBpbiBhIGNvbmUgaW4gZnJvbnQgb2YgcGxheWVyXG4gICAgdGhpcy5wZXJmb3JtTWVsZWVEYW1hZ2UocGxheWVyVHJhbnNmb3JtKTtcbiAgICBcbiAgICAvLyBOb3RlOiBTd2luZyBjb21wbGV0aW9uIGFuZCBjb21ibyBhZHZhbmNlbWVudCBpcyBub3cgaGFuZGxlZCBieSBvblN3b3JkU3dpbmdDb21wbGV0ZSBjYWxsYmFja1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIHN3aW5nIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgcHVibGljIG9uU3dvcmRTd2luZ0NvbXBsZXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1N3aW5naW5nKSByZXR1cm47IC8vIFByZXZlbnQgbXVsdGlwbGUgY2FsbHNcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+Xoe+4jyBTd29yZCBzd2luZyBjb21wbGV0ZWQgLSB3YXMgY29tYm8gc3RlcCAke3RoaXMuc3dvcmRDb21ib1N0ZXB9YCk7XG4gICAgXG4gICAgLy8gUmVzZXQgc3dpbmdpbmcgc3RhdGVcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgICBcbiAgICAvLyBBZHZhbmNlIGNvbWJvIHN0ZXAgZm9yIG5leHQgYXR0YWNrXG4gICAgdGhpcy5zd29yZENvbWJvU3RlcCA9ICh0aGlzLnN3b3JkQ29tYm9TdGVwICUgMyArIDEpIGFzIDEgfCAyIHwgMztcbiAgICBcbiAgICBjb25zb2xlLmxvZyhg8J+Xoe+4jyBOZXh0IGNvbWJvIHN0ZXAgd2lsbCBiZTogJHt0aGlzLnN3b3JkQ29tYm9TdGVwfWApO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTYWJyZXNJbnB1dChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBsZWZ0IGNsaWNrIGZvciBkdWFsIHNhYnJlIGF0dGFja1xuICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5pc01vdXNlQnV0dG9uUHJlc3NlZCgwKSAmJiAhdGhpcy5pc1N3aW5naW5nKSB7XG4gICAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZUF0dGFjayhwbGF5ZXJUcmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlQXR0YWNrKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gUmF0ZSBsaW1pdGluZyAtIHByZXZlbnQgc3BhbSBjbGlja2luZyAodXNlIHNhYnJlcy1zcGVjaWZpYyBmaXJlIHJhdGUpXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RGaXJlVGltZSA8IHRoaXMuc2FicmVzRmlyZVJhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RmlyZVRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn4pqU77iPIFNhYnJlcyBkdWFsIGF0dGFjayBpbml0aWF0ZWQnKTtcbiAgICBcbiAgICAvLyBTZXQgc3dpbmdpbmcgc3RhdGUgLSBjb21wbGV0aW9uIHdpbGwgYmUgaGFuZGxlZCBieSBzYWJyZXMgY29tcG9uZW50IGNhbGxiYWNrXG4gICAgdGhpcy5pc1N3aW5naW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIG1lbGVlIGRhbWFnZSBpbiBhIGNvbmUgaW4gZnJvbnQgb2YgcGxheWVyIChkdWFsIGF0dGFjaylcbiAgICB0aGlzLnBlcmZvcm1TYWJyZXNNZWxlZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHNhYnJlcyBjb21wb25lbnQgd2hlbiBzd2luZyBhbmltYXRpb24gY29tcGxldGVzXG4gIHB1YmxpYyBvblNhYnJlc1N3aW5nQ29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzU3dpbmdpbmcpIHJldHVybjsgLy8gUHJldmVudCBtdWx0aXBsZSBjYWxsc1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gU2FicmVzIGR1YWwgc3dpbmcgY29tcGxldGVkJyk7XG4gICAgXG4gICAgLy8gUmVzZXQgc3dpbmdpbmcgc3RhdGVcbiAgICB0aGlzLmlzU3dpbmdpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBcbiAgICAvLyBHZXQgYWxsIGVudGl0aWVzIHRoYXQgY291bGQgYmUgZGFtYWdlZFxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSBhbGxFbnRpdGllcy5maWx0ZXIoZW50aXR5ID0+IFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChIZWFsdGgpICYmIFxuICAgICAgZW50aXR5Lmhhc0NvbXBvbmVudChUcmFuc2Zvcm0pICYmXG4gICAgICBlbnRpdHkgIT09IHRoaXMucGxheWVyRW50aXR5XG4gICAgKTtcbiAgICBcbiAgICAvLyBTQUJSRVMgREFNQUdFXG4gICAgY29uc3QgYXR0YWNrUmFuZ2UgPSA0OyAvLyBTbGlnaHRseSBsb25nZXIgcmFuZ2UgdGhhbiBzd29yZFxuICAgIGNvbnN0IGF0dGFja0FuZ2xlID0gTWF0aC5QSSAvIDIuNTsgLy8gNjAgZGVncmVlIGNvbmUgKHdpZGVyIHRoYW4gc3dvcmQpXG4gICAgY29uc3QgbGVmdFNhYnJlRGFtYWdlID0gMTk7IC8vIERhbWFnZSBwZXIgc2FicmVcbiAgICBjb25zdCByaWdodFNhYnJlRGFtYWdlID0gMjM7XG4gICAgXG4gICAgLy8gR2V0IGNhbWVyYSBkaXJlY3Rpb24gZm9yIGF0dGFjayBkaXJlY3Rpb25cbiAgICBjb25zdCBhdHRhY2tEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGF0dGFja0RpcmVjdGlvbik7XG4gICAgYXR0YWNrRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIGxldCBoaXRDb3VudCA9IDA7XG4gICAgXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcG90ZW50aWFsVGFyZ2V0cykge1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIXRhcmdldFRyYW5zZm9ybSB8fCAhdGFyZ2V0SGVhbHRoIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgICAgY29uc3QgZGlyZWN0aW9uVG9UYXJnZXQgPSB0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKS5zdWIocGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9UYXJnZXQgPSBkaXJlY3Rpb25Ub1RhcmdldC5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRpc3RhbmNlVG9UYXJnZXQgPiBhdHRhY2tSYW5nZSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyB3aXRoaW4gYXR0YWNrIGNvbmVcbiAgICAgIGRpcmVjdGlvblRvVGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuICAgICAgY29uc3QgZG90UHJvZHVjdCA9IGF0dGFja0RpcmVjdGlvbi5kb3QoZGlyZWN0aW9uVG9UYXJnZXQpO1xuICAgICAgY29uc3QgYW5nbGVUb1RhcmdldCA9IE1hdGguYWNvcyhNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgZG90UHJvZHVjdCkpKTtcbiAgICAgIFxuICAgICAgaWYgKGFuZ2xlVG9UYXJnZXQgPiBhdHRhY2tBbmdsZSAvIDIpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBUYXJnZXQgaXMgd2l0aGluIHJhbmdlIGFuZCBjb25lIC0gYXBwbHkgZGFtYWdlIGZyb20gYm90aCBzYWJyZXNcbiAgICAgIGNvbnN0IGNvbWJhdFN5c3RlbSA9IHRoaXMud29ybGQuZ2V0U3lzdGVtKENvbWJhdFN5c3RlbSk7XG4gICAgICBpZiAoY29tYmF0U3lzdGVtKSB7XG4gICAgICAgIC8vIExlZnQgc2FicmUgaGl0IChpbW1lZGlhdGUpXG4gICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZSh0YXJnZXQsIGxlZnRTYWJyZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHkgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJpZ2h0IHNhYnJlIGhpdCAod2l0aCBzbWFsbCBkZWxheSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0YXJnZXRIZWFsdGguaXNEZWFkKSB7XG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UodGFyZ2V0LCByaWdodFNhYnJlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwKTsgLy8gMTAwbXMgZGVsYXkgYmV0d2VlbiBzYWJyZSBoaXRzXG4gICAgICAgIFxuICAgICAgICBoaXRDb3VudCsrO1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqU77iPIFNhYnJlcyBoaXQgdGFyZ2V0IGF0IGRpc3RhbmNlICR7ZGlzdGFuY2VUb1RhcmdldC50b0ZpeGVkKDIpfSBmb3IgJHtsZWZ0U2FicmVEYW1hZ2UgKyByaWdodFNhYnJlRGFtYWdlfSB0b3RhbCBkYW1hZ2VgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKGhpdENvdW50ID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIFNhYnJlcyBhdHRhY2sgbWlzc2VkIC0gbm8gdGFyZ2V0cyBpbiByYW5nZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqU77iPIFNhYnJlcyBhdHRhY2sgaGl0ICR7aGl0Q291bnR9IHRhcmdldChzKWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybU1lbGVlRGFtYWdlKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gR2V0IGFsbCBlbnRpdGllcyBpbiB0aGUgd29ybGQgdG8gY2hlY2sgZm9yIGVuZW1pZXNcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IHRoaXMud29ybGQuZ2V0QWxsRW50aXRpZXMoKTtcbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIGZhY2luZyBkaXJlY3Rpb24gKGNhbWVyYSBkaXJlY3Rpb24pXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBNZWxlZSBhdHRhY2sgcGFyYW1ldGVycyAtIGluY3JlYXNlZCBmb3IgUFZQIGNvbWJhdFxuICAgIGNvbnN0IG1lbGVlUmFuZ2UgPSA0Ljk7IC8vIEluY3JlYXNlZCBhdHRhY2sgcmFuZ2UgZm9yIFBWUFxuICAgIGNvbnN0IG1lbGVlQW5nbGUgPSBNYXRoLlBJIC8gMjsgLy8gMTIwIGRlZ3JlZSBjb25lICg2MCBkZWdyZWVzIGVhY2ggc2lkZSlcbiAgICBcbiAgICAvLyBCYXNlIGRhbWFnZSB2YWx1ZXMgYmFzZWQgb24gY29tYm8gc3RlcCAtIHdvcmtzIGZvciBhbGwgc3ViY2xhc3Nlc1xuICAgIGxldCBiYXNlRGFtYWdlID0gMjU7IC8vIEJhc2Ugc3dvcmQgZGFtYWdlXG4gICAgLy8gQ29tYm8gZGFtYWdlIHNjYWxpbmdcbiAgICBzd2l0Y2ggKHRoaXMuc3dvcmRDb21ib1N0ZXApIHtcbiAgICAgIGNhc2UgMTogYmFzZURhbWFnZSA9IDI1OyBicmVhaztcbiAgICAgIGNhc2UgMjogYmFzZURhbWFnZSA9IDMwOyBicmVhaztcbiAgICAgIGNhc2UgMzogYmFzZURhbWFnZSA9IDQwOyBicmVhazsgLy8gRmluaXNoZXIgZG9lcyBtb3JlIGRhbWFnZVxuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgY29tYmF0IHN5c3RlbSB0byBhcHBseSBkYW1hZ2VcbiAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgIFxuICAgIC8vIFRyYWNrIGVuZW1pZXMgaGl0IGZvciByYWdlIGdlbmVyYXRpb25cbiAgICBsZXQgZW5lbWllc0hpdCA9IDA7XG4gICAgXG4gICAgYWxsRW50aXRpZXMuZm9yRWFjaChlbnRpdHkgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgZW50aXR5IGhhcyBlbmVteSBjb21wb25lbnQgYW5kIGhlYWx0aFxuICAgICAgY29uc3QgZW5lbXlUcmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCBlbmVteUhlYWx0aCA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoKTtcbiAgICAgIGlmICghZW5lbXlUcmFuc2Zvcm0gfHwgIWVuZW15SGVhbHRoIHx8IGVudGl0eS5pZCA9PT0gdGhpcy5wbGF5ZXJFbnRpdHk/LmlkKSByZXR1cm47XG4gICAgICBcbiAgICAgIGNvbnN0IGVuZW15UG9zaXRpb24gPSBlbmVteVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgIGNvbnN0IHRvRW5lbXkgPSBlbmVteVBvc2l0aW9uLmNsb25lKCkuc3ViKHBsYXllclBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG9FbmVteS5sZW5ndGgoKTtcbiAgICAgIFxuICAgICAgLy8gRGVidWcgbG9nZ2luZyBmb3IgUFZQIGhpdCBkZXRlY3Rpb25cbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBWUCBTd29yZCBjaGVjayAtIEVudGl0eSAke2VudGl0eS5pZH06IFBsYXllciBwb3MgKCR7cGxheWVyUG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtwbGF5ZXJQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke3BsYXllclBvc2l0aW9uLnoudG9GaXhlZCgyKX0pLCBFbmVteSBwb3MgKCR7ZW5lbXlQb3NpdGlvbi54LnRvRml4ZWQoMil9LCAke2VuZW15UG9zaXRpb24ueS50b0ZpeGVkKDIpfSwgJHtlbmVteVBvc2l0aW9uLnoudG9GaXhlZCgyKX0pLCBEaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgUmFuZ2U6ICR7bWVsZWVSYW5nZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgZW5lbXkgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gbWVsZWVSYW5nZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBlbmVteSBpcyB3aXRoaW4gYXR0YWNrIGNvbmVcbiAgICAgICAgdG9FbmVteS5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBkaXJlY3Rpb24uYW5nbGVUbyh0b0VuZW15KTtcbiAgICAgICAgY29uc3QgYW5nbGVEZWdyZWVzID0gYW5nbGUgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBjb25zdCBtYXhBbmdsZURlZ3JlZXMgPSAobWVsZWVBbmdsZSAvIDIpICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFBWUCBTd29yZCBhbmdsZSBjaGVjayAtIEVudGl0eSAke2VudGl0eS5pZH06IEFuZ2xlICR7YW5nbGVEZWdyZWVzLnRvRml4ZWQoMSl9wrAsIE1heCBhbmdsZTogJHttYXhBbmdsZURlZ3JlZXMudG9GaXhlZCgxKX3CsGApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFuZ2xlIDw9IG1lbGVlQW5nbGUgLyAyKSB7XG4gICAgICAgICAgLy8gRW5lbXkgaXMgd2l0aGluIGF0dGFjayBjb25lIC0gZGVhbCBkYW1hZ2UgdGhyb3VnaCBjb21iYXQgc3lzdGVtXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfl6HvuI8gUFZQIFN3b3JkIGhpdCBjb25maXJtZWQhIEVudGl0eSAke2VudGl0eS5pZH0gYXQgZGlzdGFuY2UgJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgYW5nbGUgJHthbmdsZURlZ3JlZXMudG9GaXhlZCgxKX3CsGApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIC8vIFF1ZXVlIGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW0gKHdoaWNoIHdpbGwgcm91dGUgdG8gbXVsdGlwbGF5ZXIgZm9yIGVuZW1pZXMpXG4gICAgICAgICAgICBjb21iYXRTeXN0ZW0ucXVldWVEYW1hZ2UoZW50aXR5LCBiYXNlRGFtYWdlLCB0aGlzLnBsYXllckVudGl0eSwgJ21lbGVlJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+SpSBRdWV1ZWQgJHtiYXNlRGFtYWdlfSBtZWxlZSBkYW1hZ2UgdG8gZW50aXR5ICR7ZW50aXR5LmlkfSAoY29tYm8gc3RlcCAke3RoaXMuc3dvcmRDb21ib1N0ZXB9KWApO1xuICAgICAgICAgICAgZW5lbWllc0hpdCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4p2MIFBWUCBTd29yZCBtaXNzZWQgLSBFbnRpdHkgJHtlbnRpdHkuaWR9IG91dHNpZGUgYXR0YWNrIGNvbmUgKCR7YW5nbGVEZWdyZWVzLnRvRml4ZWQoMSl9wrAgPiAke21heEFuZ2xlRGVncmVlcy50b0ZpeGVkKDEpfcKwKWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIFBWUCBTd29yZCBtaXNzZWQgLSBFbnRpdHkgJHtlbnRpdHkuaWR9IG91dCBvZiByYW5nZSAoJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSA+ICR7bWVsZWVSYW5nZX0pYCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgcmFnZSBvbmx5IGlmIHdlIGhpdCBlbmVtaWVzICg1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nKVxuICAgIGlmIChlbmVtaWVzSGl0ID4gMCkge1xuICAgICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICAgIGlmIChnYW1lVUkpIHtcbiAgICAgICAgY29uc3QgcmFnZUJlZm9yZSA9IGdhbWVVSS5nZXRDdXJyZW50UmFnZSA/IGdhbWVVSS5nZXRDdXJyZW50UmFnZSgpIDogJ3Vua25vd24nO1xuICAgICAgICBjb25zdCByYWdlVG9HYWluID0gTWF0aC5taW4oZW5lbWllc0hpdCAqIDUsIDUpOyAvLyA1IHJhZ2UgcGVyIGhpdCwgbWF4IDUgcGVyIHN3aW5nXG4gICAgICAgIGdhbWVVSS5nYWluUmFnZShyYWdlVG9HYWluKTtcbiAgICAgICAgY29uc3QgcmFnZUFmdGVyID0gZ2FtZVVJLmdldEN1cnJlbnRSYWdlID8gZ2FtZVVJLmdldEN1cnJlbnRSYWdlKCkgOiAndW5rbm93bic7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5eh77iPIEdhaW5lZCAke3JhZ2VUb0dhaW59IHJhZ2UgZnJvbSBoaXR0aW5nICR7ZW5lbWllc0hpdH0gZW5lbWllcyB3aXRoIHN3b3JkIGNvbWJvICR7dGhpcy5zd29yZENvbWJvU3RlcH0gLSBSYWdlOiAke3JhZ2VCZWZvcmV9IOKGkiAke3JhZ2VBZnRlcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9yRGFzaElucHV0KG1vdmVtZW50OiBNb3ZlbWVudCwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBmb3IgZG91YmxlLXRhcCBvbiBtb3ZlbWVudCBrZXlzXG4gICAgY29uc3QgZGFzaERpcmVjdGlvbnMgPSBbXG4gICAgICB7IGtleTogJ3cnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDAsIDAsIC0xKSB9LCAvLyBGb3J3YXJkXG4gICAgICB7IGtleTogJ3MnLCBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKDAsIDAsIDEpIH0sICAvLyBCYWNrd2FyZFxuICAgICAgeyBrZXk6ICdhJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygtMSwgMCwgMCkgfSwgLy8gTGVmdFxuICAgICAgeyBrZXk6ICdkJywgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygxLCAwLCAwKSB9ICAgLy8gUmlnaHRcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCB7IGtleSwgZGlyZWN0aW9uIH0gb2YgZGFzaERpcmVjdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmlucHV0TWFuYWdlci5jaGVja0RvdWJsZVRhcChrZXkpKSB7XG4gICAgICAgIC8vIERlYnVnOiBMb2cgdGhlIGRvdWJsZSB0YXAgZGV0ZWN0aW9uXG4gICAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IHRoaXMuaW5wdXRNYW5hZ2VyLmdldERvdWJsZVRhcERlYnVnSW5mbyhrZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBEb3VibGUgdGFwIGRldGVjdGVkIGZvciBrZXkgJyR7a2V5LnRvVXBwZXJDYXNlKCl9JzpgLCBkZWJ1Z0luZm8pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBpbnB1dCBkaXJlY3Rpb24gdG8gd29ybGQgc3BhY2UgYmFzZWQgb24gY2FtZXJhIG9yaWVudGF0aW9uXG4gICAgICAgIGNvbnN0IHdvcmxkRGlyZWN0aW9uID0gdGhpcy5nZXRXb3JsZFNwYWNlRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBBdHRlbXB0IHRvIHN0YXJ0IGRhc2hcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgICAgIGNvbnN0IGRhc2hTdGFydGVkID0gbW92ZW1lbnQuc3RhcnREYXNoKHdvcmxkRGlyZWN0aW9uLCB0cmFuc2Zvcm0ucG9zaXRpb24sIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXNoU3RhcnRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn4+DIERhc2ggc3RhcnRlZCBpbiBkaXJlY3Rpb246ICR7a2V5LnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIGRvdWJsZS10YXAgc3RhdGUgdG8gcHJldmVudCBtdWx0aXBsZSBkYXNoZXNcbiAgICAgICAgICB0aGlzLmlucHV0TWFuYWdlci5yZXNldERvdWJsZVRhcChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybihg4p2MIERhc2ggZmFpbGVkIHRvIHN0YXJ0IGZvciBrZXk6ICR7a2V5LnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGJyZWFrOyAvLyBPbmx5IHByb2Nlc3Mgb25lIGRhc2ggcGVyIGZyYW1lXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVEYXNoTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNEYXNoaW5nKSByZXR1cm47XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwOyAvLyBDb252ZXJ0IHRvIHNlY29uZHNcbiAgICBjb25zdCBkYXNoUmVzdWx0ID0gbW92ZW1lbnQudXBkYXRlRGFzaChjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoZGFzaFJlc3VsdC5uZXdQb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgYm91bmRzIGNoZWNraW5nIChzaW1pbGFyIHRvIG9sZCBpbXBsZW1lbnRhdGlvbilcbiAgICAgIGNvbnN0IE1BWF9EQVNIX0JPVU5EUyA9IDI5OyAvLyBNYXhpbXVtIGRpc3RhbmNlIGZyb20gb3JpZ2luIChtYXRjaGVzIG1hcCBib3VuZGFyeSlcbiAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IGRhc2hSZXN1bHQubmV3UG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZUZyb21PcmlnaW4gPD0gTUFYX0RBU0hfQk9VTkRTKSB7XG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGRhc2hSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FuY2VsIGRhc2ggaWYgaXQgd291bGQgbW92ZSB0b28gZmFyIGZyb20gb3JpZ2luXG4gICAgICAgIGNvbnNvbGUud2FybihgRGFzaCBjYW5jZWxsZWQ6IHdvdWxkIG1vdmUgdG9vIGZhciBmcm9tIG9yaWdpbiAoJHtkaXN0YW5jZUZyb21PcmlnaW4udG9GaXhlZCgyKX0gPiAke01BWF9EQVNIX0JPVU5EU30pYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbERhc2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGFzaFJlc3VsdC5pc0NvbXBsZXRlKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+PgSBEYXNoIGNvbXBsZXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQ2hhcmdlTW92ZW1lbnQobW92ZW1lbnQ6IE1vdmVtZW50LCB0cmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGlmICghbW92ZW1lbnQuaXNDaGFyZ2luZykgcmV0dXJuO1xuXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDsgLy8gQ29udmVydCB0byBzZWNvbmRzXG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgY2hhcmdlIHdhcyBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgIGlmICh0aGlzLmNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbikge1xuICAgICAgbW92ZW1lbnQuY2FuY2VsQ2hhcmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNoYXJnZVJlc3VsdCA9IG1vdmVtZW50LnVwZGF0ZUNoYXJnZShjdXJyZW50VGltZSk7XG5cbiAgICBpZiAoY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uKSB7XG4gICAgICAvLyBBcHBseSBib3VuZHMgY2hlY2tpbmdcbiAgICAgIGNvbnN0IE1BWF9DSEFSR0VfQk9VTkRTID0gMjk7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW4gKG1hdGNoZXMgbWFwIGJvdW5kYXJ5KVxuICAgICAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gY2hhcmdlUmVzdWx0Lm5ld1Bvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcGlsbGFyIGNvbGxpc2lvblxuICAgICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihjaGFyZ2VSZXN1bHQubmV3UG9zaXRpb24pO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2VGcm9tT3JpZ2luID4gTUFYX0NIQVJHRV9CT1VORFMpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW5cbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFyZ2UgY2FuY2VsbGVkOiB3b3VsZCBtb3ZlIHRvbyBmYXIgZnJvbSBvcmlnaW4gKCR7ZGlzdGFuY2VGcm9tT3JpZ2luLnRvRml4ZWQoMil9ID4gJHtNQVhfQ0hBUkdFX0JPVU5EU30pYCk7XG4gICAgICAgIG1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAvLyBOb3RpZnkgc3dvcmQgY29tcG9uZW50IHRoYXQgY2hhcmdlIHdhcyBjYW5jZWxsZWRcbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gQ2FuY2VsIGNoYXJnZSBpZiBpdCB3b3VsZCBjb2xsaWRlIHdpdGggYSBwaWxsYXJcbiAgICAgICAgY29uc29sZS53YXJuKGBDaGFyZ2UgY2FuY2VsbGVkOiB3b3VsZCBjb2xsaWRlIHdpdGggcGlsbGFyIGF0IFske3BpbGxhckNvbGxpc2lvbi5waWxsYXJDZW50ZXIudG9BcnJheSgpLmpvaW4oJywgJyl9XWApO1xuICAgICAgICBtb3ZlbWVudC5jYW5jZWxDaGFyZ2UoKTtcbiAgICAgICAgLy8gTm90aWZ5IHN3b3JkIGNvbXBvbmVudCB0aGF0IGNoYXJnZSB3YXMgY2FuY2VsbGVkXG4gICAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24pIHtcbiAgICAgICAgLy8gT25seSB1cGRhdGUgcG9zaXRpb24gaWYgbm90IHN0b3BwZWQgYnkgY29sbGlzaW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KGNoYXJnZVJlc3VsdC5uZXdQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYXJnZVJlc3VsdC5pc0NvbXBsZXRlIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqU77iPIENoYXJnZSBtb3ZlbWVudCBjb21wbGV0ZWQnKTtcbiAgICAgIC8vIE5vdGlmeSBzd29yZCBjb21wb25lbnQgdGhhdCBjaGFyZ2UgaXMgY29tcGxldGVcbiAgICAgIHRoaXMub25DaGFyZ2VDb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGdldFdvcmxkU3BhY2VEaXJlY3Rpb24oaW5wdXREaXJlY3Rpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICAvLyBHZXQgY2FtZXJhIGRpcmVjdGlvbiB2ZWN0b3JzXG4gICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1lcmFEaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyByaWdodCB2ZWN0b3JcbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGNhbWVyYURpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEdldCBjYW1lcmEncyBmb3J3YXJkIHZlY3RvciAocHJvamVjdGVkIG9uIFhaIHBsYW5lKVxuICAgIGNvbnN0IGNhbWVyYUZvcndhcmQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNhbWVyYUZvcndhcmQuY3Jvc3NWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDEsIDApLCBjYW1lcmFSaWdodCkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gaW5wdXQgZGlyZWN0aW9uIHRvIHdvcmxkIHNwYWNlXG4gICAgY29uc3Qgd29ybGREaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHdvcmxkRGlyZWN0aW9uLmFkZFNjYWxlZFZlY3RvcihjYW1lcmFSaWdodCwgaW5wdXREaXJlY3Rpb24ueCk7XG4gICAgd29ybGREaXJlY3Rpb24uYWRkU2NhbGVkVmVjdG9yKGNhbWVyYUZvcndhcmQsIC1pbnB1dERpcmVjdGlvbi56KTtcbiAgICB3b3JsZERpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB3b3JsZERpcmVjdGlvbjtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybURpdmluZVN0b3JtKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggcmFnZSAobWluaW11bSAyMCByYWdlIHJlcXVpcmVkKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSAmJiAhZ2FtZVVJLmNhbkNhc3REaXZpbmVTdG9ybSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygn4pqhIE5vdCBlbm91Z2ggcmFnZSB0byBjYXN0IERpdmluZSBTdG9ybSAocmVxdWlyZXMgbWluaW11bSAyMCByYWdlKScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUgPCB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgRGl2aW5lIFN0b3JtIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgY3VycmVudCByYWdlIGFtb3VudCBhbmQgY29uc3VtZSBBTEwgcmFnZVxuICAgIGNvbnN0IGN1cnJlbnRSYWdlID0gZ2FtZVVJID8gZ2FtZVVJLmdldEN1cnJlbnRSYWdlKCkgOiA0MDsgLy8gRmFsbGJhY2sgdG8gMjAgaWYgZ2FtZVVJIG5vdCBhdmFpbGFibGVcbiAgICBpZiAoZ2FtZVVJKSB7XG4gICAgICBnYW1lVUkuY29uc3VtZUFsbFJhZ2UoKTsgLy8gQ29uc3VtZSBhbGwgcmFnZSBpbnN0ZWFkIG9mIGp1c3QgMjBcbiAgICAgIGNvbnNvbGUubG9nKGDimqEgQ29uc3VtZWQgJHtjdXJyZW50UmFnZX0gcmFnZSBmb3IgRGl2aW5lIFN0b3JtYCk7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGV4dGVuZGVkIGR1cmF0aW9uOiBiYXNlIDQgc2Vjb25kcyArIDEgc2Vjb25kIHBlciAxMCByYWdlIGNvbnN1bWVkXG4gICAgY29uc3QgYmFzZVN0b3JtRHVyYXRpb24gPSAxMDAwOyAvLyA0IHNlY29uZHMgYmFzZVxuICAgIGNvbnN0IGJvbnVzRHVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRSYWdlIC8gMTApICogNTAwOyAvLyAxIHNlY29uZCBwZXIgMTAgcmFnZVxuICAgIGNvbnN0IHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbiA9IGJhc2VTdG9ybUR1cmF0aW9uICsgYm9udXNEdXJhdGlvbjtcblxuICAgIGNvbnNvbGUubG9nKGDimqEgRGl2aW5lIFN0b3JtIGFjdGl2YXRlZCEgRHVyYXRpb246ICR7dG90YWxEaXZpbmVTdG9ybUR1cmF0aW9uIC8gMTAwMH1zIChiYXNlOiA0cyArIGJvbnVzOiAke2JvbnVzRHVyYXRpb24gLyAxMDAwfXMgZnJvbSAke2N1cnJlbnRSYWdlfSByYWdlKWApO1xuICAgIHRoaXMuaXNEaXZpbmVTdG9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0RGl2aW5lU3Rvcm1UaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBEaXZpbmUgU3Rvcm0gY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICAgIHRoaXMub25EaXZpbmVTdG9ybUNhbGxiYWNrKHBsYXllclRyYW5zZm9ybS5wb3NpdGlvbi5jbG9uZSgpLCBkaXJlY3Rpb24sIHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gRGl2aW5lIFN0b3JtIGxhc3RzIGZvciBjYWxjdWxhdGVkIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmlzRGl2aW5lU3Rvcm1pbmcgPSBmYWxzZTtcbiAgICAgIGNvbnNvbGUubG9nKCfimqEgRGl2aW5lIFN0b3JtIGNvbXBsZXRlZCcpO1xuICAgIH0sIHRvdGFsRGl2aW5lU3Rvcm1EdXJhdGlvbik7XG4gIH1cblxuICBwcml2YXRlIHBlcmZvcm1DaGFyZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSA8IHRoaXMuY2hhcmdlQ29vbGRvd24pIHtcbiAgICAgIGNvbnNvbGUubG9nKGDij7AgQ2hhcmdlIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmNoYXJnZUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ2hhcmdlIGFjdGl2YXRlZCEnKTtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0Q2hhcmdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFJlc2V0IGNvbGxpc2lvbiB0cmFja2luZyBmb3IgbmV3IGNoYXJnZVxuICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBDaGFyZ2UgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25DaGFyZ2VDYWxsYmFjaykge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLm9uQ2hhcmdlQ2FsbGJhY2socGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLmNsb25lKCksIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIC8vIEdhaW4gcmFnZSBmb3IgdXNpbmcgY2hhcmdlIGFiaWxpdHkgKCsyMCByYWdlKVxuICAgIGNvbnN0IGdhbWVVSSA9ICh3aW5kb3cgYXMgYW55KS5nYW1lVUk7XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmdhaW5SYWdlKDIwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gR2FpbmVkIDIwIHJhZ2UgZnJvbSB1c2luZyBDaGFyZ2UgYWJpbGl0eScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTdGFydCB0aGUgY2hhcmdlIG1vdmVtZW50IHVzaW5nIHRoZSBzZXBhcmF0ZSBjaGFyZ2Ugc3lzdGVtXG4gICAgaWYgKHRoaXMucGxheWVyRW50aXR5KSB7XG4gICAgICBjb25zdCBwbGF5ZXJNb3ZlbWVudCA9IHRoaXMucGxheWVyRW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG4gICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgLy8gR2V0IGNoYXJnZSBkaXJlY3Rpb24gZnJvbSBjYW1lcmFcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSAwOyAvLyBLZWVwIG1vdmVtZW50IGhvcml6b250YWxcbiAgICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgY2hhcmdlIHdpdGggMTAuNSBkaXN0YW5jZSAoc2VwYXJhdGUgZnJvbSBkYXNoIHN5c3RlbSlcbiAgICAgICAgY29uc3QgY2hhcmdlU3RhcnRlZCA9IHBsYXllck1vdmVtZW50LnN0YXJ0Q2hhcmdlKGRpcmVjdGlvbiwgcGxheWVyVHJhbnNmb3JtLnBvc2l0aW9uLCBjdXJyZW50VGltZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhcmdlU3RhcnRlZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfimpTvuI8gQ2hhcmdlIG1vdmVtZW50IHN0YXJ0ZWQgd2l0aCAxMC41IGRpc3RhbmNlJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2NoZWR1bGUgY2hhcmdlIGRhbWFnZSBkZXRlY3Rpb24gZHVyaW5nIG1vdmVtZW50XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm0sIGRpcmVjdGlvbiwgY3VycmVudFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqU77iPIENoYXJnZSBmYWlsZWQgdG8gc3RhcnQgKGFscmVhZHkgY2hhcmdpbmcgb3IgZGFzaGluZyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNrIGNoYXJnZSBoaXQgZW50aXRpZXMgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzIGFuZCBlbmFibGUgY29sbGlzaW9uIHN0b3BwaW5nXG4gIHByaXZhdGUgY2hhcmdlSGl0RW50aXRpZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBjaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSBmYWxzZTtcblxuICAvLyBTY2hlZHVsZSBkYW1hZ2UgZGV0ZWN0aW9uIGR1cmluZyBjaGFyZ2UgbW92ZW1lbnRcbiAgcHJpdmF0ZSBzY2hlZHVsZUNoYXJnZURhbWFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSwgY2hhcmdlRGlyZWN0aW9uOiBWZWN0b3IzLCBzdGFydFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMC43NTsgLy8gQ2hhcmdlIGxhc3RzIGFib3V0IDEuNSBzZWNvbmRzXG4gICAgY29uc3QgZGFtYWdlQ2hlY2tJbnRlcnZhbCA9IDUwOyAvLyBDaGVjayBmb3IgZGFtYWdlIGV2ZXJ5IDUwbXMgZm9yIGJldHRlciBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgY29uc3QgY2hhcmdlRGFtYWdlID0gNDA7IC8vIEhpZ2ggZGFtYWdlIGZvciBjaGFyZ2UgYWJpbGl0eVxuICAgIGNvbnN0IGNoYXJnZVJhZGl1cyA9IDIuNTsgLy8gRGFtYWdlIHJhZGl1cyBhcm91bmQgcGxheWVyIGR1cmluZyBjaGFyZ2VcbiAgICBcbiAgICAvLyBSZXNldCBjaGFyZ2UgaGl0IHRyYWNraW5nXG4gICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5jbGVhcigpO1xuICAgIHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uID0gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgZGFtYWdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgXG4gICAgICAvLyBTdG9wIGlmIGNoYXJnZSBpcyBjb21wbGV0ZSwgY2FuY2VsbGVkLCBvciBzdG9wcGVkIGJ5IGNvbGxpc2lvblxuICAgICAgaWYgKCF0aGlzLmlzU3dvcmRDaGFyZ2luZyB8fCBjdXJyZW50VGltZSAtIHN0YXJ0VGltZSA+IGNoYXJnZUR1cmF0aW9uIHx8IHRoaXMuY2hhcmdlU3RvcHBlZEJ5Q29sbGlzaW9uKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZGFtYWdlSW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIHRvIGNoZWNrIGZvciBkYW1hZ2VcbiAgICAgIGNvbnN0IGFsbEVudGl0aWVzID0gdGhpcy53b3JsZC5nZXRBbGxFbnRpdGllcygpO1xuICAgICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICBcbiAgICAgIGxldCBoaXRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gRGVidWc6IExvZyBhbGwgZW50aXRpZXMgaW4gdGhlIHdvcmxkIGR1cmluZyBjaGFyZ2VcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIENoYXJnZSBjb2xsaXNpb24gY2hlY2sgLSBUb3RhbCBlbnRpdGllcyBpbiB3b3JsZDogJHthbGxFbnRpdGllcy5sZW5ndGh9YCk7XG4gICAgICBcbiAgICAgIC8vIEVOSEFOQ0VEOiBBbHNvIGNoZWNrIGFnYWluc3Qgc2VydmVyIHBsYXllciBwb3NpdGlvbnMgZGlyZWN0bHkgYXMgYSBmYWxsYmFja1xuICAgICAgLy8gVGhpcyBlbnN1cmVzIHdlIGRvbid0IG1pc3MgY29sbGlzaW9ucyBkdWUgdG8gZW50aXR5IHN5bmMgaXNzdWVzXG4gICAgICBjb25zdCBzZXJ2ZXJQbGF5ZXJzID0gKHdpbmRvdyBhcyBhbnkpLnB2cFBsYXllcnMgfHwgbmV3IE1hcCgpO1xuICAgICAgY29uc3QgbG9jYWxTb2NrZXRJZCA9ICh3aW5kb3cgYXMgYW55KS5sb2NhbFNvY2tldElkO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+UjSBBbHNvIGNoZWNraW5nICR7c2VydmVyUGxheWVycy5zaXplfSBzZXJ2ZXIgcGxheWVycyBkaXJlY3RseSBmb3IgY29sbGlzaW9uYCk7XG4gICAgICBcbiAgICAgIHNlcnZlclBsYXllcnMuZm9yRWFjaCgoc2VydmVyUGxheWVyOiBhbnksIHBsYXllcklkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgLy8gU2tpcCBzZWxmXG4gICAgICAgIGlmIChwbGF5ZXJJZCA9PT0gbG9jYWxTb2NrZXRJZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBhbHJlYWR5IGhpdCBwbGF5ZXJzICh1c2UgaGFzaCBvZiBwbGF5ZXIgSUQgZm9yIHRyYWNraW5nKVxuICAgICAgICBjb25zdCBwbGF5ZXJJZEhhc2ggPSBwbGF5ZXJJZC5sZW5ndGggKiAxMDAwICsgcGxheWVySWQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuaGFzKHBsYXllcklkSGFzaCkpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNlcnZlclBsYXllclBvcyA9IG5ldyBWZWN0b3IzKHNlcnZlclBsYXllci5wb3NpdGlvbi54LCBzZXJ2ZXJQbGF5ZXIucG9zaXRpb24ueSwgc2VydmVyUGxheWVyLnBvc2l0aW9uLnopO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBsYXllclBvc2l0aW9uLmRpc3RhbmNlVG8oc2VydmVyUGxheWVyUG9zKTtcbiAgICAgICAgY29uc3Qgc3RvcERpc3RhbmNlID0gMC45ICsgMS4wOyAvLyBQbGF5ZXIgY29sbGlzaW9uIHJhZGl1cyArIGJ1ZmZlclxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gRGlyZWN0IHNlcnZlciBwbGF5ZXIgY2hlY2sgLSAke3BsYXllcklkfTogZGlzdGFuY2U9JHtkaXN0YW5jZS50b0ZpeGVkKDIpfSwgc3RvcERpc3RhbmNlPSR7c3RvcERpc3RhbmNlLnRvRml4ZWQoMil9YCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gc3RvcERpc3RhbmNlICYmIHNlcnZlclBsYXllci5oZWFsdGggPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKalO+4jyBEaXJlY3Qgc2VydmVyIGNvbGxpc2lvbiBkZXRlY3RlZCB3aXRoIHBsYXllciAke3BsYXllcklkfSFgKTtcbiAgICAgICAgICB0aGlzLmNoYXJnZUhpdEVudGl0aWVzLmFkZChwbGF5ZXJJZEhhc2gpO1xuICAgICAgICAgIGhpdFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXBwbHkgZGFtYWdlIHRocm91Z2ggUFZQIHN5c3RlbSBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCdzd29yZF9jaGFyZ2VfaGl0JywgcGxheWVyUG9zaXRpb24uY2xvbmUoKSwgY2hhcmdlRGlyZWN0aW9uLmNsb25lKCksIHtcbiAgICAgICAgICAgICAgZGFtYWdlOiBjaGFyZ2VEYW1hZ2UsXG4gICAgICAgICAgICAgIHRhcmdldElkOiBwbGF5ZXJJZCxcbiAgICAgICAgICAgICAgaGl0UG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBzZXJ2ZXJQbGF5ZXJQb3MueCxcbiAgICAgICAgICAgICAgICB5OiBzZXJ2ZXJQbGF5ZXJQb3MueSxcbiAgICAgICAgICAgICAgICB6OiBzZXJ2ZXJQbGF5ZXJQb3MuelxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhbGxFbnRpdGllcy5mb3JFYWNoKGVudGl0eSA9PiB7XG4gICAgICAgIC8vIFNraXAgc2VsZlxuICAgICAgICBpZiAoZW50aXR5LmlkID09PSB0aGlzLnBsYXllckVudGl0eT8uaWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIFNraXAgYWxyZWFkeSBoaXQgZW50aXRpZXNcbiAgICAgICAgaWYgKHRoaXMuY2hhcmdlSGl0RW50aXRpZXMuaGFzKGVudGl0eS5pZCkpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBoYXMgdHJhbnNmb3JtIGFuZCBoZWFsdGggKGNvdWxkIGJlIGVuZW15IG9yIHBsYXllcilcbiAgICAgICAgY29uc3QgZW50aXR5VHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgICBjb25zdCBlbnRpdHlIZWFsdGggPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEhlYWx0aCk7XG4gICAgICAgIGNvbnN0IGVudGl0eUNvbGxpZGVyID0gZW50aXR5LmdldENvbXBvbmVudChDb2xsaWRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBEZWJ1ZzogTG9nIGVudGl0eSBkZXRhaWxzXG4gICAgICAgIGNvbnN0IGVuZW15ID0gZW50aXR5LmdldENvbXBvbmVudChFbmVteSk7XG4gICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7ZW50aXR5LmlkfSlgO1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBDaGVja2luZyBlbnRpdHkgJHtlbnRpdHkuaWR9ICgke2VudGl0eVR5cGV9KTogdHJhbnNmb3JtPSR7ISFlbnRpdHlUcmFuc2Zvcm19LCBoZWFsdGg9JHshIWVudGl0eUhlYWx0aH0sIGNvbGxpZGVyPSR7ISFlbnRpdHlDb2xsaWRlcn0sIGlzRGVhZD0ke2VudGl0eUhlYWx0aD8uaXNEZWFkfWApO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFlbnRpdHlUcmFuc2Zvcm0gfHwgIWVudGl0eUhlYWx0aCB8fCBlbnRpdHlIZWFsdGguaXNEZWFkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zdCBlbnRpdHlQb3NpdGlvbiA9IGVudGl0eVRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwbGF5ZXJQb3NpdGlvbi5kaXN0YW5jZVRvKGVudGl0eVBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGVudGl0eSBpcyB3aXRoaW4gY2hhcmdlIGRhbWFnZSByYWRpdXNcbiAgICAgICAgLy8gSW4gUFZQLCB3ZSB3YW50IHRvIHN0b3AganVzdCBiZWZvcmUgaGl0dGluZyB0aGUgZW5lbXksIG5vdCBvdmVybGFwIHdpdGggdGhlbVxuICAgICAgICBjb25zdCBzdG9wRGlzdGFuY2UgPSBlbnRpdHlDb2xsaWRlciA/IGVudGl0eUNvbGxpZGVyLnJhZGl1cyArIDEuMCA6IGNoYXJnZVJhZGl1czsgLy8gU3RvcCAxIHVuaXQgYXdheSBmcm9tIGVuZW15IGVkZ2VcbiAgICAgICAgXG4gICAgICAgIC8vIERlYnVnOiBMb2cgcG9zaXRpb24gYW5kIGRpc3RhbmNlIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEVudGl0eSAke2VudGl0eS5pZH0gKCR7ZW50aXR5VHlwZX0pOiBwbGF5ZXJQb3M9WyR7cGxheWVyUG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtwbGF5ZXJQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke3BsYXllclBvc2l0aW9uLnoudG9GaXhlZCgyKX1dLCBlbnRpdHlQb3M9WyR7ZW50aXR5UG9zaXRpb24ueC50b0ZpeGVkKDIpfSwgJHtlbnRpdHlQb3NpdGlvbi55LnRvRml4ZWQoMil9LCAke2VudGl0eVBvc2l0aW9uLnoudG9GaXhlZCgyKX1dLCBkaXN0YW5jZT0ke2Rpc3RhbmNlLnRvRml4ZWQoMil9LCBzdG9wRGlzdGFuY2U9JHtzdG9wRGlzdGFuY2UudG9GaXhlZCgyKX0sIGNvbGxpZGVyUmFkaXVzPSR7ZW50aXR5Q29sbGlkZXI/LnJhZGl1cyB8fCAnbm9uZSd9YCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UgPD0gc3RvcERpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gTWFyayBhcyBoaXQgdG8gcHJldmVudCBtdWx0aXBsZSBoaXRzXG4gICAgICAgICAgdGhpcy5jaGFyZ2VIaXRFbnRpdGllcy5hZGQoZW50aXR5LmlkKTtcbiAgICAgICAgICBoaXRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IGRhbWFnZSB0aHJvdWdoIGNvbWJhdCBzeXN0ZW1cbiAgICAgICAgICBjb25zdCBjb21iYXRTeXN0ZW0gPSB0aGlzLndvcmxkLmdldFN5c3RlbShDb21iYXRTeXN0ZW0pO1xuICAgICAgICAgIGlmIChjb21iYXRTeXN0ZW0gJiYgdGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZShlbnRpdHksIGNoYXJnZURhbWFnZSwgdGhpcy5wbGF5ZXJFbnRpdHksICdjaGFyZ2UnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgZW5lbXkgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBlbmVteSA/IGBFbmVteSgke2VuZW15LmdldERpc3BsYXlOYW1lKCl9KWAgOiBgUGxheWVyKCR7ZW50aXR5LmlkfSlgO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKalO+4jyBDaGFyZ2UgaGl0ICR7ZW50aXR5VHlwZX0gZm9yICR7Y2hhcmdlRGFtYWdlfSBkYW1hZ2UgYXQgZGlzdGFuY2UgJHtkaXN0YW5jZS50b0ZpeGVkKDIpfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBCcm9hZGNhc3QgY2hhcmdlIGF0dGFjayBmb3IgUFZQIChpbmNsdWRlcyBkYW1hZ2UgYW5kIGFuaW1hdGlvbilcbiAgICAgICAgICAgIGlmICh0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgICB0aGlzLm9uUHJvamVjdGlsZUNyZWF0ZWRDYWxsYmFjaygnc3dvcmRfY2hhcmdlX2hpdCcsIHBsYXllclBvc2l0aW9uLmNsb25lKCksIGNoYXJnZURpcmVjdGlvbi5jbG9uZSgpLCB7XG4gICAgICAgICAgICAgICAgZGFtYWdlOiBjaGFyZ2VEYW1hZ2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IGVudGl0eS5pZCxcbiAgICAgICAgICAgICAgICBoaXRQb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogZW50aXR5UG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgIHk6IGVudGl0eVBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICB6OiBlbnRpdHlQb3NpdGlvbi56XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJbiBQVlAgbW9kZSwgc3RvcCBjaGFyZ2Ugd2hlbiBoaXR0aW5nIHNvbWV0aGluZ1xuICAgICAgaWYgKGhpdFNvbWV0aGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pqU77iPIENoYXJnZSBzdG9wcGVkIGJ5IGNvbGxpc2lvbiAtIGVuZGluZyBjaGFyZ2UgbW92ZW1lbnRgKTtcbiAgICAgICAgdGhpcy5jaGFyZ2VTdG9wcGVkQnlDb2xsaXNpb24gPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcCB0aGUgY2hhcmdlIG1vdmVtZW50IGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgICAgIGNvbnN0IHBsYXllck1vdmVtZW50ID0gdGhpcy5wbGF5ZXJFbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcbiAgICAgICAgICBpZiAocGxheWVyTW92ZW1lbnQpIHtcbiAgICAgICAgICAgIHBsYXllck1vdmVtZW50LmNhbmNlbENoYXJnZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGRhbWFnZSBpbnRlcnZhbCBpbW1lZGlhdGVseSB0byBwcmV2ZW50IGZ1cnRoZXIgaGl0c1xuICAgICAgICBjbGVhckludGVydmFsKGRhbWFnZUludGVydmFsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyaWdnZXIgY2hhcmdlIGNvbXBsZXRpb25cbiAgICAgICAgdGhpcy5vbkNoYXJnZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgZGFtYWdlQ2hlY2tJbnRlcnZhbCk7XG4gIH1cblxuICAvLyBDYWxsZWQgYnkgc3dvcmQgY29tcG9uZW50IHdoZW4gQ2hhcmdlIGNvbXBsZXRlc1xuICBwdWJsaWMgb25DaGFyZ2VDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn4pqU77iPIENoYXJnZSBjb21wbGV0ZWQnKTtcbiAgICB0aGlzLmlzU3dvcmRDaGFyZ2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtRGVmbGVjdChwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBpZiAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REZWZsZWN0VGltZSA8IHRoaXMuZGVmbGVjdENvb2xkb3duKSB7XG4gICAgICBjb25zb2xlLmxvZyhg4o+wIERlZmxlY3Qgb24gY29vbGRvd24gZm9yICR7KHRoaXMuZGVmbGVjdENvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RGVmbGVjdFRpbWUpKS50b0ZpeGVkKDEpfXNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygn8J+boe+4jyBEZWZsZWN0IGFjdGl2YXRlZCEnKTtcbiAgICB0aGlzLmlzRGVmbGVjdGluZyA9IHRydWU7XG4gICAgdGhpcy5sYXN0RGVmbGVjdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIERlZmxlY3QgY2FsbGJhY2sgZm9yIG11bHRpcGxheWVyXG4gICAgaWYgKHRoaXMub25EZWZsZWN0Q2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgdGhpcy5vbkRlZmxlY3RDYWxsYmFjayhwbGF5ZXJUcmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IHVwIGRlZmxlY3QgYmFycmllciB0aGF0IGJsb2NrcyBkYW1hZ2UgYW5kIHJlZmxlY3RzIHByb2plY3RpbGVzXG4gICAgdGhpcy5zZXR1cERlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybSk7XG4gICAgXG4gICAgLy8gQXV0by1jb21wbGV0ZSBkZWZsZWN0IGFmdGVyIGR1cmF0aW9uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm9uRGVmbGVjdENvbXBsZXRlKCk7XG4gICAgfSwgdGhpcy5kZWZsZWN0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuXG4gIHByaXZhdGUgcGVyZm9ybVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUgPCB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYOKPsCBWaXBlciBTdGluZyBvbiBjb29sZG93biBmb3IgJHsodGhpcy52aXBlclN0aW5nRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RWaXBlclN0aW5nVGltZSkpLnRvRml4ZWQoMSl9c2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHBsYXllciBoYXMgZW5vdWdoIGVuZXJneSAoNjAgZW5lcmd5IGNvc3QpXG4gICAgY29uc3QgZ2FtZVVJID0gKHdpbmRvdyBhcyBhbnkpLmdhbWVVSTtcbiAgICBpZiAoZ2FtZVVJICYmICFnYW1lVUkuY2FuQ2FzdFZpcGVyU3RpbmcoKSkge1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gTm90IGVub3VnaCBlbmVyZ3kgdG8gY2FzdCBWaXBlciBTdGluZyAocmVxdWlyZXMgNjAgZW5lcmd5KScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnN1bWUgZW5lcmd5XG4gICAgaWYgKGdhbWVVSSkge1xuICAgICAgZ2FtZVVJLmNvbnN1bWVFbmVyZ3koNjApO1xuICAgICAgY29uc29sZS5sb2coJ/CfkI0gQ29uc3VtZWQgNjAgZW5lcmd5IGZvciBWaXBlciBTdGluZycpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn5CNIFZpcGVyIFN0aW5nIGFjdGl2YXRlZCAtIHN0YXJ0aW5nIGNoYXJnZSEnKTtcbiAgICB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5sYXN0VmlwZXJTdGluZ1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICBcbiAgICAvLyBTdGFydCBjaGFyZ2luZyBhbmltYXRpb25cbiAgICBjb25zdCBjaGFyZ2VTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNoYXJnZUR1cmF0aW9uID0gMTAwMDsgLy8gMSBzZWNvbmQgY2hhcmdlIHRpbWVcbiAgICBcbiAgICBjb25zdCBjaGFyZ2VJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gY2hhcmdlU3RhcnRUaW1lO1xuICAgICAgdGhpcy52aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MgPSBNYXRoLm1pbihlbGFwc2VkIC8gY2hhcmdlRHVyYXRpb24sIDEuMCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA+PSAxLjApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGFyZ2VJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuZmlyZVZpcGVyU3RpbmcocGxheWVyVHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5pc1ZpcGVyU3RpbmdDaGFyZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpcGVyU3RpbmdDaGFyZ2VQcm9ncmVzcyA9IDA7XG4gICAgICB9XG4gICAgfSwgMTYpOyAvLyB+NjBmcHMgdXBkYXRlc1xuICB9XG5cbiAgcHJpdmF0ZSBmaXJlVmlwZXJTdGluZyhwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn5CNIEZpcmluZyBWaXBlciBTdGluZyBwcm9qZWN0aWxlIScpO1xuICAgIFxuICAgIC8vIEdldCBwbGF5ZXIgcG9zaXRpb24gYW5kIGRpcmVjdGlvblxuICAgIGNvbnN0IHBsYXllclBvc2l0aW9uID0gcGxheWVyVHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcbiAgICBwbGF5ZXJQb3NpdGlvbi55ICs9IDAuNzU7IC8vIFNob290IGZyb20gY2hlc3QgbGV2ZWxcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgYW5nbGUgY29tcGVuc2F0aW9uIGFzIG90aGVyIHByb2plY3RpbGVzXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlcyBkb3dud2FyZCBjb21wZW5zYXRpb25cbiAgICBjb25zdCBjYW1lcmFSaWdodCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY2FtZXJhUmlnaHQuY3Jvc3NWZWN0b3JzKGRpcmVjdGlvbiwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpLm5vcm1hbGl6ZSgpO1xuICAgIFxuICAgIC8vIEFwcGx5IHJvdGF0aW9uIGFyb3VuZCB0aGUgcmlnaHQgYXhpcyB0byB0aWx0IHRoZSBkaXJlY3Rpb24gZG93bndhcmRcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uQXhpcyhjYW1lcmFSaWdodCwgY29tcGVuc2F0aW9uQW5nbGUpO1xuICAgIGRpcmVjdGlvbi5hcHBseU1hdHJpeDQocm90YXRpb25NYXRyaXgpO1xuICAgIGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBcbiAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICBjb25zdCBzcGF3blBvc2l0aW9uID0gcGxheWVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICBzcGF3blBvc2l0aW9uLmFkZChkaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcigxKSk7IC8vIDEgdW5pdCBmb3J3YXJkXG4gICAgXG4gICAgLy8gTm90ZTogVmlwZXIgU3RpbmcgZGFtYWdlIGlzIGhhbmRsZWQgYnkgVmlwZXJTdGluZ01hbmFnZXIsIG5vdCBFQ1MgcHJvamVjdGlsZXNcbiAgICAvLyBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZSBwcm9qZWN0aWxlcyBhbmQgZGFtYWdlXG4gICAgXG4gICAgLy8gVHJpZ2dlciBWaXBlciBTdGluZyBjYWxsYmFjayBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICBpZiAodGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjaykge1xuICAgICAgdGhpcy5vblZpcGVyU3RpbmdDYWxsYmFjayhwbGF5ZXJQb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJpZ2dlciB0aGUgZ2xvYmFsIFZpcGVyIFN0aW5nIG1hbmFnZXIgZm9yIHZpc3VhbCBlZmZlY3RzXG4gICAgY29uc3Qgc3VjY2VzcyA9IHRyaWdnZXJHbG9iYWxWaXBlclN0aW5nKCk7XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5CNIFZpcGVyIFN0aW5nIHZpc3VhbCBlZmZlY3RzIHN1Y2Nlc3NmdWxseSB0cmlnZ2VyZWQhJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEJyb2FkY2FzdCBwcm9qZWN0aWxlIGNyZWF0aW9uIHRvIG90aGVyIHBsYXllcnNcbiAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrKCd2aXBlcl9zdGluZ19wcm9qZWN0aWxlJywgc3Bhd25Qb3NpdGlvbiwgZGlyZWN0aW9uLCB7XG4gICAgICAgIHNwZWVkOiAxNixcbiAgICAgICAgZGFtYWdlOiA2MSxcbiAgICAgICAgbGlmZXRpbWU6IDUsXG4gICAgICAgIGlzUmV0dXJuaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwZXJmb3JtQmFycmFnZShwbGF5ZXJUcmFuc2Zvcm06IFRyYW5zZm9ybSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn4+5IHBlcmZvcm1CYXJyYWdlIGNhbGxlZCEnKTtcbiAgICBcbiAgICAvLyBDaGVjayBjb29sZG93blxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgaWYgKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0QmFycmFnZVRpbWUgPCB0aGlzLmJhcnJhZ2VGaXJlUmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYOKPsCBCYXJyYWdlIG9uIGNvb2xkb3duIGZvciAkeyh0aGlzLmJhcnJhZ2VGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdEJhcnJhZ2VUaW1lKSkudG9GaXhlZCgxKX1zYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgcGxheWVyIGhhcyBlbm91Z2ggZW5lcmd5ICg0MCBlbmVyZ3kgY29zdClcbiAgICBjb25zdCBnYW1lVUkgPSAod2luZG93IGFzIGFueSkuZ2FtZVVJO1xuICAgIGlmIChnYW1lVUkgJiYgIWdhbWVVSS5jYW5DYXN0QmFycmFnZSgpKSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+PuSBOb3QgZW5vdWdoIGVuZXJneSB0byBjYXN0IEJhcnJhZ2UgKHJlcXVpcmVzIDQwIGVuZXJneSknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lIGVuZXJneVxuICAgIGlmIChnYW1lVUkpIHtcbiAgICAgIGdhbWVVSS5jb25zdW1lRW5lcmd5KDQwKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn4+5IENvbnN1bWVkIDQwIGVuZXJneSBmb3IgQmFycmFnZScpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCfwn4+5IEJhcnJhZ2UgYWN0aXZhdGVkIC0gc3RhcnRpbmcgY2hhcmdlIScpO1xuICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSB0cnVlO1xuICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gMDtcbiAgICB0aGlzLmxhc3RCYXJyYWdlVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNoYXJnaW5nIGFuaW1hdGlvblxuICAgIGNvbnN0IGNoYXJnZVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgY2hhcmdlRHVyYXRpb24gPSA1MDA7IC8vIDEgc2Vjb25kIGNoYXJnZSB0aW1lXG4gICAgXG4gICAgY29uc3QgY2hhcmdlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGNoYXJnZVN0YXJ0VGltZTtcbiAgICAgIHRoaXMuYmFycmFnZUNoYXJnZVByb2dyZXNzID0gTWF0aC5taW4oZWxhcHNlZCAvIGNoYXJnZUR1cmF0aW9uLCAxLjApO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPj0gMS4wKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY2hhcmdlSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmZpcmVCYXJyYWdlKHBsYXllclRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuaXNCYXJyYWdlQ2hhcmdpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuICAgIH0sIDE2KTsgLy8gfjYwZnBzIHVwZGF0ZXNcbiAgfVxuXG4gIHByaXZhdGUgZmlyZUJhcnJhZ2UocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+PuSBGaXJpbmcgQmFycmFnZSBwcm9qZWN0aWxlcyEnKTtcbiAgICBcbiAgICAvLyBHZXQgcGxheWVyIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb25cbiAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgcGxheWVyUG9zaXRpb24ueSArPSAxOyAvLyBTaG9vdCBmcm9tIGNoZXN0IGxldmVsXG4gICAgY29uc3QgZGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIC8vIEFwcGx5IHNhbWUgZG93bndhcmQgY29tcGVuc2F0aW9uIGFzIHByb2plY3RpbGUgc3lzdGVtXG4gICAgY29uc3QgY29tcGVuc2F0aW9uQW5nbGUgPSBNYXRoLlBJIC8gNjsgLy8gMzAgZGVncmVlc1xuICAgIGNvbnN0IGNhbWVyYVJpZ2h0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjYW1lcmFSaWdodC5jcm9zc1ZlY3RvcnMoZGlyZWN0aW9uLCBuZXcgVmVjdG9yMygwLCAxLCAwKSkubm9ybWFsaXplKCk7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkF4aXMoY2FtZXJhUmlnaHQsIGNvbXBlbnNhdGlvbkFuZ2xlKTtcbiAgICBkaXJlY3Rpb24uYXBwbHlNYXRyaXg0KHJvdGF0aW9uTWF0cml4KTtcbiAgICBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIDUgYXJyb3dzOiBjZW50ZXIgKDDCsCksIGxlZnQgKDE1wrAsIDMwwrApLCByaWdodCAoLTE1wrAsIC0zMMKwKSB1c2luZyBwcm9wZXIgRUNTIHByb2plY3RpbGVzXG4gICAgY29uc3QgYW5nbGVzID0gWzAsIE1hdGguUEkgLyAxMiwgLU1hdGguUEkgLyAxMiwgTWF0aC5QSSAvIDYsIC1NYXRoLlBJIC8gNl07IC8vIDDCsCwgMTXCsCwgLTE1wrAsIDMwwrAsIC0zMMKwXG4gICAgXG4gICAgYW5nbGVzLmZvckVhY2goYW5nbGUgPT4ge1xuICAgICAgLy8gUm90YXRlIHRoZSBiYXNlIGRpcmVjdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCkubWFrZVJvdGF0aW9uWShhbmdsZSk7XG4gICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLmFwcGx5TWF0cml4NChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICBwcm9qZWN0aWxlRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgXG4gICAgICAvLyBPZmZzZXQgc3Bhd24gcG9zaXRpb24gc2xpZ2h0bHkgZm9yd2FyZCB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBwbGF5ZXJcbiAgICAgIGNvbnN0IHNwYXduUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgc3Bhd25Qb3NpdGlvbi5hZGQocHJvamVjdGlsZURpcmVjdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEpKTsgLy8gMSB1bml0IGZvcndhcmRcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHByb3BlciBFQ1MgcHJvamVjdGlsZSBlbnRpdHlcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiAyMiwgLy8gU2xpZ2h0bHkgZmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3MgKDIwKVxuICAgICAgICBkYW1hZ2U6IDMwLCAvLyBIaWdoIGRhbWFnZSBmb3IgYmFycmFnZSBhcnJvd3NcbiAgICAgICAgbGlmZXRpbWU6IDgsXG4gICAgICAgIHBpZXJjaW5nOiBmYWxzZSxcbiAgICAgICAgc3ViY2xhc3M6IHRoaXMuY3VycmVudFN1YmNsYXNzLFxuICAgICAgICBsZXZlbDogMSxcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHNwYXduUG9zaXRpb24sXG4gICAgICAgIHByb2plY3RpbGVEaXJlY3Rpb24sXG4gICAgICAgIHRoaXMucGxheWVyRW50aXR5IS5pZCxcbiAgICAgICAgcHJvamVjdGlsZUNvbmZpZ1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gTWFyayBhcyBiYXJyYWdlIGFycm93IGZvciB2aXN1YWwgaWRlbnRpZmljYXRpb25cbiAgICAgIGNvbnN0IHJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoUmVuZGVyZXIpIGFzIFJlbmRlcmVyO1xuICAgICAgaWYgKHJlbmRlcmVyPy5tZXNoKSB7XG4gICAgICAgIHJlbmRlcmVyLm1lc2gudXNlckRhdGEuaXNCYXJyYWdlQXJyb3cgPSB0cnVlO1xuICAgICAgICByZW5kZXJlci5tZXNoLnVzZXJEYXRhLmlzUmVndWxhckFycm93ID0gZmFsc2U7IC8vIE92ZXJyaWRlIHJlZ3VsYXIgYXJyb3cgbWFya2luZ1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBCcm9hZGNhc3QgcHJvamVjdGlsZSBjcmVhdGlvbiB0byBvdGhlciBwbGF5ZXJzXG4gICAgICBpZiAodGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vblByb2plY3RpbGVDcmVhdGVkQ2FsbGJhY2soJ2JhcnJhZ2VfcHJvamVjdGlsZScsIHNwYXduUG9zaXRpb24sIHByb2plY3RpbGVEaXJlY3Rpb24sIHByb2plY3RpbGVDb25maWcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhg8J+PuSBDcmVhdGVkIEJhcnJhZ2UgYXJyb3cgJHtwcm9qZWN0aWxlRW50aXR5LmlkfSBhdCBhbmdsZSAkeyhhbmdsZSAqIDE4MCAvIE1hdGguUEkpLnRvRml4ZWQoMSl9wrBgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBUcmlnZ2VyIEJhcnJhZ2UgY2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgdmlzdWFsIGVmZmVjdHMgaWYgbmVlZGVkXG4gICAgaWYgKHRoaXMub25CYXJyYWdlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25CYXJyYWdlQ2FsbGJhY2socGxheWVyUG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCfwn4+5IEJhcnJhZ2Ugc3VjY2Vzc2Z1bGx5IGZpcmVkIHdpdGggNSBFQ1MgcHJvamVjdGlsZXMhJyk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwRGVmbGVjdEJhcnJpZXIocGxheWVyVHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiB2b2lkIHtcbiAgICAvLyBBY3RpdmF0ZSB0aGUgZGVmbGVjdCBiYXJyaWVyXG4gICAgY29uc3QgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJUcmFuc2Zvcm0uZ2V0V29ybGRQb3NpdGlvbigpO1xuICAgIGNvbnN0IHBsYXllclJvdGF0aW9uID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgXG4gICAgLy8gVXNlIFNBTUUgcm90YXRpb24gbG9naWMgYXMgRHJhZ29uUmVuZGVyZXIgZm9yIGNvbnNpc3RlbmN5IHdpdGggdmlzdWFsIHNoaWVsZFxuICAgIGlmICh0aGlzLnBsYXllckVudGl0eSkge1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgaWYgKG1vdmVtZW50ICYmIG1vdmVtZW50LmlucHV0U3RyZW5ndGggPiAwLjEpIHtcbiAgICAgICAgLy8gUGxheWVyIGlzIGFjdGl2ZWx5IG1vdmluZyAtIHVzZSBtb3ZlbWVudCBkaXJlY3Rpb24gKHNhbWUgYXMgRHJhZ29uUmVuZGVyZXIpXG4gICAgICAgIGNvbnN0IG1vdmVEaXIgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uO1xuICAgICAgICBpZiAobW92ZURpci5sZW5ndGgoKSA+IDAuMSkge1xuICAgICAgICAgIGNvbnN0IG1vdmVBbmdsZSA9IE1hdGguYXRhbjIobW92ZURpci54LCBtb3ZlRGlyLnopO1xuICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBtb3ZlQW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBtb3ZpbmcgLSB1c2UgY2FtZXJhIGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlciBmYWxsYmFjaylcbiAgICAgICAgY29uc3QgY2FtZXJhRGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5jYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyZWN0aW9uKTtcbiAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IE1hdGguYXRhbjIoY2FtZXJhRGlyZWN0aW9uLngsIGNhbWVyYURpcmVjdGlvbi56KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5hY3RpdmF0ZShwbGF5ZXJQb3NpdGlvbiwgcGxheWVyUm90YXRpb24sIHRoaXMucGxheWVyRW50aXR5IHx8IHVuZGVmaW5lZCk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZURlZmxlY3RCYXJyaWVyKHBsYXllclRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgLy8gVXBkYXRlIGRlZmxlY3QgYmFycmllciBwb3NpdGlvbiBpZiBpdCdzIGFjdGl2ZVxuICAgIGlmICh0aGlzLmRlZmxlY3RCYXJyaWVyLmlzQmFycmllckFjdGl2ZSgpKSB7XG4gICAgICBjb25zdCBwbGF5ZXJQb3NpdGlvbiA9IHBsYXllclRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBwbGF5ZXJSb3RhdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuICAgICAgXG4gICAgICAvLyBVc2UgU0FNRSByb3RhdGlvbiBsb2dpYyBhcyBEcmFnb25SZW5kZXJlciBmb3IgY29uc2lzdGVuY3kgd2l0aCB2aXN1YWwgc2hpZWxkXG4gICAgICBpZiAodGhpcy5wbGF5ZXJFbnRpdHkpIHtcbiAgICAgICAgY29uc3QgbW92ZW1lbnQgPSB0aGlzLnBsYXllckVudGl0eS5nZXRDb21wb25lbnQoTW92ZW1lbnQpO1xuICAgICAgICBpZiAobW92ZW1lbnQgJiYgbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCA+IDAuMSkge1xuICAgICAgICAgIC8vIFBsYXllciBpcyBhY3RpdmVseSBtb3ZpbmcgLSB1c2UgbW92ZW1lbnQgZGlyZWN0aW9uIChzYW1lIGFzIERyYWdvblJlbmRlcmVyKVxuICAgICAgICAgIGNvbnN0IG1vdmVEaXIgPSBtb3ZlbWVudC5tb3ZlRGlyZWN0aW9uO1xuICAgICAgICAgIGlmIChtb3ZlRGlyLmxlbmd0aCgpID4gMC4xKSB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlQW5nbGUgPSBNYXRoLmF0YW4yKG1vdmVEaXIueCwgbW92ZURpci56KTtcbiAgICAgICAgICAgIHBsYXllclJvdGF0aW9uLnkgPSBtb3ZlQW5nbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdCBtb3ZpbmcgLSB1c2UgY2FtZXJhIGRpcmVjdGlvbiAoc2FtZSBhcyBEcmFnb25SZW5kZXJlciBmYWxsYmFjaylcbiAgICAgICAgICBjb25zdCBjYW1lcmFEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICAgIHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGNhbWVyYURpcmVjdGlvbik7XG4gICAgICAgICAgcGxheWVyUm90YXRpb24ueSA9IE1hdGguYXRhbjIoY2FtZXJhRGlyZWN0aW9uLngsIGNhbWVyYURpcmVjdGlvbi56KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgYmFycmllciBwb3NpdGlvbiB0byBmb2xsb3cgcGxheWVyXG4gICAgICB0aGlzLmRlZmxlY3RCYXJyaWVyLnVwZGF0ZVBvc2l0aW9uKHBsYXllclBvc2l0aW9uLCBwbGF5ZXJSb3RhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGJ5IHN3b3JkIGNvbXBvbmVudCB3aGVuIERlZmxlY3QgY29tcGxldGVzXG4gIHB1YmxpYyBvbkRlZmxlY3RDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZygn8J+boe+4jyBEZWZsZWN0IGNvbXBsZXRlZCcpO1xuICAgIHRoaXMuaXNEZWZsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kZWZsZWN0QmFycmllci5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICAvLyBQdWJsaWMgbWV0aG9kcyB0byBnZXQgY29vbGRvd24gaW5mb3JtYXRpb24gZm9yIFVJXG4gIHB1YmxpYyBnZXRXZWFwb25Td2l0Y2hDb29sZG93bigpOiB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXIgfSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFdlYXBvblN3aXRjaFRpbWUpKSxcbiAgICAgIG1heDogdGhpcy53ZWFwb25Td2l0Y2hDb29sZG93blxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0QWJpbGl0eUNvb2xkb3ducygpOiBSZWNvcmQ8c3RyaW5nLCB7IGN1cnJlbnQ6IG51bWJlcjsgbWF4OiBudW1iZXI7IGlzQWN0aXZlOiBib29sZWFuIH0+IHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIFxuICAgIGNvbnN0IGNvb2xkb3duczogUmVjb3JkPHN0cmluZywgeyBjdXJyZW50OiBudW1iZXI7IG1heDogbnVtYmVyOyBpc0FjdGl2ZTogYm9vbGVhbiB9PiA9IHt9O1xuICAgIFxuICAgIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuU1dPUkQpIHtcbiAgICAgIGNvb2xkb3duc1snUSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRlZmxlY3RDb29sZG93biAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdERlZmxlY3RUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy5kZWZsZWN0Q29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGVmbGVjdGluZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNoYXJnZUNvb2xkb3duIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q2hhcmdlVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY2hhcmdlQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzU3dvcmRDaGFyZ2luZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24gLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3REaXZpbmVTdG9ybVRpbWUpKSxcbiAgICAgICAgbWF4OiB0aGlzLmRpdmluZVN0b3JtQ29vbGRvd24sXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzRGl2aW5lU3Rvcm1pbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRXZWFwb24gPT09IFdlYXBvblR5cGUuQk9XKSB7XG4gICAgICBjb29sZG93bnNbJ1EnXSA9IHtcbiAgICAgICAgY3VycmVudDogTWF0aC5tYXgoMCwgdGhpcy5iYXJyYWdlRmlyZVJhdGUgLSAoY3VycmVudFRpbWUgLSB0aGlzLmxhc3RCYXJyYWdlVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuYmFycmFnZUZpcmVSYXRlLFxuICAgICAgICBpc0FjdGl2ZTogdGhpcy5pc0JhcnJhZ2VDaGFyZ2luZ1xuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNvYnJhU2hvdEZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q29icmFTaG90VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY29icmFTaG90RmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLnZpcGVyU3RpbmdGaXJlUmF0ZSAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFZpcGVyU3RpbmdUaW1lKSksXG4gICAgICAgIG1heDogdGhpcy52aXBlclN0aW5nRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzVmlwZXJTdGluZ0NoYXJnaW5nXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50V2VhcG9uID09PSBXZWFwb25UeXBlLlNDWVRIRSkge1xuICAgICAgY29vbGRvd25zWydRJ10gPSB7XG4gICAgICAgIGN1cnJlbnQ6IE1hdGgubWF4KDAsIDEuMCAtIChjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlYW5pbWF0ZVRpbWUpKSxcbiAgICAgICAgbWF4OiAxLjAsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snRSddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmZyb3N0Tm92YUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0RnJvc3ROb3ZhVGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuZnJvc3ROb3ZhRmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvb2xkb3duc1snUiddID0ge1xuICAgICAgICBjdXJyZW50OiBNYXRoLm1heCgwLCB0aGlzLmNyb3NzZW50cm9weUZpcmVSYXRlIC0gKGN1cnJlbnRUaW1lIC0gdGhpcy5sYXN0Q3Jvc3NlbnRyb3B5VGltZSkpLFxuICAgICAgICBtYXg6IHRoaXMuY3Jvc3NlbnRyb3B5RmlyZVJhdGUsXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvb2xkb3ducztcbiAgfVxufSJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiTWF0cml4NCIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwiSGVhbHRoIiwiRW5lbXkiLCJSZW5kZXJlciIsIkNvbGxpZGVyIiwiQ29tYmF0U3lzdGVtIiwiV2VhcG9uU3ViY2xhc3MiLCJXZWFwb25UeXBlIiwiRGVmbGVjdEJhcnJpZXIiLCJ0cmlnZ2VyR2xvYmFsRnJvc3ROb3ZhIiwiYWRkR2xvYmFsRnJvemVuRW5lbXkiLCJ0cmlnZ2VyR2xvYmFsQ29icmFTaG90IiwidHJpZ2dlckdsb2JhbFZpcGVyU3RpbmciLCJDb250cm9sU3lzdGVtIiwic2V0UGxheWVyIiwiZW50aXR5IiwicGxheWVyRW50aXR5IiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJwbGF5ZXJUcmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJwbGF5ZXJNb3ZlbWVudCIsInVwZGF0ZURlYnVmZnMiLCJjb25zb2xlIiwid2FybiIsImhhbmRsZVdlYXBvblN3aXRjaGluZyIsImhhbmRsZURhc2hNb3ZlbWVudCIsImhhbmRsZUNoYXJnZU1vdmVtZW50IiwiaXNEYXNoaW5nIiwiaXNDaGFyZ2luZyIsImlzRnJvemVuIiwiaGFuZGxlTW92ZW1lbnRJbnB1dCIsImhhbmRsZUNvbWJhdElucHV0IiwidXBkYXRlRGVmbGVjdEJhcnJpZXIiLCJtb3ZlbWVudCIsImNoZWNrRm9yRGFzaElucHV0IiwiaW5wdXREaXJlY3Rpb24iLCJoYXNJbnB1dCIsImlucHV0TWFuYWdlciIsImlzS2V5UHJlc3NlZCIsInoiLCJ4IiwibGVuZ3RoIiwibm9ybWFsaXplIiwiY2FtZXJhRGlyZWN0aW9uIiwiY2FtZXJhIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJjYW1lcmFSaWdodCIsImNyb3NzVmVjdG9ycyIsImNhbWVyYUZvcndhcmQiLCJ3b3JsZERpcmVjdGlvbiIsImFkZFNjYWxlZFZlY3RvciIsInNldE1vdmVEaXJlY3Rpb24iLCJqdW1wIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFdlYXBvblN3aXRjaFRpbWUiLCJ3ZWFwb25Td2l0Y2hDb29sZG93biIsImN1cnJlbnRXZWFwb24iLCJTV09SRCIsImN1cnJlbnRTdWJjbGFzcyIsIkRJVklOSVRZIiwiZmlyZVJhdGUiLCJzd29yZEZpcmVSYXRlIiwic3dvcmRDb21ib1N0ZXAiLCJsb2ciLCJCT1ciLCJFTEVNRU5UQUwiLCJTQ1lUSEUiLCJDSEFPUyIsInNjeXRoZUZpcmVSYXRlIiwiU0FCUkVTIiwiRlJPU1QiLCJzYWJyZXNGaXJlUmF0ZSIsImhhbmRsZUJvd0lucHV0IiwiaGFuZGxlU2N5dGhlSW5wdXQiLCJoYW5kbGVTd29yZElucHV0IiwiaGFuZGxlU2FicmVzSW5wdXQiLCJpc1ZpcGVyU3RpbmdDaGFyZ2luZyIsInBlcmZvcm1WaXBlclN0aW5nIiwiaXNCYXJyYWdlQ2hhcmdpbmciLCJwZXJmb3JtQmFycmFnZSIsImlzQ29icmFTaG90Q2hhcmdpbmciLCJwZXJmb3JtQ29icmFTaG90IiwiaXNNb3VzZUJ1dHRvblByZXNzZWQiLCJjaGFyZ2VQcm9ncmVzcyIsIk1hdGgiLCJtaW4iLCJmaW5hbENoYXJnZVByb2dyZXNzIiwiZmlyZVByb2plY3RpbGUiLCJ0cmlnZ2VyQm93UmVsZWFzZUVmZmVjdHMiLCJmaXJlRW50cm9waWNCb2x0UHJvamVjdGlsZSIsImZpcmVDcm9zc2VudHJvcHlCb2x0QWJpbGl0eSIsInBlcmZvcm1SZWFuaW1hdGVBYmlsaXR5IiwicGVyZm9ybUZyb3N0Tm92YUFiaWxpdHkiLCJsYXN0RmlyZVRpbWUiLCJkaXJlY3Rpb24iLCJjb21wZW5zYXRpb25BbmdsZSIsIlBJIiwicm90YXRpb25NYXRyaXgiLCJtYWtlUm90YXRpb25BeGlzIiwiYXBwbHlNYXRyaXg0IiwicGVyZmVjdFNob3RNaW5UaHJlc2hvbGQiLCJwZXJmZWN0U2hvdE1heFRocmVzaG9sZCIsImlzUGVyZmVjdFNob3QiLCJjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlIiwicG9zaXRpb24iLCJjbG9uZSIsImNyZWF0ZVBlcmZlY3RTaG90UHJvamVjdGlsZSIsImFuZ2xlIiwiYXRhbjIiLCJ0b0ZpeGVkIiwiY3JlYXRlUHJvamVjdGlsZSIsInNwaW5TdGF0dXMiLCJjcmVhdGVFbnRyb3BpY0JvbHRQcm9qZWN0aWxlIiwibGFzdENyb3NzZW50cm9weVRpbWUiLCJjcm9zc2VudHJvcHlGaXJlUmF0ZSIsImNyZWF0ZUNyb3NzZW50cm9weUJvbHRQcm9qZWN0aWxlIiwicG90ZW50aWFsVGFyZ2V0cyIsIndvcmxkIiwicXVlcnlFbnRpdGllcyIsInZhbGlkVGFyZ2V0cyIsImZpbHRlciIsInRhcmdldCIsImlkIiwiaXNEZWFkIiwiaGFzVmFsaWRUYXJnZXRzIiwic2hvdWxkQnJvYWRjYXN0Iiwib25Qcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrIiwidW5kZWZpbmVkIiwic3Bhd25Qb3NpdGlvbiIsImFkZCIsIm11bHRpcGx5U2NhbGFyIiwieSIsInByb2plY3RpbGVDb25maWciLCJzcGVlZCIsImRhbWFnZSIsImxpZmV0aW1lIiwic3ViY2xhc3MiLCJsZXZlbCIsImN1cnJlbnRMZXZlbCIsIm9wYWNpdHkiLCJwcm9qZWN0aWxlU3lzdGVtIiwiZ2FtZVVJIiwid2luZG93IiwiY2FuQ2FzdEVudHJvcGljQm9sdCIsImNvbnN1bWVNYW5hIiwiZW50cm9waWNDb25maWciLCJwaWVyY2luZyIsImV4cGxvc2l2ZSIsImV4cGxvc2lvblJhZGl1cyIsImNhbkNhc3RDcm9zc2VudHJvcHlCb2x0IiwiY3Jvc3NlbnRyb3B5Q29uZmlnIiwibGFzdFJlYW5pbWF0ZVRpbWUiLCJjdXJyZW50TWFuYSIsImdldEN1cnJlbnRNYW5hIiwiY2FuQ2FzdFJlYW5pbWF0ZSIsIm1hbmFCZWZvcmUiLCJtYW5hQWZ0ZXIiLCJ0cmlnZ2VyUmVhbmltYXRlRWZmZWN0IiwiaGVhbHRoQ29tcG9uZW50IiwiZGlkSGVhbCIsImhlYWwiLCJjdXJyZW50SGVhbHRoIiwibWF4SGVhbHRoIiwib25SZWFuaW1hdGVDYWxsYmFjayIsInBsYXllclBvc2l0aW9uIiwibGFzdEZyb3N0Tm92YVRpbWUiLCJmcm9zdE5vdmFGaXJlUmF0ZSIsImNhbkNhc3RGcm9zdE5vdmEiLCJnZXRXb3JsZFBvc2l0aW9uIiwib25Gcm9zdE5vdmFDYWxsYmFjayIsImZyZWV6ZUVuZW1pZXNJblJhZGl1cyIsImxhc3RDb2JyYVNob3RUaW1lIiwiY29icmFTaG90RmlyZVJhdGUiLCJjYW5DYXN0Q29icmFTaG90IiwiY29uc3VtZUVuZXJneSIsImNvYnJhU2hvdENoYXJnZVByb2dyZXNzIiwiY2hhcmdlU3RhcnRUaW1lIiwiY2hhcmdlRHVyYXRpb24iLCJjaGFyZ2VJbnRlcnZhbCIsInNldEludGVydmFsIiwiZWxhcHNlZCIsImNsZWFySW50ZXJ2YWwiLCJmaXJlQ29icmFTaG90Iiwib25Db2JyYVNob3RDYWxsYmFjayIsInZlbm9tRHVyYXRpb24iLCJjZW50ZXJQb3NpdGlvbiIsInJhZGl1cyIsImFsbEVudGl0aWVzIiwiZ2V0QWxsRW50aXRpZXMiLCJmcm96ZW5Db3VudCIsImRhbWFnZWRQbGF5ZXJzIiwiZm9yRWFjaCIsImVudGl0eVRyYW5zZm9ybSIsImVudGl0eUhlYWx0aCIsImVudGl0eVBvc2l0aW9uIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZW5lbXkiLCJmcmVlemUiLCJ0b1N0cmluZyIsImNvbWJhdFN5c3RlbSIsImdldFN5c3RlbSIsImZyb3N0Tm92YURhbWFnZSIsInF1ZXVlRGFtYWdlIiwib25EZWJ1ZmZDYWxsYmFjayIsImNoYXJnZWRBcnJvd0NvbmZpZyIsInNldFdlYXBvblN1YmNsYXNzIiwic2V0Qm93UmVsZWFzZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJvbkJvd1JlbGVhc2VDYWxsYmFjayIsInNldERpdmluZVN0b3JtQ2FsbGJhY2siLCJvbkRpdmluZVN0b3JtQ2FsbGJhY2siLCJzZXRQcm9qZWN0aWxlQ3JlYXRlZENhbGxiYWNrIiwic2V0VmlwZXJTdGluZ0NhbGxiYWNrIiwib25WaXBlclN0aW5nQ2FsbGJhY2siLCJzZXRCYXJyYWdlQ2FsbGJhY2siLCJvbkJhcnJhZ2VDYWxsYmFjayIsInNldFJlYW5pbWF0ZUNhbGxiYWNrIiwic2V0RnJvc3ROb3ZhQ2FsbGJhY2siLCJzZXRDb2JyYVNob3RDYWxsYmFjayIsInNldENoYXJnZUNhbGxiYWNrIiwib25DaGFyZ2VDYWxsYmFjayIsInNldERlZmxlY3RDYWxsYmFjayIsIm9uRGVmbGVjdENhbGxiYWNrIiwic2V0RGVidWZmQ2FsbGJhY2siLCJzZXRXZWFwb25MZXZlbCIsImdldEN1cnJlbnRXZWFwb25Db25maWciLCJ3ZWFwb24iLCJnZXRDdXJyZW50V2VhcG9uIiwiZ2V0Q3VycmVudFN1YmNsYXNzIiwiaXNXZWFwb25DaGFyZ2luZyIsImdldENoYXJnZVByb2dyZXNzIiwiaXNWaXBlclN0aW5nQ2hhcmdpbmdBY3RpdmUiLCJnZXRWaXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MiLCJ2aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MiLCJpc0JhcnJhZ2VDaGFyZ2luZ0FjdGl2ZSIsImdldEJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyIsImJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyIsImlzQ29icmFTaG90Q2hhcmdpbmdBY3RpdmUiLCJnZXRDb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyIsImlzV2VhcG9uU3dpbmdpbmciLCJpc1N3aW5naW5nIiwiZ2V0U3dvcmRDb21ib1N0ZXAiLCJpc0RpdmluZVN0b3JtQWN0aXZlIiwiaXNEaXZpbmVTdG9ybWluZyIsImlzQ2hhcmdlQWN0aXZlIiwiaXNTd29yZENoYXJnaW5nIiwiaXNEZWZsZWN0QWN0aXZlIiwiaXNEZWZsZWN0aW5nIiwicGVyZm9ybVN3b3JkTWVsZWVBdHRhY2siLCJwZXJmb3JtRGl2aW5lU3Rvcm0iLCJwZXJmb3JtQ2hhcmdlIiwicGVyZm9ybURlZmxlY3QiLCJsYXN0U3dvcmRBdHRhY2tUaW1lIiwic3dvcmRDb21ib1Jlc2V0VGltZSIsInBlcmZvcm1NZWxlZURhbWFnZSIsIm9uU3dvcmRTd2luZ0NvbXBsZXRlIiwicGVyZm9ybVNhYnJlc01lbGVlQXR0YWNrIiwicGVyZm9ybVNhYnJlc01lbGVlRGFtYWdlIiwib25TYWJyZXNTd2luZ0NvbXBsZXRlIiwiaGFzQ29tcG9uZW50IiwiYXR0YWNrUmFuZ2UiLCJhdHRhY2tBbmdsZSIsImxlZnRTYWJyZURhbWFnZSIsInJpZ2h0U2FicmVEYW1hZ2UiLCJhdHRhY2tEaXJlY3Rpb24iLCJoaXRDb3VudCIsInRhcmdldFRyYW5zZm9ybSIsInRhcmdldEhlYWx0aCIsImRpcmVjdGlvblRvVGFyZ2V0Iiwic3ViIiwiZGlzdGFuY2VUb1RhcmdldCIsImRvdFByb2R1Y3QiLCJkb3QiLCJhbmdsZVRvVGFyZ2V0IiwiYWNvcyIsIm1heCIsInNldFRpbWVvdXQiLCJtZWxlZVJhbmdlIiwibWVsZWVBbmdsZSIsImJhc2VEYW1hZ2UiLCJlbmVtaWVzSGl0IiwiZW5lbXlUcmFuc2Zvcm0iLCJlbmVteUhlYWx0aCIsImVuZW15UG9zaXRpb24iLCJ0b0VuZW15IiwiYW5nbGVUbyIsImFuZ2xlRGVncmVlcyIsIm1heEFuZ2xlRGVncmVlcyIsInJhZ2VCZWZvcmUiLCJnZXRDdXJyZW50UmFnZSIsInJhZ2VUb0dhaW4iLCJnYWluUmFnZSIsInJhZ2VBZnRlciIsInRyYW5zZm9ybSIsImRhc2hEaXJlY3Rpb25zIiwia2V5IiwiY2hlY2tEb3VibGVUYXAiLCJkZWJ1Z0luZm8iLCJnZXREb3VibGVUYXBEZWJ1Z0luZm8iLCJ0b1VwcGVyQ2FzZSIsImdldFdvcmxkU3BhY2VEaXJlY3Rpb24iLCJkYXNoU3RhcnRlZCIsInN0YXJ0RGFzaCIsInJlc2V0RG91YmxlVGFwIiwiZGFzaFJlc3VsdCIsInVwZGF0ZURhc2giLCJuZXdQb3NpdGlvbiIsIk1BWF9EQVNIX0JPVU5EUyIsImRpc3RhbmNlRnJvbU9yaWdpbiIsImNvcHkiLCJjYW5jZWxEYXNoIiwiaXNDb21wbGV0ZSIsImNoYXJnZVN0b3BwZWRCeUNvbGxpc2lvbiIsImNhbmNlbENoYXJnZSIsImNoYXJnZVJlc3VsdCIsInVwZGF0ZUNoYXJnZSIsIk1BWF9DSEFSR0VfQk9VTkRTIiwicGlsbGFyQ29sbGlzaW9uIiwiY2hlY2tQaWxsYXJDb2xsaXNpb24iLCJvbkNoYXJnZUNvbXBsZXRlIiwiaGFzQ29sbGlzaW9uIiwicGlsbGFyQ2VudGVyIiwidG9BcnJheSIsImpvaW4iLCJwaWxsYXJQb3MiLCJQSUxMQVJfUE9TSVRJT05TIiwiaG9yaXpvbnRhbFBvcyIsInBpbGxhckhvcml6b250YWwiLCJQSUxMQVJfUkFESVVTIiwibm9ybWFsIiwic2V0IiwiY2FuQ2FzdERpdmluZVN0b3JtIiwibGFzdERpdmluZVN0b3JtVGltZSIsImRpdmluZVN0b3JtQ29vbGRvd24iLCJjdXJyZW50UmFnZSIsImNvbnN1bWVBbGxSYWdlIiwiYmFzZVN0b3JtRHVyYXRpb24iLCJib251c0R1cmF0aW9uIiwiZmxvb3IiLCJ0b3RhbERpdmluZVN0b3JtRHVyYXRpb24iLCJsYXN0Q2hhcmdlVGltZSIsImNoYXJnZUNvb2xkb3duIiwiY2hhcmdlU3RhcnRlZCIsInN0YXJ0Q2hhcmdlIiwic2NoZWR1bGVDaGFyZ2VEYW1hZ2UiLCJjaGFyZ2VEaXJlY3Rpb24iLCJzdGFydFRpbWUiLCJkYW1hZ2VDaGVja0ludGVydmFsIiwiY2hhcmdlRGFtYWdlIiwiY2hhcmdlUmFkaXVzIiwiY2hhcmdlSGl0RW50aXRpZXMiLCJjbGVhciIsImRhbWFnZUludGVydmFsIiwiaGl0U29tZXRoaW5nIiwic2VydmVyUGxheWVycyIsInB2cFBsYXllcnMiLCJNYXAiLCJsb2NhbFNvY2tldElkIiwic2l6ZSIsInNlcnZlclBsYXllciIsInBsYXllcklkIiwicGxheWVySWRIYXNoIiwiY2hhckNvZGVBdCIsImhhcyIsInNlcnZlclBsYXllclBvcyIsInN0b3BEaXN0YW5jZSIsImhlYWx0aCIsInRhcmdldElkIiwiaGl0UG9zaXRpb24iLCJlbnRpdHlDb2xsaWRlciIsImVudGl0eVR5cGUiLCJnZXREaXNwbGF5TmFtZSIsImxhc3REZWZsZWN0VGltZSIsImRlZmxlY3RDb29sZG93biIsInNldHVwRGVmbGVjdEJhcnJpZXIiLCJvbkRlZmxlY3RDb21wbGV0ZSIsImRlZmxlY3REdXJhdGlvbiIsImxhc3RWaXBlclN0aW5nVGltZSIsInZpcGVyU3RpbmdGaXJlUmF0ZSIsImNhbkNhc3RWaXBlclN0aW5nIiwiZmlyZVZpcGVyU3RpbmciLCJzdWNjZXNzIiwiaXNSZXR1cm5pbmciLCJsYXN0QmFycmFnZVRpbWUiLCJiYXJyYWdlRmlyZVJhdGUiLCJjYW5DYXN0QmFycmFnZSIsImZpcmVCYXJyYWdlIiwiYW5nbGVzIiwicHJvamVjdGlsZURpcmVjdGlvbiIsIm1ha2VSb3RhdGlvblkiLCJwcm9qZWN0aWxlRW50aXR5IiwicmVuZGVyZXIiLCJtZXNoIiwidXNlckRhdGEiLCJpc0JhcnJhZ2VBcnJvdyIsImlzUmVndWxhckFycm93IiwicGxheWVyUm90YXRpb24iLCJpbnB1dFN0cmVuZ3RoIiwibW92ZURpciIsIm1vdmVEaXJlY3Rpb24iLCJtb3ZlQW5nbGUiLCJkZWZsZWN0QmFycmllciIsImFjdGl2YXRlIiwiaXNCYXJyaWVyQWN0aXZlIiwidXBkYXRlUG9zaXRpb24iLCJkZWFjdGl2YXRlIiwiZ2V0V2VhcG9uU3dpdGNoQ29vbGRvd24iLCJjdXJyZW50IiwiZ2V0QWJpbGl0eUNvb2xkb3ducyIsImNvb2xkb3ducyIsImlzQWN0aXZlIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJyZWFuaW1hdGVGaXJlUmF0ZSIsIlNldCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ControlSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/HealthBarSystem.ts":
/*!****************************************!*\
  !*** ./src/systems/HealthBarSystem.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HealthBarSystem: function() { return /* binding */ HealthBarSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/HealthBar */ \"(app-pages-browser)/./src/ecs/components/HealthBar.ts\");\n// Health bar system for rendering health bars above entities\n\n\n\n\n\nclass HealthBarSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update health bar logic\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n            if (!transform.enabled || !health.enabled || !healthBar.enabled) {\n                continue;\n            }\n            // Update health bar with current health ratio\n            const worldPosition = transform.getWorldPosition();\n            const cameraPosition = this.camera.position;\n            healthBar.updateHealthBar(health.getHealthRatio(), cameraPosition, worldPosition, deltaTime);\n        }\n    }\n    render(entities, deltaTime) {\n    // Health bars are automatically rendered as part of the scene\n    // This method can be used for any additional rendering logic\n    }\n    onEntityAdded(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Add health bar group to scene\n            this.scene.add(healthBar.getGroup());\n        }\n    }\n    onEntityRemoved(entity) {\n        const healthBar = entity.getComponent(_ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar);\n        if (healthBar) {\n            // Remove health bar group from scene and dispose resources\n            this.scene.remove(healthBar.getGroup());\n            healthBar.dispose();\n        }\n    }\n    onDisable() {\n        // Clean up all health bars from scene\n        const healthBarGroups = [];\n        this.scene.traverse((object)=>{\n            if (object instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Group && object.userData.isHealthBar) {\n                healthBarGroups.push(object);\n            }\n        });\n        for (const group of healthBarGroups){\n            this.scene.remove(group);\n        }\n    }\n    constructor(scene, camera){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_HealthBar__WEBPACK_IMPORTED_MODULE_4__.HealthBar\n        ];\n        this.scene = scene;\n        this.camera = camera;\n        this.priority = 100; // Render after main objects\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL0hlYWx0aEJhclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSw2REFBNkQ7QUFDQTtBQUNqQjtBQUVXO0FBQ047QUFDTTtBQUVoRCxNQUFNSyx3QkFBd0JKLHFEQUFZQTtJQVl4Q0ssT0FBT0MsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQkFBMEI7UUFDMUIsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1QsZ0VBQVNBO1lBQy9DLE1BQU1VLFNBQVNILE9BQU9FLFlBQVksQ0FBQ1IsMERBQU1BO1lBQ3pDLE1BQU1VLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBRS9DLElBQUksQ0FBQ00sVUFBVUksT0FBTyxJQUFJLENBQUNGLE9BQU9FLE9BQU8sSUFBSSxDQUFDRCxVQUFVQyxPQUFPLEVBQUU7Z0JBQy9EO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsTUFBTUMsZ0JBQWdCTCxVQUFVTSxnQkFBZ0I7WUFDaEQsTUFBTUMsaUJBQWlCLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRO1lBRTNDTixVQUFVTyxlQUFlLENBQ3ZCUixPQUFPUyxjQUFjLElBQ3JCSixnQkFDQUYsZUFDQVA7UUFFSjtJQUNGO0lBRU9jLE9BQU9mLFFBQWtCLEVBQUVDLFNBQWlCLEVBQVE7SUFDekQsOERBQThEO0lBQzlELDZEQUE2RDtJQUMvRDtJQUVPZSxjQUFjZCxNQUFjLEVBQVE7UUFDekMsTUFBTUksWUFBWUosT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7UUFDL0MsSUFBSVMsV0FBVztZQUNiLGdDQUFnQztZQUNoQyxJQUFJLENBQUNXLEtBQUssQ0FBQ0MsR0FBRyxDQUFDWixVQUFVYSxRQUFRO1FBQ25DO0lBQ0Y7SUFFT0MsZ0JBQWdCbEIsTUFBYyxFQUFRO1FBQzNDLE1BQU1JLFlBQVlKLE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1FBQy9DLElBQUlTLFdBQVc7WUFDYiwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDVyxLQUFLLENBQUNJLE1BQU0sQ0FBQ2YsVUFBVWEsUUFBUTtZQUNwQ2IsVUFBVWdCLE9BQU87UUFDbkI7SUFDRjtJQUVPQyxZQUFrQjtRQUN2QixzQ0FBc0M7UUFDdEMsTUFBTUMsa0JBQTJCLEVBQUU7UUFFbkMsSUFBSSxDQUFDUCxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDQztZQUNuQixJQUFJQSxrQkFBa0JqQyx1REFBS0EsSUFBSWlDLE9BQU9DLFFBQVEsQ0FBQ0MsV0FBVyxFQUFFO2dCQUMxREosZ0JBQWdCSyxJQUFJLENBQUNIO1lBQ3ZCO1FBQ0Y7UUFFQSxLQUFLLE1BQU1JLFNBQVNOLGdCQUFpQjtZQUNuQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUztRQUNwQjtJQUNGO0lBbEVBQyxZQUFZZCxLQUFZLEVBQUVOLE1BQWMsQ0FBRTtRQUN4QyxLQUFLO2FBTFNxQixxQkFBcUI7WUFBQ3JDLGdFQUFTQTtZQUFFQywwREFBTUE7WUFBRUMsZ0VBQVNBO1NBQUM7UUFNakUsSUFBSSxDQUFDb0IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ04sTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRyxLQUFLLDRCQUE0QjtJQUNuRDtBQThERiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3lzdGVtcy9IZWFsdGhCYXJTeXN0ZW0udHM/YTJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWFsdGggYmFyIHN5c3RlbSBmb3IgcmVuZGVyaW5nIGhlYWx0aCBiYXJzIGFib3ZlIGVudGl0aWVzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBHcm91cCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IEhlYWx0aCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoJztcbmltcG9ydCB7IEhlYWx0aEJhciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvSGVhbHRoQmFyJztcblxuZXhwb3J0IGNsYXNzIEhlYWx0aEJhclN5c3RlbSBleHRlbmRzIFJlbmRlclN5c3RlbSB7XG4gIHB1YmxpYyByZWFkb25seSByZXF1aXJlZENvbXBvbmVudHMgPSBbVHJhbnNmb3JtLCBIZWFsdGgsIEhlYWx0aEJhcl07XG4gIHByaXZhdGUgc2NlbmU6IFNjZW5lO1xuICBwcml2YXRlIGNhbWVyYTogQ2FtZXJhO1xuXG4gIGNvbnN0cnVjdG9yKHNjZW5lOiBTY2VuZSwgY2FtZXJhOiBDYW1lcmEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwOyAvLyBSZW5kZXIgYWZ0ZXIgbWFpbiBvYmplY3RzXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgaGVhbHRoIGJhciBsb2dpY1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIWhlYWx0aC5lbmFibGVkIHx8ICFoZWFsdGhCYXIuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGhlYWx0aCBiYXIgd2l0aCBjdXJyZW50IGhlYWx0aCByYXRpb1xuICAgICAgY29uc3Qgd29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybS5nZXRXb3JsZFBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgXG4gICAgICBoZWFsdGhCYXIudXBkYXRlSGVhbHRoQmFyKFxuICAgICAgICBoZWFsdGguZ2V0SGVhbHRoUmF0aW8oKSxcbiAgICAgICAgY2FtZXJhUG9zaXRpb24sXG4gICAgICAgIHdvcmxkUG9zaXRpb24sXG4gICAgICAgIGRlbHRhVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVuZGVyKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBIZWFsdGggYmFycyBhcmUgYXV0b21hdGljYWxseSByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzY2VuZVxuICAgIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIGZvciBhbnkgYWRkaXRpb25hbCByZW5kZXJpbmcgbG9naWNcbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgaGVhbHRoQmFyID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGhCYXIpO1xuICAgIGlmIChoZWFsdGhCYXIpIHtcbiAgICAgIC8vIEFkZCBoZWFsdGggYmFyIGdyb3VwIHRvIHNjZW5lXG4gICAgICB0aGlzLnNjZW5lLmFkZChoZWFsdGhCYXIuZ2V0R3JvdXAoKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGhlYWx0aEJhciA9IGVudGl0eS5nZXRDb21wb25lbnQoSGVhbHRoQmFyKTtcbiAgICBpZiAoaGVhbHRoQmFyKSB7XG4gICAgICAvLyBSZW1vdmUgaGVhbHRoIGJhciBncm91cCBmcm9tIHNjZW5lIGFuZCBkaXNwb3NlIHJlc291cmNlc1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoaGVhbHRoQmFyLmdldEdyb3VwKCkpO1xuICAgICAgaGVhbHRoQmFyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIC8vIENsZWFuIHVwIGFsbCBoZWFsdGggYmFycyBmcm9tIHNjZW5lXG4gICAgY29uc3QgaGVhbHRoQmFyR3JvdXBzOiBHcm91cFtdID0gW107XG4gICAgXG4gICAgdGhpcy5zY2VuZS50cmF2ZXJzZSgob2JqZWN0KSA9PiB7XG4gICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgR3JvdXAgJiYgb2JqZWN0LnVzZXJEYXRhLmlzSGVhbHRoQmFyKSB7XG4gICAgICAgIGhlYWx0aEJhckdyb3Vwcy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGhlYWx0aEJhckdyb3Vwcykge1xuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUoZ3JvdXApO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkdyb3VwIiwiUmVuZGVyU3lzdGVtIiwiVHJhbnNmb3JtIiwiSGVhbHRoIiwiSGVhbHRoQmFyIiwiSGVhbHRoQmFyU3lzdGVtIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJoZWFsdGgiLCJoZWFsdGhCYXIiLCJlbmFibGVkIiwid29ybGRQb3NpdGlvbiIsImdldFdvcmxkUG9zaXRpb24iLCJjYW1lcmFQb3NpdGlvbiIsImNhbWVyYSIsInBvc2l0aW9uIiwidXBkYXRlSGVhbHRoQmFyIiwiZ2V0SGVhbHRoUmF0aW8iLCJyZW5kZXIiLCJvbkVudGl0eUFkZGVkIiwic2NlbmUiLCJhZGQiLCJnZXRHcm91cCIsIm9uRW50aXR5UmVtb3ZlZCIsInJlbW92ZSIsImRpc3Bvc2UiLCJvbkRpc2FibGUiLCJoZWFsdGhCYXJHcm91cHMiLCJ0cmF2ZXJzZSIsIm9iamVjdCIsInVzZXJEYXRhIiwiaXNIZWFsdGhCYXIiLCJwdXNoIiwiZ3JvdXAiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/HealthBarSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/PhysicsSystem.ts":
/*!**************************************!*\
  !*** ./src/systems/PhysicsSystem.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsSystem: function() { return /* binding */ PhysicsSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Movement */ \"(app-pages-browser)/./src/ecs/components/Movement.ts\");\n// Physics system for handling movement physics\n\n\n\n\nclass PhysicsSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.PhysicsSystem {\n    update(entities, deltaTime) {\n        // This runs every frame for variable timestep updates\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            // Update debuff states (frozen, slowed, etc.)\n            if (typeof movement.updateDebuffs === \"function\") {\n                movement.updateDebuffs();\n            } else {\n                console.warn(\"⚠️ Movement component missing updateDebuffs method:\", movement);\n            }\n            this.updateMovement(transform, movement, deltaTime);\n        }\n    }\n    fixedUpdate(entities, fixedDeltaTime) {\n        // This runs at fixed timestep for physics\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const movement = entity.getComponent(_ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement);\n            // Skip if required components are missing\n            if (!transform || !movement) {\n                continue;\n            }\n            if (!transform.enabled || !movement.enabled || !movement.canMove) {\n                continue;\n            }\n            this.applyPhysics(transform, movement, fixedDeltaTime);\n        }\n    }\n    updateMovement(transform, movement, deltaTime) {\n        // Update position based on velocity\n        const deltaPosition = movement.velocity.clone().multiplyScalar(deltaTime);\n        // Calculate potential new position\n        const currentPosition = transform.position.clone();\n        const potentialPosition = currentPosition.clone().add(deltaPosition);\n        // Apply map boundary constraints with smooth sliding (radius of 29 units from origin)\n        const MAP_RADIUS = 29;\n        // Only check horizontal distance (ignore Y for boundary)\n        const horizontalPosition = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(potentialPosition.x, 0, potentialPosition.z);\n        const distanceFromCenter = horizontalPosition.length();\n        // Check for pillar collisions first\n        const pillarCollision = this.checkPillarCollision(potentialPosition);\n        if (distanceFromCenter >= MAP_RADIUS) {\n            // If we hit the boundary, calculate tangent movement for smooth sliding\n            const currentHorizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(currentPosition.x, 0, currentPosition.z);\n            const toCenter = currentHorizontalPos.clone().normalize();\n            // Create tangent vector (perpendicular to radius)\n            const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-toCenter.z, 0, toCenter.x);\n            // Project our horizontal movement onto the tangent\n            const horizontalMovement = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(deltaPosition.x, 0, deltaPosition.z);\n            const tangentMovement = tangent.multiplyScalar(horizontalMovement.dot(tangent));\n            // Apply the tangential movement while keeping distance to center constant\n            const newHorizontalPosition = currentHorizontalPos.add(tangentMovement);\n            newHorizontalPosition.normalize().multiplyScalar(MAP_RADIUS);\n            // Update position with tangent movement and preserve Y movement\n            transform.setPosition(newHorizontalPosition.x, currentPosition.y + deltaPosition.y, newHorizontalPosition.z);\n        } else if (pillarCollision.hasCollision) {\n            // Handle pillar collision with smooth sliding\n            const slidePosition = this.calculatePillarSliding(currentPosition, deltaPosition, pillarCollision);\n            transform.setPosition(slidePosition.x, slidePosition.y, slidePosition.z);\n            // Reduce velocity in the direction of the pillar to prevent bouncing\n            const velocityNormalComponent = movement.velocity.clone().projectOnVector(pillarCollision.normal);\n            movement.velocity.sub(velocityNormalComponent.multiplyScalar(0.5));\n        } else {\n            // If within bounds and no pillar collision, move normally\n            transform.translate(deltaPosition.x, deltaPosition.y, deltaPosition.z);\n        }\n        // Mark transform matrix as needing update\n        transform.matrixNeedsUpdate = true;\n    }\n    checkPillarCollision(position) {\n        for (const pillarPos of this.PILLAR_POSITIONS){\n            // Only check horizontal distance (ignore Y)\n            const horizontalPos = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(position.x, 0, position.z);\n            const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(pillarPos.x, 0, pillarPos.z);\n            const distance = horizontalPos.distanceTo(pillarHorizontal);\n            if (distance < this.PILLAR_RADIUS) {\n                // Calculate normal vector pointing away from pillar center\n                const normal = horizontalPos.clone().sub(pillarHorizontal).normalize();\n                // Handle case where player is exactly at pillar center\n                if (normal.length() === 0) {\n                    normal.set(1, 0, 0); // Default direction\n                }\n                return {\n                    hasCollision: true,\n                    normal: normal,\n                    pillarCenter: pillarPos.clone()\n                };\n            }\n        }\n        return {\n            hasCollision: false,\n            normal: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            pillarCenter: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n        };\n    }\n    calculatePillarSliding(currentPosition, deltaPosition, collision) {\n        // Calculate the tangent vector (perpendicular to normal in XZ plane)\n        const tangent = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-collision.normal.z, 0, collision.normal.x);\n        // Project the movement vector onto the tangent for sliding\n        const tangentMovement = deltaPosition.clone().projectOnVector(tangent);\n        // Calculate the new position with sliding movement\n        const slidePosition = currentPosition.clone().add(tangentMovement);\n        // Ensure we maintain minimum distance from pillar center\n        const pillarHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(collision.pillarCenter.x, 0, collision.pillarCenter.z);\n        const slideHorizontal = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(slidePosition.x, 0, slidePosition.z);\n        const distanceAfterSlide = slideHorizontal.distanceTo(pillarHorizontal);\n        if (distanceAfterSlide < this.PILLAR_RADIUS) {\n            // Push the position to maintain minimum distance\n            const pushDirection = slideHorizontal.clone().sub(pillarHorizontal).normalize();\n            if (pushDirection.length() === 0) {\n                pushDirection.set(1, 0, 0); // Default direction\n            }\n            const correctedHorizontal = pillarHorizontal.clone().add(pushDirection.multiplyScalar(this.PILLAR_RADIUS));\n            slidePosition.x = correctedHorizontal.x;\n            slidePosition.z = correctedHorizontal.z;\n        }\n        return slidePosition;\n    }\n    applyPhysics(transform, movement, deltaTime) {\n        // Apply gravity (only affects Y velocity)\n        movement.applyGravity(deltaTime);\n        // Handle horizontal movement directly for immediate response\n        if (movement.inputStrength > 0) {\n            // Use effective max speed which accounts for frozen/slowed states\n            const effectiveMaxSpeed = movement.getEffectiveMaxSpeed();\n            // Direct velocity setting for responsive movement\n            const targetVelocity = movement.moveDirection.clone();\n            targetVelocity.multiplyScalar(effectiveMaxSpeed * movement.inputStrength);\n            // Set horizontal velocity directly (preserve Y velocity for gravity/jumping)\n            movement.velocity.x = targetVelocity.x;\n            movement.velocity.z = targetVelocity.z;\n        } else {\n            // No input - stop horizontal movement immediately for responsive controls\n            movement.velocity.x = 0;\n            movement.velocity.z = 0;\n        }\n        // Apply any additional forces (like knockback, wind, etc.)\n        movement.velocity.add(movement.acceleration.clone().multiplyScalar(deltaTime));\n        // Reset acceleration for next frame\n        movement.acceleration.set(0, 0, 0);\n        // Simple ground check (Y = 0 is ground level, account for sphere radius)\n        const sphereRadius = 0.5; // Player sphere radius\n        const groundLevel = sphereRadius; // Sphere center should be at radius height above ground\n        if (transform.position.y <= groundLevel && movement.velocity.y <= 0) {\n            transform.position.y = groundLevel;\n            movement.velocity.y = 0;\n            movement.isGrounded = true;\n        } else {\n            movement.isGrounded = false;\n        }\n    }\n    constructor(){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Movement__WEBPACK_IMPORTED_MODULE_3__.Movement\n        ];\n        // Define pillar positions (same as in Environment.tsx)\n        this.PILLAR_POSITIONS = [\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(-4.25, 0, 2.5),\n            new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(4.25, 0, 2.5) // Right pillar\n        ];\n        this.PILLAR_RADIUS = 0.7 // Same as PillarCollision.tsx\n        ;\n        this.priority = 15; // Run after control system but before rendering\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrQ0FBK0M7QUFDQztBQUNrQjtBQUVYO0FBQ0Y7QUFFOUMsTUFBTUMsc0JBQXNCQyxzREFBaUJBO0lBUTNDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELHNEQUFzRDtRQUN0RCxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsV0FBV0gsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFN0MsMENBQTBDO1lBQzFDLElBQUksQ0FBQ0ssYUFBYSxDQUFDRSxVQUFVO2dCQUMzQjtZQUNGO1lBRUEsSUFBSSxDQUFDRixVQUFVRyxPQUFPLElBQUksQ0FBQ0QsU0FBU0MsT0FBTyxJQUFJLENBQUNELFNBQVNFLE9BQU8sRUFBRTtnQkFDaEU7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLE9BQU9GLFNBQVNHLGFBQWEsS0FBSyxZQUFZO2dCQUNoREgsU0FBU0csYUFBYTtZQUN4QixPQUFPO2dCQUNMQyxRQUFRQyxJQUFJLENBQUMsdURBQXVETDtZQUN0RTtZQUVBLElBQUksQ0FBQ00sY0FBYyxDQUFDUixXQUFXRSxVQUFVSjtRQUMzQztJQUNGO0lBRU9XLFlBQVlaLFFBQWtCLEVBQUVhLGNBQXNCLEVBQVE7UUFDbkUsMENBQTBDO1FBQzFDLEtBQUssTUFBTVgsVUFBVUYsU0FBVTtZQUM3QixNQUFNRyxZQUFZRCxPQUFPRSxZQUFZLENBQUNQLGdFQUFTQTtZQUMvQyxNQUFNUSxXQUFXSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUU3QywwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDSyxhQUFhLENBQUNFLFVBQVU7Z0JBQzNCO1lBQ0Y7WUFFQSxJQUFJLENBQUNGLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxTQUFTQyxPQUFPLElBQUks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Q0FBQ1MsQ0FBQyxHQUFHO1lBQ3RCcEIsU0FBU1csUUFBUSxDQUFDVSxDQUFDLEdBQUc7UUFDeEI7UUFFQSwyREFBMkQ7UUFDM0RyQixTQUFTVyxRQUFRLENBQUNNLEdBQUcsQ0FBQ2pCLFNBQVNpRSxZQUFZLENBQUNyRCxLQUFLLEdBQUdDLGNBQWMsQ0FBQ2pCO1FBRW5FLG9DQUFvQztRQUNwQ0ksU0FBU2lFLFlBQVksQ0FBQ2IsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUVoQyx5RUFBeUU7UUFDekUsTUFBTWMsZUFBZSxLQUFLLHVCQUF1QjtRQUNqRCxNQUFNQyxjQUFjRCxjQUFjLHdEQUF3RDtRQUUxRixJQUFJcEUsVUFBVWlCLFFBQVEsQ0FBQ29CLENBQUMsSUFBSWdDLGVBQWVuRSxTQUFTVyxRQUFRLENBQUN3QixDQUFDLElBQUksR0FBRztZQUNuRXJDLFVBQVVpQixRQUFRLENBQUNvQixDQUFDLEdBQUdnQztZQUN2Qm5FLFNBQVNXLFFBQVEsQ0FBQ3dCLENBQUMsR0FBRztZQUN0Qm5DLFNBQVNvRSxVQUFVLEdBQUc7UUFDeEIsT0FBTztZQUNMcEUsU0FBU29FLFVBQVUsR0FBRztRQUN4QjtJQUNGO0lBaE5BQyxhQUFjO1FBQ1osS0FBSzthQUhTQyxxQkFBcUI7WUFBQzlFLGdFQUFTQTtZQUFFQyw4REFBUUE7U0FBQztRQTZHMUQsdURBQXVEO2FBQ3RDcUQsbUJBQW1CO1lBQ2xDLElBQUl6RCx5REFBT0EsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNuQixJQUFJQSx5REFBT0EsQ0FBQyxDQUFDLE1BQU0sR0FBRztZQUN0QixJQUFJQSx5REFBT0EsQ0FBQyxNQUFNLEdBQUcsS0FBUyxlQUFlO1NBQzlDO2FBQ2dCOEQsZ0JBQWdCLElBQUssOEJBQThCOztRQS9HbEUsSUFBSSxDQUFDb0IsUUFBUSxHQUFHLElBQUksZ0RBQWdEO0lBQ3RFO0FBOE1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1BoeXNpY3NTeXN0ZW0udHM/MGNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQaHlzaWNzIHN5c3RlbSBmb3IgaGFuZGxpbmcgbW92ZW1lbnQgcGh5c2ljc1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBQaHlzaWNzU3lzdGVtIGFzIEJhc2VQaHlzaWNzU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBNb3ZlbWVudCB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvTW92ZW1lbnQnO1xuXG5leHBvcnQgY2xhc3MgUGh5c2ljc1N5c3RlbSBleHRlbmRzIEJhc2VQaHlzaWNzU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIE1vdmVtZW50XTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucHJpb3JpdHkgPSAxNTsgLy8gUnVuIGFmdGVyIGNvbnRyb2wgc3lzdGVtIGJ1dCBiZWZvcmUgcmVuZGVyaW5nXG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBUaGlzIHJ1bnMgZXZlcnkgZnJhbWUgZm9yIHZhcmlhYmxlIHRpbWVzdGVwIHVwZGF0ZXNcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gZW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgY29uc3QgbW92ZW1lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KE1vdmVtZW50KTtcblxuICAgICAgLy8gU2tpcCBpZiByZXF1aXJlZCBjb21wb25lbnRzIGFyZSBtaXNzaW5nXG4gICAgICBpZiAoIXRyYW5zZm9ybSB8fCAhbW92ZW1lbnQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIW1vdmVtZW50LmVuYWJsZWQgfHwgIW1vdmVtZW50LmNhbk1vdmUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBkZWJ1ZmYgc3RhdGVzIChmcm96ZW4sIHNsb3dlZCwgZXRjLilcbiAgICAgIGlmICh0eXBlb2YgbW92ZW1lbnQudXBkYXRlRGVidWZmcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtb3ZlbWVudC51cGRhdGVEZWJ1ZmZzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBNb3ZlbWVudCBjb21wb25lbnQgbWlzc2luZyB1cGRhdGVEZWJ1ZmZzIG1ldGhvZDonLCBtb3ZlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlTW92ZW1lbnQodHJhbnNmb3JtLCBtb3ZlbWVudCwgZGVsdGFUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZml4ZWRVcGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBmaXhlZERlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gVGhpcyBydW5zIGF0IGZpeGVkIHRpbWVzdGVwIGZvciBwaHlzaWNzXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IG1vdmVtZW50ID0gZW50aXR5LmdldENvbXBvbmVudChNb3ZlbWVudCk7XG5cbiAgICAgIC8vIFNraXAgaWYgcmVxdWlyZWQgY29tcG9uZW50cyBhcmUgbWlzc2luZ1xuICAgICAgaWYgKCF0cmFuc2Zvcm0gfHwgIW1vdmVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zZm9ybS5lbmFibGVkIHx8ICFtb3ZlbWVudC5lbmFibGVkIHx8ICFtb3ZlbWVudC5jYW5Nb3ZlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGx5UGh5c2ljcyh0cmFuc2Zvcm0sIG1vdmVtZW50LCBmaXhlZERlbHRhVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVNb3ZlbWVudCh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB2ZWxvY2l0eVxuICAgIGNvbnN0IGRlbHRhUG9zaXRpb24gPSBtb3ZlbWVudC52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRlbHRhVGltZSk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHBvdGVudGlhbCBuZXcgcG9zaXRpb25cbiAgICBjb25zdCBjdXJyZW50UG9zaXRpb24gPSB0cmFuc2Zvcm0ucG9zaXRpb24uY2xvbmUoKTtcbiAgICBjb25zdCBwb3RlbnRpYWxQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpLmFkZChkZWx0YVBvc2l0aW9uKTtcbiAgICBcbiAgICAvLyBBcHBseSBtYXAgYm91bmRhcnkgY29uc3RyYWludHMgd2l0aCBzbW9vdGggc2xpZGluZyAocmFkaXVzIG9mIDI5IHVuaXRzIGZyb20gb3JpZ2luKVxuICAgIGNvbnN0IE1BUF9SQURJVVMgPSAyOTtcbiAgICBcbiAgICAvLyBPbmx5IGNoZWNrIGhvcml6b250YWwgZGlzdGFuY2UgKGlnbm9yZSBZIGZvciBib3VuZGFyeSlcbiAgICBjb25zdCBob3Jpem9udGFsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhwb3RlbnRpYWxQb3NpdGlvbi54LCAwLCBwb3RlbnRpYWxQb3NpdGlvbi56KTtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBob3Jpem9udGFsUG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHBpbGxhciBjb2xsaXNpb25zIGZpcnN0XG4gICAgY29uc3QgcGlsbGFyQ29sbGlzaW9uID0gdGhpcy5jaGVja1BpbGxhckNvbGxpc2lvbihwb3RlbnRpYWxQb3NpdGlvbik7XG4gICAgXG4gICAgaWYgKGRpc3RhbmNlRnJvbUNlbnRlciA+PSBNQVBfUkFESVVTKSB7XG4gICAgICAvLyBJZiB3ZSBoaXQgdGhlIGJvdW5kYXJ5LCBjYWxjdWxhdGUgdGFuZ2VudCBtb3ZlbWVudCBmb3Igc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IGN1cnJlbnRIb3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMoY3VycmVudFBvc2l0aW9uLngsIDAsIGN1cnJlbnRQb3NpdGlvbi56KTtcbiAgICAgIGNvbnN0IHRvQ2VudGVyID0gY3VycmVudEhvcml6b250YWxQb3MuY2xvbmUoKS5ub3JtYWxpemUoKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRhbmdlbnQgdmVjdG9yIChwZXJwZW5kaWN1bGFyIHRvIHJhZGl1cylcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgVmVjdG9yMygtdG9DZW50ZXIueiwgMCwgdG9DZW50ZXIueCk7XG4gICAgICBcbiAgICAgIC8vIFByb2plY3Qgb3VyIGhvcml6b250YWwgbW92ZW1lbnQgb250byB0aGUgdGFuZ2VudFxuICAgICAgY29uc3QgaG9yaXpvbnRhbE1vdmVtZW50ID0gbmV3IFZlY3RvcjMoZGVsdGFQb3NpdGlvbi54LCAwLCBkZWx0YVBvc2l0aW9uLnopO1xuICAgICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcihob3Jpem9udGFsTW92ZW1lbnQuZG90KHRhbmdlbnQpKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgdGhlIHRhbmdlbnRpYWwgbW92ZW1lbnQgd2hpbGUga2VlcGluZyBkaXN0YW5jZSB0byBjZW50ZXIgY29uc3RhbnRcbiAgICAgIGNvbnN0IG5ld0hvcml6b250YWxQb3NpdGlvbiA9IGN1cnJlbnRIb3Jpem9udGFsUG9zLmFkZCh0YW5nZW50TW92ZW1lbnQpO1xuICAgICAgbmV3SG9yaXpvbnRhbFBvc2l0aW9uLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKE1BUF9SQURJVVMpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcG9zaXRpb24gd2l0aCB0YW5nZW50IG1vdmVtZW50IGFuZCBwcmVzZXJ2ZSBZIG1vdmVtZW50XG4gICAgICB0cmFuc2Zvcm0uc2V0UG9zaXRpb24oXG4gICAgICAgIG5ld0hvcml6b250YWxQb3NpdGlvbi54LCBcbiAgICAgICAgY3VycmVudFBvc2l0aW9uLnkgKyBkZWx0YVBvc2l0aW9uLnksIC8vIEFsbG93IHZlcnRpY2FsIG1vdmVtZW50IChqdW1waW5nLCBmYWxsaW5nKVxuICAgICAgICBuZXdIb3Jpem9udGFsUG9zaXRpb24uelxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBpbGxhckNvbGxpc2lvbi5oYXNDb2xsaXNpb24pIHtcbiAgICAgIC8vIEhhbmRsZSBwaWxsYXIgY29sbGlzaW9uIHdpdGggc21vb3RoIHNsaWRpbmdcbiAgICAgIGNvbnN0IHNsaWRlUG9zaXRpb24gPSB0aGlzLmNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uLCBkZWx0YVBvc2l0aW9uLCBwaWxsYXJDb2xsaXNpb24pO1xuICAgICAgdHJhbnNmb3JtLnNldFBvc2l0aW9uKHNsaWRlUG9zaXRpb24ueCwgc2xpZGVQb3NpdGlvbi55LCBzbGlkZVBvc2l0aW9uLnopO1xuICAgICAgXG4gICAgICAvLyBSZWR1Y2UgdmVsb2NpdHkgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGlsbGFyIHRvIHByZXZlbnQgYm91bmNpbmdcbiAgICAgIGNvbnN0IHZlbG9jaXR5Tm9ybWFsQ29tcG9uZW50ID0gbW92ZW1lbnQudmVsb2NpdHkuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IocGlsbGFyQ29sbGlzaW9uLm5vcm1hbCk7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS5zdWIodmVsb2NpdHlOb3JtYWxDb21wb25lbnQubXVsdGlwbHlTY2FsYXIoMC41KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdpdGhpbiBib3VuZHMgYW5kIG5vIHBpbGxhciBjb2xsaXNpb24sIG1vdmUgbm9ybWFsbHlcbiAgICAgIHRyYW5zZm9ybS50cmFuc2xhdGUoZGVsdGFQb3NpdGlvbi54LCBkZWx0YVBvc2l0aW9uLnksIGRlbHRhUG9zaXRpb24ueik7XG4gICAgfVxuXG4gICAgLy8gTWFyayB0cmFuc2Zvcm0gbWF0cml4IGFzIG5lZWRpbmcgdXBkYXRlXG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIERlZmluZSBwaWxsYXIgcG9zaXRpb25zIChzYW1lIGFzIGluIEVudmlyb25tZW50LnRzeClcbiAgcHJpdmF0ZSByZWFkb25seSBQSUxMQVJfUE9TSVRJT05TID0gW1xuICAgIG5ldyBWZWN0b3IzKDAsIDAsIC01KSwgICAgICAgIC8vIEZyb250IHBpbGxhclxuICAgIG5ldyBWZWN0b3IzKC00LjI1LCAwLCAyLjUpLCAgIC8vIExlZnQgcGlsbGFyXG4gICAgbmV3IFZlY3RvcjMoNC4yNSwgMCwgMi41KSAgICAgLy8gUmlnaHQgcGlsbGFyXG4gIF07XG4gIHByaXZhdGUgcmVhZG9ubHkgUElMTEFSX1JBRElVUyA9IDAuNzsgLy8gU2FtZSBhcyBQaWxsYXJDb2xsaXNpb24udHN4XG5cbiAgcHJpdmF0ZSBjaGVja1BpbGxhckNvbGxpc2lvbihwb3NpdGlvbjogVmVjdG9yMyk6IHsgaGFzQ29sbGlzaW9uOiBib29sZWFuOyBub3JtYWw6IFZlY3RvcjM7IHBpbGxhckNlbnRlcjogVmVjdG9yMyB9IHtcbiAgICBmb3IgKGNvbnN0IHBpbGxhclBvcyBvZiB0aGlzLlBJTExBUl9QT1NJVElPTlMpIHtcbiAgICAgIC8vIE9ubHkgY2hlY2sgaG9yaXpvbnRhbCBkaXN0YW5jZSAoaWdub3JlIFkpXG4gICAgICBjb25zdCBob3Jpem9udGFsUG9zID0gbmV3IFZlY3RvcjMocG9zaXRpb24ueCwgMCwgcG9zaXRpb24ueik7XG4gICAgICBjb25zdCBwaWxsYXJIb3Jpem9udGFsID0gbmV3IFZlY3RvcjMocGlsbGFyUG9zLngsIDAsIHBpbGxhclBvcy56KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gaG9yaXpvbnRhbFBvcy5kaXN0YW5jZVRvKHBpbGxhckhvcml6b250YWwpO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2UgPCB0aGlzLlBJTExBUl9SQURJVVMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vcm1hbCB2ZWN0b3IgcG9pbnRpbmcgYXdheSBmcm9tIHBpbGxhciBjZW50ZXJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gaG9yaXpvbnRhbFBvcy5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlcmUgcGxheWVyIGlzIGV4YWN0bHkgYXQgcGlsbGFyIGNlbnRlclxuICAgICAgICBpZiAobm9ybWFsLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgICAgbm9ybWFsLnNldCgxLCAwLCAwKTsgLy8gRGVmYXVsdCBkaXJlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhhc0NvbGxpc2lvbjogdHJ1ZSxcbiAgICAgICAgICBub3JtYWw6IG5vcm1hbCxcbiAgICAgICAgICBwaWxsYXJDZW50ZXI6IHBpbGxhclBvcy5jbG9uZSgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGhhc0NvbGxpc2lvbjogZmFsc2UsIG5vcm1hbDogbmV3IFZlY3RvcjMoKSwgcGlsbGFyQ2VudGVyOiBuZXcgVmVjdG9yMygpIH07XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZVBpbGxhclNsaWRpbmcoY3VycmVudFBvc2l0aW9uOiBWZWN0b3IzLCBkZWx0YVBvc2l0aW9uOiBWZWN0b3IzLCBjb2xsaXNpb246IHsgbm9ybWFsOiBWZWN0b3IzOyBwaWxsYXJDZW50ZXI6IFZlY3RvcjMgfSk6IFZlY3RvcjMge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgdGFuZ2VudCB2ZWN0b3IgKHBlcnBlbmRpY3VsYXIgdG8gbm9ybWFsIGluIFhaIHBsYW5lKVxuICAgIGNvbnN0IHRhbmdlbnQgPSBuZXcgVmVjdG9yMygtY29sbGlzaW9uLm5vcm1hbC56LCAwLCBjb2xsaXNpb24ubm9ybWFsLngpO1xuICAgIFxuICAgIC8vIFByb2plY3QgdGhlIG1vdmVtZW50IHZlY3RvciBvbnRvIHRoZSB0YW5nZW50IGZvciBzbGlkaW5nXG4gICAgY29uc3QgdGFuZ2VudE1vdmVtZW50ID0gZGVsdGFQb3NpdGlvbi5jbG9uZSgpLnByb2plY3RPblZlY3Rvcih0YW5nZW50KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwb3NpdGlvbiB3aXRoIHNsaWRpbmcgbW92ZW1lbnRcbiAgICBjb25zdCBzbGlkZVBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uLmNsb25lKCkuYWRkKHRhbmdlbnRNb3ZlbWVudCk7XG4gICAgXG4gICAgLy8gRW5zdXJlIHdlIG1haW50YWluIG1pbmltdW0gZGlzdGFuY2UgZnJvbSBwaWxsYXIgY2VudGVyXG4gICAgY29uc3QgcGlsbGFySG9yaXpvbnRhbCA9IG5ldyBWZWN0b3IzKGNvbGxpc2lvbi5waWxsYXJDZW50ZXIueCwgMCwgY29sbGlzaW9uLnBpbGxhckNlbnRlci56KTtcbiAgICBjb25zdCBzbGlkZUhvcml6b250YWwgPSBuZXcgVmVjdG9yMyhzbGlkZVBvc2l0aW9uLngsIDAsIHNsaWRlUG9zaXRpb24ueik7XG4gICAgY29uc3QgZGlzdGFuY2VBZnRlclNsaWRlID0gc2xpZGVIb3Jpem9udGFsLmRpc3RhbmNlVG8ocGlsbGFySG9yaXpvbnRhbCk7XG4gICAgXG4gICAgaWYgKGRpc3RhbmNlQWZ0ZXJTbGlkZSA8IHRoaXMuUElMTEFSX1JBRElVUykge1xuICAgICAgLy8gUHVzaCB0aGUgcG9zaXRpb24gdG8gbWFpbnRhaW4gbWluaW11bSBkaXN0YW5jZVxuICAgICAgY29uc3QgcHVzaERpcmVjdGlvbiA9IHNsaWRlSG9yaXpvbnRhbC5jbG9uZSgpLnN1YihwaWxsYXJIb3Jpem9udGFsKS5ub3JtYWxpemUoKTtcbiAgICAgIGlmIChwdXNoRGlyZWN0aW9uLmxlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHB1c2hEaXJlY3Rpb24uc2V0KDEsIDAsIDApOyAvLyBEZWZhdWx0IGRpcmVjdGlvblxuICAgICAgfVxuICAgICAgY29uc3QgY29ycmVjdGVkSG9yaXpvbnRhbCA9IHBpbGxhckhvcml6b250YWwuY2xvbmUoKS5hZGQocHVzaERpcmVjdGlvbi5tdWx0aXBseVNjYWxhcih0aGlzLlBJTExBUl9SQURJVVMpKTtcbiAgICAgIHNsaWRlUG9zaXRpb24ueCA9IGNvcnJlY3RlZEhvcml6b250YWwueDtcbiAgICAgIHNsaWRlUG9zaXRpb24ueiA9IGNvcnJlY3RlZEhvcml6b250YWwuejtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNsaWRlUG9zaXRpb247XG4gIH1cblxuICBwcml2YXRlIGFwcGx5UGh5c2ljcyh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgbW92ZW1lbnQ6IE1vdmVtZW50LCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEFwcGx5IGdyYXZpdHkgKG9ubHkgYWZmZWN0cyBZIHZlbG9jaXR5KVxuICAgIG1vdmVtZW50LmFwcGx5R3Jhdml0eShkZWx0YVRpbWUpO1xuXG4gICAgLy8gSGFuZGxlIGhvcml6b250YWwgbW92ZW1lbnQgZGlyZWN0bHkgZm9yIGltbWVkaWF0ZSByZXNwb25zZVxuICAgIGlmIChtb3ZlbWVudC5pbnB1dFN0cmVuZ3RoID4gMCkge1xuICAgICAgLy8gVXNlIGVmZmVjdGl2ZSBtYXggc3BlZWQgd2hpY2ggYWNjb3VudHMgZm9yIGZyb3plbi9zbG93ZWQgc3RhdGVzXG4gICAgICBjb25zdCBlZmZlY3RpdmVNYXhTcGVlZCA9IG1vdmVtZW50LmdldEVmZmVjdGl2ZU1heFNwZWVkKCk7XG4gICAgICBcbiAgICAgIC8vIERpcmVjdCB2ZWxvY2l0eSBzZXR0aW5nIGZvciByZXNwb25zaXZlIG1vdmVtZW50XG4gICAgICBjb25zdCB0YXJnZXRWZWxvY2l0eSA9IG1vdmVtZW50Lm1vdmVEaXJlY3Rpb24uY2xvbmUoKTtcbiAgICAgIHRhcmdldFZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKGVmZmVjdGl2ZU1heFNwZWVkICogbW92ZW1lbnQuaW5wdXRTdHJlbmd0aCk7XG4gICAgICBcbiAgICAgIC8vIFNldCBob3Jpem9udGFsIHZlbG9jaXR5IGRpcmVjdGx5IChwcmVzZXJ2ZSBZIHZlbG9jaXR5IGZvciBncmF2aXR5L2p1bXBpbmcpXG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS54ID0gdGFyZ2V0VmVsb2NpdHkueDtcbiAgICAgIG1vdmVtZW50LnZlbG9jaXR5LnogPSB0YXJnZXRWZWxvY2l0eS56O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBpbnB1dCAtIHN0b3AgaG9yaXpvbnRhbCBtb3ZlbWVudCBpbW1lZGlhdGVseSBmb3IgcmVzcG9uc2l2ZSBjb250cm9sc1xuICAgICAgbW92ZW1lbnQudmVsb2NpdHkueCA9IDA7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS56ID0gMDtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhbnkgYWRkaXRpb25hbCBmb3JjZXMgKGxpa2Uga25vY2tiYWNrLCB3aW5kLCBldGMuKVxuICAgIG1vdmVtZW50LnZlbG9jaXR5LmFkZChtb3ZlbWVudC5hY2NlbGVyYXRpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpKTtcblxuICAgIC8vIFJlc2V0IGFjY2VsZXJhdGlvbiBmb3IgbmV4dCBmcmFtZVxuICAgIG1vdmVtZW50LmFjY2VsZXJhdGlvbi5zZXQoMCwgMCwgMCk7XG5cbiAgICAvLyBTaW1wbGUgZ3JvdW5kIGNoZWNrIChZID0gMCBpcyBncm91bmQgbGV2ZWwsIGFjY291bnQgZm9yIHNwaGVyZSByYWRpdXMpXG4gICAgY29uc3Qgc3BoZXJlUmFkaXVzID0gMC41OyAvLyBQbGF5ZXIgc3BoZXJlIHJhZGl1c1xuICAgIGNvbnN0IGdyb3VuZExldmVsID0gc3BoZXJlUmFkaXVzOyAvLyBTcGhlcmUgY2VudGVyIHNob3VsZCBiZSBhdCByYWRpdXMgaGVpZ2h0IGFib3ZlIGdyb3VuZFxuICAgIFxuICAgIGlmICh0cmFuc2Zvcm0ucG9zaXRpb24ueSA8PSBncm91bmRMZXZlbCAmJiBtb3ZlbWVudC52ZWxvY2l0eS55IDw9IDApIHtcbiAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi55ID0gZ3JvdW5kTGV2ZWw7XG4gICAgICBtb3ZlbWVudC52ZWxvY2l0eS55ID0gMDtcbiAgICAgIG1vdmVtZW50LmlzR3JvdW5kZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb3ZlbWVudC5pc0dyb3VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlBoeXNpY3NTeXN0ZW0iLCJCYXNlUGh5c2ljc1N5c3RlbSIsIlRyYW5zZm9ybSIsIk1vdmVtZW50IiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJtb3ZlbWVudCIsImVuYWJsZWQiLCJjYW5Nb3ZlIiwidXBkYXRlRGVidWZmcyIsImNvbnNvbGUiLCJ3YXJuIiwidXBkYXRlTW92ZW1lbnQiLCJmaXhlZFVwZGF0ZSIsImZpeGVkRGVsdGFUaW1lIiwiYXBwbHlQaHlzaWNzIiwiZGVsdGFQb3NpdGlvbiIsInZlbG9jaXR5IiwiY2xvbmUiLCJtdWx0aXBseVNjYWxhciIsImN1cnJlbnRQb3NpdGlvbiIsInBvc2l0aW9uIiwicG90ZW50aWFsUG9zaXRpb24iLCJhZGQiLCJNQVBfUkFESVVTIiwiaG9yaXpvbnRhbFBvc2l0aW9uIiwieCIsInoiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJsZW5ndGgiLCJwaWxsYXJDb2xsaXNpb24iLCJjaGVja1BpbGxhckNvbGxpc2lvbiIsImN1cnJlbnRIb3Jpem9udGFsUG9zIiwidG9DZW50ZXIiLCJub3JtYWxpemUiLCJ0YW5nZW50IiwiaG9yaXpvbnRhbE1vdmVtZW50IiwidGFuZ2VudE1vdmVtZW50IiwiZG90IiwibmV3SG9yaXpvbnRhbFBvc2l0aW9uIiwic2V0UG9zaXRpb24iLCJ5IiwiaGFzQ29sbGlzaW9uIiwic2xpZGVQb3NpdGlvbiIsImNhbGN1bGF0ZVBpbGxhclNsaWRpbmciLCJ2ZWxvY2l0eU5vcm1hbENvbXBvbmVudCIsInByb2plY3RPblZlY3RvciIsIm5vcm1hbCIsInN1YiIsInRyYW5zbGF0ZSIsIm1hdHJpeE5lZWRzVXBkYXRlIiwicGlsbGFyUG9zIiwiUElMTEFSX1BPU0lUSU9OUyIsImhvcml6b250YWxQb3MiLCJwaWxsYXJIb3Jpem9udGFsIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiUElMTEFSX1JBRElVUyIsInNldCIsInBpbGxhckNlbnRlciIsImNvbGxpc2lvbiIsInNsaWRlSG9yaXpvbnRhbCIsImRpc3RhbmNlQWZ0ZXJTbGlkZSIsInB1c2hEaXJlY3Rpb24iLCJjb3JyZWN0ZWRIb3Jpem9udGFsIiwiYXBwbHlHcmF2aXR5IiwiaW5wdXRTdHJlbmd0aCIsImVmZmVjdGl2ZU1heFNwZWVkIiwiZ2V0RWZmZWN0aXZlTWF4U3BlZWQiLCJ0YXJnZXRWZWxvY2l0eSIsIm1vdmVEaXJlY3Rpb24iLCJhY2NlbGVyYXRpb24iLCJzcGhlcmVSYWRpdXMiLCJncm91bmRMZXZlbCIsImlzR3JvdW5kZWQiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/PhysicsSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/ProjectileSystem.ts":
/*!*****************************************!*\
  !*** ./src/systems/ProjectileSystem.ts ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProjectileSystem: function() { return /* binding */ ProjectileSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Projectile */ \"(app-pages-browser)/./src/ecs/components/Projectile.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n/* harmony import */ var _ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/ecs/components/Enemy */ \"(app-pages-browser)/./src/ecs/components/Enemy.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// Projectile system for handling projectile movement and collisions\n\n\n\n\n\n\n\n\n\nclass ProjectileSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setCombatSystem(combatSystem) {\n        this.combatSystem = combatSystem;\n    }\n    update(entities, deltaTime) {\n        this.projectilesToDestroy.length = 0;\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n            if (!transform.enabled || !projectile.enabled) {\n                continue;\n            }\n            // Update projectile\n            projectile.update(deltaTime);\n            // Check if projectile has expired\n            if (projectile.isExpired()) {\n                this.projectilesToDestroy.push(entity.id);\n                continue;\n            }\n            // Move projectile\n            this.moveProjectile(transform, projectile, deltaTime);\n            // Arrow orientation is set once at creation - no need to update every frame\n            // this.updateArrowOrientation(entity, projectile);\n            // Check collisions\n            this.checkCollisions(entity, transform, projectile);\n            // Check world boundaries\n            this.checkWorldBounds(entity, transform);\n        }\n        // Destroy expired projectiles\n        for (const entityId of this.projectilesToDestroy){\n            this.world.destroyEntity(entityId);\n        }\n    }\n    moveProjectile(transform, projectile, deltaTime) {\n        // Use temp vector to avoid allocations\n        this.tempVector.copy(projectile.velocity).multiplyScalar(deltaTime);\n        // Update position\n        transform.translate(this.tempVector.x, this.tempVector.y, this.tempVector.z);\n        transform.matrixNeedsUpdate = true;\n    }\n    checkCollisions(projectileEntity, transform, projectile) {\n        const projectilePos = transform.position;\n        // Get all entities that could be hit - specifically look for enemies with colliders\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider\n        ]);\n        // Early exit if no targets\n        if (potentialTargets.length === 0) return;\n        for (const target of potentialTargets){\n            // Skip self and owner\n            if (target.id === projectileEntity.id || target.id === projectile.owner) {\n                // Debug logging for owner collision prevention\n                if (target.id === projectile.owner) {\n                    console.log(\"\\uD83D\\uDEAB Projectile \".concat(projectileEntity.id, \" skipping owner \").concat(projectile.owner, \" (target \").concat(target.id, \")\"));\n                }\n                continue;\n            }\n            // Skip if already hit and not piercing\n            if (!projectile.canHitTarget(target.id)) {\n                continue;\n            }\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n            // Skip if target is dead\n            if (targetHealth.isDead) {\n                continue;\n            }\n            // Check if projectile can hit this target (layer-based collision)\n            // In PVP mode, projectiles can hit both ENEMY (remote players) and PLAYER (local player) layers\n            if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.ENEMY && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER) {\n                continue;\n            }\n            // Additional safety check: prevent projectiles from hitting their owner in PVP mode\n            // This is a backup check in case the owner comparison above fails\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PLAYER && target.id === projectile.owner) {\n                console.log(\"\\uD83D\\uDEAB Extra safety: Projectile \".concat(projectileEntity.id, \" prevented from hitting owner \").concat(projectile.owner, \" (PVP mode)\"));\n                continue;\n            }\n            const targetPos = targetTransform.getWorldPosition();\n            // Use collider radius for more accurate collision detection\n            const projectileRadius = 0.2; // Increased from 0.1 for more forgiving collision detection\n            const targetRadius = targetCollider.radius;\n            // Use squared distance for performance (avoid sqrt)\n            const distanceSquared = projectilePos.distanceToSquared(targetPos);\n            const collisionRadiusSquared = (projectileRadius + targetRadius) ** 2;\n            if (distanceSquared <= collisionRadiusSquared) {\n                this.handleHit(projectileEntity, target, projectile, targetHealth);\n                // If not piercing, destroy projectile\n                if (!projectile.piercing) {\n                    this.projectilesToDestroy.push(projectileEntity.id);\n                    break;\n                }\n            }\n        }\n    }\n    handleHit(projectileEntity, target, projectile, targetHealth) {\n        // Mark target as hit\n        projectile.addHitTarget(target.id);\n        // Deal damage through combat system if available, otherwise directly\n        if (this.combatSystem) {\n            var _renderer_mesh_userData, _renderer_mesh, _renderer_mesh_userData1, _renderer_mesh1;\n            // Check projectile type for special damage handling\n            const renderer = projectileEntity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n            const isCrossentropyBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh = renderer.mesh) === null || _renderer_mesh === void 0 ? void 0 : (_renderer_mesh_userData = _renderer_mesh.userData) === null || _renderer_mesh_userData === void 0 ? void 0 : _renderer_mesh_userData.isCrossentropyBolt;\n            const isEntropicBolt = renderer === null || renderer === void 0 ? void 0 : (_renderer_mesh1 = renderer.mesh) === null || _renderer_mesh1 === void 0 ? void 0 : (_renderer_mesh_userData1 = _renderer_mesh1.userData) === null || _renderer_mesh_userData1 === void 0 ? void 0 : _renderer_mesh_userData1.isEntropicBolt;\n            let damageType = \"projectile\";\n            if (isCrossentropyBolt) {\n                damageType = \"crossentropy\";\n            } else if (isEntropicBolt) {\n                damageType = \"entropic\";\n            }\n            // Debug logging\n            if (isCrossentropyBolt) {\n                console.log(\"\\uD83D\\uDFE2 CrossEntropy bolt hit detected, using green damage numbers\");\n            } else if (isEntropicBolt) {\n                console.log(\"⚡ Entropic bolt hit detected, using green damage numbers\");\n            }\n            this.combatSystem.queueDamage(target, projectile.damage, projectileEntity, damageType);\n        } else {\n            // Fallback to direct damage (pass entity for shield absorption)\n            const currentTime = Date.now() / 1000;\n            const damageDealt = targetHealth.takeDamage(projectile.damage, currentTime, target);\n            if (damageDealt) {\n                const enemy = target.getComponent(_ecs_components_Enemy__WEBPACK_IMPORTED_MODULE_7__.Enemy);\n                const targetName = enemy ? enemy.getDisplayName() : \"Entity \".concat(target.id);\n                console.log(\"\\uD83D\\uDCA5 Bone Arrow hit \".concat(targetName, \" for \").concat(projectile.damage, \" damage (\").concat(targetHealth.currentHealth, \"/\").concat(targetHealth.maxHealth, \" HP)\"));\n            }\n        }\n        // Handle explosion if explosive\n        if (projectile.explosionRadius > 0) {\n            this.handleExplosion(projectileEntity, projectile);\n        }\n    }\n    handleExplosion(projectileEntity, projectile) {\n        const projectileTransform = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const explosionCenter = projectileTransform.position;\n        // Emit explosion event for visual effects\n        this.world.emitEvent(\"explosion\", {\n            position: explosionCenter.clone(),\n            color: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Color(\"#00ff44\"),\n            size: projectile.explosionRadius,\n            duration: 0.5\n        });\n        // Find all entities within explosion radius\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health\n        ]);\n        for (const target of potentialTargets){\n            if (target.id === projectile.owner) continue; // Don't damage owner\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_4__.Health);\n            const distance = explosionCenter.distanceTo(targetTransform.position);\n            if (distance <= projectile.explosionRadius) {\n                // Calculate damage falloff based on distance\n                const damageFalloff = 1 - distance / projectile.explosionRadius;\n                const explosionDamage = Math.floor(projectile.damage * damageFalloff);\n                if (explosionDamage > 0) {\n                    const currentTime = Date.now() / 1000;\n                    targetHealth.takeDamage(explosionDamage, currentTime, target);\n                    console.log(\"\\uD83D\\uDCA5 Explosion hit target \".concat(target.id, \" for \").concat(explosionDamage, \" damage\"));\n                }\n            }\n        }\n    }\n    checkWorldBounds(entity, transform) {\n        const pos = transform.position;\n        const maxDistance = 40; // Maximum distance from origin\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Check if projectile is too far from origin (using squared distance)\n        if (pos.lengthSq() > maxDistanceSquared) {\n            this.projectilesToDestroy.push(entity.id);\n            return; // Early exit\n        }\n        // Check if projectile is below ground (simple ground check)\n        if (pos.y < -10) {\n            this.projectilesToDestroy.push(entity.id);\n        }\n    }\n    // Utility method to create a ChargedArrow projectile for fully charged bow\n    createChargedArrowProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with charged arrow-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 35; // Faster than regular arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 25; // Higher damage than regular arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for ChargedArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a ChargedArrow for special handling\n        placeholderMesh.userData.isChargedArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        return projectileEntity;\n    }\n    // Utility method to create a CrossentropyBolt projectile for scythe\n    createCrossentropyBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with scythe-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 15; // Slower than arrows\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 30; // Higher damage than arrows\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 10; // Longer lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for CrossentropyBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.28, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 2,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a CrossentropyBolt for special handling\n        placeholderMesh.userData.isCrossentropyBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n            console.warn(\"⚠️ Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        console.log(\"⚔️ Created CrossentropyBolt projectile \".concat(projectileEntity.id, \" at\"), position, \"moving\", direction);\n        console.log(\"\\uD83D\\uDCCA Active projectiles: \".concat(this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ]).length));\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create an EntropicBolt projectile for scythe left click\n    createEntropicBoltProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component with EntropicBolt-specific settings\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20; // Faster than CrossentropyBolt\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 20; // EntropicBolt damage\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 8; // Shorter lifetime\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for EntropicBolt\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 6, 6);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#00ff44\",\n            emissive: \"#00ff44\",\n            emissiveIntensity: 1.5,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as an EntropicBolt for special handling\n        placeholderMesh.userData.isEntropicBolt = true;\n        placeholderMesh.userData.projectileEntity = projectileEntity;\n        placeholderMesh.userData.direction = direction.clone();\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false);\n        } else {\n            console.warn(\"⚠️ Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        console.log(\"⚡ Created EntropicBolt projectile \".concat(projectileEntity.id, \" at\"), position, \"moving\", direction);\n        console.log(\"\\uD83D\\uDCCA Active projectiles: \".concat(this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ]).length));\n        // Notify systems that the entity is ready\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Utility method to create a projectile\n    createProjectile(world, position, direction, ownerId, config) {\n        const projectileEntity = world.createEntity();\n        // Add Transform component\n        const transform = world.createComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        transform.position.copy(position);\n        projectileEntity.addComponent(transform);\n        // Add Projectile component\n        const projectile = world.createComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        projectile.speed = (config === null || config === void 0 ? void 0 : config.speed) || 20;\n        projectile.damage = (config === null || config === void 0 ? void 0 : config.damage) || 5; // Set default damage to 5 as requested\n        projectile.maxLifetime = (config === null || config === void 0 ? void 0 : config.lifetime) || 5;\n        projectile.owner = ownerId;\n        projectile.setDirection(direction);\n        if (config === null || config === void 0 ? void 0 : config.piercing) projectile.setPiercing(true);\n        if ((config === null || config === void 0 ? void 0 : config.explosive) && (config === null || config === void 0 ? void 0 : config.explosionRadius)) {\n            projectile.setExplosive(config.explosionRadius);\n        }\n        projectileEntity.addComponent(projectile);\n        // Add Renderer component - we'll use a special marker for RegularArrow\n        const renderer = world.createComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_5__.Renderer);\n        // Create a simple placeholder mesh that will be replaced by the React component\n        const placeholderGeometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry(0.15, 8, 8);\n        const placeholderMaterial = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: \"#ffaa00\",\n            emissive: \"#ffaa00\",\n            emissiveIntensity: 3,\n            transparent: true,\n            opacity: 0.1 // Very low opacity since React component will handle visuals\n        });\n        const placeholderMesh = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh(placeholderGeometry, placeholderMaterial);\n        // Mark this as a RegularArrow for special handling\n        placeholderMesh.userData.isRegularArrow = true;\n        placeholderMesh.userData.direction = direction.clone();\n        placeholderMesh.userData.subclass = config === null || config === void 0 ? void 0 : config.subclass;\n        placeholderMesh.userData.level = config === null || config === void 0 ? void 0 : config.level;\n        placeholderMesh.userData.opacity = (config === null || config === void 0 ? void 0 : config.opacity) || 1.0;\n        renderer.mesh = placeholderMesh;\n        // Set shadow casting with safety check\n        if (typeof renderer.setCastShadow === \"function\") {\n            renderer.setCastShadow(false); // Projectiles don't need to cast shadows\n        } else {\n            console.warn(\"⚠️ Renderer component missing setCastShadow method:\", renderer);\n        }\n        projectileEntity.addComponent(renderer);\n        // Add Collider component\n        const collider = world.createComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.Collider);\n        collider.radius = 0.15;\n        collider.layer = _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_6__.CollisionLayer.PROJECTILE;\n        projectileEntity.addComponent(collider);\n        console.log(\"\\uD83D\\uDE80 Created projectile \".concat(projectileEntity.id, \" at\"), position, \"moving\", direction, \"(owner: \".concat(ownerId, \")\"));\n        console.log(\"\\uD83D\\uDCCA Active projectiles: \".concat(this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ]).length));\n        // Notify systems that the entity is ready (this will trigger RenderSystem.onEntityAdded)\n        this.world.notifyEntityAdded(projectileEntity);\n        return projectileEntity;\n    }\n    // Clean up projectile resources when entity is removed\n    onEntityRemoved(entity) {\n        const projectile = entity.getComponent(_ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile);\n        if (projectile) {\n            console.log(\"\\uD83D\\uDCA5 Destroying projectile \".concat(entity.id, \" (lifetime: \").concat(projectile.lifetime.toFixed(2), \"s)\"));\n            console.log(\"\\uD83D\\uDCCA Remaining projectiles: \".concat(this.world.queryEntities([\n                _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n                _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n            ]).length - 1));\n        }\n    // No special cleanup needed for RegularArrow - React components handle their own lifecycle\n    }\n    // Get pool statistics for debugging\n    getPoolStats() {\n        return {\n            vector3: this.vector3Pool.getPoolSize()\n        };\n    }\n    // Dispose of all pools when system is destroyed\n    onDisable() {\n        console.log(\"\\uD83E\\uDDF9 Cleaning up ProjectileSystem pools:\", this.getPoolStats());\n        this.vector3Pool.clear();\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Projectile__WEBPACK_IMPORTED_MODULE_3__.Projectile\n        ];\n        this.combatSystem = null;\n        this.projectilesToDestroy = [];\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 20; // Run after movement\n        // Initialize vector pool for calculations\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_8__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 100);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLG9FQUFvRTtBQUMrQjtBQUM3RDtBQUVpQjtBQUNFO0FBQ1I7QUFDSTtBQUNnQjtBQUN0QjtBQUVDO0FBTXpDLE1BQU1jLHlCQUF5QlQsK0NBQU1BO0lBOEJuQ1UsZ0JBQWdCQyxZQUEwQixFQUFRO1FBQ3ZELElBQUksQ0FBQ0EsWUFBWSxHQUFHQTtJQUN0QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELElBQUksQ0FBQ0Msb0JBQW9CLENBQUNDLE1BQU0sR0FBRztRQUVuQyxLQUFLLE1BQU1DLFVBQVVKLFNBQVU7WUFDN0IsTUFBTUssWUFBWUQsT0FBT0UsWUFBWSxDQUFDbEIsZ0VBQVNBO1lBQy9DLE1BQU1tQixhQUFhSCxPQUFPRSxZQUFZLENBQUNqQixrRUFBVUE7WUFFakQsSUFBSSxDQUFDZ0IsVUFBVUcsT0FBTyxJQUFJLENBQUNELFdBQVdDLE9BQU8sRUFBRTtnQkFDN0M7WUFDRjtZQUVBLG9CQUFvQjtZQUNwQkQsV0FBV1IsTUFBTSxDQUFDRTtZQUVsQixrQ0FBa0M7WUFDbEMsSUFBSU0sV0FBV0UsU0FBUyxJQUFJO2dCQUMxQixJQUFJLENBQUNQLG9CQUFvQixDQUFDUSxJQUFJLENBQUNOLE9BQU9PLEVBQUU7Z0JBQ3hDO1lBQ0Y7WUFFQSxrQkFBa0I7WUFDbEIsSUFBSSxDQUFDQyxjQUFjLENBQUNQLFdBQVdFLFlBQVlOO1lBRTNDLDRFQUE0RTtZQUM1RSxtREFBbUQ7WUFFbkQsbUJBQW1CO1lBQ25CLElBQUksQ0FBQ1ksZUFBZSxDQUFDVCxRQUFRQyxXQUFXRTtZQUV4Qyx5QkFBeUI7WUFDekIsSUFBSSxDQUFDTyxnQkFBZ0IsQ0FBQ1YsUUFBUUM7UUFDaEM7UUFFQSw4QkFBOEI7UUFDOUIsS0FBSyxNQUFNVSxZQUFZLElBQUksQ0FBQ2Isb0JBQW9CLENBQUU7WUFDaEQsSUFBSSxDQUFDYyxLQUFLLENBQUNDLGFBQWEsQ0FBQ0Y7UUFDM0I7SUFDRjtJQUVRSCxlQUFlUCxTQUFvQixFQUFFRSxVQUFzQixFQUFFTixTQUFpQixFQUFRO1FBQzVGLHVDQUF1QztRQUN2QyxJQUFJLENBQUNpQixVQUFVLENBQUNDLElBQUksQ0FBQ1osV0FBV2EsUUFBUSxFQUFFQyxjQUFjLENBQUNwQjtRQUV6RCxrQkFBa0I7UUFDbEJJLFVBQVVpQixTQUFTLENBQUMsSUFBSSxDQUFDSixVQUFVLENBQUNLLENBQUMsRUFBRSxJQUFJLENBQUNMLFVBQVUsQ0FBQ00sQ0FBQyxFQUFFLElBQUksQ0FBQ04sVUFBVSxDQUFDTyxDQUFDO1FBQzNFcEIsVUFBVXFCLGlCQUFpQixHQUFHO0lBQ2hDO0lBSVFiLGdCQUFnQmMsZ0JBQXdCLEVBQUV0QixTQUFvQixFQUFFRSxVQUFzQixFQUFRO1FBQ3BHLE1BQU1xQixnQkFBZ0J2QixVQUFVd0IsUUFBUTtRQUV4QyxvRkFBb0Y7UUFDcEYsTUFBTUMsbUJBQW1CLElBQUksQ0FBQ2QsS0FBSyxDQUFDZSxhQUFhLENBQUM7WUFBQzNDLGdFQUFTQTtZQUFFRSwwREFBTUE7WUFBRUUsOERBQVFBO1NBQUM7UUFFL0UsMkJBQTJCO1FBQzNCLElBQUlzQyxpQkFBaUIzQixNQUFNLEtBQUssR0FBRztRQUVuQyxLQUFLLE1BQU02QixVQUFVRixpQkFBa0I7WUFDckMsc0JBQXNCO1lBQ3RCLElBQUlFLE9BQU9yQixFQUFFLEtBQUtnQixpQkFBaUJoQixFQUFFLElBQUlxQixPQUFPckIsRUFBRSxLQUFLSixXQUFXMEIsS0FBSyxFQUFFO2dCQUN2RSwrQ0FBK0M7Z0JBQy9DLElBQUlELE9BQU9yQixFQUFFLEtBQUtKLFdBQVcwQixLQUFLLEVBQUU7b0JBQ2xDQyxRQUFRQyxHQUFHLENBQUMsMkJBQXVENUIsT0FBdENvQixpQkFBaUJoQixFQUFFLEVBQUMsb0JBQThDcUIsT0FBNUJ6QixXQUFXMEIsS0FBSyxFQUFDLGFBQXFCLE9BQVZELE9BQU9yQixFQUFFLEVBQUM7Z0JBQzNHO2dCQUNBO1lBQ0Y7WUFFQSx1Q0FBdUM7WUFDdkMsSUFBSSxDQUFDSixXQUFXNkIsWUFBWSxDQUFDSixPQUFPckIsRUFBRSxHQUFHO2dCQUN2QztZQUNGO1lBRUEsTUFBTTBCLGtCQUFrQkwsT0FBTzFCLFlBQVksQ0FBQ2xCLGdFQUFTQTtZQUNyRCxNQUFNa0QsZUFBZU4sT0FBTzFCLFlBQVksQ0FBQ2hCLDBEQUFNQTtZQUMvQyxNQUFNaUQsaUJBQWlCUCxPQUFPMUIsWUFBWSxDQUFDZCw4REFBUUE7WUFFbkQseUJBQXlCO1lBQ3pCLElBQUk4QyxhQUFhRSxNQUFNLEVBQUU7Z0JBQ3ZCO1lBQ0Y7WUFFQSxrRUFBa0U7WUFDbEUsZ0dBQWdHO1lBQ2hHLElBQUlELGVBQWVFLEtBQUssS0FBS2hELG9FQUFjQSxDQUFDaUQsS0FBSyxJQUFJSCxlQUFlRSxLQUFLLEtBQUtoRCxvRUFBY0EsQ0FBQ2tELE1BQU0sRUFBRTtnQkFDbkc7WUFDRjtZQUVBLG9GQUFvRjtZQUNwRixrRUFBa0U7WUFDbEUsSUFBSUosZUFBZUUsS0FBSyxLQUFLaEQsb0VBQWNBLENBQUNrRCxNQUFNLElBQUlYLE9BQU9yQixFQUFFLEtBQUtKLFdBQVcwQixLQUFLLEVBQUU7Z0JBQ3BGQyxRQUFRQyxHQUFHLENBQUMseUNBQW1GNUIsT0FBcERvQixpQkFBaUJoQixFQUFFLEVBQUMsa0NBQWlELE9BQWpCSixXQUFXMEIsS0FBSyxFQUFDO2dCQUNoSDtZQUNGO1lBRUEsTUFBTVcsWUFBWVAsZ0JBQWdCUSxnQkFBZ0I7WUFFbEQsNERBQTREO1lBQzVELE1BQU1DLG1CQUFtQixLQUFLLDREQUE0RDtZQUMxRixNQUFNQyxlQUFlUixlQUFlUyxNQUFNO1lBRTFDLG9EQUFvRDtZQUNwRCxNQUFNQyxrQkFBa0JyQixjQUFjc0IsaUJBQWlCLENBQUNOO1lBQ3hELE1BQU1PLHlCQUF5QixDQUFDTCxtQkFBbUJDLFlBQVcsS0FBTTtZQUVwRSxJQUFJRSxtQkFBbUJFLHdCQUF3QjtnQkFDN0MsSUFBSSxDQUFDQyxTQUFTLENBQUN6QixrQkFBa0JLLFFBQVF6QixZQUFZK0I7Z0JBRXJELHNDQUFzQztnQkFDdEMsSUFBSSxDQUFDL0IsV0FBVzhDLFFBQVEsRUFBRTtvQkFDeEIsSUFBSSxDQUFDbkQsb0JBQW9CLENBQUNRLElBQUksQ0FBQ2lCLGlCQUFpQmhCLEVBQUU7b0JBQ2xEO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRVF5QyxVQUNOekIsZ0JBQXdCLEVBQ3hCSyxNQUFjLEVBQ2R6QixVQUFzQixFQUN0QitCLFlBQW9CLEVBQ2Q7UUFDTixxQkFBcUI7UUFDckIvQixXQUFXK0MsWUFBWSxDQUFDdEIsT0FBT3JCLEVBQUU7UUFFakMscUVBQXFFO1FBQ3JFLElBQUksSUFBSSxDQUFDYixZQUFZLEVBQUU7Z0JBR015RCx5QkFBQUEsZ0JBQ0pBLDBCQUFBQTtZQUh2QixvREFBb0Q7WUFDcEQsTUFBTUEsV0FBVzVCLGlCQUFpQnJCLFlBQVksQ0FBQ2YsOERBQVFBO1lBQ3ZELE1BQU1pRSxxQkFBcUJELHFCQUFBQSxnQ0FBQUEsaUJBQUFBLFNBQVVFLElBQUksY0FBZEYsc0NBQUFBLDBCQUFBQSxlQUFnQkcsUUFBUSxjQUF4QkgsOENBQUFBLHdCQUEwQkMsa0JBQWtCO1lBQ3ZFLE1BQU1HLGlCQUFpQkoscUJBQUFBLGdDQUFBQSxrQkFBQUEsU0FBVUUsSUFBSSxjQUFkRix1Q0FBQUEsMkJBQUFBLGdCQUFnQkcsUUFBUSxjQUF4QkgsK0NBQUFBLHlCQUEwQkksY0FBYztZQUUvRCxJQUFJQyxhQUFhO1lBQ2pCLElBQUlKLG9CQUFvQjtnQkFDdEJJLGFBQWE7WUFDZixPQUFPLElBQUlELGdCQUFnQjtnQkFDekJDLGFBQWE7WUFDZjtZQUVBLGdCQUFnQjtZQUNoQixJQUFJSixvQkFBb0I7Z0JBQ3RCdEIsUUFBUUMsR0FBRyxDQUFDO1lBQ2QsT0FBTyxJQUFJd0IsZ0JBQWdCO2dCQUN6QnpCLFFBQVFDLEdBQUcsQ0FBQztZQUNkO1lBRUEsSUFBSSxDQUFDckMsWUFBWSxDQUFDK0QsV0FBVyxDQUFDN0IsUUFBUXpCLFdBQVd1RCxNQUFNLEVBQUVuQyxrQkFBa0JpQztRQUM3RSxPQUFPO1lBQ0wsZ0VBQWdFO1lBQ2hFLE1BQU1HLGNBQWNDLEtBQUtDLEdBQUcsS0FBSztZQUNqQyxNQUFNQyxjQUFjNUIsYUFBYTZCLFVBQVUsQ0FBQzVELFdBQVd1RCxNQUFNLEVBQUVDLGFBQWEvQjtZQUU1RSxJQUFJa0MsYUFBYTtnQkFDZixNQUFNRSxRQUFRcEMsT0FBTzFCLFlBQVksQ0FBQ1osd0RBQUtBO2dCQUN2QyxNQUFNMkUsYUFBYUQsUUFBUUEsTUFBTUUsY0FBYyxLQUFLLFVBQW9CLE9BQVZ0QyxPQUFPckIsRUFBRTtnQkFDdkV1QixRQUFRQyxHQUFHLENBQUMsK0JBQXVDNUIsT0FBbEI4RCxZQUFXLFNBQW9DL0IsT0FBN0IvQixXQUFXdUQsTUFBTSxFQUFDLGFBQXlDeEIsT0FBOUJBLGFBQWFpQyxhQUFhLEVBQUMsS0FBMEIsT0FBdkJqQyxhQUFha0MsU0FBUyxFQUFDO1lBQ3ZJO1FBQ0Y7UUFFQSxnQ0FBZ0M7UUFDaEMsSUFBSWpFLFdBQVdrRSxlQUFlLEdBQUcsR0FBRztZQUNsQyxJQUFJLENBQUNDLGVBQWUsQ0FBQy9DLGtCQUFrQnBCO1FBQ3pDO0lBQ0Y7SUFFUW1FLGdCQUFnQi9DLGdCQUF3QixFQUFFcEIsVUFBc0IsRUFBUTtRQUM5RSxNQUFNb0Usc0JBQXNCaEQsaUJBQWlCckIsWUFBWSxDQUFDbEIsZ0VBQVNBO1FBQ25FLE1BQU13RixrQkFBa0JELG9CQUFvQjlDLFFBQVE7UUFFcEQsMENBQTBDO1FBQzFDLElBQUksQ0FBQ2IsS0FBSyxDQUFDNkQsU0FBUyxDQUFDLGFBQWE7WUFDaENoRCxVQUFVK0MsZ0JBQWdCRSxLQUFLO1lBQy9CQyxPQUFPLElBQUloRyx1REFBS0EsQ0FBQztZQUNqQmlHLE1BQU16RSxXQUFXa0UsZUFBZTtZQUNoQ1EsVUFBVTtRQUNaO1FBRUEsNENBQTRDO1FBQzVDLE1BQU1uRCxtQkFBbUIsSUFBSSxDQUFDZCxLQUFLLENBQUNlLGFBQWEsQ0FBQztZQUFDM0MsZ0VBQVNBO1lBQUVFLDBEQUFNQTtTQUFDO1FBRXJFLEtBQUssTUFBTTBDLFVBQVVGLGlCQUFrQjtZQUNyQyxJQUFJRSxPQUFPckIsRUFBRSxLQUFLSixXQUFXMEIsS0FBSyxFQUFFLFVBQVUscUJBQXFCO1lBRW5FLE1BQU1JLGtCQUFrQkwsT0FBTzFCLFlBQVksQ0FBQ2xCLGdFQUFTQTtZQUNyRCxNQUFNa0QsZUFBZU4sT0FBTzFCLFlBQVksQ0FBQ2hCLDBEQUFNQTtZQUMvQyxNQUFNNEYsV0FBV04sZ0JBQWdCTyxVQUFVLENBQUM5QyxnQkFBZ0JSLFFBQVE7WUFFcEUsSUFBSXFELFlBQVkzRSxXQUFXa0UsZUFBZSxFQUFFO2dCQUMxQyw2Q0FBNkM7Z0JBQzdDLE1BQU1XLGdCQUFnQixJQUFLRixXQUFXM0UsV0FBV2tFLGVBQWU7Z0JBQ2hFLE1BQU1ZLGtCQUFrQkMsS0FBS0MsS0FBSyxDQUFDaEYsV0FBV3VELE1BQU0sR0FBR3NCO2dCQUV2RCxJQUFJQyxrQkFBa0IsR0FBRztvQkFDdkIsTUFBTXRCLGNBQWNDLEtBQUtDLEdBQUcsS0FBSztvQkFDakMzQixhQUFhNkIsVUFBVSxDQUFDa0IsaUJBQWlCdEIsYUFBYS9CO29CQUN0REUsUUFBUUMsR0FBRyxDQUFDLHFDQUE0Q2tELE9BQWpCckQsT0FBT3JCLEVBQUUsRUFBQyxTQUF1QixPQUFoQjBFLGlCQUFnQjtnQkFDMUU7WUFDRjtRQUNGO0lBQ0Y7SUFFUXZFLGlCQUFpQlYsTUFBYyxFQUFFQyxTQUFvQixFQUFRO1FBQ25FLE1BQU1tRixNQUFNbkYsVUFBVXdCLFFBQVE7UUFDOUIsTUFBTTRELGNBQWMsSUFBSSwrQkFBK0I7UUFDdkQsTUFBTUMscUJBQXFCRCxjQUFjQTtRQUV6QyxzRUFBc0U7UUFDdEUsSUFBSUQsSUFBSUcsUUFBUSxLQUFLRCxvQkFBb0I7WUFDdkMsSUFBSSxDQUFDeEYsb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtZQUN4QyxRQUFRLGFBQWE7UUFDdkI7UUFFQSw0REFBNEQ7UUFDNUQsSUFBSTZFLElBQUloRSxDQUFDLEdBQUcsQ0FBQyxJQUFJO1lBQ2YsSUFBSSxDQUFDdEIsb0JBQW9CLENBQUNRLElBQUksQ0FBQ04sT0FBT08sRUFBRTtRQUMxQztJQUNGO0lBRUEsMkVBQTJFO0lBQ3BFaUYsNkJBQ0w1RSxLQUFZLEVBQ1phLFFBQWlCLEVBQ2pCZ0UsU0FBa0IsRUFDbEJDLE9BQWUsRUFDZkMsTUFVQyxFQUNPO1FBQ1IsTUFBTXBFLG1CQUFtQlgsTUFBTWdGLFlBQVk7UUFFM0MsMEJBQTBCO1FBQzFCLE1BQU0zRixZQUFZVyxNQUFNaUYsZUFBZSxDQUFDN0csZ0VBQVNBO1FBQ2pEaUIsVUFBVXdCLFFBQVEsQ0FBQ1YsSUFBSSxDQUFDVTtRQUN4QkYsaUJBQWlCdUUsWUFBWSxDQUFDN0Y7UUFFOUIsZ0VBQWdFO1FBQ2hFLE1BQU1FLGFBQWFTLE1BQU1pRixlQUFlLENBQUM1RyxrRUFBVUE7UUFDbkRrQixXQUFXNEYsS0FBSyxHQUFHSixDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFJLEtBQUssS0FBSSxJQUFJLDZCQUE2QjtRQUNyRTVGLFdBQVd1RCxNQUFNLEdBQUdpQyxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFqQyxNQUFNLEtBQUksSUFBSSxvQ0FBb0M7UUFDOUV2RCxXQUFXNkYsV0FBVyxHQUFHTCxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFNLFFBQVEsS0FBSSxHQUFHLGtCQUFrQjtRQUNsRTlGLFdBQVcwQixLQUFLLEdBQUc2RDtRQUNuQnZGLFdBQVcrRixZQUFZLENBQUNUO1FBRXhCLElBQUlFLG1CQUFBQSw2QkFBQUEsT0FBUTFDLFFBQVEsRUFBRTlDLFdBQVdnRyxXQUFXLENBQUM7UUFDN0MsSUFBSVIsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRUyxTQUFTLE1BQUlULG1CQUFBQSw2QkFBQUEsT0FBUXRCLGVBQWUsR0FBRTtZQUNoRGxFLFdBQVdrRyxZQUFZLENBQUNWLE9BQU90QixlQUFlO1FBQ2hEO1FBRUE5QyxpQkFBaUJ1RSxZQUFZLENBQUMzRjtRQUU5Qix1RUFBdUU7UUFDdkUsTUFBTWdELFdBQVd2QyxNQUFNaUYsZUFBZSxDQUFDMUcsOERBQVFBO1FBRS9DLGdGQUFnRjtRQUNoRixNQUFNbUgsc0JBQXNCLElBQUkxSCxnRUFBY0EsQ0FBQyxNQUFNLEdBQUc7UUFDeEQsTUFBTTJILHNCQUFzQixJQUFJMUgsc0VBQW9CQSxDQUFDO1lBQ25EOEYsT0FBTztZQUNQNkIsVUFBVTtZQUNWQyxtQkFBbUI7WUFDbkJDLGFBQWE7WUFDYkMsU0FBUyxJQUFJLDZEQUE2RDtRQUM1RTtRQUNBLE1BQU1DLGtCQUFrQixJQUFJOUgsc0RBQUlBLENBQUN3SCxxQkFBcUJDO1FBRXRELG1EQUFtRDtRQUNuREssZ0JBQWdCdEQsUUFBUSxDQUFDdUQsY0FBYyxHQUFHO1FBQzFDRCxnQkFBZ0J0RCxRQUFRLENBQUNtQyxTQUFTLEdBQUdBLFVBQVVmLEtBQUs7UUFDcERrQyxnQkFBZ0J0RCxRQUFRLENBQUN3RCxRQUFRLEdBQUduQixtQkFBQUEsNkJBQUFBLE9BQVFtQixRQUFRO1FBQ3BERixnQkFBZ0J0RCxRQUFRLENBQUN5RCxLQUFLLEdBQUdwQixtQkFBQUEsNkJBQUFBLE9BQVFvQixLQUFLO1FBQzlDSCxnQkFBZ0J0RCxRQUFRLENBQUNxRCxPQUFPLEdBQUdoQixDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFnQixPQUFPLEtBQUk7UUFFdER4RCxTQUFTRSxJQUFJLEdBQUd1RDtRQUNoQnJGLGlCQUFpQnVFLFlBQVksQ0FBQzNDO1FBRTlCLHlCQUF5QjtRQUN6QixNQUFNNkQsV0FBV3BHLE1BQU1pRixlQUFlLENBQUN6Ryw4REFBUUE7UUFDL0M0SCxTQUFTcEUsTUFBTSxHQUFHO1FBQ2xCb0UsU0FBUzNFLEtBQUssR0FBR2hELG9FQUFjQSxDQUFDNEgsVUFBVTtRQUMxQzFGLGlCQUFpQnVFLFlBQVksQ0FBQ2tCO1FBRTlCLE9BQU96RjtJQUNUO0lBRUEsb0VBQW9FO0lBQzdEMkYsaUNBQ0x0RyxLQUFZLEVBQ1phLFFBQWlCLEVBQ2pCZ0UsU0FBa0IsRUFDbEJDLE9BQWUsRUFDZkMsTUFVQyxFQUNPO1FBQ1IsTUFBTXBFLG1CQUFtQlgsTUFBTWdGLFlBQVk7UUFFM0MsMEJBQTBCO1FBQzFCLE1BQU0zRixZQUFZVyxNQUFNaUYsZUFBZSxDQUFDN0csZ0VBQVNBO1FBQ2pEaUIsVUFBVXdCLFFBQVEsQ0FBQ1YsSUFBSSxDQUFDVTtRQUN4QkYsaUJBQWlCdUUsWUFBWSxDQUFDN0Y7UUFFOUIseURBQXlEO1FBQ3pELE1BQU1FLGFBQWFTLE1BQU1pRixlQUFlLENBQUM1RyxrRUFBVUE7UUFDbkRrQixXQUFXNEYsS0FBSyxHQUFHSixDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFJLEtBQUssS0FBSSxJQUFJLHFCQUFxQjtRQUM3RDVGLFdBQVd1RCxNQUFNLEdBQUdpQyxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFqQyxNQUFNLEtBQUksSUFBSSw0QkFBNEI7UUFDdEV2RCxXQUFXNkYsV0FBVyxHQUFHTCxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFNLFFBQVEsS0FBSSxJQUFJLGtCQUFrQjtRQUNuRTlGLFdBQVcwQixLQUFLLEdBQUc2RDtRQUNuQnZGLFdBQVcrRixZQUFZLENBQUNUO1FBRXhCLElBQUlFLG1CQUFBQSw2QkFBQUEsT0FBUTFDLFFBQVEsRUFBRTlDLFdBQVdnRyxXQUFXLENBQUM7UUFDN0MsSUFBSVIsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRUyxTQUFTLE1BQUlULG1CQUFBQSw2QkFBQUEsT0FBUXRCLGVBQWUsR0FBRTtZQUNoRGxFLFdBQVdrRyxZQUFZLENBQUNWLE9BQU90QixlQUFlO1FBQ2hEO1FBRUE5QyxpQkFBaUJ1RSxZQUFZLENBQUMzRjtRQUU5QiwyRUFBMkU7UUFDM0UsTUFBTWdELFdBQVd2QyxNQUFNaUYsZUFBZSxDQUFDMUcsOERBQVFBO1FBRS9DLGdGQUFnRjtRQUNoRixNQUFNbUgsc0JBQXNCLElBQUkxSCxnRUFBY0EsQ0FBQyxNQUFNLEdBQUc7UUFDeEQsTUFBTTJILHNCQUFzQixJQUFJMUgsc0VBQW9CQSxDQUFDO1lBQ25EOEYsT0FBTztZQUNQNkIsVUFBVTtZQUNWQyxtQkFBbUI7WUFDbkJDLGFBQWE7WUFDYkMsU0FBUyxJQUFJLDZEQUE2RDtRQUM1RTtRQUNBLE1BQU1DLGtCQUFrQixJQUFJOUgsc0RBQUlBLENBQUN3SCxxQkFBcUJDO1FBRXRELHVEQUF1RDtRQUN2REssZ0JBQWdCdEQsUUFBUSxDQUFDRixrQkFBa0IsR0FBRztRQUM5Q3dELGdCQUFnQnRELFFBQVEsQ0FBQy9CLGdCQUFnQixHQUFHQTtRQUM1Q3FGLGdCQUFnQnRELFFBQVEsQ0FBQ21DLFNBQVMsR0FBR0EsVUFBVWYsS0FBSztRQUVwRHZCLFNBQVNFLElBQUksR0FBR3VEO1FBRWhCLHVDQUF1QztRQUN2QyxJQUFJLE9BQU96RCxTQUFTZ0UsYUFBYSxLQUFLLFlBQVk7WUFDaERoRSxTQUFTZ0UsYUFBYSxDQUFDO1FBQ3pCLE9BQU87WUFDTHJGLFFBQVFzRixJQUFJLENBQUMsdURBQXVEakU7UUFDdEU7UUFFQTVCLGlCQUFpQnVFLFlBQVksQ0FBQzNDO1FBRTlCckIsUUFBUUMsR0FBRyxDQUFDLDBDQUE4RCxPQUFwQlIsaUJBQWlCaEIsRUFBRSxFQUFDLFFBQU1rQixVQUFVLFVBQVVnRTtRQUNwRzNELFFBQVFDLEdBQUcsQ0FBQyxvQ0FBbUYsT0FBekQsSUFBSSxDQUFDbkIsS0FBSyxDQUFDZSxhQUFhLENBQUM7WUFBQzNDLGdFQUFTQTtZQUFFQyxrRUFBVUE7U0FBQyxFQUFFYyxNQUFNO1FBRTlGLDBDQUEwQztRQUMxQyxJQUFJLENBQUNhLEtBQUssQ0FBQ3lHLGlCQUFpQixDQUFDOUY7UUFFN0IsT0FBT0E7SUFDVDtJQUVBLDRFQUE0RTtJQUNyRStGLDZCQUNMMUcsS0FBWSxFQUNaYSxRQUFpQixFQUNqQmdFLFNBQWtCLEVBQ2xCQyxPQUFlLEVBQ2ZDLE1BVUMsRUFDTztRQUNSLE1BQU1wRSxtQkFBbUJYLE1BQU1nRixZQUFZO1FBRTNDLDBCQUEwQjtRQUMxQixNQUFNM0YsWUFBWVcsTUFBTWlGLGVBQWUsQ0FBQzdHLGdFQUFTQTtRQUNqRGlCLFVBQVV3QixRQUFRLENBQUNWLElBQUksQ0FBQ1U7UUFDeEJGLGlCQUFpQnVFLFlBQVksQ0FBQzdGO1FBRTlCLCtEQUErRDtRQUMvRCxNQUFNRSxhQUFhUyxNQUFNaUYsZUFBZSxDQUFDNUcsa0VBQVVBO1FBQ25Ea0IsV0FBVzRGLEtBQUssR0FBR0osQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRSSxLQUFLLEtBQUksSUFBSSwrQkFBK0I7UUFDdkU1RixXQUFXdUQsTUFBTSxHQUFHaUMsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRakMsTUFBTSxLQUFJLElBQUksc0JBQXNCO1FBQ2hFdkQsV0FBVzZGLFdBQVcsR0FBR0wsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRTSxRQUFRLEtBQUksR0FBRyxtQkFBbUI7UUFDbkU5RixXQUFXMEIsS0FBSyxHQUFHNkQ7UUFDbkJ2RixXQUFXK0YsWUFBWSxDQUFDVDtRQUV4QixJQUFJRSxtQkFBQUEsNkJBQUFBLE9BQVExQyxRQUFRLEVBQUU5QyxXQUFXZ0csV0FBVyxDQUFDO1FBQzdDLElBQUlSLENBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUVMsU0FBUyxNQUFJVCxtQkFBQUEsNkJBQUFBLE9BQVF0QixlQUFlLEdBQUU7WUFDaERsRSxXQUFXa0csWUFBWSxDQUFDVixPQUFPdEIsZUFBZTtRQUNoRDtRQUVBOUMsaUJBQWlCdUUsWUFBWSxDQUFDM0Y7UUFFOUIsdUVBQXVFO1FBQ3ZFLE1BQU1nRCxXQUFXdkMsTUFBTWlGLGVBQWUsQ0FBQzFHLDhEQUFRQTtRQUUvQyxnRkFBZ0Y7UUFDaEYsTUFBTW1ILHNCQUFzQixJQUFJMUgsZ0VBQWNBLENBQUMsTUFBTSxHQUFHO1FBQ3hELE1BQU0ySCxzQkFBc0IsSUFBSTFILHNFQUFvQkEsQ0FBQztZQUNuRDhGLE9BQU87WUFDUDZCLFVBQVU7WUFDVkMsbUJBQW1CO1lBQ25CQyxhQUFhO1lBQ2JDLFNBQVMsSUFBSSw2REFBNkQ7UUFDNUU7UUFDQSxNQUFNQyxrQkFBa0IsSUFBSTlILHNEQUFJQSxDQUFDd0gscUJBQXFCQztRQUV0RCxvREFBb0Q7UUFDcERLLGdCQUFnQnRELFFBQVEsQ0FBQ0MsY0FBYyxHQUFHO1FBQzFDcUQsZ0JBQWdCdEQsUUFBUSxDQUFDL0IsZ0JBQWdCLEdBQUdBO1FBQzVDcUYsZ0JBQWdCdEQsUUFBUSxDQUFDbUMsU0FBUyxHQUFHQSxVQUFVZixLQUFLO1FBRXBEdkIsU0FBU0UsSUFBSSxHQUFHdUQ7UUFFaEIsdUNBQXVDO1FBQ3ZDLElBQUksT0FBT3pELFNBQVNnRSxhQUFhLEtBQUssWUFBWTtZQUNoRGhFLFNBQVNnRSxhQUFhLENBQUM7UUFDekIsT0FBTztZQUNMckYsUUFBUXNGLElBQUksQ0FBQyx1REFBdURqRTtRQUN0RTtRQUVBNUIsaUJBQWlCdUUsWUFBWSxDQUFDM0M7UUFFOUJyQixRQUFRQyxHQUFHLENBQUMscUNBQXlELE9BQXBCUixpQkFBaUJoQixFQUFFLEVBQUMsUUFBTWtCLFVBQVUsVUFBVWdFO1FBQy9GM0QsUUFBUUMsR0FBRyxDQUFDLG9DQUFtRixPQUF6RCxJQUFJLENBQUNuQixLQUFLLENBQUNlLGFBQWEsQ0FBQztZQUFDM0MsZ0VBQVNBO1lBQUVDLGtFQUFVQTtTQUFDLEVBQUVjLE1BQU07UUFFOUYsMENBQTBDO1FBQzFDLElBQUksQ0FBQ2EsS0FBSyxDQUFDeUcsaUJBQWlCLENBQUM5RjtRQUU3QixPQUFPQTtJQUNUO0lBRUEsd0NBQXdDO0lBQ2pDZ0csaUJBQ0wzRyxLQUFZLEVBQ1phLFFBQWlCLEVBQ2pCZ0UsU0FBa0IsRUFDbEJDLE9BQWUsRUFDZkMsTUFVQyxFQUNPO1FBQ1IsTUFBTXBFLG1CQUFtQlgsTUFBTWdGLFlBQVk7UUFFM0MsMEJBQTBCO1FBQzFCLE1BQU0zRixZQUFZVyxNQUFNaUYsZUFBZSxDQUFDN0csZ0VBQVNBO1FBQ2pEaUIsVUFBVXdCLFFBQVEsQ0FBQ1YsSUFBSSxDQUFDVTtRQUN4QkYsaUJBQWlCdUUsWUFBWSxDQUFDN0Y7UUFFOUIsMkJBQTJCO1FBQzNCLE1BQU1FLGFBQWFTLE1BQU1pRixlQUFlLENBQUM1RyxrRUFBVUE7UUFDbkRrQixXQUFXNEYsS0FBSyxHQUFHSixDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFJLEtBQUssS0FBSTtRQUNwQzVGLFdBQVd1RCxNQUFNLEdBQUdpQyxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFqQyxNQUFNLEtBQUksR0FBRyx1Q0FBdUM7UUFDaEZ2RCxXQUFXNkYsV0FBVyxHQUFHTCxDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFNLFFBQVEsS0FBSTtRQUM3QzlGLFdBQVcwQixLQUFLLEdBQUc2RDtRQUNuQnZGLFdBQVcrRixZQUFZLENBQUNUO1FBRXhCLElBQUlFLG1CQUFBQSw2QkFBQUEsT0FBUTFDLFFBQVEsRUFBRTlDLFdBQVdnRyxXQUFXLENBQUM7UUFDN0MsSUFBSVIsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRUyxTQUFTLE1BQUlULG1CQUFBQSw2QkFBQUEsT0FBUXRCLGVBQWUsR0FBRTtZQUNoRGxFLFdBQVdrRyxZQUFZLENBQUNWLE9BQU90QixlQUFlO1FBQ2hEO1FBRUE5QyxpQkFBaUJ1RSxZQUFZLENBQUMzRjtRQUU5Qix1RUFBdUU7UUFDdkUsTUFBTWdELFdBQVd2QyxNQUFNaUYsZUFBZSxDQUFDMUcsOERBQVFBO1FBRS9DLGdGQUFnRjtRQUNoRixNQUFNbUgsc0JBQXNCLElBQUkxSCxnRUFBY0EsQ0FBQyxNQUFNLEdBQUc7UUFDeEQsTUFBTTJILHNCQUFzQixJQUFJMUgsc0VBQW9CQSxDQUFDO1lBQ25EOEYsT0FBTztZQUNQNkIsVUFBVTtZQUNWQyxtQkFBbUI7WUFDbkJDLGFBQWE7WUFDYkMsU0FBUyxJQUFJLDZEQUE2RDtRQUM1RTtRQUNBLE1BQU1DLGtCQUFrQixJQUFJOUgsc0RBQUlBLENBQUN3SCxxQkFBcUJDO1FBRXRELG1EQUFtRDtRQUNuREssZ0JBQWdCdEQsUUFBUSxDQUFDa0UsY0FBYyxHQUFHO1FBQzFDWixnQkFBZ0J0RCxRQUFRLENBQUNtQyxTQUFTLEdBQUdBLFVBQVVmLEtBQUs7UUFDcERrQyxnQkFBZ0J0RCxRQUFRLENBQUN3RCxRQUFRLEdBQUduQixtQkFBQUEsNkJBQUFBLE9BQVFtQixRQUFRO1FBQ3BERixnQkFBZ0J0RCxRQUFRLENBQUN5RCxLQUFLLEdBQUdwQixtQkFBQUEsNkJBQUFBLE9BQVFvQixLQUFLO1FBQzlDSCxnQkFBZ0J0RCxRQUFRLENBQUNxRCxPQUFPLEdBQUdoQixDQUFBQSxtQkFBQUEsNkJBQUFBLE9BQVFnQixPQUFPLEtBQUk7UUFFdER4RCxTQUFTRSxJQUFJLEdBQUd1RDtRQUVoQix1Q0FBdUM7UUFDdkMsSUFBSSxPQUFPekQsU0FBU2dFLGFBQWEsS0FBSyxZQUFZO1lBQ2hEaEUsU0FBU2dFLGFBQWEsQ0FBQyxRQUFRLHlDQUF5QztRQUMxRSxPQUFPO1lBQ0xyRixRQUFRc0YsSUFBSSxDQUFDLHVEQUF1RGpFO1FBQ3RFO1FBRUE1QixpQkFBaUJ1RSxZQUFZLENBQUMzQztRQUU5Qix5QkFBeUI7UUFDekIsTUFBTTZELFdBQVdwRyxNQUFNaUYsZUFBZSxDQUFDekcsOERBQVFBO1FBQy9DNEgsU0FBU3BFLE1BQU0sR0FBRztRQUNsQm9FLFNBQVMzRSxLQUFLLEdBQUdoRCxvRUFBY0EsQ0FBQzRILFVBQVU7UUFDMUMxRixpQkFBaUJ1RSxZQUFZLENBQUNrQjtRQUU5QmxGLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBNkMsT0FBcEJSLGlCQUFpQmhCLEVBQUUsRUFBQyxRQUFNa0IsVUFBVSxVQUFVZ0UsV0FBVyxXQUFtQixPQUFSQyxTQUFRO1FBQ2pINUQsUUFBUUMsR0FBRyxDQUFDLG9DQUFtRixPQUF6RCxJQUFJLENBQUNuQixLQUFLLENBQUNlLGFBQWEsQ0FBQztZQUFDM0MsZ0VBQVNBO1lBQUVDLGtFQUFVQTtTQUFDLEVBQUVjLE1BQU07UUFFOUYseUZBQXlGO1FBQ3pGLElBQUksQ0FBQ2EsS0FBSyxDQUFDeUcsaUJBQWlCLENBQUM5RjtRQUU3QixPQUFPQTtJQUNUO0lBRUEsdURBQXVEO0lBQ2hEa0csZ0JBQWdCekgsTUFBYyxFQUFRO1FBQzNDLE1BQU1HLGFBQWFILE9BQU9FLFlBQVksQ0FBQ2pCLGtFQUFVQTtRQUNqRCxJQUFJa0IsWUFBWTtZQUNkMkIsUUFBUUMsR0FBRyxDQUFDLHNDQUFvRDVCLE9BQXhCSCxPQUFPTyxFQUFFLEVBQUMsZ0JBQTZDLE9BQS9CSixXQUFXOEYsUUFBUSxDQUFDeUIsT0FBTyxDQUFDLElBQUc7WUFDL0Y1RixRQUFRQyxHQUFHLENBQUMsdUNBQTBGLE9BQTdELElBQUksQ0FBQ25CLEtBQUssQ0FBQ2UsYUFBYSxDQUFDO2dCQUFDM0MsZ0VBQVNBO2dCQUFFQyxrRUFBVUE7YUFBQyxFQUFFYyxNQUFNLEdBQUc7UUFDdEc7SUFFQSwyRkFBMkY7SUFDN0Y7SUFFQSxvQ0FBb0M7SUFDN0I0SCxlQUVMO1FBQ0EsT0FBTztZQUNMQyxTQUFTLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxXQUFXO1FBQ3ZDO0lBQ0Y7SUFFQSxnREFBZ0Q7SUFDekNDLFlBQWtCO1FBQ3ZCakcsUUFBUUMsR0FBRyxDQUFDLG9EQUEwQyxJQUFJLENBQUM0RixZQUFZO1FBQ3ZFLElBQUksQ0FBQ0UsV0FBVyxDQUFDRyxLQUFLO0lBQ3hCO0lBcmtCQUMsWUFBWXJILEtBQVksQ0FBRTtRQUN4QixLQUFLO2FBZlNzSCxxQkFBcUI7WUFBQ2xKLGdFQUFTQTtZQUFFQyxrRUFBVUE7U0FBQzthQUVwRFMsZUFBb0M7YUFDcENJLHVCQUFpQyxFQUFFO1FBTzNDLHlDQUF5QzthQUNqQ2dCLGFBQWEsSUFBSXBDLHlEQUFPQTthQUN4QnlKLGNBQWMsSUFBSXpKLHlEQUFPQTtRQUkvQixJQUFJLENBQUNrQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDd0gsUUFBUSxHQUFHLElBQUkscUJBQXFCO1FBSXpDLDBDQUEwQztRQUMxQyxJQUFJLENBQUNQLFdBQVcsR0FBRyxJQUFJdEkseURBQVVBLENBQy9CLElBQU0sSUFBSWIseURBQU9BLElBQ2pCLENBQUMySixTQUFXQSxPQUFPQyxHQUFHLENBQUMsR0FBRyxHQUFHLElBQzdCO0lBRUo7QUF5akJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1Byb2plY3RpbGVTeXN0ZW0udHM/MDBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcm9qZWN0aWxlIHN5c3RlbSBmb3IgaGFuZGxpbmcgcHJvamVjdGlsZSBtb3ZlbWVudCBhbmQgY29sbGlzaW9uc1xuaW1wb3J0IHsgVmVjdG9yMywgQ29sb3IsIFNwaGVyZUdlb21ldHJ5LCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgTWVzaCB9IGZyb20gJ0AvdXRpbHMvdGhyZWUtZXhwb3J0cyc7XG5pbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IFByb2plY3RpbGUgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1Byb2plY3RpbGUnO1xuaW1wb3J0IHsgSGVhbHRoIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9IZWFsdGgnO1xuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1JlbmRlcmVyJztcbmltcG9ydCB7IENvbGxpZGVyLCBDb2xsaXNpb25MYXllciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvQ29sbGlkZXInO1xuaW1wb3J0IHsgRW5lbXkgfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0VuZW15JztcbmltcG9ydCB7IFdvcmxkIH0gZnJvbSAnQC9lY3MvV29ybGQnO1xuaW1wb3J0IHsgT2JqZWN0UG9vbCB9IGZyb20gJ0AvdXRpbHMvT2JqZWN0UG9vbCc7XG5cbmltcG9ydCB7IFdlYXBvblN1YmNsYXNzIH0gZnJvbSAnQC9jb21wb25lbnRzL2RyYWdvbi93ZWFwb25zJztcbmltcG9ydCB7IENvbWJhdFN5c3RlbSB9IGZyb20gJy4vQ29tYmF0U3lzdGVtJztcbmltcG9ydCBDcm9zc2VudHJvcHlCb2x0IGZyb20gJ0AvY29tcG9uZW50cy9wcm9qZWN0aWxlcy9Dcm9zc2VudHJvcHlCb2x0JztcblxuZXhwb3J0IGNsYXNzIFByb2plY3RpbGVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgUHJvamVjdGlsZV07XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIGNvbWJhdFN5c3RlbTogQ29tYmF0U3lzdGVtIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcHJvamVjdGlsZXNUb0Rlc3Ryb3k6IG51bWJlcltdID0gW107XG4gIFxuXG4gIFxuICAvLyBPYmplY3QgcG9vbHMgZm9yIHBlcmZvcm1hbmNlIChrZWVwaW5nIHZlY3RvciBwb29sIGZvciBjYWxjdWxhdGlvbnMpXG4gIHByaXZhdGUgdmVjdG9yM1Bvb2w6IE9iamVjdFBvb2w8VmVjdG9yMz47XG4gIFxuICAvLyBSZXVzYWJsZSBvYmplY3RzIHRvIHJlZHVjZSBhbGxvY2F0aW9uc1xuICBwcml2YXRlIHRlbXBWZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICBwcml2YXRlIHRlbXBWZWN0b3IyID0gbmV3IFZlY3RvcjMoKTtcblxuICBjb25zdHJ1Y3Rvcih3b3JsZDogV29ybGQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgICB0aGlzLnByaW9yaXR5ID0gMjA7IC8vIFJ1biBhZnRlciBtb3ZlbWVudFxuICAgIFxuXG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB2ZWN0b3IgcG9vbCBmb3IgY2FsY3VsYXRpb25zXG4gICAgdGhpcy52ZWN0b3IzUG9vbCA9IG5ldyBPYmplY3RQb29sKFxuICAgICAgKCkgPT4gbmV3IFZlY3RvcjMoKSxcbiAgICAgICh2ZWN0b3IpID0+IHZlY3Rvci5zZXQoMCwgMCwgMCksXG4gICAgICAxMDBcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHNldENvbWJhdFN5c3RlbShjb21iYXRTeXN0ZW06IENvbWJhdFN5c3RlbSk6IHZvaWQge1xuICAgIHRoaXMuY29tYmF0U3lzdGVtID0gY29tYmF0U3lzdGVtO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5W10sIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5sZW5ndGggPSAwO1xuXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCBwcm9qZWN0aWxlID0gZW50aXR5LmdldENvbXBvbmVudChQcm9qZWN0aWxlKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXByb2plY3RpbGUuZW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHByb2plY3RpbGVcbiAgICAgIHByb2plY3RpbGUudXBkYXRlKGRlbHRhVGltZSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHByb2plY3RpbGUgaGFzIGV4cGlyZWRcbiAgICAgIGlmIChwcm9qZWN0aWxlLmlzRXhwaXJlZCgpKSB7XG4gICAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTW92ZSBwcm9qZWN0aWxlXG4gICAgICB0aGlzLm1vdmVQcm9qZWN0aWxlKHRyYW5zZm9ybSwgcHJvamVjdGlsZSwgZGVsdGFUaW1lKTtcblxuICAgICAgLy8gQXJyb3cgb3JpZW50YXRpb24gaXMgc2V0IG9uY2UgYXQgY3JlYXRpb24gLSBubyBuZWVkIHRvIHVwZGF0ZSBldmVyeSBmcmFtZVxuICAgICAgLy8gdGhpcy51cGRhdGVBcnJvd09yaWVudGF0aW9uKGVudGl0eSwgcHJvamVjdGlsZSk7XG5cbiAgICAgIC8vIENoZWNrIGNvbGxpc2lvbnNcbiAgICAgIHRoaXMuY2hlY2tDb2xsaXNpb25zKGVudGl0eSwgdHJhbnNmb3JtLCBwcm9qZWN0aWxlKTtcblxuICAgICAgLy8gQ2hlY2sgd29ybGQgYm91bmRhcmllc1xuICAgICAgdGhpcy5jaGVja1dvcmxkQm91bmRzKGVudGl0eSwgdHJhbnNmb3JtKTtcbiAgICB9XG5cbiAgICAvLyBEZXN0cm95IGV4cGlyZWQgcHJvamVjdGlsZXNcbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kpIHtcbiAgICAgIHRoaXMud29ybGQuZGVzdHJveUVudGl0eShlbnRpdHlJZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBtb3ZlUHJvamVjdGlsZSh0cmFuc2Zvcm06IFRyYW5zZm9ybSwgcHJvamVjdGlsZTogUHJvamVjdGlsZSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVc2UgdGVtcCB2ZWN0b3IgdG8gYXZvaWQgYWxsb2NhdGlvbnNcbiAgICB0aGlzLnRlbXBWZWN0b3IuY29weShwcm9qZWN0aWxlLnZlbG9jaXR5KS5tdWx0aXBseVNjYWxhcihkZWx0YVRpbWUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwb3NpdGlvblxuICAgIHRyYW5zZm9ybS50cmFuc2xhdGUodGhpcy50ZW1wVmVjdG9yLngsIHRoaXMudGVtcFZlY3Rvci55LCB0aGlzLnRlbXBWZWN0b3Iueik7XG4gICAgdHJhbnNmb3JtLm1hdHJpeE5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfVxuXG5cblxuICBwcml2YXRlIGNoZWNrQ29sbGlzaW9ucyhwcm9qZWN0aWxlRW50aXR5OiBFbnRpdHksIHRyYW5zZm9ybTogVHJhbnNmb3JtLCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKTogdm9pZCB7XG4gICAgY29uc3QgcHJvamVjdGlsZVBvcyA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcblxuICAgIC8vIEdldCBhbGwgZW50aXRpZXMgdGhhdCBjb3VsZCBiZSBoaXQgLSBzcGVjaWZpY2FsbHkgbG9vayBmb3IgZW5lbWllcyB3aXRoIGNvbGxpZGVyc1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuXG4gICAgLy8gRWFybHkgZXhpdCBpZiBubyB0YXJnZXRzXG4gICAgaWYgKHBvdGVudGlhbFRhcmdldHMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICAvLyBTa2lwIHNlbGYgYW5kIG93bmVyXG4gICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlRW50aXR5LmlkIHx8IHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikge1xuICAgICAgICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBvd25lciBjb2xsaXNpb24gcHJldmVudGlvblxuICAgICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfmqsgUHJvamVjdGlsZSAke3Byb2plY3RpbGVFbnRpdHkuaWR9IHNraXBwaW5nIG93bmVyICR7cHJvamVjdGlsZS5vd25lcn0gKHRhcmdldCAke3RhcmdldC5pZH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBoaXQgYW5kIG5vdCBwaWVyY2luZ1xuICAgICAgaWYgKCFwcm9qZWN0aWxlLmNhbkhpdFRhcmdldCh0YXJnZXQuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXJnZXRUcmFuc2Zvcm0gPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpITtcbiAgICAgIGNvbnN0IHRhcmdldENvbGxpZGVyID0gdGFyZ2V0LmdldENvbXBvbmVudChDb2xsaWRlcikhO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGlmIHRhcmdldCBpcyBkZWFkXG4gICAgICBpZiAodGFyZ2V0SGVhbHRoLmlzRGVhZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBjYW4gaGl0IHRoaXMgdGFyZ2V0IChsYXllci1iYXNlZCBjb2xsaXNpb24pXG4gICAgICAvLyBJbiBQVlAgbW9kZSwgcHJvamVjdGlsZXMgY2FuIGhpdCBib3RoIEVORU1ZIChyZW1vdGUgcGxheWVycykgYW5kIFBMQVlFUiAobG9jYWwgcGxheWVyKSBsYXllcnNcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciAhPT0gQ29sbGlzaW9uTGF5ZXIuRU5FTVkgJiYgdGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLlBMQVlFUikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkaXRpb25hbCBzYWZldHkgY2hlY2s6IHByZXZlbnQgcHJvamVjdGlsZXMgZnJvbSBoaXR0aW5nIHRoZWlyIG93bmVyIGluIFBWUCBtb2RlXG4gICAgICAvLyBUaGlzIGlzIGEgYmFja3VwIGNoZWNrIGluIGNhc2UgdGhlIG93bmVyIGNvbXBhcmlzb24gYWJvdmUgZmFpbHNcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSICYmIHRhcmdldC5pZCA9PT0gcHJvamVjdGlsZS5vd25lcikge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+aqyBFeHRyYSBzYWZldHk6IFByb2plY3RpbGUgJHtwcm9qZWN0aWxlRW50aXR5LmlkfSBwcmV2ZW50ZWQgZnJvbSBoaXR0aW5nIG93bmVyICR7cHJvamVjdGlsZS5vd25lcn0gKFBWUCBtb2RlKWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGFyZ2V0VHJhbnNmb3JtLmdldFdvcmxkUG9zaXRpb24oKTtcblxuICAgICAgLy8gVXNlIGNvbGxpZGVyIHJhZGl1cyBmb3IgbW9yZSBhY2N1cmF0ZSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICBjb25zdCBwcm9qZWN0aWxlUmFkaXVzID0gMC4yOyAvLyBJbmNyZWFzZWQgZnJvbSAwLjEgZm9yIG1vcmUgZm9yZ2l2aW5nIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgIGNvbnN0IHRhcmdldFJhZGl1cyA9IHRhcmdldENvbGxpZGVyLnJhZGl1cztcblxuICAgICAgLy8gVXNlIHNxdWFyZWQgZGlzdGFuY2UgZm9yIHBlcmZvcm1hbmNlIChhdm9pZCBzcXJ0KVxuICAgICAgY29uc3QgZGlzdGFuY2VTcXVhcmVkID0gcHJvamVjdGlsZVBvcy5kaXN0YW5jZVRvU3F1YXJlZCh0YXJnZXRQb3MpO1xuICAgICAgY29uc3QgY29sbGlzaW9uUmFkaXVzU3F1YXJlZCA9IChwcm9qZWN0aWxlUmFkaXVzICsgdGFyZ2V0UmFkaXVzKSAqKiAyO1xuICAgICAgXG4gICAgICBpZiAoZGlzdGFuY2VTcXVhcmVkIDw9IGNvbGxpc2lvblJhZGl1c1NxdWFyZWQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVIaXQocHJvamVjdGlsZUVudGl0eSwgdGFyZ2V0LCBwcm9qZWN0aWxlLCB0YXJnZXRIZWFsdGgpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgbm90IHBpZXJjaW5nLCBkZXN0cm95IHByb2plY3RpbGVcbiAgICAgICAgaWYgKCFwcm9qZWN0aWxlLnBpZXJjaW5nKSB7XG4gICAgICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKHByb2plY3RpbGVFbnRpdHkuaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVIaXQoXG4gICAgcHJvamVjdGlsZUVudGl0eTogRW50aXR5LCBcbiAgICB0YXJnZXQ6IEVudGl0eSwgXG4gICAgcHJvamVjdGlsZTogUHJvamVjdGlsZSwgXG4gICAgdGFyZ2V0SGVhbHRoOiBIZWFsdGhcbiAgKTogdm9pZCB7XG4gICAgLy8gTWFyayB0YXJnZXQgYXMgaGl0XG4gICAgcHJvamVjdGlsZS5hZGRIaXRUYXJnZXQodGFyZ2V0LmlkKTtcblxuICAgIC8vIERlYWwgZGFtYWdlIHRocm91Z2ggY29tYmF0IHN5c3RlbSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBkaXJlY3RseVxuICAgIGlmICh0aGlzLmNvbWJhdFN5c3RlbSkge1xuICAgICAgLy8gQ2hlY2sgcHJvamVjdGlsZSB0eXBlIGZvciBzcGVjaWFsIGRhbWFnZSBoYW5kbGluZ1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSBwcm9qZWN0aWxlRW50aXR5LmdldENvbXBvbmVudChSZW5kZXJlcik7XG4gICAgICBjb25zdCBpc0Nyb3NzZW50cm9weUJvbHQgPSByZW5kZXJlcj8ubWVzaD8udXNlckRhdGE/LmlzQ3Jvc3NlbnRyb3B5Qm9sdDtcbiAgICAgIGNvbnN0IGlzRW50cm9waWNCb2x0ID0gcmVuZGVyZXI/Lm1lc2g/LnVzZXJEYXRhPy5pc0VudHJvcGljQm9sdDtcbiAgICAgIFxuICAgICAgbGV0IGRhbWFnZVR5cGUgPSAncHJvamVjdGlsZSc7XG4gICAgICBpZiAoaXNDcm9zc2VudHJvcHlCb2x0KSB7XG4gICAgICAgIGRhbWFnZVR5cGUgPSAnY3Jvc3NlbnRyb3B5JztcbiAgICAgIH0gZWxzZSBpZiAoaXNFbnRyb3BpY0JvbHQpIHtcbiAgICAgICAgZGFtYWdlVHlwZSA9ICdlbnRyb3BpYyc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICAgIGlmIChpc0Nyb3NzZW50cm9weUJvbHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfn6IgQ3Jvc3NFbnRyb3B5IGJvbHQgaGl0IGRldGVjdGVkLCB1c2luZyBncmVlbiBkYW1hZ2UgbnVtYmVycycpO1xuICAgICAgfSBlbHNlIGlmIChpc0VudHJvcGljQm9sdCkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqhIEVudHJvcGljIGJvbHQgaGl0IGRldGVjdGVkLCB1c2luZyBncmVlbiBkYW1hZ2UgbnVtYmVycycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLmNvbWJhdFN5c3RlbS5xdWV1ZURhbWFnZSh0YXJnZXQsIHByb2plY3RpbGUuZGFtYWdlLCBwcm9qZWN0aWxlRW50aXR5LCBkYW1hZ2VUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IGRhbWFnZSAocGFzcyBlbnRpdHkgZm9yIHNoaWVsZCBhYnNvcnB0aW9uKVxuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgIGNvbnN0IGRhbWFnZURlYWx0ID0gdGFyZ2V0SGVhbHRoLnRha2VEYW1hZ2UocHJvamVjdGlsZS5kYW1hZ2UsIGN1cnJlbnRUaW1lLCB0YXJnZXQpO1xuICAgICAgXG4gICAgICBpZiAoZGFtYWdlRGVhbHQpIHtcbiAgICAgICAgY29uc3QgZW5lbXkgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEVuZW15KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IGVuZW15ID8gZW5lbXkuZ2V0RGlzcGxheU5hbWUoKSA6IGBFbnRpdHkgJHt0YXJnZXQuaWR9YDtcbiAgICAgICAgY29uc29sZS5sb2coYPCfkqUgQm9uZSBBcnJvdyBoaXQgJHt0YXJnZXROYW1lfSBmb3IgJHtwcm9qZWN0aWxlLmRhbWFnZX0gZGFtYWdlICgke3RhcmdldEhlYWx0aC5jdXJyZW50SGVhbHRofS8ke3RhcmdldEhlYWx0aC5tYXhIZWFsdGh9IEhQKWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBleHBsb3Npb24gaWYgZXhwbG9zaXZlXG4gICAgaWYgKHByb2plY3RpbGUuZXhwbG9zaW9uUmFkaXVzID4gMCkge1xuICAgICAgdGhpcy5oYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eSwgcHJvamVjdGlsZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVFeHBsb3Npb24ocHJvamVjdGlsZUVudGl0eTogRW50aXR5LCBwcm9qZWN0aWxlOiBQcm9qZWN0aWxlKTogdm9pZCB7XG4gICAgY29uc3QgcHJvamVjdGlsZVRyYW5zZm9ybSA9IHByb2plY3RpbGVFbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgIGNvbnN0IGV4cGxvc2lvbkNlbnRlciA9IHByb2plY3RpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG5cbiAgICAvLyBFbWl0IGV4cGxvc2lvbiBldmVudCBmb3IgdmlzdWFsIGVmZmVjdHNcbiAgICB0aGlzLndvcmxkLmVtaXRFdmVudCgnZXhwbG9zaW9uJywge1xuICAgICAgcG9zaXRpb246IGV4cGxvc2lvbkNlbnRlci5jbG9uZSgpLFxuICAgICAgY29sb3I6IG5ldyBDb2xvcignIzAwZmY0NCcpLFxuICAgICAgc2l6ZTogcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMsXG4gICAgICBkdXJhdGlvbjogMC41XG4gICAgfSk7XG5cbiAgICAvLyBGaW5kIGFsbCBlbnRpdGllcyB3aXRoaW4gZXhwbG9zaW9uIHJhZGl1c1xuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoXSk7XG5cbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBpZiAodGFyZ2V0LmlkID09PSBwcm9qZWN0aWxlLm93bmVyKSBjb250aW51ZTsgLy8gRG9uJ3QgZGFtYWdlIG93bmVyXG5cbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKSE7XG4gICAgICBjb25zdCB0YXJnZXRIZWFsdGggPSB0YXJnZXQuZ2V0Q29tcG9uZW50KEhlYWx0aCkhO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBleHBsb3Npb25DZW50ZXIuZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPD0gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRhbWFnZSBmYWxsb2ZmIGJhc2VkIG9uIGRpc3RhbmNlXG4gICAgICAgIGNvbnN0IGRhbWFnZUZhbGxvZmYgPSAxIC0gKGRpc3RhbmNlIC8gcHJvamVjdGlsZS5leHBsb3Npb25SYWRpdXMpO1xuICAgICAgICBjb25zdCBleHBsb3Npb25EYW1hZ2UgPSBNYXRoLmZsb29yKHByb2plY3RpbGUuZGFtYWdlICogZGFtYWdlRmFsbG9mZik7XG5cbiAgICAgICAgaWYgKGV4cGxvc2lvbkRhbWFnZSA+IDApIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgIHRhcmdldEhlYWx0aC50YWtlRGFtYWdlKGV4cGxvc2lvbkRhbWFnZSwgY3VycmVudFRpbWUsIHRhcmdldCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfkqUgRXhwbG9zaW9uIGhpdCB0YXJnZXQgJHt0YXJnZXQuaWR9IGZvciAke2V4cGxvc2lvbkRhbWFnZX0gZGFtYWdlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrV29ybGRCb3VuZHMoZW50aXR5OiBFbnRpdHksIHRyYW5zZm9ybTogVHJhbnNmb3JtKTogdm9pZCB7XG4gICAgY29uc3QgcG9zID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIGNvbnN0IG1heERpc3RhbmNlID0gNDA7IC8vIE1heGltdW0gZGlzdGFuY2UgZnJvbSBvcmlnaW5cbiAgICBjb25zdCBtYXhEaXN0YW5jZVNxdWFyZWQgPSBtYXhEaXN0YW5jZSAqIG1heERpc3RhbmNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgcHJvamVjdGlsZSBpcyB0b28gZmFyIGZyb20gb3JpZ2luICh1c2luZyBzcXVhcmVkIGRpc3RhbmNlKVxuICAgIGlmIChwb3MubGVuZ3RoU3EoKSA+IG1heERpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgdGhpcy5wcm9qZWN0aWxlc1RvRGVzdHJveS5wdXNoKGVudGl0eS5pZCk7XG4gICAgICByZXR1cm47IC8vIEVhcmx5IGV4aXRcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBwcm9qZWN0aWxlIGlzIGJlbG93IGdyb3VuZCAoc2ltcGxlIGdyb3VuZCBjaGVjaylcbiAgICBpZiAocG9zLnkgPCAtMTApIHtcbiAgICAgIHRoaXMucHJvamVjdGlsZXNUb0Rlc3Ryb3kucHVzaChlbnRpdHkuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENoYXJnZWRBcnJvdyBwcm9qZWN0aWxlIGZvciBmdWxseSBjaGFyZ2VkIGJvd1xuICBwdWJsaWMgY3JlYXRlQ2hhcmdlZEFycm93UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBjaGFyZ2VkIGFycm93LXNwZWNpZmljIHNldHRpbmdzXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChQcm9qZWN0aWxlKTtcbiAgICBwcm9qZWN0aWxlLnNwZWVkID0gY29uZmlnPy5zcGVlZCB8fCAzNTsgLy8gRmFzdGVyIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDI1OyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gcmVndWxhciBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLm1heExpZmV0aW1lID0gY29uZmlnPy5saWZldGltZSB8fCA1OyAvLyBMb25nZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBDaGFyZ2VkQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDaGFyZ2VkQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNDaGFyZ2VkQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIFxuICAgIHJlbmRlcmVyLm1lc2ggPSBwbGFjZWhvbGRlck1lc2g7XG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgLy8gQWRkIENvbGxpZGVyIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbGxpZGVyID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KENvbGxpZGVyKTtcbiAgICBjb2xsaWRlci5yYWRpdXMgPSAwLjE1O1xuICAgIGNvbGxpZGVyLmxheWVyID0gQ29sbGlzaW9uTGF5ZXIuUFJPSkVDVElMRTtcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChjb2xsaWRlcik7XG5cbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSBmb3Igc2N5dGhlXG4gIHB1YmxpYyBjcmVhdGVDcm9zc2VudHJvcHlCb2x0UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBzY3l0aGUtc3BlY2lmaWMgc2V0dGluZ3NcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDE1OyAvLyBTbG93ZXIgdGhhbiBhcnJvd3NcbiAgICBwcm9qZWN0aWxlLmRhbWFnZSA9IGNvbmZpZz8uZGFtYWdlIHx8IDMwOyAvLyBIaWdoZXIgZGFtYWdlIHRoYW4gYXJyb3dzXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgMTA7IC8vIExvbmdlciBsaWZldGltZVxuICAgIHByb2plY3RpbGUub3duZXIgPSBvd25lcklkO1xuICAgIHByb2plY3RpbGUuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgXG4gICAgaWYgKGNvbmZpZz8ucGllcmNpbmcpIHByb2plY3RpbGUuc2V0UGllcmNpbmcodHJ1ZSk7XG4gICAgaWYgKGNvbmZpZz8uZXhwbG9zaXZlICYmIGNvbmZpZz8uZXhwbG9zaW9uUmFkaXVzKSB7XG4gICAgICBwcm9qZWN0aWxlLnNldEV4cGxvc2l2ZShjb25maWcuZXhwbG9zaW9uUmFkaXVzKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocHJvamVjdGlsZSk7XG5cbiAgICAvLyBBZGQgUmVuZGVyZXIgY29tcG9uZW50IC0gd2UnbGwgdXNlIGEgc3BlY2lhbCBtYXJrZXIgZm9yIENyb3NzZW50cm9weUJvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMjgsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBDcm9zc2VudHJvcHlCb2x0IGZvciBzcGVjaWFsIGhhbmRsaW5nXG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLmlzQ3Jvc3NlbnRyb3B5Qm9sdCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLnByb2plY3RpbGVFbnRpdHkgPSBwcm9qZWN0aWxlRW50aXR5O1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBcbiAgICByZW5kZXJlci5tZXNoID0gcGxhY2Vob2xkZXJNZXNoO1xuICAgIFxuICAgIC8vIFNldCBzaGFkb3cgY2FzdGluZyB3aXRoIHNhZmV0eSBjaGVja1xuICAgIGlmICh0eXBlb2YgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVuZGVyZXIuc2V0Q2FzdFNoYWRvdyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHNldENhc3RTaGFkb3cgbWV0aG9kOicsIHJlbmRlcmVyKTtcbiAgICB9XG4gICAgXG4gICAgcHJvamVjdGlsZUVudGl0eS5hZGRDb21wb25lbnQocmVuZGVyZXIpO1xuXG4gICAgY29uc29sZS5sb2coYOKalO+4jyBDcmVhdGVkIENyb3NzZW50cm9weUJvbHQgcHJvamVjdGlsZSAke3Byb2plY3RpbGVFbnRpdHkuaWR9IGF0YCwgcG9zaXRpb24sICdtb3ZpbmcnLCBkaXJlY3Rpb24pO1xuICAgIGNvbnNvbGUubG9nKGDwn5OKIEFjdGl2ZSBwcm9qZWN0aWxlczogJHt0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgUHJvamVjdGlsZV0pLmxlbmd0aH1gKTtcbiAgICBcbiAgICAvLyBOb3RpZnkgc3lzdGVtcyB0aGF0IHRoZSBlbnRpdHkgaXMgcmVhZHlcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGFuIEVudHJvcGljQm9sdCBwcm9qZWN0aWxlIGZvciBzY3l0aGUgbGVmdCBjbGlja1xuICBwdWJsaWMgY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnQgd2l0aCBFbnRyb3BpY0JvbHQtc3BlY2lmaWMgc2V0dGluZ3NcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDIwOyAvLyBGYXN0ZXIgdGhhbiBDcm9zc2VudHJvcHlCb2x0XG4gICAgcHJvamVjdGlsZS5kYW1hZ2UgPSBjb25maWc/LmRhbWFnZSB8fCAyMDsgLy8gRW50cm9waWNCb2x0IGRhbWFnZVxuICAgIHByb2plY3RpbGUubWF4TGlmZXRpbWUgPSBjb25maWc/LmxpZmV0aW1lIHx8IDg7IC8vIFNob3J0ZXIgbGlmZXRpbWVcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBFbnRyb3BpY0JvbHRcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDYsIDYpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjMDBmZjQ0JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmY0NCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMS41LFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAwLjEgLy8gVmVyeSBsb3cgb3BhY2l0eSBzaW5jZSBSZWFjdCBjb21wb25lbnQgd2lsbCBoYW5kbGUgdmlzdWFsc1xuICAgIH0pO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWVzaCA9IG5ldyBNZXNoKHBsYWNlaG9sZGVyR2VvbWV0cnksIHBsYWNlaG9sZGVyTWF0ZXJpYWwpO1xuICAgIFxuICAgIC8vIE1hcmsgdGhpcyBhcyBhbiBFbnRyb3BpY0JvbHQgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNFbnRyb3BpY0JvbHQgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5wcm9qZWN0aWxlRW50aXR5ID0gcHJvamVjdGlsZUVudGl0eTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuZGlyZWN0aW9uID0gZGlyZWN0aW9uLmNsb25lKCk7XG4gICAgXG4gICAgcmVuZGVyZXIubWVzaCA9IHBsYWNlaG9sZGVyTWVzaDtcbiAgICBcbiAgICAvLyBTZXQgc2hhZG93IGNhc3Rpbmcgd2l0aCBzYWZldHkgY2hlY2tcbiAgICBpZiAodHlwZW9mIHJlbmRlcmVyLnNldENhc3RTaGFkb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlbmRlcmVyLnNldENhc3RTaGFkb3coZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBSZW5kZXJlciBjb21wb25lbnQgbWlzc2luZyBzZXRDYXN0U2hhZG93IG1ldGhvZDonLCByZW5kZXJlcik7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHJlbmRlcmVyKTtcblxuICAgIGNvbnNvbGUubG9nKGDimqEgQ3JlYXRlZCBFbnRyb3BpY0JvbHQgcHJvamVjdGlsZSAke3Byb2plY3RpbGVFbnRpdHkuaWR9IGF0YCwgcG9zaXRpb24sICdtb3ZpbmcnLCBkaXJlY3Rpb24pO1xuICAgIGNvbnNvbGUubG9nKGDwn5OKIEFjdGl2ZSBwcm9qZWN0aWxlczogJHt0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgUHJvamVjdGlsZV0pLmxlbmd0aH1gKTtcbiAgICBcbiAgICAvLyBOb3RpZnkgc3lzdGVtcyB0aGF0IHRoZSBlbnRpdHkgaXMgcmVhZHlcbiAgICB0aGlzLndvcmxkLm5vdGlmeUVudGl0eUFkZGVkKHByb2plY3RpbGVFbnRpdHkpO1xuICAgIFxuICAgIHJldHVybiBwcm9qZWN0aWxlRW50aXR5O1xuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gY3JlYXRlIGEgcHJvamVjdGlsZVxuICBwdWJsaWMgY3JlYXRlUHJvamVjdGlsZShcbiAgICB3b3JsZDogV29ybGQsXG4gICAgcG9zaXRpb246IFZlY3RvcjMsXG4gICAgZGlyZWN0aW9uOiBWZWN0b3IzLFxuICAgIG93bmVySWQ6IG51bWJlcixcbiAgICBjb25maWc/OiB7XG4gICAgICBzcGVlZD86IG51bWJlcjtcbiAgICAgIGRhbWFnZT86IG51bWJlcjtcbiAgICAgIGxpZmV0aW1lPzogbnVtYmVyO1xuICAgICAgcGllcmNpbmc/OiBib29sZWFuO1xuICAgICAgZXhwbG9zaXZlPzogYm9vbGVhbjtcbiAgICAgIGV4cGxvc2lvblJhZGl1cz86IG51bWJlcjtcbiAgICAgIHN1YmNsYXNzPzogV2VhcG9uU3ViY2xhc3M7XG4gICAgICBsZXZlbD86IG51bWJlcjtcbiAgICAgIG9wYWNpdHk/OiBudW1iZXI7XG4gICAgfVxuICApOiBFbnRpdHkge1xuICAgIGNvbnN0IHByb2plY3RpbGVFbnRpdHkgPSB3b3JsZC5jcmVhdGVFbnRpdHkoKTtcblxuICAgIC8vIEFkZCBUcmFuc2Zvcm0gY29tcG9uZW50XG4gICAgY29uc3QgdHJhbnNmb3JtID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgdHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHRyYW5zZm9ybSk7XG5cbiAgICAvLyBBZGQgUHJvamVjdGlsZSBjb21wb25lbnRcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gd29ybGQuY3JlYXRlQ29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIHByb2plY3RpbGUuc3BlZWQgPSBjb25maWc/LnNwZWVkIHx8IDIwO1xuICAgIHByb2plY3RpbGUuZGFtYWdlID0gY29uZmlnPy5kYW1hZ2UgfHwgNTsgLy8gU2V0IGRlZmF1bHQgZGFtYWdlIHRvIDUgYXMgcmVxdWVzdGVkXG4gICAgcHJvamVjdGlsZS5tYXhMaWZldGltZSA9IGNvbmZpZz8ubGlmZXRpbWUgfHwgNTtcbiAgICBwcm9qZWN0aWxlLm93bmVyID0gb3duZXJJZDtcbiAgICBwcm9qZWN0aWxlLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIFxuICAgIGlmIChjb25maWc/LnBpZXJjaW5nKSBwcm9qZWN0aWxlLnNldFBpZXJjaW5nKHRydWUpO1xuICAgIGlmIChjb25maWc/LmV4cGxvc2l2ZSAmJiBjb25maWc/LmV4cGxvc2lvblJhZGl1cykge1xuICAgICAgcHJvamVjdGlsZS5zZXRFeHBsb3NpdmUoY29uZmlnLmV4cGxvc2lvblJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KHByb2plY3RpbGUpO1xuXG4gICAgLy8gQWRkIFJlbmRlcmVyIGNvbXBvbmVudCAtIHdlJ2xsIHVzZSBhIHNwZWNpYWwgbWFya2VyIGZvciBSZWd1bGFyQXJyb3dcbiAgICBjb25zdCByZW5kZXJlciA9IHdvcmxkLmNyZWF0ZUNvbXBvbmVudChSZW5kZXJlcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHBsYWNlaG9sZGVyIG1lc2ggdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBSZWFjdCBjb21wb25lbnRcbiAgICBjb25zdCBwbGFjZWhvbGRlckdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KDAuMTUsIDgsIDgpO1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0ZXJpYWwgPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6ICcjZmZhYTAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmYWEwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMyxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgb3BhY2l0eTogMC4xIC8vIFZlcnkgbG93IG9wYWNpdHkgc2luY2UgUmVhY3QgY29tcG9uZW50IHdpbGwgaGFuZGxlIHZpc3VhbHNcbiAgICB9KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlck1lc2ggPSBuZXcgTWVzaChwbGFjZWhvbGRlckdlb21ldHJ5LCBwbGFjZWhvbGRlck1hdGVyaWFsKTtcbiAgICBcbiAgICAvLyBNYXJrIHRoaXMgYXMgYSBSZWd1bGFyQXJyb3cgZm9yIHNwZWNpYWwgaGFuZGxpbmdcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuaXNSZWd1bGFyQXJyb3cgPSB0cnVlO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5kaXJlY3Rpb24gPSBkaXJlY3Rpb24uY2xvbmUoKTtcbiAgICBwbGFjZWhvbGRlck1lc2gudXNlckRhdGEuc3ViY2xhc3MgPSBjb25maWc/LnN1YmNsYXNzO1xuICAgIHBsYWNlaG9sZGVyTWVzaC51c2VyRGF0YS5sZXZlbCA9IGNvbmZpZz8ubGV2ZWw7XG4gICAgcGxhY2Vob2xkZXJNZXNoLnVzZXJEYXRhLm9wYWNpdHkgPSBjb25maWc/Lm9wYWNpdHkgfHwgMS4wO1xuICAgIFxuICAgIHJlbmRlcmVyLm1lc2ggPSBwbGFjZWhvbGRlck1lc2g7XG4gICAgXG4gICAgLy8gU2V0IHNoYWRvdyBjYXN0aW5nIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgaWYgKHR5cGVvZiByZW5kZXJlci5zZXRDYXN0U2hhZG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZW5kZXJlci5zZXRDYXN0U2hhZG93KGZhbHNlKTsgLy8gUHJvamVjdGlsZXMgZG9uJ3QgbmVlZCB0byBjYXN0IHNoYWRvd3NcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3Npbmcgc2V0Q2FzdFNoYWRvdyBtZXRob2Q6JywgcmVuZGVyZXIpO1xuICAgIH1cbiAgICBcbiAgICBwcm9qZWN0aWxlRW50aXR5LmFkZENvbXBvbmVudChyZW5kZXJlcik7XG5cbiAgICAvLyBBZGQgQ29sbGlkZXIgY29tcG9uZW50XG4gICAgY29uc3QgY29sbGlkZXIgPSB3b3JsZC5jcmVhdGVDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgIGNvbGxpZGVyLnJhZGl1cyA9IDAuMTU7XG4gICAgY29sbGlkZXIubGF5ZXIgPSBDb2xsaXNpb25MYXllci5QUk9KRUNUSUxFO1xuICAgIHByb2plY3RpbGVFbnRpdHkuYWRkQ29tcG9uZW50KGNvbGxpZGVyKTtcblxuICAgIGNvbnNvbGUubG9nKGDwn5qAIENyZWF0ZWQgcHJvamVjdGlsZSAke3Byb2plY3RpbGVFbnRpdHkuaWR9IGF0YCwgcG9zaXRpb24sICdtb3ZpbmcnLCBkaXJlY3Rpb24sIGAob3duZXI6ICR7b3duZXJJZH0pYCk7XG4gICAgY29uc29sZS5sb2coYPCfk4ogQWN0aXZlIHByb2plY3RpbGVzOiAke3RoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBQcm9qZWN0aWxlXSkubGVuZ3RofWApO1xuICAgIFxuICAgIC8vIE5vdGlmeSBzeXN0ZW1zIHRoYXQgdGhlIGVudGl0eSBpcyByZWFkeSAodGhpcyB3aWxsIHRyaWdnZXIgUmVuZGVyU3lzdGVtLm9uRW50aXR5QWRkZWQpXG4gICAgdGhpcy53b3JsZC5ub3RpZnlFbnRpdHlBZGRlZChwcm9qZWN0aWxlRW50aXR5KTtcbiAgICBcbiAgICByZXR1cm4gcHJvamVjdGlsZUVudGl0eTtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIHByb2plY3RpbGUgcmVzb3VyY2VzIHdoZW4gZW50aXR5IGlzIHJlbW92ZWRcbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IHByb2plY3RpbGUgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFByb2plY3RpbGUpO1xuICAgIGlmIChwcm9qZWN0aWxlKSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+SpSBEZXN0cm95aW5nIHByb2plY3RpbGUgJHtlbnRpdHkuaWR9IChsaWZldGltZTogJHtwcm9qZWN0aWxlLmxpZmV0aW1lLnRvRml4ZWQoMil9cylgKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFJlbWFpbmluZyBwcm9qZWN0aWxlczogJHt0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgUHJvamVjdGlsZV0pLmxlbmd0aCAtIDF9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vIHNwZWNpYWwgY2xlYW51cCBuZWVkZWQgZm9yIFJlZ3VsYXJBcnJvdyAtIFJlYWN0IGNvbXBvbmVudHMgaGFuZGxlIHRoZWlyIG93biBsaWZlY3ljbGVcbiAgfVxuXG4gIC8vIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICBwdWJsaWMgZ2V0UG9vbFN0YXRzKCk6IHsgXG4gICAgdmVjdG9yMzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVjdG9yMzogdGhpcy52ZWN0b3IzUG9vbC5nZXRQb29sU2l6ZSgpXG4gICAgfTtcbiAgfVxuXG4gIC8vIERpc3Bvc2Ugb2YgYWxsIHBvb2xzIHdoZW4gc3lzdGVtIGlzIGRlc3Ryb3llZFxuICBwdWJsaWMgb25EaXNhYmxlKCk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCfwn6e5IENsZWFuaW5nIHVwIFByb2plY3RpbGVTeXN0ZW0gcG9vbHM6JywgdGhpcy5nZXRQb29sU3RhdHMoKSk7XG4gICAgdGhpcy52ZWN0b3IzUG9vbC5jbGVhcigpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIkNvbG9yIiwiU3BoZXJlR2VvbWV0cnkiLCJNZXNoU3RhbmRhcmRNYXRlcmlhbCIsIk1lc2giLCJTeXN0ZW0iLCJUcmFuc2Zvcm0iLCJQcm9qZWN0aWxlIiwiSGVhbHRoIiwiUmVuZGVyZXIiLCJDb2xsaWRlciIsIkNvbGxpc2lvbkxheWVyIiwiRW5lbXkiLCJPYmplY3RQb29sIiwiUHJvamVjdGlsZVN5c3RlbSIsInNldENvbWJhdFN5c3RlbSIsImNvbWJhdFN5c3RlbSIsInVwZGF0ZSIsImVudGl0aWVzIiwiZGVsdGFUaW1lIiwicHJvamVjdGlsZXNUb0Rlc3Ryb3kiLCJsZW5ndGgiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJwcm9qZWN0aWxlIiwiZW5hYmxlZCIsImlzRXhwaXJlZCIsInB1c2giLCJpZCIsIm1vdmVQcm9qZWN0aWxlIiwiY2hlY2tDb2xsaXNpb25zIiwiY2hlY2tXb3JsZEJvdW5kcyIsImVudGl0eUlkIiwid29ybGQiLCJkZXN0cm95RW50aXR5IiwidGVtcFZlY3RvciIsImNvcHkiLCJ2ZWxvY2l0eSIsIm11bHRpcGx5U2NhbGFyIiwidHJhbnNsYXRlIiwieCIsInkiLCJ6IiwibWF0cml4TmVlZHNVcGRhdGUiLCJwcm9qZWN0aWxlRW50aXR5IiwicHJvamVjdGlsZVBvcyIsInBvc2l0aW9uIiwicG90ZW50aWFsVGFyZ2V0cyIsInF1ZXJ5RW50aXRpZXMiLCJ0YXJnZXQiLCJvd25lciIsImNvbnNvbGUiLCJsb2ciLCJjYW5IaXRUYXJnZXQiLCJ0YXJnZXRUcmFuc2Zvcm0iLCJ0YXJnZXRIZWFsdGgiLCJ0YXJnZXRDb2xsaWRlciIsImlzRGVhZCIsImxheWVyIiwiRU5FTVkiLCJQTEFZRVIiLCJ0YXJnZXRQb3MiLCJnZXRXb3JsZFBvc2l0aW9uIiwicHJvamVjdGlsZVJhZGl1cyIsInRhcmdldFJhZGl1cyIsInJhZGl1cyIsImRpc3RhbmNlU3F1YXJlZCIsImRpc3RhbmNlVG9TcXVhcmVkIiwiY29sbGlzaW9uUmFkaXVzU3F1YXJlZCIsImhhbmRsZUhpdCIsInBpZXJjaW5nIiwiYWRkSGl0VGFyZ2V0IiwicmVuZGVyZXIiLCJpc0Nyb3NzZW50cm9weUJvbHQiLCJtZXNoIiwidXNlckRhdGEiLCJpc0VudHJvcGljQm9sdCIsImRhbWFnZVR5cGUiLCJxdWV1ZURhbWFnZSIsImRhbWFnZSIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImRhbWFnZURlYWx0IiwidGFrZURhbWFnZSIsImVuZW15IiwidGFyZ2V0TmFtZSIsImdldERpc3BsYXlOYW1lIiwiY3VycmVudEhlYWx0aCIsIm1heEhlYWx0aCIsImV4cGxvc2lvblJhZGl1cyIsImhhbmRsZUV4cGxvc2lvbiIsInByb2plY3RpbGVUcmFuc2Zvcm0iLCJleHBsb3Npb25DZW50ZXIiLCJlbWl0RXZlbnQiLCJjbG9uZSIsImNvbG9yIiwic2l6ZSIsImR1cmF0aW9uIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiZGFtYWdlRmFsbG9mZiIsImV4cGxvc2lvbkRhbWFnZSIsIk1hdGgiLCJmbG9vciIsInBvcyIsIm1heERpc3RhbmNlIiwibWF4RGlzdGFuY2VTcXVhcmVkIiwibGVuZ3RoU3EiLCJjcmVhdGVDaGFyZ2VkQXJyb3dQcm9qZWN0aWxlIiwiZGlyZWN0aW9uIiwib3duZXJJZCIsImNvbmZpZyIsImNyZWF0ZUVudGl0eSIsImNyZWF0ZUNvbXBvbmVudCIsImFkZENvbXBvbmVudCIsInNwZWVkIiwibWF4TGlmZXRpbWUiLCJsaWZldGltZSIsInNldERpcmVjdGlvbiIsInNldFBpZXJjaW5nIiwiZXhwbG9zaXZlIiwic2V0RXhwbG9zaXZlIiwicGxhY2Vob2xkZXJHZW9tZXRyeSIsInBsYWNlaG9sZGVyTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwidHJhbnNwYXJlbnQiLCJvcGFjaXR5IiwicGxhY2Vob2xkZXJNZXNoIiwiaXNDaGFyZ2VkQXJyb3ciLCJzdWJjbGFzcyIsImxldmVsIiwiY29sbGlkZXIiLCJQUk9KRUNUSUxFIiwiY3JlYXRlQ3Jvc3NlbnRyb3B5Qm9sdFByb2plY3RpbGUiLCJzZXRDYXN0U2hhZG93Iiwid2FybiIsIm5vdGlmeUVudGl0eUFkZGVkIiwiY3JlYXRlRW50cm9waWNCb2x0UHJvamVjdGlsZSIsImNyZWF0ZVByb2plY3RpbGUiLCJpc1JlZ3VsYXJBcnJvdyIsIm9uRW50aXR5UmVtb3ZlZCIsInRvRml4ZWQiLCJnZXRQb29sU3RhdHMiLCJ2ZWN0b3IzIiwidmVjdG9yM1Bvb2wiLCJnZXRQb29sU2l6ZSIsIm9uRGlzYWJsZSIsImNsZWFyIiwiY29uc3RydWN0b3IiLCJyZXF1aXJlZENvbXBvbmVudHMiLCJ0ZW1wVmVjdG9yMiIsInByaW9yaXR5IiwidmVjdG9yIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/ProjectileSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/RenderSystem.ts":
/*!*************************************!*\
  !*** ./src/systems/RenderSystem.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderSystem: function() { return /* binding */ RenderSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Renderer */ \"(app-pages-browser)/./src/ecs/components/Renderer.ts\");\n// Render system for 3D rendering with Three.js\n\n\n\n\nclass RenderSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.RenderSystem {\n    update(entities, deltaTime) {\n        // Update animations and renderer components\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            // Update animations with safety check\n            if (typeof rendererComponent.updateAnimations === \"function\") {\n                rendererComponent.updateAnimations(deltaTime);\n            } else {\n                console.warn(\"⚠️ Renderer component missing updateAnimations method:\", rendererComponent);\n            }\n            // Update mesh if needed\n            this.updateEntityMesh(entity, transform, rendererComponent);\n        }\n    }\n    render(entities, deltaTime) {\n        // Update all entity transforms and meshes\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n            if (!transform.enabled || !rendererComponent.enabled) {\n                continue;\n            }\n            this.updateEntityTransform(entity, transform, rendererComponent);\n        }\n        // Render the scene\n        this.renderer.render(this.scene, this.camera);\n    }\n    updateEntityMesh(entity, transform, rendererComponent) {\n        const existingMesh = this.meshMap.get(entity.id);\n        // Handle pre-built mesh/group (like arrows)\n        if (!existingMesh && rendererComponent.mesh) {\n            this.meshMap.set(entity.id, rendererComponent.mesh);\n            this.scene.add(rendererComponent.mesh);\n            return;\n        }\n        // Create mesh if it doesn't exist or needs update (traditional geometry + material)\n        if (!existingMesh && rendererComponent.geometry && rendererComponent.material) {\n            const mesh = rendererComponent.createMesh();\n            if (mesh) {\n                this.meshMap.set(entity.id, mesh);\n                this.scene.add(mesh);\n            }\n        } else if (existingMesh) {\n            // Update existing mesh with safety check\n            if (typeof rendererComponent.updateMesh === \"function\") {\n                rendererComponent.updateMesh();\n            } else {\n                console.warn(\"⚠️ Renderer component missing updateMesh method:\", rendererComponent);\n            }\n        }\n    }\n    updateEntityTransform(entity, transform, rendererComponent) {\n        const meshOrGroup = this.meshMap.get(entity.id);\n        if (!meshOrGroup) return;\n        // Update transform matrix\n        transform.updateMatrix();\n        // Apply transform to mesh or group\n        meshOrGroup.position.copy(transform.position);\n        meshOrGroup.quaternion.copy(transform.quaternion);\n        meshOrGroup.scale.copy(transform.scale);\n        // Handle instanced rendering (only for meshes)\n        if (rendererComponent.isInstanced && meshOrGroup instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\n            rendererComponent.updateInstanceMatrix(transform.matrix);\n        }\n    }\n    onEntityAdded(entity) {\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent) {\n            console.log(\"\\uD83C\\uDFA8 RenderSystem: Adding entity \".concat(entity.id, \" to scene\"));\n            // Handle pre-built mesh/group (like arrows and elite enemies)\n            if (rendererComponent.mesh) {\n                console.log(\"\\uD83C\\uDFF9 Adding pre-built mesh/group for entity \".concat(entity.id));\n                this.meshMap.set(entity.id, rendererComponent.mesh);\n                this.scene.add(rendererComponent.mesh);\n                return;\n            }\n            // Handle traditional geometry + material\n            if (rendererComponent.geometry && rendererComponent.material) {\n                console.log(\"\\uD83D\\uDD37 Creating mesh from geometry + material for entity \".concat(entity.id));\n                const mesh = rendererComponent.createMesh();\n                if (mesh) {\n                    this.meshMap.set(entity.id, mesh);\n                    this.scene.add(mesh);\n                }\n            } else {\n                console.log(\"⚪ Entity \".concat(entity.id, \" has Renderer but no geometry/material - skipping mesh creation\"));\n            }\n        } else {\n            console.log(\"⚠️ RenderSystem: Entity \".concat(entity.id, \" has no Renderer component\"));\n        }\n    }\n    onEntityRemoved(entity) {\n        const mesh = this.meshMap.get(entity.id);\n        if (mesh) {\n            this.scene.remove(mesh);\n            this.meshMap.delete(entity.id);\n        }\n        const rendererComponent = entity.getComponent(_ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer);\n        if (rendererComponent && typeof rendererComponent.dispose === \"function\") {\n            rendererComponent.dispose();\n        }\n    }\n    getMesh(entityId) {\n        return this.meshMap.get(entityId);\n    }\n    getScene() {\n        return this.scene;\n    }\n    getCamera() {\n        return this.camera;\n    }\n    getRenderer() {\n        return this.renderer;\n    }\n    // Utility methods for managing the scene\n    addLight(light) {\n        this.scene.add(light);\n    }\n    removeLight(light) {\n        this.scene.remove(light);\n    }\n    addObject(object) {\n        this.scene.add(object);\n    }\n    removeObject(object) {\n        this.scene.remove(object);\n    }\n    setFog(fog) {\n        this.scene.fog = fog;\n    }\n    setBackground(background) {\n        this.scene.background = background;\n    }\n    enableShadows() {\n        let enable = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        this.renderer.shadowMap.enabled = enable;\n        this.renderer.shadowMap.type = _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap;\n    }\n    setPixelRatio(ratio) {\n        this.renderer.setPixelRatio(ratio || window.devicePixelRatio);\n    }\n    setSize(width, height) {\n        this.renderer.setSize(width, height);\n        if (this.camera instanceof _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera) {\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n        }\n    }\n    dispose() {\n        // Clean up all meshes\n        for (const [entityId, mesh] of Array.from(this.meshMap.entries())){\n            this.scene.remove(mesh);\n        }\n        this.meshMap.clear();\n        // Dispose renderer\n        this.renderer.dispose();\n    }\n    constructor(scene, camera, renderer){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Renderer__WEBPACK_IMPORTED_MODULE_3__.Renderer\n        ];\n        this.meshMap = new Map() // Entity ID -> Mesh/Group mapping\n        ;\n        this.scene = scene;\n        this.camera = camera;\n        this.renderer = renderer;\n        this.priority = 1000; // Render systems should run last\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLCtDQUErQztBQUNvSTtBQUNuSDtBQUVUO0FBQ0Y7QUFFOUMsTUFBTUcscUJBQXFCQyxxREFBZ0JBO0lBZXpDRyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELDRDQUE0QztRQUM1QyxLQUFLLE1BQU1DLFVBQVVGLFNBQVU7WUFDN0IsTUFBTUcsWUFBWUQsT0FBT0UsWUFBWSxDQUFDUCxnRUFBU0E7WUFDL0MsTUFBTVEsb0JBQW9CSCxPQUFPRSxZQUFZLENBQUNOLDhEQUFRQTtZQUV0RCxJQUFJLENBQUNLLFVBQVVHLE9BQU8sSUFBSSxDQUFDRCxrQkFBa0JDLE9BQU8sRUFBRTtnQkFDcEQ7WUFDRjtZQUVBLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9ELGtCQUFrQkUsZ0JBQWdCLEtBQUssWUFBWTtnQkFDNURGLGtCQUFrQkUsZ0JBQWdCLENBQUNOO1lBQ3JDLE9BQU87Z0JBQ0xPLFFBQVFDLElBQUksQ0FBQywwREFBMERKO1lBQ3pFO1lBRUEsd0JBQXdCO1lBQ3hCLElBQUksQ0FBQ0ssZ0JBQWdCLENBQUNSLFFBQVFDLFdBQVdFO1FBQzNDO0lBQ0Y7SUFFT00sT0FBT1gsUUFBa0IsRUFBRUMsU0FBaUIsRUFBUTtRQUN6RCwwQ0FBMEM7UUFDMUMsS0FBSyxNQUFNQyxVQUFVRixTQUFVO1lBQzdCLE1BQU1HLFlBQVlELE9BQU9FLFlBQVksQ0FBQ1AsZ0VBQVNBO1lBQy9DLE1BQU1RLG9CQUFvQkgsT0FBT0UsWUFBWSxDQUFDTiw4REFBUUE7WUFFdEQsSUFBSSxDQUFDSyxVQUFVRyxPQUFPLElBQUksQ0FBQ0Qsa0JBQWtCQyxPQUFPLEVBQUU7Z0JBQ3BEO1lBQ0Y7WUFFQSxJQUFJLENBQUNNLHFCQUFxQixDQUFDVixRQUFRQyxXQUFXRTtRQUNoRDtRQUVBLG1CQUFtQjtRQUNuQixJQUFJLENBQUNRLFFBQVEsQ0FBQ0Ys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QUNILE9BQU8sQ0FBQ3dELEtBQUs7UUFFbEIsbUJBQW1CO1FBQ25CLElBQUksQ0FBQzVELFFBQVEsQ0FBQzRCLE9BQU87SUFDdkI7SUExTUFpQyxZQUFZNUQsS0FBWSxFQUFFQyxNQUFjLEVBQUVGLFFBQXVCLENBQUU7UUFDakUsS0FBSzthQVBTOEQscUJBQXFCO1lBQUM5RSxnRUFBU0E7WUFBRUMsOERBQVFBO1NBQUM7YUFJbERtQixVQUFVLElBQUkyRCxNQUE2QixrQ0FBa0M7O1FBSW5GLElBQUksQ0FBQzlELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDZ0UsUUFBUSxHQUFHLE1BQU0saUNBQWlDO0lBQ3pEO0FBcU1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zeXN0ZW1zL1JlbmRlclN5c3RlbS50cz9iMzA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbmRlciBzeXN0ZW0gZm9yIDNEIHJlbmRlcmluZyB3aXRoIFRocmVlLmpzXG5pbXBvcnQgeyBTY2VuZSwgQ2FtZXJhLCBXZWJHTFJlbmRlcmVyLCBNZXNoLCBHcm91cCwgTGlnaHQsIE9iamVjdDNELCBDb2xvciwgVGV4dHVyZSwgUENGU29mdFNoYWRvd01hcCwgUGVyc3BlY3RpdmVDYW1lcmEsIEZvZywgRm9nRXhwMiwgQ3ViZVRleHR1cmUgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgUmVuZGVyU3lzdGVtIGFzIEJhc2VSZW5kZXJTeXN0ZW0gfSBmcm9tICdAL2Vjcy9TeXN0ZW0nO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVHJhbnNmb3JtJztcbmltcG9ydCB7IFJlbmRlcmVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9SZW5kZXJlcic7XG5cbmV4cG9ydCBjbGFzcyBSZW5kZXJTeXN0ZW0gZXh0ZW5kcyBCYXNlUmVuZGVyU3lzdGVtIHtcbiAgcHVibGljIHJlYWRvbmx5IHJlcXVpcmVkQ29tcG9uZW50cyA9IFtUcmFuc2Zvcm0sIFJlbmRlcmVyXTtcbiAgcHJpdmF0ZSBzY2VuZTogU2NlbmU7XG4gIHByaXZhdGUgY2FtZXJhOiBDYW1lcmE7XG4gIHByaXZhdGUgcmVuZGVyZXI6IFdlYkdMUmVuZGVyZXI7XG4gIHByaXZhdGUgbWVzaE1hcCA9IG5ldyBNYXA8bnVtYmVyLCBNZXNoIHwgR3JvdXA+KCk7IC8vIEVudGl0eSBJRCAtPiBNZXNoL0dyb3VwIG1hcHBpbmdcblxuICBjb25zdHJ1Y3RvcihzY2VuZTogU2NlbmUsIGNhbWVyYTogQ2FtZXJhLCByZW5kZXJlcjogV2ViR0xSZW5kZXJlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnByaW9yaXR5ID0gMTAwMDsgLy8gUmVuZGVyIHN5c3RlbXMgc2hvdWxkIHJ1biBsYXN0XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0aWVzOiBFbnRpdHlbXSwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBVcGRhdGUgYW5pbWF0aW9ucyBhbmQgcmVuZGVyZXIgY29tcG9uZW50c1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXJlbmRlcmVyQ29tcG9uZW50LmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb25zIHdpdGggc2FmZXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZUFuaW1hdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVuZGVyZXJDb21wb25lbnQudXBkYXRlQW5pbWF0aW9ucyhkZWx0YVRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gUmVuZGVyZXIgY29tcG9uZW50IG1pc3NpbmcgdXBkYXRlQW5pbWF0aW9ucyBtZXRob2Q6JywgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbWVzaCBpZiBuZWVkZWRcbiAgICAgIHRoaXMudXBkYXRlRW50aXR5TWVzaChlbnRpdHksIHRyYW5zZm9ybSwgcmVuZGVyZXJDb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZW5kZXIoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIFVwZGF0ZSBhbGwgZW50aXR5IHRyYW5zZm9ybXMgYW5kIG1lc2hlc1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSkhO1xuICAgICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKSE7XG5cbiAgICAgIGlmICghdHJhbnNmb3JtLmVuYWJsZWQgfHwgIXJlbmRlcmVyQ29tcG9uZW50LmVuYWJsZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlRW50aXR5VHJhbnNmb3JtKGVudGl0eSwgdHJhbnNmb3JtLCByZW5kZXJlckNvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIHRoZSBzY2VuZVxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRW50aXR5TWVzaChlbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50OiBSZW5kZXJlcik6IHZvaWQge1xuICAgIGNvbnN0IGV4aXN0aW5nTWVzaCA9IHRoaXMubWVzaE1hcC5nZXQoZW50aXR5LmlkKTtcblxuICAgIC8vIEhhbmRsZSBwcmUtYnVpbHQgbWVzaC9ncm91cCAobGlrZSBhcnJvd3MpXG4gICAgaWYgKCFleGlzdGluZ01lc2ggJiYgcmVuZGVyZXJDb21wb25lbnQubWVzaCkge1xuICAgICAgdGhpcy5tZXNoTWFwLnNldChlbnRpdHkuaWQsIHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQocmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG1lc2ggaWYgaXQgZG9lc24ndCBleGlzdCBvciBuZWVkcyB1cGRhdGUgKHRyYWRpdGlvbmFsIGdlb21ldHJ5ICsgbWF0ZXJpYWwpXG4gICAgaWYgKCFleGlzdGluZ01lc2ggJiYgcmVuZGVyZXJDb21wb25lbnQuZ2VvbWV0cnkgJiYgcmVuZGVyZXJDb21wb25lbnQubWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IG1lc2ggPSByZW5kZXJlckNvbXBvbmVudC5jcmVhdGVNZXNoKCk7XG4gICAgICBpZiAobWVzaCkge1xuICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgbWVzaCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKG1lc2gpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdNZXNoKSB7XG4gICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgbWVzaCB3aXRoIHNhZmV0eSBjaGVja1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlckNvbXBvbmVudC51cGRhdGVNZXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZU1lc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFJlbmRlcmVyIGNvbXBvbmVudCBtaXNzaW5nIHVwZGF0ZU1lc2ggbWV0aG9kOicsIHJlbmRlcmVyQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUVudGl0eVRyYW5zZm9ybShlbnRpdHk6IEVudGl0eSwgdHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHJlbmRlcmVyQ29tcG9uZW50OiBSZW5kZXJlcik6IHZvaWQge1xuICAgIGNvbnN0IG1lc2hPckdyb3VwID0gdGhpcy5tZXNoTWFwLmdldChlbnRpdHkuaWQpO1xuICAgIGlmICghbWVzaE9yR3JvdXApIHJldHVybjtcblxuICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgdHJhbnNmb3JtLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtIHRvIG1lc2ggb3IgZ3JvdXBcbiAgICBtZXNoT3JHcm91cC5wb3NpdGlvbi5jb3B5KHRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgbWVzaE9yR3JvdXAucXVhdGVybmlvbi5jb3B5KHRyYW5zZm9ybS5xdWF0ZXJuaW9uKTtcbiAgICBtZXNoT3JHcm91cC5zY2FsZS5jb3B5KHRyYW5zZm9ybS5zY2FsZSk7XG5cbiAgICAvLyBIYW5kbGUgaW5zdGFuY2VkIHJlbmRlcmluZyAob25seSBmb3IgbWVzaGVzKVxuICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5pc0luc3RhbmNlZCAmJiBtZXNoT3JHcm91cCBpbnN0YW5jZW9mIE1lc2gpIHtcbiAgICAgIHJlbmRlcmVyQ29tcG9uZW50LnVwZGF0ZUluc3RhbmNlTWF0cml4KHRyYW5zZm9ybS5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBvbkVudGl0eUFkZGVkKGVudGl0eTogRW50aXR5KTogdm9pZCB7XG4gICAgY29uc3QgcmVuZGVyZXJDb21wb25lbnQgPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFJlbmRlcmVyKTtcbiAgICBpZiAocmVuZGVyZXJDb21wb25lbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46oIFJlbmRlclN5c3RlbTogQWRkaW5nIGVudGl0eSAke2VudGl0eS5pZH0gdG8gc2NlbmVgKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHByZS1idWlsdCBtZXNoL2dyb3VwIChsaWtlIGFycm93cyBhbmQgZWxpdGUgZW5lbWllcylcbiAgICAgIGlmIChyZW5kZXJlckNvbXBvbmVudC5tZXNoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDwn4+5IEFkZGluZyBwcmUtYnVpbHQgbWVzaC9ncm91cCBmb3IgZW50aXR5ICR7ZW50aXR5LmlkfWApO1xuICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgcmVuZGVyZXJDb21wb25lbnQubWVzaCk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHJlbmRlcmVyQ29tcG9uZW50Lm1lc2gpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhhbmRsZSB0cmFkaXRpb25hbCBnZW9tZXRyeSArIG1hdGVyaWFsXG4gICAgICBpZiAocmVuZGVyZXJDb21wb25lbnQuZ2VvbWV0cnkgJiYgcmVuZGVyZXJDb21wb25lbnQubWF0ZXJpYWwpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflLcgQ3JlYXRpbmcgbWVzaCBmcm9tIGdlb21ldHJ5ICsgbWF0ZXJpYWwgZm9yIGVudGl0eSAke2VudGl0eS5pZH1gKTtcbiAgICAgICAgY29uc3QgbWVzaCA9IHJlbmRlcmVyQ29tcG9uZW50LmNyZWF0ZU1lc2goKTtcbiAgICAgICAgaWYgKG1lc2gpIHtcbiAgICAgICAgICB0aGlzLm1lc2hNYXAuc2V0KGVudGl0eS5pZCwgbWVzaCk7XG4gICAgICAgICAgdGhpcy5zY2VuZS5hZGQobWVzaCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDimqogRW50aXR5ICR7ZW50aXR5LmlkfSBoYXMgUmVuZGVyZXIgYnV0IG5vIGdlb21ldHJ5L21hdGVyaWFsIC0gc2tpcHBpbmcgbWVzaCBjcmVhdGlvbmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg4pqg77iPIFJlbmRlclN5c3RlbTogRW50aXR5ICR7ZW50aXR5LmlkfSBoYXMgbm8gUmVuZGVyZXIgY29tcG9uZW50YCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9uRW50aXR5UmVtb3ZlZChlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IG1lc2ggPSB0aGlzLm1lc2hNYXAuZ2V0KGVudGl0eS5pZCk7XG4gICAgaWYgKG1lc2gpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG1lc2gpO1xuICAgICAgdGhpcy5tZXNoTWFwLmRlbGV0ZShlbnRpdHkuaWQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyQ29tcG9uZW50ID0gZW50aXR5LmdldENvbXBvbmVudChSZW5kZXJlcik7XG4gICAgaWYgKHJlbmRlcmVyQ29tcG9uZW50ICYmIHR5cGVvZiByZW5kZXJlckNvbXBvbmVudC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZW5kZXJlckNvbXBvbmVudC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldE1lc2goZW50aXR5SWQ6IG51bWJlcik6IE1lc2ggfCBHcm91cCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMubWVzaE1hcC5nZXQoZW50aXR5SWQpO1xuICB9XG5cbiAgcHVibGljIGdldFNjZW5lKCk6IFNjZW5lIHtcbiAgICByZXR1cm4gdGhpcy5zY2VuZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYW1lcmEoKTogQ2FtZXJhIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmE7XG4gIH1cblxuICBwdWJsaWMgZ2V0UmVuZGVyZXIoKTogV2ViR0xSZW5kZXJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gIH1cblxuICAvLyBVdGlsaXR5IG1ldGhvZHMgZm9yIG1hbmFnaW5nIHRoZSBzY2VuZVxuICBwdWJsaWMgYWRkTGlnaHQobGlnaHQ6IExpZ2h0KTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5hZGQobGlnaHQpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUxpZ2h0KGxpZ2h0OiBMaWdodCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUucmVtb3ZlKGxpZ2h0KTtcbiAgfVxuXG4gIHB1YmxpYyBhZGRPYmplY3Qob2JqZWN0OiBPYmplY3QzRCk6IHZvaWQge1xuICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdCk7XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlT2JqZWN0KG9iamVjdDogT2JqZWN0M0QpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLnJlbW92ZShvYmplY3QpO1xuICB9XG5cbiAgcHVibGljIHNldEZvZyhmb2c6IEZvZyB8IEZvZ0V4cDIgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5zY2VuZS5mb2cgPSBmb2c7XG4gIH1cblxuICBwdWJsaWMgc2V0QmFja2dyb3VuZChiYWNrZ3JvdW5kOiBDb2xvciB8IFRleHR1cmUgfCBDdWJlVGV4dHVyZSB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZVNoYWRvd3MoZW5hYmxlOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSBlbmFibGU7XG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFBDRlNvZnRTaGFkb3dNYXA7XG4gIH1cblxuICBwdWJsaWMgc2V0UGl4ZWxSYXRpbyhyYXRpbz86IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhyYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gIH1cblxuICBwdWJsaWMgc2V0U2l6ZSh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICBpZiAodGhpcy5jYW1lcmEgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgLy8gQ2xlYW4gdXAgYWxsIG1lc2hlc1xuICAgIGZvciAoY29uc3QgW2VudGl0eUlkLCBtZXNoXSBvZiBBcnJheS5mcm9tKHRoaXMubWVzaE1hcC5lbnRyaWVzKCkpKSB7XG4gICAgICB0aGlzLnNjZW5lLnJlbW92ZShtZXNoKTtcbiAgICB9XG4gICAgdGhpcy5tZXNoTWFwLmNsZWFyKCk7XG5cbiAgICAvLyBEaXNwb3NlIHJlbmRlcmVyXG4gICAgdGhpcy5yZW5kZXJlci5kaXNwb3NlKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJNZXNoIiwiUENGU29mdFNoYWRvd01hcCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiUmVuZGVyU3lzdGVtIiwiQmFzZVJlbmRlclN5c3RlbSIsIlRyYW5zZm9ybSIsIlJlbmRlcmVyIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJyZW5kZXJlckNvbXBvbmVudCIsImVuYWJsZWQiLCJ1cGRhdGVBbmltYXRpb25zIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVFbnRpdHlNZXNoIiwicmVuZGVyIiwidXBkYXRlRW50aXR5VHJhbnNmb3JtIiwicmVuZGVyZXIiLCJzY2VuZSIsImNhbWVyYSIsImV4aXN0aW5nTWVzaCIsIm1lc2hNYXAiLCJnZXQiLCJpZCIsIm1lc2giLCJzZXQiLCJhZGQiLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiY3JlYXRlTWVzaCIsInVwZGF0ZU1lc2giLCJtZXNoT3JHcm91cCIsInVwZGF0ZU1hdHJpeCIsInBvc2l0aW9uIiwiY29weSIsInF1YXRlcm5pb24iLCJzY2FsZSIsImlzSW5zdGFuY2VkIiwidXBkYXRlSW5zdGFuY2VNYXRyaXgiLCJtYXRyaXgiLCJvbkVudGl0eUFkZGVkIiwibG9nIiwib25FbnRpdHlSZW1vdmVkIiwicmVtb3ZlIiwiZGVsZXRlIiwiZGlzcG9zZSIsImdldE1lc2giLCJlbnRpdHlJZCIsImdldFNjZW5lIiwiZ2V0Q2FtZXJhIiwiZ2V0UmVuZGVyZXIiLCJhZGRMaWdodCIsImxpZ2h0IiwicmVtb3ZlTGlnaHQiLCJhZGRPYmplY3QiLCJvYmplY3QiLCJyZW1vdmVPYmplY3QiLCJzZXRGb2ciLCJmb2ciLCJzZXRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsImVuYWJsZVNoYWRvd3MiLCJlbmFibGUiLCJzaGFkb3dNYXAiLCJ0eXBlIiwic2V0UGl4ZWxSYXRpbyIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJ3aWR0aCIsImhlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJBcnJheSIsImZyb20iLCJlbnRyaWVzIiwiY2xlYXIiLCJjb25zdHJ1Y3RvciIsInJlcXVpcmVkQ29tcG9uZW50cyIsIk1hcCIsInByaW9yaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/RenderSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/systems/TowerSystem.ts":
/*!************************************!*\
  !*** ./src/systems/TowerSystem.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TowerSystem: function() { return /* binding */ TowerSystem; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _ecs_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/ecs/System */ \"(app-pages-browser)/./src/ecs/System.ts\");\n/* harmony import */ var _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/ecs/components/Transform */ \"(app-pages-browser)/./src/ecs/components/Transform.ts\");\n/* harmony import */ var _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/ecs/components/Health */ \"(app-pages-browser)/./src/ecs/components/Health.ts\");\n/* harmony import */ var _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/ecs/components/Tower */ \"(app-pages-browser)/./src/ecs/components/Tower.ts\");\n/* harmony import */ var _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/ecs/components/Collider */ \"(app-pages-browser)/./src/ecs/components/Collider.ts\");\n// Tower system for managing PVP tower AI, targeting, and shooting\n\n\n\n\n\n\nclass TowerSystem extends _ecs_System__WEBPACK_IMPORTED_MODULE_1__.System {\n    setProjectileSystem(projectileSystem) {\n        this.projectileSystem = projectileSystem;\n    }\n    setTowerAttackCallback(callback) {\n        this.onTowerAttackCallback = callback;\n    }\n    setPlayerMapping(serverPlayerEntities, localSocketId) {\n        this.serverPlayerEntities = serverPlayerEntities;\n        this.localSocketId = localSocketId;\n    }\n    update(entities, deltaTime) {\n        const currentTime = Date.now() / 1000; // Convert to seconds\n        for (const entity of entities){\n            const transform = entity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            if (!transform || !tower || !health) continue;\n            // Check if tower is dead\n            if (health.isDead && !tower.isDead) {\n                tower.die(currentTime);\n                console.log(\"\\uD83C\\uDFF0 Tower \".concat(tower.getDisplayName(), \" has been destroyed!\"));\n                continue;\n            }\n            // Skip inactive or dead towers\n            if (!tower.isActive || tower.isDead) continue;\n            // Search for targets periodically\n            if (tower.canSearchForTargets(currentTime)) {\n                this.searchForTarget(entity, transform, tower, currentTime);\n            }\n            // Validate current target (check if still alive and in range)\n            if (tower.currentTarget) {\n                const targetEntity = this.world.getEntity(tower.currentTarget);\n                if (!this.isValidTarget(targetEntity || null, transform, tower)) {\n                    tower.clearTarget();\n                }\n            }\n            // Attack current target if possible\n            if (tower.currentTarget && tower.canAttack(currentTime)) {\n                this.attackTarget(entity, transform, tower, currentTime);\n            }\n        }\n    }\n    searchForTarget(towerEntity, towerTransform, tower, currentTime) {\n        tower.updateTargetSearch(currentTime);\n        // Get all potential targets (players that are not the tower owner)\n        const potentialTargets = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health,\n            _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider\n        ]);\n        console.log(\"\\uD83D\\uDD0D Tower \".concat(tower.getDisplayName(), \" searching for targets. Found \").concat(potentialTargets.length, \" potential entities\"));\n        let closestTarget = null;\n        let closestDistance = Infinity;\n        let validTargetCount = 0;\n        for (const target of potentialTargets){\n            const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider);\n            const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (targetCollider && targetTransform) {\n                const distance = towerTransform.position.distanceTo(targetTransform.position);\n                console.log(\"  - Entity \".concat(target.id, \": layer=\").concat(targetCollider.layer, \", distance=\").concat(distance.toFixed(2), \", hasComponent(Tower)=\").concat(target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)));\n            }\n            if (!this.isValidTarget(target, towerTransform, tower)) continue;\n            validTargetCount++;\n            const targetTransform2 = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (!targetTransform2) continue;\n            const distance = towerTransform.position.distanceTo(targetTransform2.position);\n            if (distance <= tower.targetSearchRange && distance < closestDistance) {\n                closestTarget = target;\n                closestDistance = distance;\n            }\n        }\n        console.log(\"\\uD83D\\uDD0D Tower \".concat(tower.getDisplayName(), \" found \").concat(validTargetCount, \" valid targets\"));\n        if (closestTarget) {\n            tower.setTarget(closestTarget.id);\n            console.log(\"\\uD83C\\uDFAF Tower \".concat(tower.getDisplayName(), \" acquired target: Entity \").concat(closestTarget.id, \" at distance \").concat(closestDistance.toFixed(2)));\n        } else if (tower.currentTarget) {\n            // Clear target if no valid targets found\n            tower.clearTarget();\n            console.log(\"\\uD83C\\uDFAF Tower \".concat(tower.getDisplayName(), \" lost target - no valid targets in range\"));\n        }\n    }\n    isValidTarget(target, towerTransform, tower) {\n        if (!target) {\n            console.log(\"    ❌ Target is null\");\n            return false;\n        }\n        const targetHealth = target.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n        const targetTransform = target.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        const targetCollider = target.getComponent(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.Collider);\n        // Must have required components and be alive\n        if (!targetHealth || !targetTransform || !targetCollider || targetHealth.isDead) {\n            console.log(\"    ❌ Entity \".concat(target.id, \": Missing components or dead (health=\").concat(!!targetHealth, \", transform=\").concat(!!targetTransform, \", collider=\").concat(!!targetCollider, \", isDead=\").concat(targetHealth === null || targetHealth === void 0 ? void 0 : targetHealth.isDead, \")\"));\n            return false;\n        }\n        // Must be a player (not an enemy or other tower)\n        if (targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER && targetCollider.layer !== _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY) {\n            console.log(\"    ❌ Entity \".concat(target.id, \": Wrong collision layer (\").concat(targetCollider.layer, \"), expected PLAYER(\").concat(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER, \") or ENEMY(\").concat(_ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY, \")\"));\n            return false;\n        }\n        // Don't target other towers\n        if (target.hasComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower)) {\n            console.log(\"    ❌ Entity \".concat(target.id, \": Is a tower, skipping\"));\n            return false;\n        }\n        // In PVP mode, identify if this is an enemy player\n        if (this.localSocketId && this.serverPlayerEntities.size > 0) {\n            console.log(\"    \\uD83D\\uDD0D Entity \".concat(target.id, \": PVP mode check (localSocketId=\").concat(this.localSocketId, \", playerMappings=\").concat(this.serverPlayerEntities.size, \")\"));\n            // Check if this is the local player (PLAYER layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.PLAYER) {\n                const shouldTarget = tower.ownerId !== this.localSocketId;\n                console.log(\"    \".concat(shouldTarget ? \"✅\" : \"❌\", \" Entity \").concat(target.id, \": Local player, towerOwner=\").concat(tower.ownerId, \", localPlayer=\").concat(this.localSocketId, \", shouldTarget=\").concat(shouldTarget));\n                return shouldTarget;\n            }\n            // Check if this is a remote player (ENEMY layer)\n            if (targetCollider.layer === _ecs_components_Collider__WEBPACK_IMPORTED_MODULE_5__.CollisionLayer.ENEMY) {\n                // Find which player this entity belongs to\n                let targetPlayerId = null;\n                this.serverPlayerEntities.forEach((entityId, playerId)=>{\n                    if (entityId === target.id) {\n                        targetPlayerId = playerId;\n                    }\n                });\n                if (targetPlayerId) {\n                    const shouldTarget = tower.ownerId !== targetPlayerId;\n                    console.log(\"    \".concat(shouldTarget ? \"✅\" : \"❌\", \" Entity \").concat(target.id, \": Remote player \").concat(targetPlayerId, \", towerOwner=\").concat(tower.ownerId, \", shouldTarget=\").concat(shouldTarget));\n                    return shouldTarget;\n                }\n                console.log(\"    ✅ Entity \".concat(target.id, \": Remote player (unidentified), targeting by default\"));\n                return true;\n            }\n        }\n        console.log(\"    ✅ Entity \".concat(target.id, \": Fallback targeting\"));\n        return true;\n    }\n    attackTarget(towerEntity, towerTransform, tower, currentTime) {\n        const targetEntity = this.world.getEntity(tower.currentTarget);\n        if (!targetEntity) {\n            tower.clearTarget();\n            return;\n        }\n        const targetTransform = targetEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n        if (!targetTransform) {\n            tower.clearTarget();\n            return;\n        }\n        // Calculate direction to target\n        this.tempVector.copy(targetTransform.position);\n        this.tempVector.sub(towerTransform.position);\n        const distance = this.tempVector.length();\n        // Check if target is still in range\n        if (distance > tower.attackRange) {\n            tower.clearTarget();\n            return;\n        }\n        // Normalize direction\n        this.tempVector.normalize();\n        // Calculate projectile spawn position (slightly above tower center)\n        this.tempVector2.copy(towerTransform.position);\n        this.tempVector2.y += 2; // Spawn projectiles 2 units above tower base\n        // Create projectile\n        if (this.projectileSystem) {\n            const projectileConfig = {\n                speed: tower.projectileSpeed,\n                damage: tower.attackDamage,\n                lifetime: 5,\n                opacity: 1.0\n            };\n            const projectileEntity = this.projectileSystem.createProjectile(this.world, this.tempVector2, this.tempVector, towerEntity.id, projectileConfig);\n            // Mark projectile as tower projectile for special handling\n            const projectileRenderer = projectileEntity.getComponent(_ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform);\n            if (projectileRenderer) {\n                // Add metadata to identify this as a tower projectile\n                projectileEntity.isTowerProjectile = true;\n                projectileEntity.towerOwnerId = tower.ownerId;\n            }\n            console.log(\"\\uD83C\\uDFF0 Tower \".concat(tower.getDisplayName(), \" fired at target Entity \").concat(tower.currentTarget, \" (distance: \").concat(distance.toFixed(2), \")\"));\n        }\n        // Broadcast attack to multiplayer if callback is set\n        if (this.onTowerAttackCallback) {\n            // We need to map the target entity back to a player ID\n            // For now, we'll use a placeholder - this will need to be improved with proper player mapping\n            const targetPlayerId = \"player_\".concat(tower.currentTarget);\n            this.onTowerAttackCallback(tower.ownerId, targetPlayerId, this.tempVector2, this.tempVector);\n        }\n        tower.performAttack(currentTime);\n    }\n    // Utility method to get all towers owned by a specific player\n    getTowersByOwner(ownerId) {\n        const allTowers = this.world.queryEntities([\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ]);\n        return allTowers.filter((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            return tower && tower.ownerId === ownerId;\n        });\n    }\n    // Utility method to get tower count for a player\n    getTowerCount(ownerId) {\n        return this.getTowersByOwner(ownerId).length;\n    }\n    // Utility method to check if a player has any active towers\n    hasActiveTowers(ownerId) {\n        const towers = this.getTowersByOwner(ownerId);\n        return towers.some((entity)=>{\n            const tower = entity.getComponent(_ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower);\n            const health = entity.getComponent(_ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health);\n            return tower && health && tower.isActive && !tower.isDead && !health.isDead;\n        });\n    }\n    constructor(world){\n        super();\n        this.requiredComponents = [\n            _ecs_components_Transform__WEBPACK_IMPORTED_MODULE_2__.Transform,\n            _ecs_components_Tower__WEBPACK_IMPORTED_MODULE_4__.Tower,\n            _ecs_components_Health__WEBPACK_IMPORTED_MODULE_3__.Health\n        ];\n        this.projectileSystem = null;\n        // Player entity mapping for identifying tower owners vs enemies\n        this.serverPlayerEntities = new Map();\n        this.localSocketId = null;\n        // Reusable objects to reduce allocations\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.tempVector2 = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.world = world;\n        this.priority = 25; // Run after movement and projectiles\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zeXN0ZW1zL1Rvd2VyU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxrRUFBa0U7QUFDbEI7QUFDVjtBQUVpQjtBQUNOO0FBQ0Y7QUFDc0I7QUFJOUQsTUFBTU8sb0JBQW9CTiwrQ0FBTUE7SUFzQjlCTyxvQkFBb0JDLGdCQUFrQyxFQUFRO1FBQ25FLElBQUksQ0FBQ0EsZ0JBQWdCLEdBQUdBO0lBQzFCO0lBRU9DLHVCQUF1QkMsUUFBdUcsRUFBUTtRQUMzSSxJQUFJLENBQUNDLHFCQUFxQixHQUFHRDtJQUMvQjtJQUVPRSxpQkFBaUJDLG9CQUF5QyxFQUFFQyxhQUFxQixFQUFRO1FBQzlGLElBQUksQ0FBQ0Qsb0JBQW9CLEdBQUdBO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtJQUN2QjtJQUVPQyxPQUFPQyxRQUFrQixFQUFFQyxTQUFpQixFQUFRO1FBQ3pELE1BQU1DLGNBQWNDLEtBQUtDLEdBQUcsS0FBSyxNQUFNLHFCQUFxQjtRQUU1RCxLQUFLLE1BQU1DLFVBQVVMLFNBQVU7WUFDN0IsTUFBTU0sWUFBWUQsT0FBT0UsWUFBWSxDQUFDdEIsZ0VBQVNBO1lBQy9DLE1BQU11QixRQUFRSCxPQUFPRSxZQUFZLENBQUNwQix3REFBS0E7WUFDdkMsTUFBTXNCLFNBQVNKLE9BQU9FLFlBQVksQ0FBQ3JCLDBEQUFNQTtZQUV6QyxJQUFJLENBQUNvQixhQUFhLENBQUNFLFNBQVMsQ0FBQ0MsUUFBUTtZQUVyQyx5QkFBeUI7WUFDekIsSUFBSUEsT0FBT0MsTUFBTSxJQUFJLENBQUNGLE1BQU1FLE1BQU0sRUFBRTtnQkFDbENGLE1BQU1HLEdBQUcsQ0FBQ1Q7Z0JBQ1ZVLFFBQVFDLEdBQUcsQ0FBQyxzQkFBbUMsT0FBdkJMLE1BQU1NLGNBQWMsSUFBRztnQkFDL0M7WUFDRjtZQUVBLCtCQUErQjtZQUMvQixJQUFJLENBQUNOLE1BQU1PLFFBQVEsSUFBSVAsTUFBTUUsTUFBTSxFQUFFO1lBRXJDLGtD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LEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNxRSxRQUFRLEdBQUcsSUFBSSxxQ0FBcUM7SUFDM0Q7QUFtUUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N5c3RlbXMvVG93ZXJTeXN0ZW0udHM/NmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUb3dlciBzeXN0ZW0gZm9yIG1hbmFnaW5nIFBWUCB0b3dlciBBSSwgdGFyZ2V0aW5nLCBhbmQgc2hvb3RpbmdcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnQC9lY3MvU3lzdGVtJztcbmltcG9ydCB7IEVudGl0eSB9IGZyb20gJ0AvZWNzL0VudGl0eSc7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL1RyYW5zZm9ybSc7XG5pbXBvcnQgeyBIZWFsdGggfSBmcm9tICdAL2Vjcy9jb21wb25lbnRzL0hlYWx0aCc7XG5pbXBvcnQgeyBUb3dlciB9IGZyb20gJ0AvZWNzL2NvbXBvbmVudHMvVG93ZXInO1xuaW1wb3J0IHsgQ29sbGlkZXIsIENvbGxpc2lvbkxheWVyIH0gZnJvbSAnQC9lY3MvY29tcG9uZW50cy9Db2xsaWRlcic7XG5pbXBvcnQgeyBXb3JsZCB9IGZyb20gJ0AvZWNzL1dvcmxkJztcbmltcG9ydCB7IFByb2plY3RpbGVTeXN0ZW0gfSBmcm9tICcuL1Byb2plY3RpbGVTeXN0ZW0nO1xuXG5leHBvcnQgY2xhc3MgVG93ZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuICBwdWJsaWMgcmVhZG9ubHkgcmVxdWlyZWRDb21wb25lbnRzID0gW1RyYW5zZm9ybSwgVG93ZXIsIEhlYWx0aF07XG4gIHByaXZhdGUgd29ybGQ6IFdvcmxkO1xuICBwcml2YXRlIHByb2plY3RpbGVTeXN0ZW06IFByb2plY3RpbGVTeXN0ZW0gfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIENhbGxiYWNrIGZvciBicm9hZGNhc3RpbmcgdG93ZXIgYXR0YWNrcyBpbiBtdWx0aXBsYXllclxuICBwcml2YXRlIG9uVG93ZXJBdHRhY2tDYWxsYmFjaz86ICh0b3dlck93bmVySWQ6IHN0cmluZywgdGFyZ2V0UGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZDtcbiAgXG4gIC8vIFBsYXllciBlbnRpdHkgbWFwcGluZyBmb3IgaWRlbnRpZnlpbmcgdG93ZXIgb3duZXJzIHZzIGVuZW1pZXNcbiAgcHJpdmF0ZSBzZXJ2ZXJQbGF5ZXJFbnRpdGllczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBsb2NhbFNvY2tldElkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIFJldXNhYmxlIG9iamVjdHMgdG8gcmVkdWNlIGFsbG9jYXRpb25zXG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmxkOiBXb3JsZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMucHJpb3JpdHkgPSAyNTsgLy8gUnVuIGFmdGVyIG1vdmVtZW50IGFuZCBwcm9qZWN0aWxlc1xuICB9XG4gIFxuICBwdWJsaWMgc2V0UHJvamVjdGlsZVN5c3RlbShwcm9qZWN0aWxlU3lzdGVtOiBQcm9qZWN0aWxlU3lzdGVtKTogdm9pZCB7XG4gICAgdGhpcy5wcm9qZWN0aWxlU3lzdGVtID0gcHJvamVjdGlsZVN5c3RlbTtcbiAgfVxuICBcbiAgcHVibGljIHNldFRvd2VyQXR0YWNrQ2FsbGJhY2soY2FsbGJhY2s6ICh0b3dlck93bmVySWQ6IHN0cmluZywgdGFyZ2V0UGxheWVySWQ6IHN0cmluZywgcG9zaXRpb246IFZlY3RvcjMsIGRpcmVjdGlvbjogVmVjdG9yMykgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cbiAgXG4gIHB1YmxpYyBzZXRQbGF5ZXJNYXBwaW5nKHNlcnZlclBsYXllckVudGl0aWVzOiBNYXA8c3RyaW5nLCBudW1iZXI+LCBsb2NhbFNvY2tldElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnNlcnZlclBsYXllckVudGl0aWVzID0gc2VydmVyUGxheWVyRW50aXRpZXM7XG4gICAgdGhpcy5sb2NhbFNvY2tldElkID0gbG9jYWxTb2NrZXRJZDtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eVtdLCBkZWx0YVRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgIFxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgXG4gICAgICBpZiAoIXRyYW5zZm9ybSB8fCAhdG93ZXIgfHwgIWhlYWx0aCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRvd2VyIGlzIGRlYWRcbiAgICAgIGlmIChoZWFsdGguaXNEZWFkICYmICF0b3dlci5pc0RlYWQpIHtcbiAgICAgICAgdG93ZXIuZGllKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYPCfj7AgVG93ZXIgJHt0b3dlci5nZXREaXNwbGF5TmFtZSgpfSBoYXMgYmVlbiBkZXN0cm95ZWQhYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTa2lwIGluYWN0aXZlIG9yIGRlYWQgdG93ZXJzXG4gICAgICBpZiAoIXRvd2VyLmlzQWN0aXZlIHx8IHRvd2VyLmlzRGVhZCkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFNlYXJjaCBmb3IgdGFyZ2V0cyBwZXJpb2RpY2FsbHlcbiAgICAgIGlmICh0b3dlci5jYW5TZWFyY2hGb3JUYXJnZXRzKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLnNlYXJjaEZvclRhcmdldChlbnRpdHksIHRyYW5zZm9ybSwgdG93ZXIsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgY3VycmVudCB0YXJnZXQgKGNoZWNrIGlmIHN0aWxsIGFsaXZlIGFuZCBpbiByYW5nZSlcbiAgICAgIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHRvd2VyLmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhcmdldCh0YXJnZXRFbnRpdHkgfHwgbnVsbCwgdHJhbnNmb3JtLCB0b3dlcikpIHtcbiAgICAgICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEF0dGFjayBjdXJyZW50IHRhcmdldCBpZiBwb3NzaWJsZVxuICAgICAgaWYgKHRvd2VyLmN1cnJlbnRUYXJnZXQgJiYgdG93ZXIuY2FuQXR0YWNrKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICB0aGlzLmF0dGFja1RhcmdldChlbnRpdHksIHRyYW5zZm9ybSwgdG93ZXIsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc2VhcmNoRm9yVGFyZ2V0KHRvd2VyRW50aXR5OiBFbnRpdHksIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRvd2VyLnVwZGF0ZVRhcmdldFNlYXJjaChjdXJyZW50VGltZSk7XG4gICAgXG4gICAgLy8gR2V0IGFsbCBwb3RlbnRpYWwgdGFyZ2V0cyAocGxheWVycyB0aGF0IGFyZSBub3QgdGhlIHRvd2VyIG93bmVyKVxuICAgIGNvbnN0IHBvdGVudGlhbFRhcmdldHMgPSB0aGlzLndvcmxkLnF1ZXJ5RW50aXRpZXMoW1RyYW5zZm9ybSwgSGVhbHRoLCBDb2xsaWRlcl0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGDwn5SNIFRvd2VyICR7dG93ZXIuZ2V0RGlzcGxheU5hbWUoKX0gc2VhcmNoaW5nIGZvciB0YXJnZXRzLiBGb3VuZCAke3BvdGVudGlhbFRhcmdldHMubGVuZ3RofSBwb3RlbnRpYWwgZW50aXRpZXNgKTtcbiAgICBcbiAgICBsZXQgY2xvc2VzdFRhcmdldDogRW50aXR5IHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGxldCB2YWxpZFRhcmdldENvdW50ID0gMDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiBwb3RlbnRpYWxUYXJnZXRzKSB7XG4gICAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgICAgXG4gICAgICBpZiAodGFyZ2V0Q29sbGlkZXIgJiYgdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24uZGlzdGFuY2VUbyh0YXJnZXRUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgICAgICBjb25zb2xlLmxvZyhgICAtIEVudGl0eSAke3RhcmdldC5pZH06IGxheWVyPSR7dGFyZ2V0Q29sbGlkZXIubGF5ZXJ9LCBkaXN0YW5jZT0ke2Rpc3RhbmNlLnRvRml4ZWQoMil9LCBoYXNDb21wb25lbnQoVG93ZXIpPSR7dGFyZ2V0Lmhhc0NvbXBvbmVudChUb3dlcil9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkVGFyZ2V0KHRhcmdldCwgdG93ZXJUcmFuc2Zvcm0sIHRvd2VyKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIHZhbGlkVGFyZ2V0Q291bnQrKztcbiAgICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybTIgPSB0YXJnZXQuZ2V0Q29tcG9uZW50KFRyYW5zZm9ybSk7XG4gICAgICBpZiAoIXRhcmdldFRyYW5zZm9ybTIpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHRvd2VyVHJhbnNmb3JtLnBvc2l0aW9uLmRpc3RhbmNlVG8odGFyZ2V0VHJhbnNmb3JtMi5wb3NpdGlvbik7XG4gICAgICBcbiAgICAgIGlmIChkaXN0YW5jZSA8PSB0b3dlci50YXJnZXRTZWFyY2hSYW5nZSAmJiBkaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICBjbG9zZXN0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYPCflI0gVG93ZXIgJHt0b3dlci5nZXREaXNwbGF5TmFtZSgpfSBmb3VuZCAke3ZhbGlkVGFyZ2V0Q291bnR9IHZhbGlkIHRhcmdldHNgKTtcbiAgICBcbiAgICBpZiAoY2xvc2VzdFRhcmdldCkge1xuICAgICAgdG93ZXIuc2V0VGFyZ2V0KGNsb3Nlc3RUYXJnZXQuaWQpO1xuICAgICAgY29uc29sZS5sb2coYPCfjq8gVG93ZXIgJHt0b3dlci5nZXREaXNwbGF5TmFtZSgpfSBhY3F1aXJlZCB0YXJnZXQ6IEVudGl0eSAke2Nsb3Nlc3RUYXJnZXQuaWR9IGF0IGRpc3RhbmNlICR7Y2xvc2VzdERpc3RhbmNlLnRvRml4ZWQoMil9YCk7XG4gICAgfSBlbHNlIGlmICh0b3dlci5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhciB0YXJnZXQgaWYgbm8gdmFsaWQgdGFyZ2V0cyBmb3VuZFxuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIGNvbnNvbGUubG9nKGDwn46vIFRvd2VyICR7dG93ZXIuZ2V0RGlzcGxheU5hbWUoKX0gbG9zdCB0YXJnZXQgLSBubyB2YWxpZCB0YXJnZXRzIGluIHJhbmdlYCk7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGlzVmFsaWRUYXJnZXQodGFyZ2V0OiBFbnRpdHkgfCBudWxsLCB0b3dlclRyYW5zZm9ybTogVHJhbnNmb3JtLCB0b3dlcjogVG93ZXIpOiBib29sZWFuIHtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgY29uc29sZS5sb2coYCAgICDinYwgVGFyZ2V0IGlzIG51bGxgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGFyZ2V0SGVhbHRoID0gdGFyZ2V0LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgIGNvbnN0IHRhcmdldFRyYW5zZm9ybSA9IHRhcmdldC5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICBjb25zdCB0YXJnZXRDb2xsaWRlciA9IHRhcmdldC5nZXRDb21wb25lbnQoQ29sbGlkZXIpO1xuICAgIFxuICAgIC8vIE11c3QgaGF2ZSByZXF1aXJlZCBjb21wb25lbnRzIGFuZCBiZSBhbGl2ZVxuICAgIGlmICghdGFyZ2V0SGVhbHRoIHx8ICF0YXJnZXRUcmFuc2Zvcm0gfHwgIXRhcmdldENvbGxpZGVyIHx8IHRhcmdldEhlYWx0aC5pc0RlYWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAgICAg4p2MIEVudGl0eSAke3RhcmdldC5pZH06IE1pc3NpbmcgY29tcG9uZW50cyBvciBkZWFkIChoZWFsdGg9JHshIXRhcmdldEhlYWx0aH0sIHRyYW5zZm9ybT0keyEhdGFyZ2V0VHJhbnNmb3JtfSwgY29sbGlkZXI9JHshIXRhcmdldENvbGxpZGVyfSwgaXNEZWFkPSR7dGFyZ2V0SGVhbHRoPy5pc0RlYWR9KWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBNdXN0IGJlIGEgcGxheWVyIChub3QgYW4gZW5lbXkgb3Igb3RoZXIgdG93ZXIpXG4gICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyICE9PSBDb2xsaXNpb25MYXllci5QTEFZRVIgJiYgdGFyZ2V0Q29sbGlkZXIubGF5ZXIgIT09IENvbGxpc2lvbkxheWVyLkVORU1ZKSB7XG4gICAgICBjb25zb2xlLmxvZyhgICAgIOKdjCBFbnRpdHkgJHt0YXJnZXQuaWR9OiBXcm9uZyBjb2xsaXNpb24gbGF5ZXIgKCR7dGFyZ2V0Q29sbGlkZXIubGF5ZXJ9KSwgZXhwZWN0ZWQgUExBWUVSKCR7Q29sbGlzaW9uTGF5ZXIuUExBWUVSfSkgb3IgRU5FTVkoJHtDb2xsaXNpb25MYXllci5FTkVNWX0pYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIERvbid0IHRhcmdldCBvdGhlciB0b3dlcnNcbiAgICBpZiAodGFyZ2V0Lmhhc0NvbXBvbmVudChUb3dlcikpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAgICAg4p2MIEVudGl0eSAke3RhcmdldC5pZH06IElzIGEgdG93ZXIsIHNraXBwaW5nYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIEluIFBWUCBtb2RlLCBpZGVudGlmeSBpZiB0aGlzIGlzIGFuIGVuZW15IHBsYXllclxuICAgIGlmICh0aGlzLmxvY2FsU29ja2V0SWQgJiYgdGhpcy5zZXJ2ZXJQbGF5ZXJFbnRpdGllcy5zaXplID4gMCkge1xuICAgICAgY29uc29sZS5sb2coYCAgICDwn5SNIEVudGl0eSAke3RhcmdldC5pZH06IFBWUCBtb2RlIGNoZWNrIChsb2NhbFNvY2tldElkPSR7dGhpcy5sb2NhbFNvY2tldElkfSwgcGxheWVyTWFwcGluZ3M9JHt0aGlzLnNlcnZlclBsYXllckVudGl0aWVzLnNpemV9KWApO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBsb2NhbCBwbGF5ZXIgKFBMQVlFUiBsYXllcilcbiAgICAgIGlmICh0YXJnZXRDb2xsaWRlci5sYXllciA9PT0gQ29sbGlzaW9uTGF5ZXIuUExBWUVSKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZFRhcmdldCA9IHRvd2VyLm93bmVySWQgIT09IHRoaXMubG9jYWxTb2NrZXRJZDtcbiAgICAgICAgY29uc29sZS5sb2coYCAgICAke3Nob3VsZFRhcmdldCA/ICfinIUnIDogJ+KdjCd9IEVudGl0eSAke3RhcmdldC5pZH06IExvY2FsIHBsYXllciwgdG93ZXJPd25lcj0ke3Rvd2VyLm93bmVySWR9LCBsb2NhbFBsYXllcj0ke3RoaXMubG9jYWxTb2NrZXRJZH0sIHNob3VsZFRhcmdldD0ke3Nob3VsZFRhcmdldH1gKTtcbiAgICAgICAgcmV0dXJuIHNob3VsZFRhcmdldDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJlbW90ZSBwbGF5ZXIgKEVORU1ZIGxheWVyKVxuICAgICAgaWYgKHRhcmdldENvbGxpZGVyLmxheWVyID09PSBDb2xsaXNpb25MYXllci5FTkVNWSkge1xuICAgICAgICAvLyBGaW5kIHdoaWNoIHBsYXllciB0aGlzIGVudGl0eSBiZWxvbmdzIHRvXG4gICAgICAgIGxldCB0YXJnZXRQbGF5ZXJJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyUGxheWVyRW50aXRpZXMuZm9yRWFjaCgoZW50aXR5SWQsIHBsYXllcklkKSA9PiB7XG4gICAgICAgICAgaWYgKGVudGl0eUlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgIHRhcmdldFBsYXllcklkID0gcGxheWVySWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0YXJnZXRQbGF5ZXJJZCkge1xuICAgICAgICAgIGNvbnN0IHNob3VsZFRhcmdldCA9IHRvd2VyLm93bmVySWQgIT09IHRhcmdldFBsYXllcklkO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAgJHtzaG91bGRUYXJnZXQgPyAn4pyFJyA6ICfinYwnfSBFbnRpdHkgJHt0YXJnZXQuaWR9OiBSZW1vdGUgcGxheWVyICR7dGFyZ2V0UGxheWVySWR9LCB0b3dlck93bmVyPSR7dG93ZXIub3duZXJJZH0sIHNob3VsZFRhcmdldD0ke3Nob3VsZFRhcmdldH1gKTtcbiAgICAgICAgICByZXR1cm4gc2hvdWxkVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgICAgIOKchSBFbnRpdHkgJHt0YXJnZXQuaWR9OiBSZW1vdGUgcGxheWVyICh1bmlkZW50aWZpZWQpLCB0YXJnZXRpbmcgYnkgZGVmYXVsdGApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYCAgICDinIUgRW50aXR5ICR7dGFyZ2V0LmlkfTogRmFsbGJhY2sgdGFyZ2V0aW5nYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHByaXZhdGUgYXR0YWNrVGFyZ2V0KHRvd2VyRW50aXR5OiBFbnRpdHksIHRvd2VyVHJhbnNmb3JtOiBUcmFuc2Zvcm0sIHRvd2VyOiBUb3dlciwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldEVudGl0eSA9IHRoaXMud29ybGQuZ2V0RW50aXR5KHRvd2VyLmN1cnJlbnRUYXJnZXQhKTtcbiAgICBpZiAoIXRhcmdldEVudGl0eSkge1xuICAgICAgdG93ZXIuY2xlYXJUYXJnZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGFyZ2V0VHJhbnNmb3JtID0gdGFyZ2V0RW50aXR5LmdldENvbXBvbmVudChUcmFuc2Zvcm0pO1xuICAgIGlmICghdGFyZ2V0VHJhbnNmb3JtKSB7XG4gICAgICB0b3dlci5jbGVhclRhcmdldCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZGlyZWN0aW9uIHRvIHRhcmdldFxuICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KHRhcmdldFRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgdGhpcy50ZW1wVmVjdG9yLnN1Yih0b3dlclRyYW5zZm9ybS5wb3NpdGlvbik7XG4gICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnRlbXBWZWN0b3IubGVuZ3RoKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIHN0aWxsIGluIHJhbmdlXG4gICAgaWYgKGRpc3RhbmNlID4gdG93ZXIuYXR0YWNrUmFuZ2UpIHtcbiAgICAgIHRvd2VyLmNsZWFyVGFyZ2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb25cbiAgICB0aGlzLnRlbXBWZWN0b3Iubm9ybWFsaXplKCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHByb2plY3RpbGUgc3Bhd24gcG9zaXRpb24gKHNsaWdodGx5IGFib3ZlIHRvd2VyIGNlbnRlcilcbiAgICB0aGlzLnRlbXBWZWN0b3IyLmNvcHkodG93ZXJUcmFuc2Zvcm0ucG9zaXRpb24pO1xuICAgIHRoaXMudGVtcFZlY3RvcjIueSArPSAyOyAvLyBTcGF3biBwcm9qZWN0aWxlcyAyIHVuaXRzIGFib3ZlIHRvd2VyIGJhc2VcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJvamVjdGlsZVxuICAgIGlmICh0aGlzLnByb2plY3RpbGVTeXN0ZW0pIHtcbiAgICAgIGNvbnN0IHByb2plY3RpbGVDb25maWcgPSB7XG4gICAgICAgIHNwZWVkOiB0b3dlci5wcm9qZWN0aWxlU3BlZWQsXG4gICAgICAgIGRhbWFnZTogdG93ZXIuYXR0YWNrRGFtYWdlLFxuICAgICAgICBsaWZldGltZTogNSwgLy8gNSBzZWNvbmQgbGlmZXRpbWVcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRW50aXR5ID0gdGhpcy5wcm9qZWN0aWxlU3lzdGVtLmNyZWF0ZVByb2plY3RpbGUoXG4gICAgICAgIHRoaXMud29ybGQsXG4gICAgICAgIHRoaXMudGVtcFZlY3RvcjIsIC8vIHNwYXduIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudGVtcFZlY3RvciwgIC8vIGRpcmVjdGlvblxuICAgICAgICB0b3dlckVudGl0eS5pZCwgICAvLyB0b3dlciBhcyBvd25lclxuICAgICAgICBwcm9qZWN0aWxlQ29uZmlnXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBNYXJrIHByb2plY3RpbGUgYXMgdG93ZXIgcHJvamVjdGlsZSBmb3Igc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgY29uc3QgcHJvamVjdGlsZVJlbmRlcmVyID0gcHJvamVjdGlsZUVudGl0eS5nZXRDb21wb25lbnQoVHJhbnNmb3JtKTtcbiAgICAgIGlmIChwcm9qZWN0aWxlUmVuZGVyZXIpIHtcbiAgICAgICAgLy8gQWRkIG1ldGFkYXRhIHRvIGlkZW50aWZ5IHRoaXMgYXMgYSB0b3dlciBwcm9qZWN0aWxlXG4gICAgICAgIChwcm9qZWN0aWxlRW50aXR5IGFzIGFueSkuaXNUb3dlclByb2plY3RpbGUgPSB0cnVlO1xuICAgICAgICAocHJvamVjdGlsZUVudGl0eSBhcyBhbnkpLnRvd2VyT3duZXJJZCA9IHRvd2VyLm93bmVySWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGDwn4+wIFRvd2VyICR7dG93ZXIuZ2V0RGlzcGxheU5hbWUoKX0gZmlyZWQgYXQgdGFyZ2V0IEVudGl0eSAke3Rvd2VyLmN1cnJlbnRUYXJnZXR9IChkaXN0YW5jZTogJHtkaXN0YW5jZS50b0ZpeGVkKDIpfSlgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQnJvYWRjYXN0IGF0dGFjayB0byBtdWx0aXBsYXllciBpZiBjYWxsYmFjayBpcyBzZXRcbiAgICBpZiAodGhpcy5vblRvd2VyQXR0YWNrQ2FsbGJhY2spIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFwIHRoZSB0YXJnZXQgZW50aXR5IGJhY2sgdG8gYSBwbGF5ZXIgSURcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHVzZSBhIHBsYWNlaG9sZGVyIC0gdGhpcyB3aWxsIG5lZWQgdG8gYmUgaW1wcm92ZWQgd2l0aCBwcm9wZXIgcGxheWVyIG1hcHBpbmdcbiAgICAgIGNvbnN0IHRhcmdldFBsYXllcklkID0gYHBsYXllcl8ke3Rvd2VyLmN1cnJlbnRUYXJnZXR9YDtcbiAgICAgIHRoaXMub25Ub3dlckF0dGFja0NhbGxiYWNrKHRvd2VyLm93bmVySWQsIHRhcmdldFBsYXllcklkLCB0aGlzLnRlbXBWZWN0b3IyLCB0aGlzLnRlbXBWZWN0b3IpO1xuICAgIH1cbiAgICBcbiAgICB0b3dlci5wZXJmb3JtQXR0YWNrKGN1cnJlbnRUaW1lKTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IGFsbCB0b3dlcnMgb3duZWQgYnkgYSBzcGVjaWZpYyBwbGF5ZXJcbiAgcHVibGljIGdldFRvd2Vyc0J5T3duZXIob3duZXJJZDogc3RyaW5nKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGFsbFRvd2VycyA9IHRoaXMud29ybGQucXVlcnlFbnRpdGllcyhbVHJhbnNmb3JtLCBUb3dlciwgSGVhbHRoXSk7XG4gICAgcmV0dXJuIGFsbFRvd2Vycy5maWx0ZXIoZW50aXR5ID0+IHtcbiAgICAgIGNvbnN0IHRvd2VyID0gZW50aXR5LmdldENvbXBvbmVudChUb3dlcik7XG4gICAgICByZXR1cm4gdG93ZXIgJiYgdG93ZXIub3duZXJJZCA9PT0gb3duZXJJZDtcbiAgICB9KTtcbiAgfVxuICBcbiAgLy8gVXRpbGl0eSBtZXRob2QgdG8gZ2V0IHRvd2VyIGNvdW50IGZvciBhIHBsYXllclxuICBwdWJsaWMgZ2V0VG93ZXJDb3VudChvd25lcklkOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCkubGVuZ3RoO1xuICB9XG4gIFxuICAvLyBVdGlsaXR5IG1ldGhvZCB0byBjaGVjayBpZiBhIHBsYXllciBoYXMgYW55IGFjdGl2ZSB0b3dlcnNcbiAgcHVibGljIGhhc0FjdGl2ZVRvd2Vycyhvd25lcklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0b3dlcnMgPSB0aGlzLmdldFRvd2Vyc0J5T3duZXIob3duZXJJZCk7XG4gICAgcmV0dXJuIHRvd2Vycy5zb21lKGVudGl0eSA9PiB7XG4gICAgICBjb25zdCB0b3dlciA9IGVudGl0eS5nZXRDb21wb25lbnQoVG93ZXIpO1xuICAgICAgY29uc3QgaGVhbHRoID0gZW50aXR5LmdldENvbXBvbmVudChIZWFsdGgpO1xuICAgICAgcmV0dXJuIHRvd2VyICYmIGhlYWx0aCAmJiB0b3dlci5pc0FjdGl2ZSAmJiAhdG93ZXIuaXNEZWFkICYmICFoZWFsdGguaXNEZWFkO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlN5c3RlbSIsIlRyYW5zZm9ybSIsIkhlYWx0aCIsIlRvd2VyIiwiQ29sbGlkZXIiLCJDb2xsaXNpb25MYXllciIsIlRvd2VyU3lzdGVtIiwic2V0UHJvamVjdGlsZVN5c3RlbSIsInByb2plY3RpbGVTeXN0ZW0iLCJzZXRUb3dlckF0dGFja0NhbGxiYWNrIiwiY2FsbGJhY2siLCJvblRvd2VyQXR0YWNrQ2FsbGJhY2siLCJzZXRQbGF5ZXJNYXBwaW5nIiwic2VydmVyUGxheWVyRW50aXRpZXMiLCJsb2NhbFNvY2tldElkIiwidXBkYXRlIiwiZW50aXRpZXMiLCJkZWx0YVRpbWUiLCJjdXJyZW50VGltZSIsIkRhdGUiLCJub3ciLCJlbnRpdHkiLCJ0cmFuc2Zvcm0iLCJnZXRDb21wb25lbnQiLCJ0b3dlciIsImhlYWx0aCIsImlzRGVhZCIsImRpZSIsImNvbnNvbGUiLCJsb2ciLCJnZXREaXNwbGF5TmFtZSIsImlzQWN0aXZlIiwiY2FuU2VhcmNoRm9yVGFyZ2V0cyIsInNlYXJjaEZvclRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRFbnRpdHkiLCJ3b3JsZCIsImdldEVudGl0eSIsImlzVmFsaWRUYXJnZXQiLCJjbGVhclRhcmdldCIsImNhbkF0dGFjayIsImF0dGFja1RhcmdldCIsInRvd2VyRW50aXR5IiwidG93ZXJUcmFuc2Zvcm0iLCJ1cGRhdGVUYXJnZXRTZWFyY2giLCJwb3RlbnRpYWxUYXJnZXRzIiwicXVlcnlFbnRpdGllcyIsImxlbmd0aCIsImNsb3Nlc3RUYXJnZXQiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsInZhbGlkVGFyZ2V0Q291bnQiLCJ0YXJnZXQiLCJ0YXJnZXRDb2xsaWRlciIsInRhcmdldFRyYW5zZm9ybSIsImRpc3RhbmNlIiwicG9zaXRpb24iLCJkaXN0YW5jZVRvIiwiaWQiLCJsYXllciIsInRvRml4ZWQiLCJoYXNDb21wb25lbnQiLCJ0YXJnZXRUcmFuc2Zvcm0yIiwidGFyZ2V0U2VhcmNoUmFuZ2UiLCJzZXRUYXJnZXQiLCJ0YXJnZXRIZWFsdGgiLCJQTEFZRVIiLCJFTkVNWSIsInNpemUiLCJzaG91bGRUYXJnZXQiLCJvd25lcklkIiwidGFyZ2V0UGxheWVySWQiLCJmb3JFYWNoIiwiZW50aXR5SWQiLCJwbGF5ZXJJZCIsInRlbXBWZWN0b3IiLCJjb3B5Iiwic3ViIiwiYXR0YWNrUmFuZ2UiLCJub3JtYWxpemUiLCJ0ZW1wVmVjdG9yMiIsInkiLCJwcm9qZWN0aWxlQ29uZmlnIiwic3BlZWQiLCJwcm9qZWN0aWxlU3BlZWQiLCJkYW1hZ2UiLCJhdHRhY2tEYW1hZ2UiLCJsaWZldGltZSIsIm9wYWNpdHkiLCJwcm9qZWN0aWxlRW50aXR5IiwiY3JlYXRlUHJvamVjdGlsZSIsInByb2plY3RpbGVSZW5kZXJlciIsImlzVG93ZXJQcm9qZWN0aWxlIiwidG93ZXJPd25lcklkIiwicGVyZm9ybUF0dGFjayIsImdldFRvd2Vyc0J5T3duZXIiLCJhbGxUb3dlcnMiLCJmaWx0ZXIiLCJnZXRUb3dlckNvdW50IiwiaGFzQWN0aXZlVG93ZXJzIiwidG93ZXJzIiwic29tZSIsImNvbnN0cnVjdG9yIiwicmVxdWlyZWRDb21wb25lbnRzIiwiTWFwIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/systems/TowerSystem.ts\n"));

/***/ })

}]);