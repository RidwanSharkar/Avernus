"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_utils_ExperienceSystem_ts-_app-pages-browser_src_utils_PVPObjectPool_t-310181"],{

/***/ "(app-pages-browser)/./src/utils/ExperienceSystem.ts":
/*!***************************************!*\
  !*** ./src/utils/ExperienceSystem.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExperienceSystem: function() { return /* binding */ ExperienceSystem; }\n/* harmony export */ });\n// Experience System Utilities for PVP mode\nclass ExperienceSystem {\n    /**\n   * Calculate the level based on total experience\n   */ static getLevelFromExperience(experience) {\n        if (experience >= this.LEVEL_REQUIREMENTS[5]) return 5;\n        if (experience >= this.LEVEL_REQUIREMENTS[4]) return 4;\n        if (experience >= this.LEVEL_REQUIREMENTS[3]) return 3;\n        if (experience >= this.LEVEL_REQUIREMENTS[2]) return 2;\n        return 1;\n    }\n    /**\n   * Get the experience required to reach a specific level\n   */ static getExperienceForLevel(level) {\n        return this.LEVEL_REQUIREMENTS[level] || 0;\n    }\n    /**\n   * Get the experience required for the next level\n   */ static getExperienceForNextLevel(currentLevel) {\n        if (currentLevel >= 5) return 0;\n        return this.LEVEL_REQUIREMENTS[currentLevel + 1] || 0;\n    }\n    /**\n   * Get the experience required to level up from current level\n   */ static getExperienceIncrementForLevel(currentLevel) {\n        if (currentLevel >= 5) return 0;\n        return this.EXP_PER_LEVEL_INCREMENT[currentLevel] || 0;\n    }\n    /**\n   * Calculate current level progress (0-100)\n   */ static getLevelProgress(currentLevel, currentExp) {\n        if (currentLevel >= 5) return 100;\n        const expForCurrentLevel = this.getExperienceForLevel(currentLevel);\n        const expForNextLevel = this.getExperienceForNextLevel(currentLevel);\n        const currentLevelExp = currentExp - expForCurrentLevel;\n        const requiredExp = expForNextLevel - expForCurrentLevel;\n        return Math.min(currentLevelExp / requiredExp * 100, 100);\n    }\n    /**\n   * Get current level's experience range\n   */ static getCurrentLevelExpRange(currentLevel) {\n        const min = this.getExperienceForLevel(currentLevel);\n        const max = this.getExperienceForNextLevel(currentLevel);\n        return {\n            min,\n            max,\n            current: max - min\n        };\n    }\n    /**\n   * Calculate max health based on level\n   */ static getMaxHealthForLevel(level) {\n        const health = this.BASE_HEALTH + (level - 1) * this.HEALTH_PER_LEVEL;\n        console.log(\"\\uD83D\\uDCCA ExperienceSystem.getMaxHealthForLevel(\".concat(level, \") = \").concat(this.BASE_HEALTH, \" + ((\").concat(level, \" - 1) * \").concat(this.HEALTH_PER_LEVEL, \") = \").concat(health));\n        return health;\n    }\n    /**\n   * Check if player can level up with given experience\n   */ static canLevelUp(currentLevel, currentExp) {\n        if (currentLevel >= 5) return false;\n        const requiredExp = this.getExperienceForNextLevel(currentLevel);\n        return currentExp >= requiredExp;\n    }\n    /**\n   * Get the new level after gaining experience\n   */ static getNewLevelAfterExperience(currentLevel, currentExp, expGained) {\n        const newExp = currentExp + expGained;\n        return this.getLevelFromExperience(newExp);\n    }\n    /**\n   * Award experience and return level up information\n   */ static awardExperience(currentLevel, currentExp, expGained) {\n        const newExp = currentExp + expGained;\n        const newLevel = this.getLevelFromExperience(newExp);\n        const leveledUp = newLevel > currentLevel;\n        const levelsGained = newLevel - currentLevel;\n        return {\n            newLevel,\n            newExp,\n            leveledUp,\n            levelsGained\n        };\n    }\n    /**\n   * Get experience remaining until next level\n   */ static getExperienceToNextLevel(currentLevel, currentExp) {\n        if (currentLevel >= 5) return 0;\n        const requiredExp = this.getExperienceForNextLevel(currentLevel);\n        return Math.max(requiredExp - currentExp, 0);\n    }\n}\n// Level requirements (cumulative EXP needed)\nExperienceSystem.LEVEL_REQUIREMENTS = {\n    1: 0,\n    2: 25,\n    3: 75,\n    4: 150,\n    5: 250 // Need 250 total EXP for level 5 (max)\n};\n// EXP per level increment\nExperienceSystem.EXP_PER_LEVEL_INCREMENT = {\n    1: 25,\n    2: 50,\n    3: 75,\n    4: 100 // 150 -> 250 for level 5\n};\n// Health scaling per level\nExperienceSystem.BASE_HEALTH = 1000;\nExperienceSystem.HEALTH_PER_LEVEL = 150;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9FeHBlcmllbmNlU3lzdGVtLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwyQ0FBMkM7QUFFcEMsTUFBTUE7SUFzQlg7O0dBRUMsR0FDRCxPQUFPQyx1QkFBdUJDLFVBQWtCLEVBQVU7UUFDeEQsSUFBSUEsY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDLEVBQUUsRUFBRSxPQUFPO1FBQ3JELElBQUlELGNBQWMsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsT0FBTztRQUNyRCxJQUFJRCxjQUFjLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsRUFBRSxFQUFFLE9BQU87UUFDckQsSUFBSUQsY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDLEVBQUUsRUFBRSxPQUFPO1FBQ3JELE9BQU87SUFDVDtJQUVBOztHQUVDLEdBQ0QsT0FBT0Msc0JBQXNCQyxLQUFhLEVBQVU7UUFDbEQsT0FBTyxJQUFJLENBQUNGLGtCQUFrQixDQUFDRSxNQUE4QyxJQUFJO0lBQ25GO0lBRUE7O0dBRUMsR0FDRCxPQUFPQywwQkFBMEJDLFlBQW9CLEVBQVU7UUFDN0QsSUFBSUEsZ0JBQWdCLEdBQUcsT0FBTztRQUM5QixPQUFPLElBQUksQ0FBQ0osa0JBQWtCLENBQUVJLGVBQWUsRUFBMkMsSUFBSTtJQUNoRztJQUVBOztHQUVDLEdBQ0QsT0FBT0MsK0JBQStCRCxZQUFvQixFQUFVO1FBQ2xFLElBQUlBLGdCQUFnQixHQUFHLE9BQU87UUFDOUIsT0FBTyxJQUFJLENBQUNFLHVCQUF1QixDQUFDRixhQUEwRCxJQUFJO0lBQ3BHO0lBRUE7O0dBRUMsR0FDRCxPQUFPRyxpQkFBaUJILFlBQW9CLEVBQUVJLFVBQWtCLEVBQVU7UUFDeEUsSUFBSUosZ0JBQWdCLEdBQUcsT0FBTztRQUU5QixNQUFNSyxxQkFBcUIsSUFBSSxDQUFDUixxQkFBcUIsQ0FBQ0c7UUFDdEQsTUFBTU0sa0JBQWtCLElBQUksQ0FBQ1AseUJBQXlCLENBQUNDO1FBQ3ZELE1BQU1PLGtCQUFrQkgsYUFBYUM7UUFDckMsTUFBTUcsY0FBY0Ysa0JBQWtCRDtRQUV0QyxPQUFPSSxLQUFLQyxHQUFHLENBQUMsa0JBQW1CRixjQUFlLEtBQUs7SUFDekQ7SUFFQTs7R0FFQyxHQUNELE9BQU9HLHdCQUF3QlgsWUFBb0IsRUFBaUQ7UUFDbEcsTUFBTVUsTUFBTSxJQUFJLENBQUNiLHFCQUFxQixDQUFDRztRQUN2QyxNQUFNWSxNQUFNLElBQUksQ0FBQ2IseUJBQXlCLENBQUNDO1FBQzNDLE9BQU87WUFBRVU7WUFBS0U7WUFBS0MsU0FBU0QsTUFBTUY7UUFBSTtJQUN4QztJQUVBOztHQUVDLEdBQ0QsT0FBT0kscUJBQXFCaEIsS0FBYSxFQUFVO1FBQ2pELE1BQU1pQixTQUFTLElBQUksQ0FBQ0MsV0FBVyxHQUFJLENBQUNsQixRQUFRLEtBQUssSUFBSSxDQUFDbUIsZ0JBQWdCO1FBQ3RFQyxRQUFRQyxHQUFHLENBQUMsc0RBQXdELE9BQVpyQixPQUFNLFFBQThCQSxPQUF4QixJQUFJLENBQUNrQixXQUFXLEVBQUMsU0FBdUIsT0FBaEJsQixPQUFNLFlBQXNDaUIsT0FBNUIsSUFBSSxDQUFDRSxnQkFBZ0IsRUFBQyxRQUFhLE9BQVBGO1FBQ3hJLE9BQU9BO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELE9BQU9LLFdBQVdwQixZQUFvQixFQUFFSSxVQUFrQixFQUFXO1FBQ25FLElBQUlKLGdCQUFnQixHQUFHLE9BQU87UUFDOUIsTUFBTVEsY0FBYyxJQUFJLENBQUNULHlCQUF5QixDQUFDQztRQUNuRCxPQUFPSSxjQUFjSTtJQUN2QjtJQUVBOztHQUVDLEdBQ0QsT0FBT2EsMkJBQTJCckIsWUFBb0IsRUFBRUksVUFBa0IsRUFBRWtCLFNBQWlCLEVBQVU7UUFDckcsTUFBTUMsU0FBU25CLGFBQWFrQjtRQUM1QixPQUFPLElBQUksQ0FBQzVCLHNCQUFzQixDQUFDNkI7SUFDckM7SUFFQTs7R0FFQyxHQUNELE9BQU9DLGdCQUFnQnhCLFlBQW9CLEVBQUVJLFVBQWtCLEVBQUVrQixTQUFpQixFQUtoRjtRQUNBLE1BQU1DLFNBQVNuQixhQUFha0I7UUFDNUIsTUFBTUcsV0FBVyxJQUFJLENBQUMvQixzQkFBc0IsQ0FBQzZCO1FBQzdDLE1BQU1HLFlBQVlELFdBQVd6QjtRQUM3QixNQUFNMkIsZUFBZUYsV0FBV3pCO1FBRWhDLE9BQU87WUFDTHlCO1lBQ0FGO1lBQ0FHO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBT0MseUJBQXlCNUIsWUFBb0IsRUFBRUksVUFBa0IsRUFBVTtRQUNoRixJQUFJSixnQkFBZ0IsR0FBRyxPQUFPO1FBQzlCLE1BQU1RLGNBQWMsSUFBSSxDQUFDVCx5QkFBeUIsQ0FBQ0M7UUFDbkQsT0FBT1MsS0FBS0csR0FBRyxDQUFDSixjQUFjSixZQUFZO0lBQzVDO0FBQ0Y7QUF0SUUsNkNBQTZDO0FBRGxDWCxpQkFFYUcscUJBQXFCO0lBQzNDLEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHLElBQU8sdUNBQXVDO0FBQ25EO0FBRUEsMEJBQTBCO0FBVmZILGlCQVdhUywwQkFBMEI7SUFDaEQsR0FBRztJQUNILEdBQUc7SUFDSCxHQUFHO0lBQ0gsR0FBRyxJQUFNLHlCQUF5QjtBQUNwQztBQUVBLDJCQUEyQjtBQWxCaEJULGlCQW1CYXVCLGNBQWM7QUFuQjNCdkIsaUJBb0Jhd0IsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9FeHBlcmllbmNlU3lzdGVtLnRzPzZmZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwZXJpZW5jZSBTeXN0ZW0gVXRpbGl0aWVzIGZvciBQVlAgbW9kZVxuXG5leHBvcnQgY2xhc3MgRXhwZXJpZW5jZVN5c3RlbSB7XG4gIC8vIExldmVsIHJlcXVpcmVtZW50cyAoY3VtdWxhdGl2ZSBFWFAgbmVlZGVkKVxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBMRVZFTF9SRVFVSVJFTUVOVFMgPSB7XG4gICAgMTogMCwgICAgIC8vIFN0YXJ0aW5nIGxldmVsXG4gICAgMjogMjUsICAgIC8vIE5lZWQgMjUgdG90YWwgRVhQIGZvciBsZXZlbCAyXG4gICAgMzogNzUsICAgIC8vIE5lZWQgNzUgdG90YWwgRVhQIGZvciBsZXZlbCAzXG4gICAgNDogMTUwLCAgIC8vIE5lZWQgMTUwIHRvdGFsIEVYUCBmb3IgbGV2ZWwgNFxuICAgIDU6IDI1MCAgICAvLyBOZWVkIDI1MCB0b3RhbCBFWFAgZm9yIGxldmVsIDUgKG1heClcbiAgfTtcblxuICAvLyBFWFAgcGVyIGxldmVsIGluY3JlbWVudFxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFWFBfUEVSX0xFVkVMX0lOQ1JFTUVOVCA9IHtcbiAgICAxOiAyNSwgICAvLyAwIC0+IDI1IGZvciBsZXZlbCAyXG4gICAgMjogNTAsICAgLy8gMjUgLT4gNzUgZm9yIGxldmVsIDNcbiAgICAzOiA3NSwgICAvLyA3NSAtPiAxNTAgZm9yIGxldmVsIDRcbiAgICA0OiAxMDAgICAvLyAxNTAgLT4gMjUwIGZvciBsZXZlbCA1XG4gIH07XG5cbiAgLy8gSGVhbHRoIHNjYWxpbmcgcGVyIGxldmVsXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEJBU0VfSEVBTFRIID0gMTAwMDtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgSEVBTFRIX1BFUl9MRVZFTCA9IDE1MDtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBsZXZlbCBiYXNlZCBvbiB0b3RhbCBleHBlcmllbmNlXG4gICAqL1xuICBzdGF0aWMgZ2V0TGV2ZWxGcm9tRXhwZXJpZW5jZShleHBlcmllbmNlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChleHBlcmllbmNlID49IHRoaXMuTEVWRUxfUkVRVUlSRU1FTlRTWzVdKSByZXR1cm4gNTtcbiAgICBpZiAoZXhwZXJpZW5jZSA+PSB0aGlzLkxFVkVMX1JFUVVJUkVNRU5UU1s0XSkgcmV0dXJuIDQ7XG4gICAgaWYgKGV4cGVyaWVuY2UgPj0gdGhpcy5MRVZFTF9SRVFVSVJFTUVOVFNbM10pIHJldHVybiAzO1xuICAgIGlmIChleHBlcmllbmNlID49IHRoaXMuTEVWRUxfUkVRVUlSRU1FTlRTWzJdKSByZXR1cm4gMjtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4cGVyaWVuY2UgcmVxdWlyZWQgdG8gcmVhY2ggYSBzcGVjaWZpYyBsZXZlbFxuICAgKi9cbiAgc3RhdGljIGdldEV4cGVyaWVuY2VGb3JMZXZlbChsZXZlbDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5MRVZFTF9SRVFVSVJFTUVOVFNbbGV2ZWwgYXMga2V5b2YgdHlwZW9mIHRoaXMuTEVWRUxfUkVRVUlSRU1FTlRTXSB8fCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXhwZXJpZW5jZSByZXF1aXJlZCBmb3IgdGhlIG5leHQgbGV2ZWxcbiAgICovXG4gIHN0YXRpYyBnZXRFeHBlcmllbmNlRm9yTmV4dExldmVsKGN1cnJlbnRMZXZlbDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoY3VycmVudExldmVsID49IDUpIHJldHVybiAwO1xuICAgIHJldHVybiB0aGlzLkxFVkVMX1JFUVVJUkVNRU5UU1soY3VycmVudExldmVsICsgMSkgYXMga2V5b2YgdHlwZW9mIHRoaXMuTEVWRUxfUkVRVUlSRU1FTlRTXSB8fCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXhwZXJpZW5jZSByZXF1aXJlZCB0byBsZXZlbCB1cCBmcm9tIGN1cnJlbnQgbGV2ZWxcbiAgICovXG4gIHN0YXRpYyBnZXRFeHBlcmllbmNlSW5jcmVtZW50Rm9yTGV2ZWwoY3VycmVudExldmVsOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChjdXJyZW50TGV2ZWwgPj0gNSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHRoaXMuRVhQX1BFUl9MRVZFTF9JTkNSRU1FTlRbY3VycmVudExldmVsIGFzIGtleW9mIHR5cGVvZiB0aGlzLkVYUF9QRVJfTEVWRUxfSU5DUkVNRU5UXSB8fCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBjdXJyZW50IGxldmVsIHByb2dyZXNzICgwLTEwMClcbiAgICovXG4gIHN0YXRpYyBnZXRMZXZlbFByb2dyZXNzKGN1cnJlbnRMZXZlbDogbnVtYmVyLCBjdXJyZW50RXhwOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChjdXJyZW50TGV2ZWwgPj0gNSkgcmV0dXJuIDEwMDtcblxuICAgIGNvbnN0IGV4cEZvckN1cnJlbnRMZXZlbCA9IHRoaXMuZ2V0RXhwZXJpZW5jZUZvckxldmVsKGN1cnJlbnRMZXZlbCk7XG4gICAgY29uc3QgZXhwRm9yTmV4dExldmVsID0gdGhpcy5nZXRFeHBlcmllbmNlRm9yTmV4dExldmVsKGN1cnJlbnRMZXZlbCk7XG4gICAgY29uc3QgY3VycmVudExldmVsRXhwID0gY3VycmVudEV4cCAtIGV4cEZvckN1cnJlbnRMZXZlbDtcbiAgICBjb25zdCByZXF1aXJlZEV4cCA9IGV4cEZvck5leHRMZXZlbCAtIGV4cEZvckN1cnJlbnRMZXZlbDtcblxuICAgIHJldHVybiBNYXRoLm1pbigoY3VycmVudExldmVsRXhwIC8gcmVxdWlyZWRFeHApICogMTAwLCAxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IGxldmVsJ3MgZXhwZXJpZW5jZSByYW5nZVxuICAgKi9cbiAgc3RhdGljIGdldEN1cnJlbnRMZXZlbEV4cFJhbmdlKGN1cnJlbnRMZXZlbDogbnVtYmVyKTogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IGN1cnJlbnQ6IG51bWJlciB9IHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLmdldEV4cGVyaWVuY2VGb3JMZXZlbChjdXJyZW50TGV2ZWwpO1xuICAgIGNvbnN0IG1heCA9IHRoaXMuZ2V0RXhwZXJpZW5jZUZvck5leHRMZXZlbChjdXJyZW50TGV2ZWwpO1xuICAgIHJldHVybiB7IG1pbiwgbWF4LCBjdXJyZW50OiBtYXggLSBtaW4gfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgbWF4IGhlYWx0aCBiYXNlZCBvbiBsZXZlbFxuICAgKi9cbiAgc3RhdGljIGdldE1heEhlYWx0aEZvckxldmVsKGxldmVsOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGhlYWx0aCA9IHRoaXMuQkFTRV9IRUFMVEggKyAoKGxldmVsIC0gMSkgKiB0aGlzLkhFQUxUSF9QRVJfTEVWRUwpO1xuICAgIGNvbnNvbGUubG9nKGDwn5OKIEV4cGVyaWVuY2VTeXN0ZW0uZ2V0TWF4SGVhbHRoRm9yTGV2ZWwoJHtsZXZlbH0pID0gJHt0aGlzLkJBU0VfSEVBTFRIfSArICgoJHtsZXZlbH0gLSAxKSAqICR7dGhpcy5IRUFMVEhfUEVSX0xFVkVMfSkgPSAke2hlYWx0aH1gKTtcbiAgICByZXR1cm4gaGVhbHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBsYXllciBjYW4gbGV2ZWwgdXAgd2l0aCBnaXZlbiBleHBlcmllbmNlXG4gICAqL1xuICBzdGF0aWMgY2FuTGV2ZWxVcChjdXJyZW50TGV2ZWw6IG51bWJlciwgY3VycmVudEV4cDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKGN1cnJlbnRMZXZlbCA+PSA1KSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcmVxdWlyZWRFeHAgPSB0aGlzLmdldEV4cGVyaWVuY2VGb3JOZXh0TGV2ZWwoY3VycmVudExldmVsKTtcbiAgICByZXR1cm4gY3VycmVudEV4cCA+PSByZXF1aXJlZEV4cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5ldyBsZXZlbCBhZnRlciBnYWluaW5nIGV4cGVyaWVuY2VcbiAgICovXG4gIHN0YXRpYyBnZXROZXdMZXZlbEFmdGVyRXhwZXJpZW5jZShjdXJyZW50TGV2ZWw6IG51bWJlciwgY3VycmVudEV4cDogbnVtYmVyLCBleHBHYWluZWQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgbmV3RXhwID0gY3VycmVudEV4cCArIGV4cEdhaW5lZDtcbiAgICByZXR1cm4gdGhpcy5nZXRMZXZlbEZyb21FeHBlcmllbmNlKG5ld0V4cCk7XG4gIH1cblxuICAvKipcbiAgICogQXdhcmQgZXhwZXJpZW5jZSBhbmQgcmV0dXJuIGxldmVsIHVwIGluZm9ybWF0aW9uXG4gICAqL1xuICBzdGF0aWMgYXdhcmRFeHBlcmllbmNlKGN1cnJlbnRMZXZlbDogbnVtYmVyLCBjdXJyZW50RXhwOiBudW1iZXIsIGV4cEdhaW5lZDogbnVtYmVyKToge1xuICAgIG5ld0xldmVsOiBudW1iZXI7XG4gICAgbmV3RXhwOiBudW1iZXI7XG4gICAgbGV2ZWxlZFVwOiBib29sZWFuO1xuICAgIGxldmVsc0dhaW5lZDogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCBuZXdFeHAgPSBjdXJyZW50RXhwICsgZXhwR2FpbmVkO1xuICAgIGNvbnN0IG5ld0xldmVsID0gdGhpcy5nZXRMZXZlbEZyb21FeHBlcmllbmNlKG5ld0V4cCk7XG4gICAgY29uc3QgbGV2ZWxlZFVwID0gbmV3TGV2ZWwgPiBjdXJyZW50TGV2ZWw7XG4gICAgY29uc3QgbGV2ZWxzR2FpbmVkID0gbmV3TGV2ZWwgLSBjdXJyZW50TGV2ZWw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV3TGV2ZWwsXG4gICAgICBuZXdFeHAsXG4gICAgICBsZXZlbGVkVXAsXG4gICAgICBsZXZlbHNHYWluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBleHBlcmllbmNlIHJlbWFpbmluZyB1bnRpbCBuZXh0IGxldmVsXG4gICAqL1xuICBzdGF0aWMgZ2V0RXhwZXJpZW5jZVRvTmV4dExldmVsKGN1cnJlbnRMZXZlbDogbnVtYmVyLCBjdXJyZW50RXhwOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChjdXJyZW50TGV2ZWwgPj0gNSkgcmV0dXJuIDA7XG4gICAgY29uc3QgcmVxdWlyZWRFeHAgPSB0aGlzLmdldEV4cGVyaWVuY2VGb3JOZXh0TGV2ZWwoY3VycmVudExldmVsKTtcbiAgICByZXR1cm4gTWF0aC5tYXgocmVxdWlyZWRFeHAgLSBjdXJyZW50RXhwLCAwKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV4cGVyaWVuY2VTeXN0ZW0iLCJnZXRMZXZlbEZyb21FeHBlcmllbmNlIiwiZXhwZXJpZW5jZSIsIkxFVkVMX1JFUVVJUkVNRU5UUyIsImdldEV4cGVyaWVuY2VGb3JMZXZlbCIsImxldmVsIiwiZ2V0RXhwZXJpZW5jZUZvck5leHRMZXZlbCIsImN1cnJlbnRMZXZlbCIsImdldEV4cGVyaWVuY2VJbmNyZW1lbnRGb3JMZXZlbCIsIkVYUF9QRVJfTEVWRUxfSU5DUkVNRU5UIiwiZ2V0TGV2ZWxQcm9ncmVzcyIsImN1cnJlbnRFeHAiLCJleHBGb3JDdXJyZW50TGV2ZWwiLCJleHBGb3JOZXh0TGV2ZWwiLCJjdXJyZW50TGV2ZWxFeHAiLCJyZXF1aXJlZEV4cCIsIk1hdGgiLCJtaW4iLCJnZXRDdXJyZW50TGV2ZWxFeHBSYW5nZSIsIm1heCIsImN1cnJlbnQiLCJnZXRNYXhIZWFsdGhGb3JMZXZlbCIsImhlYWx0aCIsIkJBU0VfSEVBTFRIIiwiSEVBTFRIX1BFUl9MRVZFTCIsImNvbnNvbGUiLCJsb2ciLCJjYW5MZXZlbFVwIiwiZ2V0TmV3TGV2ZWxBZnRlckV4cGVyaWVuY2UiLCJleHBHYWluZWQiLCJuZXdFeHAiLCJhd2FyZEV4cGVyaWVuY2UiLCJuZXdMZXZlbCIsImxldmVsZWRVcCIsImxldmVsc0dhaW5lZCIsImdldEV4cGVyaWVuY2VUb05leHRMZXZlbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/ExperienceSystem.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/PVPObjectPool.ts":
/*!************************************!*\
  !*** ./src/utils/PVPObjectPool.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PVPObjectPool: function() { return /* binding */ PVPObjectPool; },\n/* harmony export */   pvpObjectPool: function() { return /* binding */ pvpObjectPool; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// PVP Object Pool for performance optimization in multiplayer scenarios\n\n\n/**\n * Centralized object pooling system for PVP components\n * Reduces garbage collection pressure by reusing frequently created objects\n */ class PVPObjectPool {\n    static getInstance() {\n        if (!PVPObjectPool.instance) {\n            PVPObjectPool.instance = new PVPObjectPool();\n        }\n        return PVPObjectPool.instance;\n    }\n    /**\n   * Get a Vector3 from the pool\n   * Remember to call releaseVector3 when done\n   */ acquireVector3() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const vector = this.vector3Pool.acquire();\n        vector.set(x, y, z);\n        return vector;\n    }\n    /**\n   * Return a Vector3 to the pool\n   */ releaseVector3(vector) {\n        this.vector3Pool.release(vector);\n    }\n    /**\n   * Get a temporary Vector3 for single-frame calculations\n   * These are automatically reset each frame, don't need to release\n   */ getTempVector3() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const index = this.tempVectorIndex % this.tempVector3s.length;\n        this.tempVectorIndex++;\n        const vector = this.tempVector3s[index];\n        vector.set(x, y, z);\n        return vector;\n    }\n    /**\n   * Get a Quaternion from the pool\n   */ acquireQuaternion() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        const quaternion = this.quaternionPool.acquire();\n        quaternion.set(x, y, z, w);\n        return quaternion;\n    }\n    /**\n   * Return a Quaternion to the pool\n   */ releaseQuaternion(quaternion) {\n        this.quaternionPool.release(quaternion);\n    }\n    /**\n   * Get a temporary Quaternion for single-frame calculations\n   */ getTempQuaternion() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        const index = this.tempQuaternionIndex % this.tempQuaternions.length;\n        this.tempQuaternionIndex++;\n        const quaternion = this.tempQuaternions[index];\n        quaternion.set(x, y, z, w);\n        return quaternion;\n    }\n    /**\n   * Create a hit key for collision tracking\n   */ createHitKey(entityId, playerId) {\n        return \"\".concat(entityId, \"-\").concat(playerId);\n    }\n    /**\n   * Get an effect data object from the pool\n   */ acquireEffectData() {\n        return this.effectDataPool.acquire();\n    }\n    /**\n   * Return an effect data object to the pool\n   */ releaseEffectData(effectData) {\n        this.effectDataPool.release(effectData);\n    }\n    /**\n   * Reset temporary object indices (call once per frame)\n   */ resetFrameTemporaries() {\n        this.tempVectorIndex = 0;\n        this.tempQuaternionIndex = 0;\n    }\n    /**\n   * Get pool statistics for debugging\n   */ getStats() {\n        return {\n            vector3Pool: this.vector3Pool.getPoolSize(),\n            quaternionPool: this.quaternionPool.getPoolSize(),\n            hitKeyPool: this.hitKeyPool.getPoolSize(),\n            effectDataPool: this.effectDataPool.getPoolSize(),\n            tempVector3sUsed: this.tempVectorIndex,\n            tempQuaternionsUsed: this.tempQuaternionIndex\n        };\n    }\n    /**\n   * Clear all pools (useful for cleanup)\n   */ clearAll() {\n        this.vector3Pool.clear();\n        this.quaternionPool.clear();\n        this.hitKeyPool.clear();\n        this.effectDataPool.clear();\n        this.resetFrameTemporaries();\n    }\n    constructor(){\n        // Temporary objects for calculations (reused within single frame)\n        this.tempVector3s = [];\n        this.tempQuaternions = [];\n        this.tempVectorIndex = 0;\n        this.tempQuaternionIndex = 0;\n        // Initialize Vector3 pool\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 50 // Pool size for PVP scenarios\n        );\n        // Initialize Quaternion pool\n        this.quaternionPool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), (quaternion)=>quaternion.set(0, 0, 0, 1), 20);\n        // Initialize hit key pool (for collision tracking)\n        this.hitKeyPool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>\"\", (key)=>\"\", 100);\n        // Initialize effect data pool\n        this.effectDataPool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>({\n                id: 0,\n                playerId: \"\",\n                position: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n                startTime: 0,\n                duration: 0,\n                debuffType: undefined\n            }), (effectData)=>{\n            effectData.id = 0;\n            effectData.playerId = \"\";\n            effectData.position.set(0, 0, 0);\n            effectData.startTime = 0;\n            effectData.duration = 0;\n            effectData.debuffType = undefined;\n        }, 30);\n        // Pre-allocate temporary objects for frame calculations\n        for(let i = 0; i < 10; i++){\n            this.tempVector3s.push(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n            this.tempQuaternions.push(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion());\n        }\n    }\n}\n// Export singleton instance for easy access\nconst pvpObjectPool = PVPObjectPool.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9QVlBPYmplY3RQb29sLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx3RUFBd0U7QUFDWjtBQUNaO0FBRWhEOzs7Q0FHQyxHQUNNLE1BQU1HO0lBd0VYLE9BQWNDLGNBQTZCO1FBQ3pDLElBQUksQ0FBQ0QsY0FBY0UsUUFBUSxFQUFFO1lBQzNCRixjQUFjRSxRQUFRLEdBQUcsSUFBSUY7UUFDL0I7UUFDQSxPQUFPQSxjQUFjRSxRQUFRO0lBQy9CO0lBRUE7OztHQUdDLEdBQ0QsaUJBQW9EO1lBQTlCRSxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSTtRQUN0QyxNQUFNQyxTQUFTLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxPQUFPO1FBQ3ZDRixPQUFPRyxHQUFHLENBQUNOLEdBQUdDLEdBQUdDO1FBQ2pCLE9BQU9DO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELGVBQXNCQSxNQUFlLEVBQVE7UUFDM0MsSUFBSSxDQUFDQyxXQUFXLENBQUNJLE9BQU8sQ0FBQ0w7SUFDM0I7SUFFQTs7O0dBR0MsR0FDRCxpQkFBb0Q7WUFBOUJILElBQUFBLGlFQUFJLEdBQUdDLElBQUFBLGlFQUFJLEdBQUdDLElBQUFBLGlFQUFJO1FBQ3RDLE1BQU1RLFFBQVEsSUFBSSxDQUFDQyxlQUFlLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUNDLE1BQU07UUFDN0QsSUFBSSxDQUFDRixlQUFlO1FBQ3BCLE1BQU1SLFNBQVMsSUFBSSxDQUFDUyxZQUFZLENBQUNGLE1BQU07UUFDdkNQLE9BQU9HLEdBQUcsQ0FBQ04sR0FBR0MsR0FBR0M7UUFDakIsT0FBT0M7SUFDVDtJQUVBOztHQUVDLEdBQ0Qsb0JBQWlFO1lBQXhDSCxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSSxHQUFHYSxJQUFBQSxpRUFBSTtRQUNoRCxNQUFNQyxhQUFhLElBQUksQ0FBQ0MsY0FBYyxDQUFD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O2dCQUNYQyxVQUFVO2dCQUNWQyxZQUFZQztZQUNkLElBQ0EsQ0FBQ2Y7WUFDQ0EsV0FBV1UsRUFBRSxHQUFHO1lBQ2hCVixXQUFXSixRQUFRLEdBQUc7WUFDdEJJLFdBQVdXLFFBQVEsQ0FBQ2pDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7WUFDOUJzQixXQUFXWSxTQUFTLEdBQUc7WUFDdkJaLFdBQVdhLFFBQVEsR0FBRztZQUN0QmIsV0FBV2MsVUFBVSxHQUFHQztRQUMxQixHQUNBO1FBR0Ysd0RBQXdEO1FBQ3hELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7WUFDM0IsSUFBSSxDQUFDaEMsWUFBWSxDQUFDaUMsSUFBSSxDQUFDLElBQUlwRCx5REFBT0E7WUFDbEMsSUFBSSxDQUFDNEIsZUFBZSxDQUFDd0IsSUFBSSxDQUFDLElBQUluRCw0REFBVUE7UUFDMUM7SUFDRjtBQW9JRjtBQUVBLDRDQUE0QztBQUNyQyxNQUFNb0QsZ0JBQWdCbEQsY0FBY0MsV0FBVyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9QVlBPYmplY3RQb29sLnRzPzU3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUFZQIE9iamVjdCBQb29sIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gaW4gbXVsdGlwbGF5ZXIgc2NlbmFyaW9zXG5pbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IE9iamVjdFBvb2wgfSBmcm9tICdAL3V0aWxzL09iamVjdFBvb2wnO1xuXG4vKipcbiAqIENlbnRyYWxpemVkIG9iamVjdCBwb29saW5nIHN5c3RlbSBmb3IgUFZQIGNvbXBvbmVudHNcbiAqIFJlZHVjZXMgZ2FyYmFnZSBjb2xsZWN0aW9uIHByZXNzdXJlIGJ5IHJldXNpbmcgZnJlcXVlbnRseSBjcmVhdGVkIG9iamVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFBWUE9iamVjdFBvb2wge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUFZQT2JqZWN0UG9vbDtcbiAgXG4gIC8vIE9iamVjdCBwb29scyBmb3IgZGlmZmVyZW50IHR5cGVzXG4gIHByaXZhdGUgdmVjdG9yM1Bvb2w6IE9iamVjdFBvb2w8VmVjdG9yMz47XG4gIHByaXZhdGUgcXVhdGVybmlvblBvb2w6IE9iamVjdFBvb2w8UXVhdGVybmlvbj47XG4gIHByaXZhdGUgaGl0S2V5UG9vbDogT2JqZWN0UG9vbDxzdHJpbmc+O1xuICBwcml2YXRlIGVmZmVjdERhdGFQb29sOiBPYmplY3RQb29sPHtcbiAgICBpZDogbnVtYmVyO1xuICAgIHBsYXllcklkOiBzdHJpbmc7XG4gICAgcG9zaXRpb246IFZlY3RvcjM7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnIHwgdW5kZWZpbmVkO1xuICB9PjtcbiAgXG4gIC8vIFRlbXBvcmFyeSBvYmplY3RzIGZvciBjYWxjdWxhdGlvbnMgKHJldXNlZCB3aXRoaW4gc2luZ2xlIGZyYW1lKVxuICBwcml2YXRlIHRlbXBWZWN0b3IzczogVmVjdG9yM1tdID0gW107XG4gIHByaXZhdGUgdGVtcFF1YXRlcm5pb25zOiBRdWF0ZXJuaW9uW10gPSBbXTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9ySW5kZXggPSAwO1xuICBwcml2YXRlIHRlbXBRdWF0ZXJuaW9uSW5kZXggPSAwO1xuICBcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBJbml0aWFsaXplIFZlY3RvcjMgcG9vbFxuICAgIHRoaXMudmVjdG9yM1Bvb2wgPSBuZXcgT2JqZWN0UG9vbChcbiAgICAgICgpID0+IG5ldyBWZWN0b3IzKCksXG4gICAgICAodmVjdG9yKSA9PiB2ZWN0b3Iuc2V0KDAsIDAsIDApLFxuICAgICAgNTAgLy8gUG9vbCBzaXplIGZvciBQVlAgc2NlbmFyaW9zXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIFF1YXRlcm5pb24gcG9vbFxuICAgIHRoaXMucXVhdGVybmlvblBvb2wgPSBuZXcgT2JqZWN0UG9vbChcbiAgICAgICgpID0+IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgICAocXVhdGVybmlvbikgPT4gcXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSksXG4gICAgICAyMFxuICAgICk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBoaXQga2V5IHBvb2wgKGZvciBjb2xsaXNpb24gdHJhY2tpbmcpXG4gICAgdGhpcy5oaXRLZXlQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiAnJyxcbiAgICAgIChrZXkpID0+ICcnLCAvLyBTdHJpbmdzIGFyZSBpbW11dGFibGUsIHJlc2V0IGhhcHBlbnMgb24gYWNxdWlyZVxuICAgICAgMTAwXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGVmZmVjdCBkYXRhIHBvb2xcbiAgICB0aGlzLmVmZmVjdERhdGFQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiAoe1xuICAgICAgICBpZDogMCxcbiAgICAgICAgcGxheWVySWQ6ICcnLFxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICAgICAgc3RhcnRUaW1lOiAwLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZGVidWZmVHlwZTogdW5kZWZpbmVkIGFzICdmcm96ZW4nIHwgJ3Nsb3dlZCcgfCB1bmRlZmluZWRcbiAgICAgIH0pLFxuICAgICAgKGVmZmVjdERhdGEpID0+IHtcbiAgICAgICAgZWZmZWN0RGF0YS5pZCA9IDA7XG4gICAgICAgIGVmZmVjdERhdGEucGxheWVySWQgPSAnJztcbiAgICAgICAgZWZmZWN0RGF0YS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICAgIGVmZmVjdERhdGEuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgZWZmZWN0RGF0YS5kdXJhdGlvbiA9IDA7XG4gICAgICAgIGVmZmVjdERhdGEuZGVidWZmVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICAzMFxuICAgICk7XG4gICAgXG4gICAgLy8gUHJlLWFsbG9jYXRlIHRlbXBvcmFyeSBvYmplY3RzIGZvciBmcmFtZSBjYWxjdWxhdGlvbnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIHRoaXMudGVtcFZlY3RvcjNzLnB1c2gobmV3IFZlY3RvcjMoKSk7XG4gICAgICB0aGlzLnRlbXBRdWF0ZXJuaW9ucy5wdXNoKG5ldyBRdWF0ZXJuaW9uKCkpO1xuICAgIH1cbiAgfVxuICBcbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQVlBPYmplY3RQb29sIHtcbiAgICBpZiAoIVBWUE9iamVjdFBvb2wuaW5zdGFuY2UpIHtcbiAgICAgIFBWUE9iamVjdFBvb2wuaW5zdGFuY2UgPSBuZXcgUFZQT2JqZWN0UG9vbCgpO1xuICAgIH1cbiAgICByZXR1cm4gUFZQT2JqZWN0UG9vbC5pbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIFZlY3RvcjMgZnJvbSB0aGUgcG9vbFxuICAgKiBSZW1lbWJlciB0byBjYWxsIHJlbGVhc2VWZWN0b3IzIHdoZW4gZG9uZVxuICAgKi9cbiAgcHVibGljIGFjcXVpcmVWZWN0b3IzKHggPSAwLCB5ID0gMCwgeiA9IDApOiBWZWN0b3IzIHtcbiAgICBjb25zdCB2ZWN0b3IgPSB0aGlzLnZlY3RvcjNQb29sLmFjcXVpcmUoKTtcbiAgICB2ZWN0b3Iuc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBWZWN0b3IzIHRvIHRoZSBwb29sXG4gICAqL1xuICBwdWJsaWMgcmVsZWFzZVZlY3RvcjModmVjdG9yOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWN0b3IzUG9vbC5yZWxlYXNlKHZlY3Rvcik7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSB0ZW1wb3JhcnkgVmVjdG9yMyBmb3Igc2luZ2xlLWZyYW1lIGNhbGN1bGF0aW9uc1xuICAgKiBUaGVzZSBhcmUgYXV0b21hdGljYWxseSByZXNldCBlYWNoIGZyYW1lLCBkb24ndCBuZWVkIHRvIHJlbGVhc2VcbiAgICovXG4gIHB1YmxpYyBnZXRUZW1wVmVjdG9yMyh4ID0gMCwgeSA9IDAsIHogPSAwKTogVmVjdG9yMyB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRlbXBWZWN0b3JJbmRleCAlIHRoaXMudGVtcFZlY3RvcjNzLmxlbmd0aDtcbiAgICB0aGlzLnRlbXBWZWN0b3JJbmRleCsrO1xuICAgIGNvbnN0IHZlY3RvciA9IHRoaXMudGVtcFZlY3RvcjNzW2luZGV4XTtcbiAgICB2ZWN0b3Iuc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBRdWF0ZXJuaW9uIGZyb20gdGhlIHBvb2xcbiAgICovXG4gIHB1YmxpYyBhY3F1aXJlUXVhdGVybmlvbih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSk6IFF1YXRlcm5pb24ge1xuICAgIGNvbnN0IHF1YXRlcm5pb24gPSB0aGlzLnF1YXRlcm5pb25Qb29sLmFjcXVpcmUoKTtcbiAgICBxdWF0ZXJuaW9uLnNldCh4LCB5LCB6LCB3KTtcbiAgICByZXR1cm4gcXVhdGVybmlvbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybiBhIFF1YXRlcm5pb24gdG8gdGhlIHBvb2xcbiAgICovXG4gIHB1YmxpYyByZWxlYXNlUXVhdGVybmlvbihxdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uKTogdm9pZCB7XG4gICAgdGhpcy5xdWF0ZXJuaW9uUG9vbC5yZWxlYXNlKHF1YXRlcm5pb24pO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgdGVtcG9yYXJ5IFF1YXRlcm5pb24gZm9yIHNpbmdsZS1mcmFtZSBjYWxjdWxhdGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRUZW1wUXVhdGVybmlvbih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSk6IFF1YXRlcm5pb24ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy50ZW1wUXVhdGVybmlvbkluZGV4ICUgdGhpcy50ZW1wUXVhdGVybmlvbnMubGVuZ3RoO1xuICAgIHRoaXMudGVtcFF1YXRlcm5pb25JbmRleCsrO1xuICAgIGNvbnN0IHF1YXRlcm5pb24gPSB0aGlzLnRlbXBRdWF0ZXJuaW9uc1tpbmRleF07XG4gICAgcXVhdGVybmlvbi5zZXQoeCwgeSwgeiwgdyk7XG4gICAgcmV0dXJuIHF1YXRlcm5pb247XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBoaXQga2V5IGZvciBjb2xsaXNpb24gdHJhY2tpbmdcbiAgICovXG4gIHB1YmxpYyBjcmVhdGVIaXRLZXkoZW50aXR5SWQ6IG51bWJlciB8IHN0cmluZywgcGxheWVySWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke2VudGl0eUlkfS0ke3BsYXllcklkfWA7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYW4gZWZmZWN0IGRhdGEgb2JqZWN0IGZyb20gdGhlIHBvb2xcbiAgICovXG4gIHB1YmxpYyBhY3F1aXJlRWZmZWN0RGF0YSgpOiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBwbGF5ZXJJZDogc3RyaW5nO1xuICAgIHBvc2l0aW9uOiBWZWN0b3IzO1xuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgZGVidWZmVHlwZTogJ2Zyb3plbicgfCAnc2xvd2VkJyB8IHVuZGVmaW5lZDtcbiAgfSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0RGF0YVBvb2wuYWNxdWlyZSgpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJuIGFuIGVmZmVjdCBkYXRhIG9iamVjdCB0byB0aGUgcG9vbFxuICAgKi9cbiAgcHVibGljIHJlbGVhc2VFZmZlY3REYXRhKGVmZmVjdERhdGE6IHtcbiAgICBpZDogbnVtYmVyO1xuICAgIHBsYXllcklkOiBzdHJpbmc7XG4gICAgcG9zaXRpb246IFZlY3RvcjM7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnIHwgdW5kZWZpbmVkO1xuICB9KTogdm9pZCB7XG4gICAgdGhpcy5lZmZlY3REYXRhUG9vbC5yZWxlYXNlKGVmZmVjdERhdGEpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVzZXQgdGVtcG9yYXJ5IG9iamVjdCBpbmRpY2VzIChjYWxsIG9uY2UgcGVyIGZyYW1lKVxuICAgKi9cbiAgcHVibGljIHJlc2V0RnJhbWVUZW1wb3JhcmllcygpOiB2b2lkIHtcbiAgICB0aGlzLnRlbXBWZWN0b3JJbmRleCA9IDA7XG4gICAgdGhpcy50ZW1wUXVhdGVybmlvbkluZGV4ID0gMDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICAgKi9cbiAgcHVibGljIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZWN0b3IzUG9vbDogdGhpcy52ZWN0b3IzUG9vbC5nZXRQb29sU2l6ZSgpLFxuICAgICAgcXVhdGVybmlvblBvb2w6IHRoaXMucXVhdGVybmlvblBvb2wuZ2V0UG9vbFNpemUoKSxcbiAgICAgIGhpdEtleVBvb2w6IHRoaXMuaGl0S2V5UG9vbC5nZXRQb29sU2l6ZSgpLFxuICAgICAgZWZmZWN0RGF0YVBvb2w6IHRoaXMuZWZmZWN0RGF0YVBvb2wuZ2V0UG9vbFNpemUoKSxcbiAgICAgIHRlbXBWZWN0b3Izc1VzZWQ6IHRoaXMudGVtcFZlY3RvckluZGV4LFxuICAgICAgdGVtcFF1YXRlcm5pb25zVXNlZDogdGhpcy50ZW1wUXVhdGVybmlvbkluZGV4XG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENsZWFyIGFsbCBwb29scyAodXNlZnVsIGZvciBjbGVhbnVwKVxuICAgKi9cbiAgcHVibGljIGNsZWFyQWxsKCk6IHZvaWQge1xuICAgIHRoaXMudmVjdG9yM1Bvb2wuY2xlYXIoKTtcbiAgICB0aGlzLnF1YXRlcm5pb25Qb29sLmNsZWFyKCk7XG4gICAgdGhpcy5oaXRLZXlQb29sLmNsZWFyKCk7XG4gICAgdGhpcy5lZmZlY3REYXRhUG9vbC5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRGcmFtZVRlbXBvcmFyaWVzKCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZSBmb3IgZWFzeSBhY2Nlc3NcbmV4cG9ydCBjb25zdCBwdnBPYmplY3RQb29sID0gUFZQT2JqZWN0UG9vbC5nZXRJbnN0YW5jZSgpO1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiT2JqZWN0UG9vbCIsIlBWUE9iamVjdFBvb2wiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiYWNxdWlyZVZlY3RvcjMiLCJ4IiwieSIsInoiLCJ2ZWN0b3IiLCJ2ZWN0b3IzUG9vbCIsImFjcXVpcmUiLCJzZXQiLCJyZWxlYXNlVmVjdG9yMyIsInJlbGVhc2UiLCJnZXRUZW1wVmVjdG9yMyIsImluZGV4IiwidGVtcFZlY3RvckluZGV4IiwidGVtcFZlY3RvcjNzIiwibGVuZ3RoIiwiYWNxdWlyZVF1YXRlcm5pb24iLCJ3IiwicXVhdGVybmlvbiIsInF1YXRlcm5pb25Qb29sIiwicmVsZWFzZVF1YXRlcm5pb24iLCJnZXRUZW1wUXVhdGVybmlvbiIsInRlbXBRdWF0ZXJuaW9uSW5kZXgiLCJ0ZW1wUXVhdGVybmlvbnMiLCJjcmVhdGVIaXRLZXkiLCJlbnRpdHlJZCIsInBsYXllcklkIiwiYWNxdWlyZUVmZmVjdERhdGEiLCJlZmZlY3REYXRhUG9vbCIsInJlbGVhc2VFZmZlY3REYXRhIiwiZWZmZWN0RGF0YSIsInJlc2V0RnJhbWVUZW1wb3JhcmllcyIsImdldFN0YXRzIiwiZ2V0UG9vbFNpemUiLCJoaXRLZXlQb29sIiwidGVtcFZlY3RvcjNzVXNlZCIsInRlbXBRdWF0ZXJuaW9uc1VzZWQiLCJjbGVhckFsbCIsImNsZWFyIiwia2V5IiwiaWQiLCJwb3NpdGlvbiIsInN0YXJ0VGltZSIsImR1cmF0aW9uIiwiZGVidWZmVHlwZSIsInVuZGVmaW5lZCIsImkiLCJwdXNoIiwicHZwT2JqZWN0UG9vbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/PVPObjectPool.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/PVPStateBatcher.ts":
/*!**************************************!*\
  !*** ./src/utils/PVPStateBatcher.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PVPStateBatcher: function() { return /* binding */ PVPStateBatcher; },\n/* harmony export */   PVPStateUpdateHelpers: function() { return /* binding */ PVPStateUpdateHelpers; },\n/* harmony export */   pvpStateBatcher: function() { return /* binding */ pvpStateBatcher; }\n/* harmony export */ });\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n// PVP State Batching Utility for Performance Optimization\n\n/**\n * Batches multiple React state updates to prevent unnecessary re-renders\n * Particularly important for PVP scenarios with frequent state changes\n */ class PVPStateBatcher {\n    static getInstance() {\n        if (!PVPStateBatcher.instance) {\n            PVPStateBatcher.instance = new PVPStateBatcher();\n        }\n        return PVPStateBatcher.instance;\n    }\n    /**\n   * Add a state update to the batch queue\n   */ batchUpdate(updateFn) {\n        this.pendingUpdates.push(updateFn);\n        if (!this.batchScheduled) {\n            this.scheduleBatch();\n        }\n    }\n    /**\n   * Schedule a batch to be executed on the next frame\n   */ scheduleBatch() {\n        this.batchScheduled = true;\n        // Use requestAnimationFrame to batch updates at the end of the frame\n        this.frameId = requestAnimationFrame(()=>{\n            this.executeBatch();\n        });\n    }\n    /**\n   * Execute all pending state updates in a single batch\n   */ executeBatch() {\n        if (this.pendingUpdates.length === 0) {\n            this.batchScheduled = false;\n            return;\n        }\n        const updates = [\n            ...this.pendingUpdates\n        ];\n        this.pendingUpdates = [];\n        this.batchScheduled = false;\n        // Track performance metrics\n        this.batchCount++;\n        this.totalUpdatesInBatch += updates.length;\n        this.lastBatchTime = performance.now();\n        // Execute all updates in a single React batch\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_0__.unstable_batchedUpdates)(()=>{\n            updates.forEach((update)=>{\n                try {\n                    update();\n                } catch (error) {\n                    console.error(\"Error in batched state update:\", error);\n                }\n            });\n        });\n    }\n    /**\n   * Force execute any pending batches immediately\n   */ flushBatch() {\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = null;\n        }\n        this.executeBatch();\n    }\n    /**\n   * Get performance statistics\n   */ getStats() {\n        const avgUpdatesPerBatch = this.batchCount > 0 ? this.totalUpdatesInBatch / this.batchCount : 0;\n        return {\n            totalBatches: this.batchCount,\n            totalUpdates: this.totalUpdatesInBatch,\n            avgUpdatesPerBatch: Math.round(avgUpdatesPerBatch * 100) / 100,\n            pendingUpdates: this.pendingUpdates.length,\n            lastBatchTime: this.lastBatchTime,\n            batchScheduled: this.batchScheduled\n        };\n    }\n    /**\n   * Reset performance statistics\n   */ resetStats() {\n        this.batchCount = 0;\n        this.totalUpdatesInBatch = 0;\n        this.lastBatchTime = 0;\n    }\n    /**\n   * Clear all pending updates (useful for cleanup)\n   */ clear() {\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = null;\n        }\n        this.pendingUpdates = [];\n        this.batchScheduled = false;\n    }\n    constructor(){\n        // Pending state updates to batch\n        this.pendingUpdates = [];\n        this.batchScheduled = false;\n        this.frameId = null;\n        // Performance tracking\n        this.batchCount = 0;\n        this.totalUpdatesInBatch = 0;\n        this.lastBatchTime = 0;\n    }\n}\n// Export singleton instance\nconst pvpStateBatcher = PVPStateBatcher.getInstance();\n/**\n * Utility functions for common PVP state update patterns\n */ class PVPStateUpdateHelpers {\n    /**\n   * Batch multiple player state updates\n   */ static batchPlayerStateUpdates(setMultiplayerPlayerStates, updates) {\n        pvpStateBatcher.batchUpdate(()=>{\n            setMultiplayerPlayerStates((prev)=>{\n                const updated = new Map(prev);\n                updates.forEach((param)=>{\n                    let { playerId, stateUpdate } = param;\n                    const currentState = updated.get(playerId) || {\n                        isCharging: false,\n                        chargeProgress: 0,\n                        isSwinging: false,\n                        swordComboStep: 1,\n                        isDivineStorming: false,\n                        isSpinning: false,\n                        isSwordCharging: false,\n                        isDeflecting: false,\n                        isViperStingCharging: false,\n                        viperStingChargeProgress: 0,\n                        isBarrageCharging: false,\n                        barrageChargeProgress: 0,\n                        isCobraShotCharging: false,\n                        cobraShotChargeProgress: 0,\n                        isSkyfalling: false,\n                        isBackstabbing: false\n                    };\n                    updated.set(playerId, {\n                        ...currentState,\n                        ...stateUpdate,\n                        lastAnimationUpdate: Date.now()\n                    });\n                });\n                return updated;\n            });\n        });\n    }\n    /**\n   * Batch effect state updates (venom, debuff, etc.)\n   */ static batchEffectUpdates(updates) {\n        // Group updates by setter to minimize state update calls\n        const updatesBySetter = new Map();\n        updates.forEach((update)=>{\n            if (!updatesBySetter.has(update.setter)) {\n                updatesBySetter.set(update.setter, []);\n            }\n            updatesBySetter.get(update.setter).push(update);\n        });\n        // Batch all updates\n        pvpStateBatcher.batchUpdate(()=>{\n            updatesBySetter.forEach((setterUpdates, setter)=>{\n                setter((prev)=>{\n                    let newState = [\n                        ...prev\n                    ];\n                    setterUpdates.forEach((update)=>{\n                        if (update.type === \"add\" && update.data) {\n                            newState.push(update.data);\n                        } else if (update.type === \"remove\" && update.filterId !== undefined) {\n                            newState = newState.filter((effect)=>effect.id !== update.filterId);\n                        }\n                    });\n                    return newState;\n                });\n            });\n        });\n    }\n    /**\n   * Batch game state updates (position, weapon state, etc.)\n   */ static batchGameStateUpdates(updates) {\n        pvpStateBatcher.batchUpdate(()=>{\n            updates.forEach((param)=>{\n                let { setter, value } = param;\n                setter(value);\n            });\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9QVlBTdGF0ZUJhdGNoZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDBEQUEwRDtBQUNOO0FBR3BEOzs7Q0FHQyxHQUNNLE1BQU1DO0lBZVgsT0FBY0MsY0FBK0I7UUFDM0MsSUFBSSxDQUFDRCxnQkFBZ0JFLFFBQVEsRUFBRTtZQUM3QkYsZ0JBQWdCRSxRQUFRLEdBQUcsSUFBSUY7UUFDakM7UUFDQSxPQUFPQSxnQkFBZ0JFLFFBQVE7SUFDakM7SUFFQTs7R0FFQyxHQUNELFlBQW1CRSxRQUFvQixFQUFRO1FBQzdDLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNGO1FBRXpCLElBQUksQ0FBQyxJQUFJLENBQUNHLGNBQWMsRUFBRTtZQUN4QixJQUFJLENBQUNDLGFBQWE7UUFDcEI7SUFDRjtJQUVBOztHQUVDLEdBQ0QsZ0JBQThCO1FBQzVCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBRXRCLHFFQUFxRTtRQUNyRSxJQUFJLENBQUNFLE9BQU8sR0FBR0Msc0JBQXNCO1lBQ25DLElBQUksQ0FBQ0MsWUFBWTtRQUNuQjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxlQUE2QjtRQUMzQixJQUFJLElBQUksQ0FBQ04sY0FBYyxDQUFDTyxNQUFNLEtBQUssR0FBRztZQUNwQyxJQUFJLENBQUNMLGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTU0sVUFBVTtlQUFJLElBQUksQ0FBQ1IsY0FBYztTQUFDO1FBQ3hDLElBQUksQ0FBQ0EsY0FBYyxHQUFHLEVBQUU7UUFDeEIsSUFBSSxDQUFDRSxjQUFjLEdBQUc7UUFFdEIsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ08sVUFBVTtRQUNmLElBQUksQ0FBQ0MsbUJBQW1CLElBQUlGLFFBQVFELE1BQU07UUFDMUMsSUFBSSxDQUFDSSxhQUFhLEdBQUdDLFlBQVlDLEdBQUc7UUFFcEMsOENBQThDO1FBQzlDbkIsa0VBQXVCQSxDQUFDO1lBQ3RCYyxRQUFRTSxPQUFP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O1lBQ2QsSUFBSSxDQUFDNEMsZ0JBQWdCQyxHQUFHLENBQUM3QyxPQUFPOEMsTUFBTSxHQUFHO2dCQUN2Q0YsZ0JBQWdCSixHQUFHLENBQUN4QyxPQUFPOEMsTUFBTSxFQUFFLEVBQUU7WUFDdkM7WUFDQUYsZ0JBQWdCckIsR0FBRyxDQUFDdkIsT0FBTzhDLE1BQU0sRUFBRzVELElBQUksQ0FBQ2M7UUFDM0M7UUFFQSxvQkFBb0I7UUFDcEJhLGdCQUFnQjlCLFdBQVcsQ0FBQztZQUMxQjZELGdCQUFnQjdDLE9BQU8sQ0FBQyxDQUFDZ0QsZUFBZUQ7Z0JBQ3RDQSxPQUFPN0IsQ0FBQUE7b0JBQ0wsSUFBSStCLFdBQVc7MkJBQUkvQjtxQkFBSztvQkFFeEI4QixjQUFjaEQsT0FBTyxDQUFDQyxDQUFBQTt3QkFDcEIsSUFBSUEsT0FBT2lELElBQUksS0FBSyxTQUFTakQsT0FBT2tELElBQUksRUFBRTs0QkFDeENGLFNBQVM5RCxJQUFJLENBQUNjLE9BQU9rRCxJQUFJO3dCQUMzQixPQUFPLElBQUlsRCxPQUFPaUQsSUFBSSxLQUFLLFlBQVlqRCxPQUFPbUQsUUFBUSxLQUFLQyxXQUFXOzRCQUNwRUosV0FBV0EsU0FBU0ssTUFBTSxDQUFDQyxDQUFBQSxTQUFVQSxPQUFPQyxFQUFFLEtBQUt2RCxPQUFPbUQsUUFBUTt3QkFDcEU7b0JBQ0Y7b0JBRUEsT0FBT0g7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQU9RLHNCQUFzQi9ELE9BRzNCLEVBQVE7UUFDUm9CLGdCQUFnQjlCLFdBQVcsQ0FBQztZQUMxQlUsUUFBUU0sT0FBTyxDQUFDO29CQUFDLEVBQUUrQyxNQUFNLEVBQUVXLEtBQUssRUFBRTtnQkFDaENYLE9BQU9XO1lBQ1Q7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL1BWUFN0YXRlQmF0Y2hlci50cz9lNDAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBWUCBTdGF0ZSBCYXRjaGluZyBVdGlsaXR5IGZvciBQZXJmb3JtYW5jZSBPcHRpbWl6YXRpb25cbmltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG4vKipcbiAqIEJhdGNoZXMgbXVsdGlwbGUgUmVhY3Qgc3RhdGUgdXBkYXRlcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcbiAqIFBhcnRpY3VsYXJseSBpbXBvcnRhbnQgZm9yIFBWUCBzY2VuYXJpb3Mgd2l0aCBmcmVxdWVudCBzdGF0ZSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBQVlBTdGF0ZUJhdGNoZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUFZQU3RhdGVCYXRjaGVyO1xuICBcbiAgLy8gUGVuZGluZyBzdGF0ZSB1cGRhdGVzIHRvIGJhdGNoXG4gIHByaXZhdGUgcGVuZGluZ1VwZGF0ZXM6ICgoKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgYmF0Y2hTY2hlZHVsZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBmcmFtZUlkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIFBlcmZvcm1hbmNlIHRyYWNraW5nXG4gIHByaXZhdGUgYmF0Y2hDb3VudCA9IDA7XG4gIHByaXZhdGUgdG90YWxVcGRhdGVzSW5CYXRjaCA9IDA7XG4gIHByaXZhdGUgbGFzdEJhdGNoVGltZSA9IDA7XG4gIFxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cbiAgXG4gIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUFZQU3RhdGVCYXRjaGVyIHtcbiAgICBpZiAoIVBWUFN0YXRlQmF0Y2hlci5pbnN0YW5jZSkge1xuICAgICAgUFZQU3RhdGVCYXRjaGVyLmluc3RhbmNlID0gbmV3IFBWUFN0YXRlQmF0Y2hlcigpO1xuICAgIH1cbiAgICByZXR1cm4gUFZQU3RhdGVCYXRjaGVyLmluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEgc3RhdGUgdXBkYXRlIHRvIHRoZSBiYXRjaCBxdWV1ZVxuICAgKi9cbiAgcHVibGljIGJhdGNoVXBkYXRlKHVwZGF0ZUZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlcy5wdXNoKHVwZGF0ZUZuKTtcbiAgICBcbiAgICBpZiAoIXRoaXMuYmF0Y2hTY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVCYXRjaCgpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFNjaGVkdWxlIGEgYmF0Y2ggdG8gYmUgZXhlY3V0ZWQgb24gdGhlIG5leHQgZnJhbWVcbiAgICovXG4gIHByaXZhdGUgc2NoZWR1bGVCYXRjaCgpOiB2b2lkIHtcbiAgICB0aGlzLmJhdGNoU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBVc2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGJhdGNoIHVwZGF0ZXMgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5leGVjdXRlQmF0Y2goKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEV4ZWN1dGUgYWxsIHBlbmRpbmcgc3RhdGUgdXBkYXRlcyBpbiBhIHNpbmdsZSBiYXRjaFxuICAgKi9cbiAgcHJpdmF0ZSBleGVjdXRlQmF0Y2goKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1VwZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJhdGNoU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHVwZGF0ZXMgPSBbLi4udGhpcy5wZW5kaW5nVXBkYXRlc107XG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlcyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBcbiAgICAvLyBUcmFjayBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgdGhpcy5iYXRjaENvdW50Kys7XG4gICAgdGhpcy50b3RhbFVwZGF0ZXNJbkJhdGNoICs9IHVwZGF0ZXMubGVuZ3RoO1xuICAgIHRoaXMubGFzdEJhdGNoVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgYWxsIHVwZGF0ZXMgaW4gYSBzaW5nbGUgUmVhY3QgYmF0Y2hcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICB1cGRhdGVzLmZvckVhY2godXBkYXRlID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBiYXRjaGVkIHN0YXRlIHVwZGF0ZTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogRm9yY2UgZXhlY3V0ZSBhbnkgcGVuZGluZyBiYXRjaGVzIGltbWVkaWF0ZWx5XG4gICAqL1xuICBwdWJsaWMgZmx1c2hCYXRjaCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRlQmF0Y2goKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwZXJmb3JtYW5jZSBzdGF0aXN0aWNzXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgYXZnVXBkYXRlc1BlckJhdGNoID0gdGhpcy5iYXRjaENvdW50ID4gMCA/IHRoaXMudG90YWxVcGRhdGVzSW5CYXRjaCAvIHRoaXMuYmF0Y2hDb3VudCA6IDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQmF0Y2hlczogdGhpcy5iYXRjaENvdW50LFxuICAgICAgdG90YWxVcGRhdGVzOiB0aGlzLnRvdGFsVXBkYXRlc0luQmF0Y2gsXG4gICAgICBhdmdVcGRhdGVzUGVyQmF0Y2g6IE1hdGgucm91bmQoYXZnVXBkYXRlc1BlckJhdGNoICogMTAwKSAvIDEwMCxcbiAgICAgIHBlbmRpbmdVcGRhdGVzOiB0aGlzLnBlbmRpbmdVcGRhdGVzLmxlbmd0aCxcbiAgICAgIGxhc3RCYXRjaFRpbWU6IHRoaXMubGFzdEJhdGNoVGltZSxcbiAgICAgIGJhdGNoU2NoZWR1bGVkOiB0aGlzLmJhdGNoU2NoZWR1bGVkXG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlc2V0IHBlcmZvcm1hbmNlIHN0YXRpc3RpY3NcbiAgICovXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMuYmF0Y2hDb3VudCA9IDA7XG4gICAgdGhpcy50b3RhbFVwZGF0ZXNJbkJhdGNoID0gMDtcbiAgICB0aGlzLmxhc3RCYXRjaFRpbWUgPSAwO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xlYXIgYWxsIHBlbmRpbmcgdXBkYXRlcyAodXNlZnVsIGZvciBjbGVhbnVwKVxuICAgKi9cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmZyYW1lSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVJZCk7XG4gICAgICB0aGlzLmZyYW1lSWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdVcGRhdGVzID0gW107XG4gICAgdGhpcy5iYXRjaFNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBwdnBTdGF0ZUJhdGNoZXIgPSBQVlBTdGF0ZUJhdGNoZXIuZ2V0SW5zdGFuY2UoKTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgY29tbW9uIFBWUCBzdGF0ZSB1cGRhdGUgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGNsYXNzIFBWUFN0YXRlVXBkYXRlSGVscGVycyB7XG4gIC8qKlxuICAgKiBCYXRjaCBtdWx0aXBsZSBwbGF5ZXIgc3RhdGUgdXBkYXRlc1xuICAgKi9cbiAgc3RhdGljIGJhdGNoUGxheWVyU3RhdGVVcGRhdGVzKFxuICAgIHNldE11bHRpcGxheWVyUGxheWVyU3RhdGVzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxNYXA8c3RyaW5nLCBhbnk+Pj4sXG4gICAgdXBkYXRlczogQXJyYXk8eyBwbGF5ZXJJZDogc3RyaW5nOyBzdGF0ZVVwZGF0ZTogUGFydGlhbDxhbnk+IH0+XG4gICk6IHZvaWQge1xuICAgIHB2cFN0YXRlQmF0Y2hlci5iYXRjaFVwZGF0ZSgoKSA9PiB7XG4gICAgICBzZXRNdWx0aXBsYXllclBsYXllclN0YXRlcyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IG5ldyBNYXAocHJldik7XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVzLmZvckVhY2goKHsgcGxheWVySWQsIHN0YXRlVXBkYXRlIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB1cGRhdGVkLmdldChwbGF5ZXJJZCkgfHwge1xuICAgICAgICAgICAgaXNDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBjaGFyZ2VQcm9ncmVzczogMCxcbiAgICAgICAgICAgIGlzU3dpbmdpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc3dvcmRDb21ib1N0ZXA6IDEgYXMgMSB8IDIgfCAzLFxuICAgICAgICAgICAgaXNEaXZpbmVTdG9ybWluZzogZmFsc2UsXG4gICAgICAgICAgICBpc1NwaW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3dvcmRDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc0RlZmxlY3Rpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaXBlclN0aW5nQ2hhcmdpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzOiAwLFxuICAgICAgICAgICAgaXNCYXJyYWdlQ2hhcmdpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYmFycmFnZUNoYXJnZVByb2dyZXNzOiAwLFxuICAgICAgICAgICAgaXNDb2JyYVNob3RDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBjb2JyYVNob3RDaGFyZ2VQcm9ncmVzczogMCxcbiAgICAgICAgICAgIGlzU2t5ZmFsbGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc0JhY2tzdGFiYmluZzogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHVwZGF0ZWQuc2V0KHBsYXllcklkLCB7XG4gICAgICAgICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAgICAgICAuLi5zdGF0ZVVwZGF0ZSxcbiAgICAgICAgICAgIGxhc3RBbmltYXRpb25VcGRhdGU6IERhdGUubm93KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQmF0Y2ggZWZmZWN0IHN0YXRlIHVwZGF0ZXMgKHZlbm9tLCBkZWJ1ZmYsIGV0Yy4pXG4gICAqL1xuICBzdGF0aWMgYmF0Y2hFZmZlY3RVcGRhdGVzKHVwZGF0ZXM6IEFycmF5PHtcbiAgICB0eXBlOiAnYWRkJyB8ICdyZW1vdmUnO1xuICAgIGVmZmVjdFR5cGU6ICd2ZW5vbScgfCAnZGVidWZmJyB8ICdyZWFuaW1hdGUnIHwgJ2Zyb3N0Tm92YScgfCAnc21pdGUnIHwgJ2RlYXRoZ3Jhc3AnIHwgJ2NvbG9zc3VzU3RyaWtlJztcbiAgICBzZXR0ZXI6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPGFueVtdPj47XG4gICAgZGF0YT86IGFueTtcbiAgICBmaWx0ZXJJZD86IG51bWJlcjtcbiAgfT4pOiB2b2lkIHtcbiAgICAvLyBHcm91cCB1cGRhdGVzIGJ5IHNldHRlciB0byBtaW5pbWl6ZSBzdGF0ZSB1cGRhdGUgY2FsbHNcbiAgICBjb25zdCB1cGRhdGVzQnlTZXR0ZXIgPSBuZXcgTWFwPFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPGFueVtdPj4sIEFycmF5PGFueT4+KCk7XG4gICAgXG4gICAgdXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB7XG4gICAgICBpZiAoIXVwZGF0ZXNCeVNldHRlci5oYXModXBkYXRlLnNldHRlcikpIHtcbiAgICAgICAgdXBkYXRlc0J5U2V0dGVyLnNldCh1cGRhdGUuc2V0dGVyLCBbXSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVzQnlTZXR0ZXIuZ2V0KHVwZGF0ZS5zZXR0ZXIpIS5wdXNoKHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQmF0Y2ggYWxsIHVwZGF0ZXNcbiAgICBwdnBTdGF0ZUJhdGNoZXIuYmF0Y2hVcGRhdGUoKCkgPT4ge1xuICAgICAgdXBkYXRlc0J5U2V0dGVyLmZvckVhY2goKHNldHRlclVwZGF0ZXMsIHNldHRlcikgPT4ge1xuICAgICAgICBzZXR0ZXIocHJldiA9PiB7XG4gICAgICAgICAgbGV0IG5ld1N0YXRlID0gWy4uLnByZXZdO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldHRlclVwZGF0ZXMuZm9yRWFjaCh1cGRhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSAnYWRkJyAmJiB1cGRhdGUuZGF0YSkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKHVwZGF0ZS5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodXBkYXRlLnR5cGUgPT09ICdyZW1vdmUnICYmIHVwZGF0ZS5maWx0ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUuZmlsdGVyKGVmZmVjdCA9PiBlZmZlY3QuaWQgIT09IHVwZGF0ZS5maWx0ZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQmF0Y2ggZ2FtZSBzdGF0ZSB1cGRhdGVzIChwb3NpdGlvbiwgd2VhcG9uIHN0YXRlLCBldGMuKVxuICAgKi9cbiAgc3RhdGljIGJhdGNoR2FtZVN0YXRlVXBkYXRlcyh1cGRhdGVzOiBBcnJheTx7XG4gICAgc2V0dGVyOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxhbnk+PjtcbiAgICB2YWx1ZTogYW55O1xuICB9Pik6IHZvaWQge1xuICAgIHB2cFN0YXRlQmF0Y2hlci5iYXRjaFVwZGF0ZSgoKSA9PiB7XG4gICAgICB1cGRhdGVzLmZvckVhY2goKHsgc2V0dGVyLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIHNldHRlcih2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwiUFZQU3RhdGVCYXRjaGVyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImJhdGNoVXBkYXRlIiwidXBkYXRlRm4iLCJwZW5kaW5nVXBkYXRlcyIsInB1c2giLCJiYXRjaFNjaGVkdWxlZCIsInNjaGVkdWxlQmF0Y2giLCJmcmFtZUlkIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZXhlY3V0ZUJhdGNoIiwibGVuZ3RoIiwidXBkYXRlcyIsImJhdGNoQ291bnQiLCJ0b3RhbFVwZGF0ZXNJbkJhdGNoIiwibGFzdEJhdGNoVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZm9yRWFjaCIsInVwZGF0ZSIsImVycm9yIiwiY29uc29sZSIsImZsdXNoQmF0Y2giLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImdldFN0YXRzIiwiYXZnVXBkYXRlc1BlckJhdGNoIiwidG90YWxCYXRjaGVzIiwidG90YWxVcGRhdGVzIiwiTWF0aCIsInJvdW5kIiwicmVzZXRTdGF0cyIsImNsZWFyIiwicHZwU3RhdGVCYXRjaGVyIiwiUFZQU3RhdGVVcGRhdGVIZWxwZXJzIiwiYmF0Y2hQbGF5ZXJTdGF0ZVVwZGF0ZXMiLCJzZXRNdWx0aXBsYXllclBsYXllclN0YXRlcyIsInByZXYiLCJ1cGRhdGVkIiwiTWFwIiwicGxheWVySWQiLCJzdGF0ZVVwZGF0ZSIsImN1cnJlbnRTdGF0ZSIsImdldCIsImlzQ2hhcmdpbmciLCJjaGFyZ2VQcm9ncmVzcyIsImlzU3dpbmdpbmciLCJzd29yZENvbWJvU3RlcCIsImlzRGl2aW5lU3Rvcm1pbmciLCJpc1NwaW5uaW5nIiwiaXNTd29yZENoYXJnaW5nIiwiaXNEZWZsZWN0aW5nIiwiaXNWaXBlclN0aW5nQ2hhcmdpbmciLCJ2aXBlclN0aW5nQ2hhcmdlUHJvZ3Jlc3MiLCJpc0JhcnJhZ2VDaGFyZ2luZyIsImJhcnJhZ2VDaGFyZ2VQcm9ncmVzcyIsImlzQ29icmFTaG90Q2hhcmdpbmciLCJjb2JyYVNob3RDaGFyZ2VQcm9ncmVzcyIsImlzU2t5ZmFsbGluZyIsImlzQmFja3N0YWJiaW5nIiwic2V0IiwibGFzdEFuaW1hdGlvblVwZGF0ZSIsIkRhdGUiLCJiYXRjaEVmZmVjdFVwZGF0ZXMiLCJ1cGRhdGVzQnlTZXR0ZXIiLCJoYXMiLCJzZXR0ZXIiLCJzZXR0ZXJVcGRhdGVzIiwibmV3U3RhdGUiLCJ0eXBlIiwiZGF0YSIsImZpbHRlcklkIiwidW5kZWZpbmVkIiwiZmlsdGVyIiwiZWZmZWN0IiwiaWQiLCJiYXRjaEdhbWVTdGF0ZVVwZGF0ZXMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/PVPStateBatcher.ts\n"));

/***/ })

}]);