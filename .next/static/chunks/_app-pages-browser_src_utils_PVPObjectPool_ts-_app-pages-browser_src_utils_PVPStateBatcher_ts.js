"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_utils_PVPObjectPool_ts-_app-pages-browser_src_utils_PVPStateBatcher_ts"],{

/***/ "(app-pages-browser)/./src/utils/PVPObjectPool.ts":
/*!************************************!*\
  !*** ./src/utils/PVPObjectPool.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PVPObjectPool: function() { return /* binding */ PVPObjectPool; },\n/* harmony export */   pvpObjectPool: function() { return /* binding */ pvpObjectPool; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n/* harmony import */ var _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/ObjectPool */ \"(app-pages-browser)/./src/utils/ObjectPool.ts\");\n// PVP Object Pool for performance optimization in multiplayer scenarios\n\n\n/**\n * Centralized object pooling system for PVP components\n * Reduces garbage collection pressure by reusing frequently created objects\n */ class PVPObjectPool {\n    static getInstance() {\n        if (!PVPObjectPool.instance) {\n            PVPObjectPool.instance = new PVPObjectPool();\n        }\n        return PVPObjectPool.instance;\n    }\n    /**\n   * Get a Vector3 from the pool\n   * Remember to call releaseVector3 when done\n   */ acquireVector3() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const vector = this.vector3Pool.acquire();\n        vector.set(x, y, z);\n        return vector;\n    }\n    /**\n   * Return a Vector3 to the pool\n   */ releaseVector3(vector) {\n        this.vector3Pool.release(vector);\n    }\n    /**\n   * Get a temporary Vector3 for single-frame calculations\n   * These are automatically reset each frame, don't need to release\n   */ getTempVector3() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const index = this.tempVectorIndex % this.tempVector3s.length;\n        this.tempVectorIndex++;\n        const vector = this.tempVector3s[index];\n        vector.set(x, y, z);\n        return vector;\n    }\n    /**\n   * Get a Quaternion from the pool\n   */ acquireQuaternion() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        const quaternion = this.quaternionPool.acquire();\n        quaternion.set(x, y, z, w);\n        return quaternion;\n    }\n    /**\n   * Return a Quaternion to the pool\n   */ releaseQuaternion(quaternion) {\n        this.quaternionPool.release(quaternion);\n    }\n    /**\n   * Get a temporary Quaternion for single-frame calculations\n   */ getTempQuaternion() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        const index = this.tempQuaternionIndex % this.tempQuaternions.length;\n        this.tempQuaternionIndex++;\n        const quaternion = this.tempQuaternions[index];\n        quaternion.set(x, y, z, w);\n        return quaternion;\n    }\n    /**\n   * Create a hit key for collision tracking\n   */ createHitKey(entityId, playerId) {\n        return \"\".concat(entityId, \"-\").concat(playerId);\n    }\n    /**\n   * Get an effect data object from the pool\n   */ acquireEffectData() {\n        return this.effectDataPool.acquire();\n    }\n    /**\n   * Return an effect data object to the pool\n   */ releaseEffectData(effectData) {\n        this.effectDataPool.release(effectData);\n    }\n    /**\n   * Reset temporary object indices (call once per frame)\n   */ resetFrameTemporaries() {\n        this.tempVectorIndex = 0;\n        this.tempQuaternionIndex = 0;\n    }\n    /**\n   * Get pool statistics for debugging\n   */ getStats() {\n        return {\n            vector3Pool: this.vector3Pool.getPoolSize(),\n            quaternionPool: this.quaternionPool.getPoolSize(),\n            hitKeyPool: this.hitKeyPool.getPoolSize(),\n            effectDataPool: this.effectDataPool.getPoolSize(),\n            tempVector3sUsed: this.tempVectorIndex,\n            tempQuaternionsUsed: this.tempQuaternionIndex\n        };\n    }\n    /**\n   * Clear all pools (useful for cleanup)\n   */ clearAll() {\n        this.vector3Pool.clear();\n        this.quaternionPool.clear();\n        this.hitKeyPool.clear();\n        this.effectDataPool.clear();\n        this.resetFrameTemporaries();\n    }\n    constructor(){\n        // Temporary objects for calculations (reused within single frame)\n        this.tempVector3s = [];\n        this.tempQuaternions = [];\n        this.tempVectorIndex = 0;\n        this.tempQuaternionIndex = 0;\n        // Initialize Vector3 pool\n        this.vector3Pool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(), (vector)=>vector.set(0, 0, 0), 50 // Pool size for PVP scenarios\n        );\n        // Initialize Quaternion pool\n        this.quaternionPool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), (quaternion)=>quaternion.set(0, 0, 0, 1), 20);\n        // Initialize hit key pool (for collision tracking)\n        this.hitKeyPool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>\"\", (key)=>\"\", 100);\n        // Initialize effect data pool\n        this.effectDataPool = new _utils_ObjectPool__WEBPACK_IMPORTED_MODULE_1__.ObjectPool(()=>({\n                id: 0,\n                playerId: \"\",\n                position: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n                startTime: 0,\n                duration: 0,\n                debuffType: undefined\n            }), (effectData)=>{\n            effectData.id = 0;\n            effectData.playerId = \"\";\n            effectData.position.set(0, 0, 0);\n            effectData.startTime = 0;\n            effectData.duration = 0;\n            effectData.debuffType = undefined;\n        }, 30);\n        // Pre-allocate temporary objects for frame calculations\n        for(let i = 0; i < 10; i++){\n            this.tempVector3s.push(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n            this.tempQuaternions.push(new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Quaternion());\n        }\n    }\n}\n// Export singleton instance for easy access\nconst pvpObjectPool = PVPObjectPool.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9QVlBPYmplY3RQb29sLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx3RUFBd0U7QUFDWjtBQUNaO0FBRWhEOzs7Q0FHQyxHQUNNLE1BQU1HO0lBd0VYLE9BQWNDLGNBQTZCO1FBQ3pDLElBQUksQ0FBQ0QsY0FBY0UsUUFBUSxFQUFFO1lBQzNCRixjQUFjRSxRQUFRLEdBQUcsSUFBSUY7UUFDL0I7UUFDQSxPQUFPQSxjQUFjRSxRQUFRO0lBQy9CO0lBRUE7OztHQUdDLEdBQ0QsaUJBQW9EO1lBQTlCRSxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSTtRQUN0QyxNQUFNQyxTQUFTLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxPQUFPO1FBQ3ZDRixPQUFPRyxHQUFHLENBQUNOLEdBQUdDLEdBQUdDO1FBQ2pCLE9BQU9DO0lBQ1Q7SUFFQTs7R0FFQyxHQUNELGVBQXNCQSxNQUFlLEVBQVE7UUFDM0MsSUFBSSxDQUFDQyxXQUFXLENBQUNJLE9BQU8sQ0FBQ0w7SUFDM0I7SUFFQTs7O0dBR0MsR0FDRCxpQkFBb0Q7WUFBOUJILElBQUFBLGlFQUFJLEdBQUdDLElBQUFBLGlFQUFJLEdBQUdDLElBQUFBLGlFQUFJO1FBQ3RDLE1BQU1RLFFBQVEsSUFBSSxDQUFDQyxlQUFlLEdBQUcsSUFBSSxDQUFDQyxZQUFZLENBQUNDLE1BQU07UUFDN0QsSUFBSSxDQUFDRixlQUFlO1FBQ3BCLE1BQU1SLFNBQVMsSUFBSSxDQUFDUyxZQUFZLENBQUNGLE1BQU07UUFDdkNQLE9BQU9HLEdBQUcsQ0FBQ04sR0FBR0MsR0FBR0M7UUFDakIsT0FBT0M7SUFDVDtJQUVBOztHQUVDLEdBQ0Qsb0JBQWlFO1lBQXhDSCxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSSxHQUFHQyxJQUFBQSxpRUFBSSxHQUFHYSxJQUFBQSxpRUFBSTtRQUNoRCxNQUFNQyxhQUFhLElBQUksQ0FBQ0MsY0FBYyxDQUFD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O2dCQUNYQyxVQUFVO2dCQUNWQyxZQUFZQztZQUNkLElBQ0EsQ0FBQ2Y7WUFDQ0EsV0FBV1UsRUFBRSxHQUFHO1lBQ2hCVixXQUFXSixRQUFRLEdBQUc7WUFDdEJJLFdBQVdXLFFBQVEsQ0FBQ2pDLEdBQUcsQ0FBQyxHQUFHLEdBQUc7WUFDOUJzQixXQUFXWSxTQUFTLEdBQUc7WUFDdkJaLFdBQVdhLFFBQVEsR0FBRztZQUN0QmIsV0FBV2MsVUFBVSxHQUFHQztRQUMxQixHQUNBO1FBR0Ysd0RBQXdEO1FBQ3hELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7WUFDM0IsSUFBSSxDQUFDaEMsWUFBWSxDQUFDaUMsSUFBSSxDQUFDLElBQUlwRCx5REFBT0E7WUFDbEMsSUFBSSxDQUFDNEIsZUFBZSxDQUFDd0IsSUFBSSxDQUFDLElBQUluRCw0REFBVUE7UUFDMUM7SUFDRjtBQW9JRjtBQUVBLDRDQUE0QztBQUNyQyxNQUFNb0QsZ0JBQWdCbEQsY0FBY0MsV0FBVyxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9QVlBPYmplY3RQb29sLnRzPzU3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUFZQIE9iamVjdCBQb29sIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gaW4gbXVsdGlwbGF5ZXIgc2NlbmFyaW9zXG5pbXBvcnQgeyBWZWN0b3IzLCBRdWF0ZXJuaW9uIH0gZnJvbSAnQC91dGlscy90aHJlZS1leHBvcnRzJztcbmltcG9ydCB7IE9iamVjdFBvb2wgfSBmcm9tICdAL3V0aWxzL09iamVjdFBvb2wnO1xuXG4vKipcbiAqIENlbnRyYWxpemVkIG9iamVjdCBwb29saW5nIHN5c3RlbSBmb3IgUFZQIGNvbXBvbmVudHNcbiAqIFJlZHVjZXMgZ2FyYmFnZSBjb2xsZWN0aW9uIHByZXNzdXJlIGJ5IHJldXNpbmcgZnJlcXVlbnRseSBjcmVhdGVkIG9iamVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFBWUE9iamVjdFBvb2wge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUFZQT2JqZWN0UG9vbDtcbiAgXG4gIC8vIE9iamVjdCBwb29scyBmb3IgZGlmZmVyZW50IHR5cGVzXG4gIHByaXZhdGUgdmVjdG9yM1Bvb2w6IE9iamVjdFBvb2w8VmVjdG9yMz47XG4gIHByaXZhdGUgcXVhdGVybmlvblBvb2w6IE9iamVjdFBvb2w8UXVhdGVybmlvbj47XG4gIHByaXZhdGUgaGl0S2V5UG9vbDogT2JqZWN0UG9vbDxzdHJpbmc+O1xuICBwcml2YXRlIGVmZmVjdERhdGFQb29sOiBPYmplY3RQb29sPHtcbiAgICBpZDogbnVtYmVyO1xuICAgIHBsYXllcklkOiBzdHJpbmc7XG4gICAgcG9zaXRpb246IFZlY3RvcjM7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnIHwgdW5kZWZpbmVkO1xuICB9PjtcbiAgXG4gIC8vIFRlbXBvcmFyeSBvYmplY3RzIGZvciBjYWxjdWxhdGlvbnMgKHJldXNlZCB3aXRoaW4gc2luZ2xlIGZyYW1lKVxuICBwcml2YXRlIHRlbXBWZWN0b3IzczogVmVjdG9yM1tdID0gW107XG4gIHByaXZhdGUgdGVtcFF1YXRlcm5pb25zOiBRdWF0ZXJuaW9uW10gPSBbXTtcbiAgcHJpdmF0ZSB0ZW1wVmVjdG9ySW5kZXggPSAwO1xuICBwcml2YXRlIHRlbXBRdWF0ZXJuaW9uSW5kZXggPSAwO1xuICBcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBJbml0aWFsaXplIFZlY3RvcjMgcG9vbFxuICAgIHRoaXMudmVjdG9yM1Bvb2wgPSBuZXcgT2JqZWN0UG9vbChcbiAgICAgICgpID0+IG5ldyBWZWN0b3IzKCksXG4gICAgICAodmVjdG9yKSA9PiB2ZWN0b3Iuc2V0KDAsIDAsIDApLFxuICAgICAgNTAgLy8gUG9vbCBzaXplIGZvciBQVlAgc2NlbmFyaW9zXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIFF1YXRlcm5pb24gcG9vbFxuICAgIHRoaXMucXVhdGVybmlvblBvb2wgPSBuZXcgT2JqZWN0UG9vbChcbiAgICAgICgpID0+IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgICAocXVhdGVybmlvbikgPT4gcXVhdGVybmlvbi5zZXQoMCwgMCwgMCwgMSksXG4gICAgICAyMFxuICAgICk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBoaXQga2V5IHBvb2wgKGZvciBjb2xsaXNpb24gdHJhY2tpbmcpXG4gICAgdGhpcy5oaXRLZXlQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiAnJyxcbiAgICAgIChrZXkpID0+ICcnLCAvLyBTdHJpbmdzIGFyZSBpbW11dGFibGUsIHJlc2V0IGhhcHBlbnMgb24gYWNxdWlyZVxuICAgICAgMTAwXG4gICAgKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGVmZmVjdCBkYXRhIHBvb2xcbiAgICB0aGlzLmVmZmVjdERhdGFQb29sID0gbmV3IE9iamVjdFBvb2woXG4gICAgICAoKSA9PiAoe1xuICAgICAgICBpZDogMCxcbiAgICAgICAgcGxheWVySWQ6ICcnLFxuICAgICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICAgICAgc3RhcnRUaW1lOiAwLFxuICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgZGVidWZmVHlwZTogdW5kZWZpbmVkIGFzICdmcm96ZW4nIHwgJ3Nsb3dlZCcgfCB1bmRlZmluZWRcbiAgICAgIH0pLFxuICAgICAgKGVmZmVjdERhdGEpID0+IHtcbiAgICAgICAgZWZmZWN0RGF0YS5pZCA9IDA7XG4gICAgICAgIGVmZmVjdERhdGEucGxheWVySWQgPSAnJztcbiAgICAgICAgZWZmZWN0RGF0YS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICAgIGVmZmVjdERhdGEuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgZWZmZWN0RGF0YS5kdXJhdGlvbiA9IDA7XG4gICAgICAgIGVmZmVjdERhdGEuZGVidWZmVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICAzMFxuICAgICk7XG4gICAgXG4gICAgLy8gUHJlLWFsbG9jYXRlIHRlbXBvcmFyeSBvYmplY3RzIGZvciBmcmFtZSBjYWxjdWxhdGlvbnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgIHRoaXMudGVtcFZlY3RvcjNzLnB1c2gobmV3IFZlY3RvcjMoKSk7XG4gICAgICB0aGlzLnRlbXBRdWF0ZXJuaW9ucy5wdXNoKG5ldyBRdWF0ZXJuaW9uKCkpO1xuICAgIH1cbiAgfVxuICBcbiAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBQVlBPYmplY3RQb29sIHtcbiAgICBpZiAoIVBWUE9iamVjdFBvb2wuaW5zdGFuY2UpIHtcbiAgICAgIFBWUE9iamVjdFBvb2wuaW5zdGFuY2UgPSBuZXcgUFZQT2JqZWN0UG9vbCgpO1xuICAgIH1cbiAgICByZXR1cm4gUFZQT2JqZWN0UG9vbC5pbnN0YW5jZTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBhIFZlY3RvcjMgZnJvbSB0aGUgcG9vbFxuICAgKiBSZW1lbWJlciB0byBjYWxsIHJlbGVhc2VWZWN0b3IzIHdoZW4gZG9uZVxuICAgKi9cbiAgcHVibGljIGFjcXVpcmVWZWN0b3IzKHggPSAwLCB5ID0gMCwgeiA9IDApOiBWZWN0b3IzIHtcbiAgICBjb25zdCB2ZWN0b3IgPSB0aGlzLnZlY3RvcjNQb29sLmFjcXVpcmUoKTtcbiAgICB2ZWN0b3Iuc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBWZWN0b3IzIHRvIHRoZSBwb29sXG4gICAqL1xuICBwdWJsaWMgcmVsZWFzZVZlY3RvcjModmVjdG9yOiBWZWN0b3IzKTogdm9pZCB7XG4gICAgdGhpcy52ZWN0b3IzUG9vbC5yZWxlYXNlKHZlY3Rvcik7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSB0ZW1wb3JhcnkgVmVjdG9yMyBmb3Igc2luZ2xlLWZyYW1lIGNhbGN1bGF0aW9uc1xuICAgKiBUaGVzZSBhcmUgYXV0b21hdGljYWxseSByZXNldCBlYWNoIGZyYW1lLCBkb24ndCBuZWVkIHRvIHJlbGVhc2VcbiAgICovXG4gIHB1YmxpYyBnZXRUZW1wVmVjdG9yMyh4ID0gMCwgeSA9IDAsIHogPSAwKTogVmVjdG9yMyB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRlbXBWZWN0b3JJbmRleCAlIHRoaXMudGVtcFZlY3RvcjNzLmxlbmd0aDtcbiAgICB0aGlzLnRlbXBWZWN0b3JJbmRleCsrO1xuICAgIGNvbnN0IHZlY3RvciA9IHRoaXMudGVtcFZlY3RvcjNzW2luZGV4XTtcbiAgICB2ZWN0b3Iuc2V0KHgsIHksIHopO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBRdWF0ZXJuaW9uIGZyb20gdGhlIHBvb2xcbiAgICovXG4gIHB1YmxpYyBhY3F1aXJlUXVhdGVybmlvbih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSk6IFF1YXRlcm5pb24ge1xuICAgIGNvbnN0IHF1YXRlcm5pb24gPSB0aGlzLnF1YXRlcm5pb25Qb29sLmFjcXVpcmUoKTtcbiAgICBxdWF0ZXJuaW9uLnNldCh4LCB5LCB6LCB3KTtcbiAgICByZXR1cm4gcXVhdGVybmlvbjtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJldHVybiBhIFF1YXRlcm5pb24gdG8gdGhlIHBvb2xcbiAgICovXG4gIHB1YmxpYyByZWxlYXNlUXVhdGVybmlvbihxdWF0ZXJuaW9uOiBRdWF0ZXJuaW9uKTogdm9pZCB7XG4gICAgdGhpcy5xdWF0ZXJuaW9uUG9vbC5yZWxlYXNlKHF1YXRlcm5pb24pO1xuICB9XG4gIFxuICAvKipcbiAgICogR2V0IGEgdGVtcG9yYXJ5IFF1YXRlcm5pb24gZm9yIHNpbmdsZS1mcmFtZSBjYWxjdWxhdGlvbnNcbiAgICovXG4gIHB1YmxpYyBnZXRUZW1wUXVhdGVybmlvbih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSk6IFF1YXRlcm5pb24ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy50ZW1wUXVhdGVybmlvbkluZGV4ICUgdGhpcy50ZW1wUXVhdGVybmlvbnMubGVuZ3RoO1xuICAgIHRoaXMudGVtcFF1YXRlcm5pb25JbmRleCsrO1xuICAgIGNvbnN0IHF1YXRlcm5pb24gPSB0aGlzLnRlbXBRdWF0ZXJuaW9uc1tpbmRleF07XG4gICAgcXVhdGVybmlvbi5zZXQoeCwgeSwgeiwgdyk7XG4gICAgcmV0dXJuIHF1YXRlcm5pb247XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBoaXQga2V5IGZvciBjb2xsaXNpb24gdHJhY2tpbmdcbiAgICovXG4gIHB1YmxpYyBjcmVhdGVIaXRLZXkoZW50aXR5SWQ6IG51bWJlciB8IHN0cmluZywgcGxheWVySWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke2VudGl0eUlkfS0ke3BsYXllcklkfWA7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBHZXQgYW4gZWZmZWN0IGRhdGEgb2JqZWN0IGZyb20gdGhlIHBvb2xcbiAgICovXG4gIHB1YmxpYyBhY3F1aXJlRWZmZWN0RGF0YSgpOiB7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBwbGF5ZXJJZDogc3RyaW5nO1xuICAgIHBvc2l0aW9uOiBWZWN0b3IzO1xuICAgIHN0YXJ0VGltZTogbnVtYmVyO1xuICAgIGR1cmF0aW9uOiBudW1iZXI7XG4gICAgZGVidWZmVHlwZTogJ2Zyb3plbicgfCAnc2xvd2VkJyB8IHVuZGVmaW5lZDtcbiAgfSB7XG4gICAgcmV0dXJuIHRoaXMuZWZmZWN0RGF0YVBvb2wuYWNxdWlyZSgpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmV0dXJuIGFuIGVmZmVjdCBkYXRhIG9iamVjdCB0byB0aGUgcG9vbFxuICAgKi9cbiAgcHVibGljIHJlbGVhc2VFZmZlY3REYXRhKGVmZmVjdERhdGE6IHtcbiAgICBpZDogbnVtYmVyO1xuICAgIHBsYXllcklkOiBzdHJpbmc7XG4gICAgcG9zaXRpb246IFZlY3RvcjM7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZHVyYXRpb246IG51bWJlcjtcbiAgICBkZWJ1ZmZUeXBlOiAnZnJvemVuJyB8ICdzbG93ZWQnIHwgdW5kZWZpbmVkO1xuICB9KTogdm9pZCB7XG4gICAgdGhpcy5lZmZlY3REYXRhUG9vbC5yZWxlYXNlKGVmZmVjdERhdGEpO1xuICB9XG4gIFxuICAvKipcbiAgICogUmVzZXQgdGVtcG9yYXJ5IG9iamVjdCBpbmRpY2VzIChjYWxsIG9uY2UgcGVyIGZyYW1lKVxuICAgKi9cbiAgcHVibGljIHJlc2V0RnJhbWVUZW1wb3JhcmllcygpOiB2b2lkIHtcbiAgICB0aGlzLnRlbXBWZWN0b3JJbmRleCA9IDA7XG4gICAgdGhpcy50ZW1wUXVhdGVybmlvbkluZGV4ID0gMDtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwb29sIHN0YXRpc3RpY3MgZm9yIGRlYnVnZ2luZ1xuICAgKi9cbiAgcHVibGljIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZWN0b3IzUG9vbDogdGhpcy52ZWN0b3IzUG9vbC5nZXRQb29sU2l6ZSgpLFxuICAgICAgcXVhdGVybmlvblBvb2w6IHRoaXMucXVhdGVybmlvblBvb2wuZ2V0UG9vbFNpemUoKSxcbiAgICAgIGhpdEtleVBvb2w6IHRoaXMuaGl0S2V5UG9vbC5nZXRQb29sU2l6ZSgpLFxuICAgICAgZWZmZWN0RGF0YVBvb2w6IHRoaXMuZWZmZWN0RGF0YVBvb2wuZ2V0UG9vbFNpemUoKSxcbiAgICAgIHRlbXBWZWN0b3Izc1VzZWQ6IHRoaXMudGVtcFZlY3RvckluZGV4LFxuICAgICAgdGVtcFF1YXRlcm5pb25zVXNlZDogdGhpcy50ZW1wUXVhdGVybmlvbkluZGV4XG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIENsZWFyIGFsbCBwb29scyAodXNlZnVsIGZvciBjbGVhbnVwKVxuICAgKi9cbiAgcHVibGljIGNsZWFyQWxsKCk6IHZvaWQge1xuICAgIHRoaXMudmVjdG9yM1Bvb2wuY2xlYXIoKTtcbiAgICB0aGlzLnF1YXRlcm5pb25Qb29sLmNsZWFyKCk7XG4gICAgdGhpcy5oaXRLZXlQb29sLmNsZWFyKCk7XG4gICAgdGhpcy5lZmZlY3REYXRhUG9vbC5jbGVhcigpO1xuICAgIHRoaXMucmVzZXRGcmFtZVRlbXBvcmFyaWVzKCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZSBmb3IgZWFzeSBhY2Nlc3NcbmV4cG9ydCBjb25zdCBwdnBPYmplY3RQb29sID0gUFZQT2JqZWN0UG9vbC5nZXRJbnN0YW5jZSgpO1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiT2JqZWN0UG9vbCIsIlBWUE9iamVjdFBvb2wiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiYWNxdWlyZVZlY3RvcjMiLCJ4IiwieSIsInoiLCJ2ZWN0b3IiLCJ2ZWN0b3IzUG9vbCIsImFjcXVpcmUiLCJzZXQiLCJyZWxlYXNlVmVjdG9yMyIsInJlbGVhc2UiLCJnZXRUZW1wVmVjdG9yMyIsImluZGV4IiwidGVtcFZlY3RvckluZGV4IiwidGVtcFZlY3RvcjNzIiwibGVuZ3RoIiwiYWNxdWlyZVF1YXRlcm5pb24iLCJ3IiwicXVhdGVybmlvbiIsInF1YXRlcm5pb25Qb29sIiwicmVsZWFzZVF1YXRlcm5pb24iLCJnZXRUZW1wUXVhdGVybmlvbiIsInRlbXBRdWF0ZXJuaW9uSW5kZXgiLCJ0ZW1wUXVhdGVybmlvbnMiLCJjcmVhdGVIaXRLZXkiLCJlbnRpdHlJZCIsInBsYXllcklkIiwiYWNxdWlyZUVmZmVjdERhdGEiLCJlZmZlY3REYXRhUG9vbCIsInJlbGVhc2VFZmZlY3REYXRhIiwiZWZmZWN0RGF0YSIsInJlc2V0RnJhbWVUZW1wb3JhcmllcyIsImdldFN0YXRzIiwiZ2V0UG9vbFNpemUiLCJoaXRLZXlQb29sIiwidGVtcFZlY3RvcjNzVXNlZCIsInRlbXBRdWF0ZXJuaW9uc1VzZWQiLCJjbGVhckFsbCIsImNsZWFyIiwia2V5IiwiaWQiLCJwb3NpdGlvbiIsInN0YXJ0VGltZSIsImR1cmF0aW9uIiwiZGVidWZmVHlwZSIsInVuZGVmaW5lZCIsImkiLCJwdXNoIiwicHZwT2JqZWN0UG9vbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/PVPObjectPool.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/PVPStateBatcher.ts":
/*!**************************************!*\
  !*** ./src/utils/PVPStateBatcher.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PVPStateBatcher: function() { return /* binding */ PVPStateBatcher; },\n/* harmony export */   PVPStateUpdateHelpers: function() { return /* binding */ PVPStateUpdateHelpers; },\n/* harmony export */   pvpStateBatcher: function() { return /* binding */ pvpStateBatcher; }\n/* harmony export */ });\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n// PVP State Batching Utility for Performance Optimization\n\n/**\n * Batches multiple React state updates to prevent unnecessary re-renders\n * Particularly important for PVP scenarios with frequent state changes\n */ class PVPStateBatcher {\n    static getInstance() {\n        if (!PVPStateBatcher.instance) {\n            PVPStateBatcher.instance = new PVPStateBatcher();\n        }\n        return PVPStateBatcher.instance;\n    }\n    /**\n   * Add a state update to the batch queue\n   */ batchUpdate(updateFn) {\n        this.pendingUpdates.push(updateFn);\n        if (!this.batchScheduled) {\n            this.scheduleBatch();\n        }\n    }\n    /**\n   * Schedule a batch to be executed on the next frame\n   */ scheduleBatch() {\n        this.batchScheduled = true;\n        // Use requestAnimationFrame to batch updates at the end of the frame\n        this.frameId = requestAnimationFrame(()=>{\n            this.executeBatch();\n        });\n    }\n    /**\n   * Execute all pending state updates in a single batch\n   */ executeBatch() {\n        if (this.pendingUpdates.length === 0) {\n            this.batchScheduled = false;\n            return;\n        }\n        const updates = [\n            ...this.pendingUpdates\n        ];\n        this.pendingUpdates = [];\n        this.batchScheduled = false;\n        // Track performance metrics\n        this.batchCount++;\n        this.totalUpdatesInBatch += updates.length;\n        this.lastBatchTime = performance.now();\n        // Execute all updates in a single React batch\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_0__.unstable_batchedUpdates)(()=>{\n            updates.forEach((update)=>{\n                try {\n                    update();\n                } catch (error) {\n                    console.error(\"Error in batched state update:\", error);\n                }\n            });\n        });\n    }\n    /**\n   * Force execute any pending batches immediately\n   */ flushBatch() {\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = null;\n        }\n        this.executeBatch();\n    }\n    /**\n   * Get performance statistics\n   */ getStats() {\n        const avgUpdatesPerBatch = this.batchCount > 0 ? this.totalUpdatesInBatch / this.batchCount : 0;\n        return {\n            totalBatches: this.batchCount,\n            totalUpdates: this.totalUpdatesInBatch,\n            avgUpdatesPerBatch: Math.round(avgUpdatesPerBatch * 100) / 100,\n            pendingUpdates: this.pendingUpdates.length,\n            lastBatchTime: this.lastBatchTime,\n            batchScheduled: this.batchScheduled\n        };\n    }\n    /**\n   * Reset performance statistics\n   */ resetStats() {\n        this.batchCount = 0;\n        this.totalUpdatesInBatch = 0;\n        this.lastBatchTime = 0;\n    }\n    /**\n   * Clear all pending updates (useful for cleanup)\n   */ clear() {\n        if (this.frameId) {\n            cancelAnimationFrame(this.frameId);\n            this.frameId = null;\n        }\n        this.pendingUpdates = [];\n        this.batchScheduled = false;\n    }\n    constructor(){\n        // Pending state updates to batch\n        this.pendingUpdates = [];\n        this.batchScheduled = false;\n        this.frameId = null;\n        // Performance tracking\n        this.batchCount = 0;\n        this.totalUpdatesInBatch = 0;\n        this.lastBatchTime = 0;\n    }\n}\n// Export singleton instance\nconst pvpStateBatcher = PVPStateBatcher.getInstance();\n/**\n * Utility functions for common PVP state update patterns\n */ class PVPStateUpdateHelpers {\n    /**\n   * Batch multiple player state updates\n   */ static batchPlayerStateUpdates(setMultiplayerPlayerStates, updates) {\n        pvpStateBatcher.batchUpdate(()=>{\n            setMultiplayerPlayerStates((prev)=>{\n                const updated = new Map(prev);\n                updates.forEach((param)=>{\n                    let { playerId, stateUpdate } = param;\n                    const currentState = updated.get(playerId) || {\n                        isCharging: false,\n                        chargeProgress: 0,\n                        isSwinging: false,\n                        swordComboStep: 1,\n                        isDivineStorming: false,\n                        isSpinning: false,\n                        isSwordCharging: false,\n                        isDeflecting: false,\n                        isViperStingCharging: false,\n                        viperStingChargeProgress: 0,\n                        isBarrageCharging: false,\n                        barrageChargeProgress: 0,\n                        isCobraShotCharging: false,\n                        cobraShotChargeProgress: 0,\n                        isSkyfalling: false,\n                        isBackstabbing: false\n                    };\n                    updated.set(playerId, {\n                        ...currentState,\n                        ...stateUpdate,\n                        lastAnimationUpdate: Date.now()\n                    });\n                });\n                return updated;\n            });\n        });\n    }\n    /**\n   * Batch effect state updates (venom, debuff, etc.)\n   */ static batchEffectUpdates(updates) {\n        // Group updates by setter to minimize state update calls\n        const updatesBySetter = new Map();\n        updates.forEach((update)=>{\n            if (!updatesBySetter.has(update.setter)) {\n                updatesBySetter.set(update.setter, []);\n            }\n            updatesBySetter.get(update.setter).push(update);\n        });\n        // Batch all updates\n        pvpStateBatcher.batchUpdate(()=>{\n            updatesBySetter.forEach((setterUpdates, setter)=>{\n                setter((prev)=>{\n                    let newState = [\n                        ...prev\n                    ];\n                    setterUpdates.forEach((update)=>{\n                        if (update.type === \"add\" && update.data) {\n                            newState.push(update.data);\n                        } else if (update.type === \"remove\" && update.filterId !== undefined) {\n                            newState = newState.filter((effect)=>effect.id !== update.filterId);\n                        }\n                    });\n                    return newState;\n                });\n            });\n        });\n    }\n    /**\n   * Batch game state updates (position, weapon state, etc.)\n   */ static batchGameStateUpdates(updates) {\n        pvpStateBatcher.batchUpdate(()=>{\n            updates.forEach((param)=>{\n                let { setter, value } = param;\n                setter(value);\n            });\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9QVlBTdGF0ZUJhdGNoZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDBEQUEwRDtBQUNOO0FBR3BEOzs7Q0FHQyxHQUNNLE1BQU1DO0lBZVgsT0FBY0MsY0FBK0I7UUFDM0MsSUFBSSxDQUFDRCxnQkFBZ0JFLFFBQVEsRUFBRTtZQUM3QkYsZ0JBQWdCRSxRQUFRLEdBQUcsSUFBSUY7UUFDakM7UUFDQSxPQUFPQSxnQkFBZ0JFLFFBQVE7SUFDakM7SUFFQTs7R0FFQyxHQUNELFlBQW1CRSxRQUFvQixFQUFRO1FBQzdDLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNGO1FBRXpCLElBQUksQ0FBQyxJQUFJLENBQUNHLGNBQWMsRUFBRTtZQUN4QixJQUFJLENBQUNDLGFBQWE7UUFDcEI7SUFDRjtJQUVBOztHQUVDLEdBQ0QsZ0JBQThCO1FBQzVCLElBQUksQ0FBQ0QsY0FBYyxHQUFHO1FBRXRCLHFFQUFxRTtRQUNyRSxJQUFJLENBQUNFLE9BQU8sR0FBR0Msc0JBQXNCO1lBQ25DLElBQUksQ0FBQ0MsWUFBWTtRQUNuQjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxlQUE2QjtRQUMzQixJQUFJLElBQUksQ0FBQ04sY0FBYyxDQUFDTyxNQUFNLEtBQUssR0FBRztZQUNwQyxJQUFJLENBQUNMLGNBQWMsR0FBRztZQUN0QjtRQUNGO1FBRUEsTUFBTU0sVUFBVTtlQUFJLElBQUksQ0FBQ1IsY0FBYztTQUFDO1FBQ3hDLElBQUksQ0FBQ0EsY0FBYyxHQUFHLEVBQUU7UUFDeEIsSUFBSSxDQUFDRSxjQUFjLEdBQUc7UUFFdEIsNEJBQTRCO1FBQzVCLElBQUksQ0FBQ08sVUFBVTtRQUNmLElBQUksQ0FBQ0MsbUJBQW1CLElBQUlGLFFBQVFELE1BQU07UUFDMUMsSUFBSSxDQUFDSSxhQUFhLEdBQUdDLFlBQVlDLEdBQUc7UUFFcEMsOENBQThDO1FBQzlDbkIsa0VBQXVCQSxDQUFDO1lBQ3RCYyxRQUFRTSxPQUFP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O1lBQ2QsSUFBSSxDQUFDNEMsZ0JBQWdCQyxHQUFHLENBQUM3QyxPQUFPOEMsTUFBTSxHQUFHO2dCQUN2Q0YsZ0JBQWdCSixHQUFHLENBQUN4QyxPQUFPOEMsTUFBTSxFQUFFLEVBQUU7WUFDdkM7WUFDQUYsZ0JBQWdCckIsR0FBRyxDQUFDdkIsT0FBTzhDLE1BQU0sRUFBRzVELElBQUksQ0FBQ2M7UUFDM0M7UUFFQSxvQkFBb0I7UUFDcEJhLGdCQUFnQjlCLFdBQVcsQ0FBQztZQUMxQjZELGdCQUFnQjdDLE9BQU8sQ0FBQyxDQUFDZ0QsZUFBZUQ7Z0JBQ3RDQSxPQUFPN0IsQ0FBQUE7b0JBQ0wsSUFBSStCLFdBQVc7MkJBQUkvQjtxQkFBSztvQkFFeEI4QixjQUFjaEQsT0FBTyxDQUFDQyxDQUFBQTt3QkFDcEIsSUFBSUEsT0FBT2lELElBQUksS0FBSyxTQUFTakQsT0FBT2tELElBQUksRUFBRTs0QkFDeENGLFNBQVM5RCxJQUFJLENBQUNjLE9BQU9rRCxJQUFJO3dCQUMzQixPQUFPLElBQUlsRCxPQUFPaUQsSUFBSSxLQUFLLFlBQVlqRCxPQUFPbUQsUUFBUSxLQUFLQyxXQUFXOzRCQUNwRUosV0FBV0EsU0FBU0ssTUFBTSxDQUFDQyxDQUFBQSxTQUFVQSxPQUFPQyxFQUFFLEtBQUt2RCxPQUFPbUQsUUFBUTt3QkFDcEU7b0JBQ0Y7b0JBRUEsT0FBT0g7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE9BQU9RLHNCQUFzQi9ELE9BRzNCLEVBQVE7UUFDUm9CLGdCQUFnQjlCLFdBQVcsQ0FBQztZQUMxQlUsUUFBUU0sT0FBTyxDQUFDO29CQUFDLEVBQUUrQyxNQUFNLEVBQUVXLEtBQUssRUFBRTtnQkFDaENYLE9BQU9XO1lBQ1Q7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL1BWUFN0YXRlQmF0Y2hlci50cz9lNDAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBWUCBTdGF0ZSBCYXRjaGluZyBVdGlsaXR5IGZvciBQZXJmb3JtYW5jZSBPcHRpbWl6YXRpb25cbmltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG4vKipcbiAqIEJhdGNoZXMgbXVsdGlwbGUgUmVhY3Qgc3RhdGUgdXBkYXRlcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcbiAqIFBhcnRpY3VsYXJseSBpbXBvcnRhbnQgZm9yIFBWUCBzY2VuYXJpb3Mgd2l0aCBmcmVxdWVudCBzdGF0ZSBjaGFuZ2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBQVlBTdGF0ZUJhdGNoZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogUFZQU3RhdGVCYXRjaGVyO1xuICBcbiAgLy8gUGVuZGluZyBzdGF0ZSB1cGRhdGVzIHRvIGJhdGNoXG4gIHByaXZhdGUgcGVuZGluZ1VwZGF0ZXM6ICgoKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgYmF0Y2hTY2hlZHVsZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBmcmFtZUlkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgXG4gIC8vIFBlcmZvcm1hbmNlIHRyYWNraW5nXG4gIHByaXZhdGUgYmF0Y2hDb3VudCA9IDA7XG4gIHByaXZhdGUgdG90YWxVcGRhdGVzSW5CYXRjaCA9IDA7XG4gIHByaXZhdGUgbGFzdEJhdGNoVGltZSA9IDA7XG4gIFxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cbiAgXG4gIHB1YmxpYyBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogUFZQU3RhdGVCYXRjaGVyIHtcbiAgICBpZiAoIVBWUFN0YXRlQmF0Y2hlci5pbnN0YW5jZSkge1xuICAgICAgUFZQU3RhdGVCYXRjaGVyLmluc3RhbmNlID0gbmV3IFBWUFN0YXRlQmF0Y2hlcigpO1xuICAgIH1cbiAgICByZXR1cm4gUFZQU3RhdGVCYXRjaGVyLmluc3RhbmNlO1xuICB9XG4gIFxuICAvKipcbiAgICogQWRkIGEgc3RhdGUgdXBkYXRlIHRvIHRoZSBiYXRjaCBxdWV1ZVxuICAgKi9cbiAgcHVibGljIGJhdGNoVXBkYXRlKHVwZGF0ZUZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlcy5wdXNoKHVwZGF0ZUZuKTtcbiAgICBcbiAgICBpZiAoIXRoaXMuYmF0Y2hTY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVCYXRjaCgpO1xuICAgIH1cbiAgfVxuICBcbiAgLyoqXG4gICAqIFNjaGVkdWxlIGEgYmF0Y2ggdG8gYmUgZXhlY3V0ZWQgb24gdGhlIG5leHQgZnJhbWVcbiAgICovXG4gIHByaXZhdGUgc2NoZWR1bGVCYXRjaCgpOiB2b2lkIHtcbiAgICB0aGlzLmJhdGNoU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBVc2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIGJhdGNoIHVwZGF0ZXMgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWVcbiAgICB0aGlzLmZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5leGVjdXRlQmF0Y2goKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEV4ZWN1dGUgYWxsIHBlbmRpbmcgc3RhdGUgdXBkYXRlcyBpbiBhIHNpbmdsZSBiYXRjaFxuICAgKi9cbiAgcHJpdmF0ZSBleGVjdXRlQmF0Y2goKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1VwZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmJhdGNoU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHVwZGF0ZXMgPSBbLi4udGhpcy5wZW5kaW5nVXBkYXRlc107XG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlcyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBcbiAgICAvLyBUcmFjayBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgdGhpcy5iYXRjaENvdW50Kys7XG4gICAgdGhpcy50b3RhbFVwZGF0ZXNJbkJhdGNoICs9IHVwZGF0ZXMubGVuZ3RoO1xuICAgIHRoaXMubGFzdEJhdGNoVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIFxuICAgIC8vIEV4ZWN1dGUgYWxsIHVwZGF0ZXMgaW4gYSBzaW5nbGUgUmVhY3QgYmF0Y2hcbiAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICB1cGRhdGVzLmZvckVhY2godXBkYXRlID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBiYXRjaGVkIHN0YXRlIHVwZGF0ZTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogRm9yY2UgZXhlY3V0ZSBhbnkgcGVuZGluZyBiYXRjaGVzIGltbWVkaWF0ZWx5XG4gICAqL1xuICBwdWJsaWMgZmx1c2hCYXRjaCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5mcmFtZUlkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSWQpO1xuICAgICAgdGhpcy5mcmFtZUlkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5leGVjdXRlQmF0Y2goKTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCBwZXJmb3JtYW5jZSBzdGF0aXN0aWNzXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgYXZnVXBkYXRlc1BlckJhdGNoID0gdGhpcy5iYXRjaENvdW50ID4gMCA/IHRoaXMudG90YWxVcGRhdGVzSW5CYXRjaCAvIHRoaXMuYmF0Y2hDb3VudCA6IDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQmF0Y2hlczogdGhpcy5iYXRjaENvdW50LFxuICAgICAgdG90YWxVcGRhdGVzOiB0aGlzLnRvdGFsVXBkYXRlc0luQmF0Y2gsXG4gICAgICBhdmdVcGRhdGVzUGVyQmF0Y2g6IE1hdGgucm91bmQoYXZnVXBkYXRlc1BlckJhdGNoICogMTAwKSAvIDEwMCxcbiAgICAgIHBlbmRpbmdVcGRhdGVzOiB0aGlzLnBlbmRpbmdVcGRhdGVzLmxlbmd0aCxcbiAgICAgIGxhc3RCYXRjaFRpbWU6IHRoaXMubGFzdEJhdGNoVGltZSxcbiAgICAgIGJhdGNoU2NoZWR1bGVkOiB0aGlzLmJhdGNoU2NoZWR1bGVkXG4gICAgfTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFJlc2V0IHBlcmZvcm1hbmNlIHN0YXRpc3RpY3NcbiAgICovXG4gIHB1YmxpYyByZXNldFN0YXRzKCk6IHZvaWQge1xuICAgIHRoaXMuYmF0Y2hDb3VudCA9IDA7XG4gICAgdGhpcy50b3RhbFVwZGF0ZXNJbkJhdGNoID0gMDtcbiAgICB0aGlzLmxhc3RCYXRjaFRpbWUgPSAwO1xuICB9XG4gIFxuICAvKipcbiAgICogQ2xlYXIgYWxsIHBlbmRpbmcgdXBkYXRlcyAodXNlZnVsIGZvciBjbGVhbnVwKVxuICAgKi9cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmZyYW1lSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVJZCk7XG4gICAgICB0aGlzLmZyYW1lSWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdVcGRhdGVzID0gW107XG4gICAgdGhpcy5iYXRjaFNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBwdnBTdGF0ZUJhdGNoZXIgPSBQVlBTdGF0ZUJhdGNoZXIuZ2V0SW5zdGFuY2UoKTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgY29tbW9uIFBWUCBzdGF0ZSB1cGRhdGUgcGF0dGVybnNcbiAqL1xuZXhwb3J0IGNsYXNzIFBWUFN0YXRlVXBkYXRlSGVscGVycyB7XG4gIC8qKlxuICAgKiBCYXRjaCBtdWx0aXBsZSBwbGF5ZXIgc3RhdGUgdXBkYXRlc1xuICAgKi9cbiAgc3RhdGljIGJhdGNoUGxheWVyU3RhdGVVcGRhdGVzKFxuICAgIHNldE11bHRpcGxheWVyUGxheWVyU3RhdGVzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxNYXA8c3RyaW5nLCBhbnk+Pj4sXG4gICAgdXBkYXRlczogQXJyYXk8eyBwbGF5ZXJJZDogc3RyaW5nOyBzdGF0ZVVwZGF0ZTogUGFydGlhbDxhbnk+IH0+XG4gICk6IHZvaWQge1xuICAgIHB2cFN0YXRlQmF0Y2hlci5iYXRjaFVwZGF0ZSgoKSA9PiB7XG4gICAgICBzZXRNdWx0aXBsYXllclBsYXllclN0YXRlcyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IG5ldyBNYXAocHJldik7XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVzLmZvckVhY2goKHsgcGxheWVySWQsIHN0YXRlVXBkYXRlIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB1cGRhdGVkLmdldChwbGF5ZXJJZCkgfHwge1xuICAgICAgICAgICAgaXNDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBjaGFyZ2VQcm9ncmVzczogMCxcbiAgICAgICAgICAgIGlzU3dpbmdpbmc6IGZhbHNlLFxuICAgICAgICAgICAgc3dvcmRDb21ib1N0ZXA6IDEgYXMgMSB8IDIgfCAzLFxuICAgICAgICAgICAgaXNEaXZpbmVTdG9ybWluZzogZmFsc2UsXG4gICAgICAgICAgICBpc1NwaW5uaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3dvcmRDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBpc0RlZmxlY3Rpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaXBlclN0aW5nQ2hhcmdpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzOiAwLFxuICAgICAgICAgICAgaXNCYXJyYWdlQ2hhcmdpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYmFycmFnZUNoYXJnZVByb2dyZXNzOiAwLFxuICAgICAgICAgICAgaXNDb2JyYVNob3RDaGFyZ2luZzogZmFsc2UsXG4gICAgICAgICAgICBjb2JyYVNob3RDaGFyZ2VQcm9ncmVzczogMCxcbiAgICAgICAgICAgIGlzU2t5ZmFsbGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc0JhY2tzdGFiYmluZzogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHVwZGF0ZWQuc2V0KHBsYXllcklkLCB7XG4gICAgICAgICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICAgICAgICAuLi5zdGF0ZVVwZGF0ZSxcbiAgICAgICAgICAgIGxhc3RBbmltYXRpb25VcGRhdGU6IERhdGUubm93KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQmF0Y2ggZWZmZWN0IHN0YXRlIHVwZGF0ZXMgKHZlbm9tLCBkZWJ1ZmYsIGV0Yy4pXG4gICAqL1xuICBzdGF0aWMgYmF0Y2hFZmZlY3RVcGRhdGVzKHVwZGF0ZXM6IEFycmF5PHtcbiAgICB0eXBlOiAnYWRkJyB8ICdyZW1vdmUnO1xuICAgIGVmZmVjdFR5cGU6ICd2ZW5vbScgfCAnZGVidWZmJyB8ICdyZWFuaW1hdGUnIHwgJ2Zyb3N0Tm92YSc7XG4gICAgc2V0dGVyOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxhbnlbXT4+O1xuICAgIGRhdGE/OiBhbnk7XG4gICAgZmlsdGVySWQ/OiBudW1iZXI7XG4gIH0+KTogdm9pZCB7XG4gICAgLy8gR3JvdXAgdXBkYXRlcyBieSBzZXR0ZXIgdG8gbWluaW1pemUgc3RhdGUgdXBkYXRlIGNhbGxzXG4gICAgY29uc3QgdXBkYXRlc0J5U2V0dGVyID0gbmV3IE1hcDxSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxhbnlbXT4+LCBBcnJheTxhbnk+PigpO1xuICAgIFxuICAgIHVwZGF0ZXMuZm9yRWFjaCh1cGRhdGUgPT4ge1xuICAgICAgaWYgKCF1cGRhdGVzQnlTZXR0ZXIuaGFzKHVwZGF0ZS5zZXR0ZXIpKSB7XG4gICAgICAgIHVwZGF0ZXNCeVNldHRlci5zZXQodXBkYXRlLnNldHRlciwgW10pO1xuICAgICAgfVxuICAgICAgdXBkYXRlc0J5U2V0dGVyLmdldCh1cGRhdGUuc2V0dGVyKSEucHVzaCh1cGRhdGUpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEJhdGNoIGFsbCB1cGRhdGVzXG4gICAgcHZwU3RhdGVCYXRjaGVyLmJhdGNoVXBkYXRlKCgpID0+IHtcbiAgICAgIHVwZGF0ZXNCeVNldHRlci5mb3JFYWNoKChzZXR0ZXJVcGRhdGVzLCBzZXR0ZXIpID0+IHtcbiAgICAgICAgc2V0dGVyKHByZXYgPT4ge1xuICAgICAgICAgIGxldCBuZXdTdGF0ZSA9IFsuLi5wcmV2XTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXR0ZXJVcGRhdGVzLmZvckVhY2godXBkYXRlID0+IHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gJ2FkZCcgJiYgdXBkYXRlLmRhdGEpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUucHVzaCh1cGRhdGUuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS50eXBlID09PSAncmVtb3ZlJyAmJiB1cGRhdGUuZmlsdGVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmZpbHRlcihlZmZlY3QgPT4gZWZmZWN0LmlkICE9PSB1cGRhdGUuZmlsdGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIEJhdGNoIGdhbWUgc3RhdGUgdXBkYXRlcyAocG9zaXRpb24sIHdlYXBvbiBzdGF0ZSwgZXRjLilcbiAgICovXG4gIHN0YXRpYyBiYXRjaEdhbWVTdGF0ZVVwZGF0ZXModXBkYXRlczogQXJyYXk8e1xuICAgIHNldHRlcjogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248YW55Pj47XG4gICAgdmFsdWU6IGFueTtcbiAgfT4pOiB2b2lkIHtcbiAgICBwdnBTdGF0ZUJhdGNoZXIuYmF0Y2hVcGRhdGUoKCkgPT4ge1xuICAgICAgdXBkYXRlcy5mb3JFYWNoKCh7IHNldHRlciwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBzZXR0ZXIodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsIlBWUFN0YXRlQmF0Y2hlciIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJiYXRjaFVwZGF0ZSIsInVwZGF0ZUZuIiwicGVuZGluZ1VwZGF0ZXMiLCJwdXNoIiwiYmF0Y2hTY2hlZHVsZWQiLCJzY2hlZHVsZUJhdGNoIiwiZnJhbWVJZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImV4ZWN1dGVCYXRjaCIsImxlbmd0aCIsInVwZGF0ZXMiLCJiYXRjaENvdW50IiwidG90YWxVcGRhdGVzSW5CYXRjaCIsImxhc3RCYXRjaFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImZvckVhY2giLCJ1cGRhdGUiLCJlcnJvciIsImNvbnNvbGUiLCJmbHVzaEJhdGNoIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRTdGF0cyIsImF2Z1VwZGF0ZXNQZXJCYXRjaCIsInRvdGFsQmF0Y2hlcyIsInRvdGFsVXBkYXRlcyIsIk1hdGgiLCJyb3VuZCIsInJlc2V0U3RhdHMiLCJjbGVhciIsInB2cFN0YXRlQmF0Y2hlciIsIlBWUFN0YXRlVXBkYXRlSGVscGVycyIsImJhdGNoUGxheWVyU3RhdGVVcGRhdGVzIiwic2V0TXVsdGlwbGF5ZXJQbGF5ZXJTdGF0ZXMiLCJwcmV2IiwidXBkYXRlZCIsIk1hcCIsInBsYXllcklkIiwic3RhdGVVcGRhdGUiLCJjdXJyZW50U3RhdGUiLCJnZXQiLCJpc0NoYXJnaW5nIiwiY2hhcmdlUHJvZ3Jlc3MiLCJpc1N3aW5naW5nIiwic3dvcmRDb21ib1N0ZXAiLCJpc0RpdmluZVN0b3JtaW5nIiwiaXNTcGlubmluZyIsImlzU3dvcmRDaGFyZ2luZyIsImlzRGVmbGVjdGluZyIsImlzVmlwZXJTdGluZ0NoYXJnaW5nIiwidmlwZXJTdGluZ0NoYXJnZVByb2dyZXNzIiwiaXNCYXJyYWdlQ2hhcmdpbmciLCJiYXJyYWdlQ2hhcmdlUHJvZ3Jlc3MiLCJpc0NvYnJhU2hvdENoYXJnaW5nIiwiY29icmFTaG90Q2hhcmdlUHJvZ3Jlc3MiLCJpc1NreWZhbGxpbmciLCJpc0JhY2tzdGFiYmluZyIsInNldCIsImxhc3RBbmltYXRpb25VcGRhdGUiLCJEYXRlIiwiYmF0Y2hFZmZlY3RVcGRhdGVzIiwidXBkYXRlc0J5U2V0dGVyIiwiaGFzIiwic2V0dGVyIiwic2V0dGVyVXBkYXRlcyIsIm5ld1N0YXRlIiwidHlwZSIsImRhdGEiLCJmaWx0ZXJJZCIsInVuZGVmaW5lZCIsImZpbHRlciIsImVmZmVjdCIsImlkIiwiYmF0Y2hHYW1lU3RhdGVVcGRhdGVzIiwidmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/PVPStateBatcher.ts\n"));

/***/ })

}]);