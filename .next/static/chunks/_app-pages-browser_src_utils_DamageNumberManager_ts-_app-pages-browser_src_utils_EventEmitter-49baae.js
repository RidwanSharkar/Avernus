"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_utils_DamageNumberManager_ts-_app-pages-browser_src_utils_EventEmitter-49baae"],{

/***/ "(app-pages-browser)/./src/utils/DamageNumberManager.ts":
/*!******************************************!*\
  !*** ./src/utils/DamageNumberManager.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DamageNumberManager: function() { return /* binding */ DamageNumberManager; }\n/* harmony export */ });\n// Manager for handling damage number display and lifecycle\nclass DamageNumberManager {\n    addDamageNumber(damage, isCritical, position, damageType) {\n        const id = \"damage_\".concat(this.nextId++);\n        const damageNumber = {\n            id,\n            damage,\n            isCritical,\n            position: position.clone(),\n            timestamp: Date.now(),\n            damageType\n        };\n        this.damageNumbers.push(damageNumber);\n        return id;\n    }\n    removeDamageNumber(id) {\n        const index = this.damageNumbers.findIndex((dn)=>dn.id === id);\n        if (index !== -1) {\n            this.damageNumbers.splice(index, 1);\n        }\n    }\n    getDamageNumbers() {\n        return [\n            ...this.damageNumbers\n        ]; // Return a copy to prevent external mutation\n    }\n    cleanup() {\n        // Remove damage numbers older than 5 seconds (failsafe)\n        const now = Date.now();\n        this.damageNumbers = this.damageNumbers.filter((dn)=>now - dn.timestamp < 5000);\n        // Also limit total number of damage numbers to prevent memory issues\n        if (this.damageNumbers.length > 50) {\n            // Keep only the 50 most recent\n            this.damageNumbers.sort((a, b)=>b.timestamp - a.timestamp);\n            this.damageNumbers = this.damageNumbers.slice(0, 50);\n        }\n    }\n    clear() {\n        this.damageNumbers.length = 0;\n        this.nextId = 0;\n    }\n    getCount() {\n        return this.damageNumbers.length;\n    }\n    constructor(){\n        this.damageNumbers = [];\n        this.nextId = 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9EYW1hZ2VOdW1iZXJNYW5hZ2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwyREFBMkQ7QUFJcEQsTUFBTUE7SUFJSkMsZ0JBQ0xDLE1BQWMsRUFDZEMsVUFBbUIsRUFDbkJDLFFBQWlCLEVBQ2pCQyxVQUFtQixFQUNYO1FBQ1IsTUFBTUMsS0FBSyxVQUF3QixPQUFkLElBQUksQ0FBQ0MsTUFBTTtRQUNoQyxNQUFNQyxlQUFpQztZQUNyQ0Y7WUFDQUo7WUFDQUM7WUFDQUMsVUFBVUEsU0FBU0ssS0FBSztZQUN4QkMsV0FBV0MsS0FBS0MsR0FBRztZQUNuQlA7UUFDRjtRQUVBLElBQUksQ0FBQ1EsYUFBYSxDQUFDQyxJQUFJLENBQUNOO1FBQ3hCLE9BQU9GO0lBQ1Q7SUFFT1MsbUJBQW1CVCxFQUFVLEVBQVE7UUFDMUMsTUFBTVUsUUFBUSxJQUFJLENBQUNILGFBQWEsQ0FBQ0ksU0FBUyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHWixFQUFFLEtBQUtBO1FBQzNELElBQUlVLFVBQVUsQ0FBQyxHQUFHO1lBQ2hCLElBQUksQ0FBQ0gsYUFBYSxDQUFDTSxNQUFNLENBQUNILE9BQU87UUFDbkM7SUFDRjtJQUVPSSxtQkFBdUM7UUFDNUMsT0FBTztlQUFJLElBQUksQ0FBQ1AsYUFBYTtTQUFDLEVBQUUsNkNBQTZDO0lBQy9FO0lBRU9RLFVBQWdCO1FBQ3JCLHdEQUF3RDtRQUN4RCxNQUFNVCxNQUFNRCxLQUFLQyxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYSxDQUFDUyxNQUFNLENBQzVDSixDQUFBQSxLQUFNTixNQUFNTSxHQUFHUixTQUFTLEdBQUc7UUFHN0IscUVBQXFFO1FBQ3JFLElBQUksSUFBSSxDQUFDRyxhQUFhLENBQUNVLE1BQU0sR0FBRyxJQUFJO1lBQ2xDLCtCQUErQjtZQUMvQixJQUFJLENBQUNWLGFBQWEsQ0FBQ1csSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVoQixTQUFTLEdBQUdlLEVBQUVmLFNBQVM7WUFDM0QsSUFBSSxDQUFDRyxhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLENBQUNjLEtBQUssQ0FBQyxHQUFHO1FBQ25EO0lBQ0Y7SUFFT0MsUUFBYztRQUNuQixJQUFJLENBQUNmLGFBQWEsQ0FBQ1UsTUFBTSxHQUFHO1FBQzVCLElBQUksQ0FBQ2hCLE1BQU0sR0FBRztJQUNoQjtJQUVPc0IsV0FBbUI7UUFDeEIsT0FBTyxJQUFJLENBQUNoQixhQUFhLENBQUNVLE1BQU07SUFDbEM7O2FBeERRVixnQkFBb0MsRUFBRTthQUN0Q04sU0FBUzs7QUF3RG5CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9EYW1hZ2VOdW1iZXJNYW5hZ2VyLnRzP2RmZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFuYWdlciBmb3IgaGFuZGxpbmcgZGFtYWdlIG51bWJlciBkaXNwbGF5IGFuZCBsaWZlY3ljbGVcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgRGFtYWdlTnVtYmVyRGF0YSB9IGZyb20gJ0AvY29tcG9uZW50cy9EYW1hZ2VOdW1iZXJzJztcblxuZXhwb3J0IGNsYXNzIERhbWFnZU51bWJlck1hbmFnZXIge1xuICBwcml2YXRlIGRhbWFnZU51bWJlcnM6IERhbWFnZU51bWJlckRhdGFbXSA9IFtdO1xuICBwcml2YXRlIG5leHRJZCA9IDA7XG5cbiAgcHVibGljIGFkZERhbWFnZU51bWJlcihcbiAgICBkYW1hZ2U6IG51bWJlcixcbiAgICBpc0NyaXRpY2FsOiBib29sZWFuLFxuICAgIHBvc2l0aW9uOiBWZWN0b3IzLFxuICAgIGRhbWFnZVR5cGU/OiBzdHJpbmdcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBpZCA9IGBkYW1hZ2VfJHt0aGlzLm5leHRJZCsrfWA7XG4gICAgY29uc3QgZGFtYWdlTnVtYmVyOiBEYW1hZ2VOdW1iZXJEYXRhID0ge1xuICAgICAgaWQsXG4gICAgICBkYW1hZ2UsXG4gICAgICBpc0NyaXRpY2FsLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLmNsb25lKCksIC8vIENsb25lIHRvIGF2b2lkIHJlZmVyZW5jZSBpc3N1ZXNcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIGRhbWFnZVR5cGUsXG4gICAgfTtcblxuICAgIHRoaXMuZGFtYWdlTnVtYmVycy5wdXNoKGRhbWFnZU51bWJlcik7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZURhbWFnZU51bWJlcihpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmRhbWFnZU51bWJlcnMuZmluZEluZGV4KGRuID0+IGRuLmlkID09PSBpZCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5kYW1hZ2VOdW1iZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldERhbWFnZU51bWJlcnMoKTogRGFtYWdlTnVtYmVyRGF0YVtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZGFtYWdlTnVtYmVyc107IC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBleHRlcm5hbCBtdXRhdGlvblxuICB9XG5cbiAgcHVibGljIGNsZWFudXAoKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGRhbWFnZSBudW1iZXJzIG9sZGVyIHRoYW4gNSBzZWNvbmRzIChmYWlsc2FmZSlcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZGFtYWdlTnVtYmVycyA9IHRoaXMuZGFtYWdlTnVtYmVycy5maWx0ZXIoXG4gICAgICBkbiA9PiBub3cgLSBkbi50aW1lc3RhbXAgPCA1MDAwXG4gICAgKTtcbiAgICBcbiAgICAvLyBBbHNvIGxpbWl0IHRvdGFsIG51bWJlciBvZiBkYW1hZ2UgbnVtYmVycyB0byBwcmV2ZW50IG1lbW9yeSBpc3N1ZXNcbiAgICBpZiAodGhpcy5kYW1hZ2VOdW1iZXJzLmxlbmd0aCA+IDUwKSB7XG4gICAgICAvLyBLZWVwIG9ubHkgdGhlIDUwIG1vc3QgcmVjZW50XG4gICAgICB0aGlzLmRhbWFnZU51bWJlcnMuc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAgLSBhLnRpbWVzdGFtcCk7XG4gICAgICB0aGlzLmRhbWFnZU51bWJlcnMgPSB0aGlzLmRhbWFnZU51bWJlcnMuc2xpY2UoMCwgNTApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjbGVhcigpOiB2b2lkIHtcbiAgICB0aGlzLmRhbWFnZU51bWJlcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLm5leHRJZCA9IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5kYW1hZ2VOdW1iZXJzLmxlbmd0aDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRhbWFnZU51bWJlck1hbmFnZXIiLCJhZGREYW1hZ2VOdW1iZXIiLCJkYW1hZ2UiLCJpc0NyaXRpY2FsIiwicG9zaXRpb24iLCJkYW1hZ2VUeXBlIiwiaWQiLCJuZXh0SWQiLCJkYW1hZ2VOdW1iZXIiLCJjbG9uZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJkYW1hZ2VOdW1iZXJzIiwicHVzaCIsInJlbW92ZURhbWFnZU51bWJlciIsImluZGV4IiwiZmluZEluZGV4IiwiZG4iLCJzcGxpY2UiLCJnZXREYW1hZ2VOdW1iZXJzIiwiY2xlYW51cCIsImZpbHRlciIsImxlbmd0aCIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwiY2xlYXIiLCJnZXRDb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/DamageNumberManager.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/EventEmitter.ts":
/*!***********************************!*\
  !*** ./src/utils/EventEmitter.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: function() { return /* binding */ EventEmitter; }\n/* harmony export */ });\n// Event system for decoupled communication\nclass EventEmitter {\n    on(event, listener) {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, []);\n        }\n        this.listeners.get(event).push(listener);\n    }\n    off(event, listener) {\n        const eventListeners = this.listeners.get(event);\n        if (eventListeners) {\n            const index = eventListeners.indexOf(listener);\n            if (index !== -1) {\n                eventListeners.splice(index, 1);\n            }\n        }\n    }\n    emit(event, data) {\n        const eventListeners = this.listeners.get(event);\n        if (eventListeners) {\n            // Create a copy to avoid issues if listeners are modified during emission\n            const listeners = [\n                ...eventListeners\n            ];\n            for (const listener of listeners){\n                listener(data);\n            }\n        }\n    }\n    once(event, listener) {\n        const onceListener = (data)=>{\n            listener(data);\n            this.off(event, onceListener);\n        };\n        this.on(event, onceListener);\n    }\n    removeAllListeners(event) {\n        if (event) {\n            this.listeners.delete(event);\n        } else {\n            this.listeners.clear();\n        }\n    }\n    getListenerCount(event) {\n        var _this_listeners_get;\n        return ((_this_listeners_get = this.listeners.get(event)) === null || _this_listeners_get === void 0 ? void 0 : _this_listeners_get.length) || 0;\n    }\n    constructor(){\n        this.listeners = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9FdmVudEVtaXR0ZXIudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDJDQUEyQztBQUdwQyxNQUFNQTtJQUdKQyxHQUFZQyxLQUFhLEVBQUVDLFFBQTBCLEVBQVE7UUFDbEUsSUFBSSxDQUFDLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxHQUFHLENBQUNILFFBQVE7WUFDOUIsSUFBSSxDQUFDRSxTQUFTLENBQUNFLEdBQUcsQ0FBQ0osT0FBTyxFQUFFO1FBQzlCO1FBQ0EsSUFBSSxDQUFDRSxTQUFTLENBQUNHLEdBQUcsQ0FBQ0wsT0FBUU0sSUFBSSxDQUFDTDtJQUNsQztJQUVPTSxJQUFhUCxLQUFhLEVBQUVDLFFBQTBCLEVBQVE7UUFDbkUsTUFBTU8saUJBQWlCLElBQUksQ0FBQ04sU0FBUyxDQUFDRyxHQUFHLENBQUNMO1FBQzFDLElBQUlRLGdCQUFnQjtZQUNsQixNQUFNQyxRQUFRRCxlQUFlRSxPQUFPLENBQUNUO1lBQ3JDLElBQUlRLFVBQVUsQ0FBQyxHQUFHO2dCQUNoQkQsZUFBZUcsTUFBTSxDQUFDRixPQUFPO1lBQy9CO1FBQ0Y7SUFDRjtJQUVPRyxLQUFjWixLQUFhLEVBQUVhLElBQVEsRUFBUTtRQUNsRCxNQUFNTCxpQkFBaUIsSUFBSSxDQUFDTixTQUFTLENBQUNHLEdBQUcsQ0FBQ0w7UUFDMUMsSUFBSVEsZ0JBQWdCO1lBQ2xCLDBFQUEwRTtZQUMxRSxNQUFNTixZQUFZO21CQUFJTTthQUFlO1lBQ3JDLEtBQUssTUFBTVAsWUFBWUMsVUFBVztnQkFDaENELFNBQVNZO1lBQ1g7UUFDRjtJQUNGO0lBRU9DLEtBQWNkLEtBQWEsRUFBRUMsUUFBMEIsRUFBUTtRQUNwRSxNQUFNYyxlQUFpQyxDQUFDRjtZQUN0Q1osU0FBU1k7WUFDVCxJQUFJLENBQUNOLEdBQUcsQ0FBQ1AsT0FBT2U7UUFDbEI7UUFDQSxJQUFJLENBQUNoQixFQUFFLENBQUNDLE9BQU9lO0lBQ2pCO0lBRU9DLG1CQUFtQmhCLEtBQWMsRUFBUTtRQUM5QyxJQUFJQSxPQUFPO1lBQ1QsSUFBSSxDQUFDRSxTQUFTLENBQUNlLE1BQU0sQ0FBQ2pCO1FBQ3hCLE9BQU87WUFDTCxJQUFJLENBQUNFLFNBQVMsQ0FBQ2dCLEtBQUs7UUFDdEI7SUFDRjtJQUVPQyxpQkFBaUJuQixLQUFhLEVBQVU7WUFDdEM7UUFBUCxPQUFPLDRCQUFJLENBQUNFLFNBQVMsQ0FBQ0csR0FBRyxDQUFDTCxvQkFBbkIsOERBQTJCb0IsTUFBTSxLQUFJO0lBQzlDOzthQWhEUWxCLFlBQVksSUFBSW1COztBQWlEMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL0V2ZW50RW1pdHRlci50cz82YTM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEV2ZW50IHN5c3RlbSBmb3IgZGVjb3VwbGVkIGNvbW11bmljYXRpb25cbmV4cG9ydCB0eXBlIEV2ZW50TGlzdGVuZXI8VCA9IGFueT4gPSAoZGF0YTogVCkgPT4gdm9pZDtcblxuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgbGlzdGVuZXJzID0gbmV3IE1hcDxzdHJpbmcsIEV2ZW50TGlzdGVuZXJbXT4oKTtcblxuICBwdWJsaWMgb248VCA9IGFueT4oZXZlbnQ6IHN0cmluZywgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8VD4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmhhcyhldmVudCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNldChldmVudCwgW10pO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnQpIS5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHB1YmxpYyBvZmY8VCA9IGFueT4oZXZlbnQ6IHN0cmluZywgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXI8VD4pOiB2b2lkIHtcbiAgICBjb25zdCBldmVudExpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldChldmVudCk7XG4gICAgaWYgKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGV2ZW50TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBlbWl0PFQgPSBhbnk+KGV2ZW50OiBzdHJpbmcsIGRhdGE/OiBUKTogdm9pZCB7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycy5nZXQoZXZlbnQpO1xuICAgIGlmIChldmVudExpc3RlbmVycykge1xuICAgICAgLy8gQ3JlYXRlIGEgY29weSB0byBhdm9pZCBpc3N1ZXMgaWYgbGlzdGVuZXJzIGFyZSBtb2RpZmllZCBkdXJpbmcgZW1pc3Npb25cbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi5ldmVudExpc3RlbmVyc107XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihkYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgb25jZTxUID0gYW55PihldmVudDogc3RyaW5nLCBsaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxUPik6IHZvaWQge1xuICAgIGNvbnN0IG9uY2VMaXN0ZW5lcjogRXZlbnRMaXN0ZW5lcjxUPiA9IChkYXRhKSA9PiB7XG4gICAgICBsaXN0ZW5lcihkYXRhKTtcbiAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlTGlzdGVuZXIpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudCwgb25jZUxpc3RlbmVyKTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldExpc3RlbmVyQ291bnQoZXZlbnQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmdldChldmVudCk/Lmxlbmd0aCB8fCAwO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwib24iLCJldmVudCIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwiaGFzIiwic2V0IiwiZ2V0IiwicHVzaCIsIm9mZiIsImV2ZW50TGlzdGVuZXJzIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiZW1pdCIsImRhdGEiLCJvbmNlIiwib25jZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZGVsZXRlIiwiY2xlYXIiLCJnZXRMaXN0ZW5lckNvdW50IiwibGVuZ3RoIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/EventEmitter.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/MathUtils.ts":
/*!********************************!*\
  !*** ./src/utils/MathUtils.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MathUtils: function() { return /* binding */ MathUtils; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n// Math utilities for game development\n\nclass MathUtils {\n    // Clamp value between min and max\n    static clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    }\n    // Linear interpolation\n    static lerp(a, b, t) {\n        return a + (b - a) * t;\n    }\n    // Smooth step interpolation\n    static smoothStep(edge0, edge1, x) {\n        const t = this.clamp((x - edge0) / (edge1 - edge0), 0, 1);\n        return t * t * (3 - 2 * t);\n    }\n    // Distance between two 2D points\n    static distance2D(x1, y1, x2, y2) {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    // Distance between two 3D points\n    static distance3D(x1, y1, z1, x2, y2, z2) {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const dz = z2 - z1;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    // Normalize angle to [-PI, PI]\n    static normalizeAngle(angle) {\n        while(angle > Math.PI)angle -= 2 * Math.PI;\n        while(angle < -Math.PI)angle += 2 * Math.PI;\n        return angle;\n    }\n    // Random number between min and max\n    static random(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    // Random integer between min and max (inclusive)\n    static randomInt(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    // Check if point is inside circle\n    static pointInCircle(px, py, cx, cy, radius) {\n        const dx = px - cx;\n        const dy = py - cy;\n        return dx * dx + dy * dy <= radius * radius;\n    }\n    // Vector3 utilities\n    static vector3Distance(a, b) {\n        return a.distanceTo(b);\n    }\n    static vector3Lerp(a, b, t) {\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3().lerpVectors(a, b, t);\n    }\n    // Convert degrees to radians\n    static degToRad(degrees) {\n        return degrees * this.DEG_TO_RAD;\n    }\n    // Convert radians to degrees\n    static radToDeg(radians) {\n        return radians * this.RAD_TO_DEG;\n    }\n    // Check if number is approximately equal (for floating point comparison)\n    static approximately(a, b) {\n        let epsilon = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.0001;\n        return Math.abs(a - b) < epsilon;\n    }\n    // Map value from one range to another\n    static map(value, fromMin, fromMax, toMin, toMax) {\n        return (value - fromMin) * (toMax - toMin) / (fromMax - fromMin) + toMin;\n    }\n}\nMathUtils.DEG_TO_RAD = Math.PI / 180;\nMathUtils.RAD_TO_DEG = 180 / Math.PI;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9NYXRoVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQ0FBc0M7QUFDVTtBQUV6QyxNQUFNQztJQUlYLGtDQUFrQztJQUNsQyxPQUFjQyxNQUFNQyxLQUFhLEVBQUVDLEdBQVcsRUFBRUMsR0FBVyxFQUFVO1FBQ25FLE9BQU9DLEtBQUtELEdBQUcsQ0FBQ0QsS0FBS0UsS0FBS0YsR0FBRyxDQUFDQyxLQUFLRjtJQUNyQztJQUVBLHVCQUF1QjtJQUN2QixPQUFjSSxLQUFLQyxDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUyxFQUFVO1FBQzFELE9BQU9GLElBQUksQ0FBQ0MsSUFBSUQsQ0FBQUEsSUFBS0U7SUFDdkI7SUFFQSw0QkFBNEI7SUFDNUIsT0FBY0MsV0FBV0MsS0FBYSxFQUFFQyxLQUFhLEVBQUVDLENBQVMsRUFBVTtRQUN4RSxNQUFNSixJQUFJLElBQUksQ0FBQ1IsS0FBSyxDQUFDLENBQUNZLElBQUlGLEtBQUksSUFBTUMsQ0FBQUEsUUFBUUQsS0FBSSxHQUFJLEdBQUc7UUFDdkQsT0FBT0YsSUFBSUEsSUFBSyxLQUFJLElBQUlBLENBQUFBO0lBQzFCO0lBRUEsaUNBQWlDO0lBQ2pDLE9BQWNLLFdBQVdDLEVBQVUsRUFBRUMsRUFBVSxFQUFFQyxFQUFVLEVBQUVDLEVBQVUsRUFBVTtRQUMvRSxNQUFNQyxLQUFLRixLQUFLRjtRQUNoQixNQUFNSyxLQUFLRixLQUFLRjtRQUNoQixPQUFPWCxLQUFLZ0IsSUFBSSxDQUFDRixLQUFLQSxLQUFLQyxLQUFLQTtJQUNsQztJQUVBLGlDQUFpQztJQUNqQyxPQUFjRSxXQUNaUCxFQUFVLEVBQUVDLEVBQVUsRUFBRU8sRUFBVSxFQUNsQ04sRUFBVSxFQUFFQyxFQUFVLEVBQUVNLEVBQVUsRUFDMUI7UUFDUixNQUFNTCxLQUFLRixLQUFLRjtRQUNoQixNQUFNSyxLQUFLRixLQUFLRjtRQUNoQixNQUFNUyxLQUFLRCxLQUFLRDtRQUNoQixPQUFPbEIsS0FBS2dCLElBQUksQ0FBQ0YsS0FBS0EsS0FBS0MsS0FBS0EsS0FBS0ssS0FBS0E7SUFDNUM7SUFFQSwrQkFBK0I7SUFDL0IsT0FBY0MsZUFBZUMsS0FBYSxFQUFVO1FBQ2xELE1BQU9BLFFBQVF0QixLQUFLdUIsRUFBRSxDQUFFRCxTQUFTLElBQUl0QixLQUFLdUIsRUFBRTtRQUM1QyxNQUFPRCxRQUFRLENBQUN0QixLQUFLdUIsRUFBRSxDQUFFRCxTQUFTLElBQUl0QixLQUFLdUIsRUFBRTtRQUM3QyxPQUFPRDtJQUNUO0lBRUEsb0NBQW9DO0lBQ3BDLE9BQWNFLE9BQU8xQixHQUFXLEVBQUVDLEdBQVcsRUFBVTtRQUNyRCxPQUFPQyxLQUFLd0IsTUFBTSxLQUFNekIsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtJQUN2QztJQUVBLGlEQUFpRDtJQUNqRCxPQUFjMkIsVUFBVTNCLEdBQVcsRUFBRUMsR0FBVyxFQUFVO1FBQ3hELE9BQU9DLEtBQUswQixLQUFLLENBQUMxQixLQUFLd0IsTUFBTSxLQUFNekIsQ0FBQUEsTUFBTUQsTUFBTSxNQUFNQTtJQUN2RDtJQUVBLGtDQUFrQztJQUNsQyxPQUFjNkIsY0FDWkMsRUFBVSxFQUFFQyxFQUFVLEVBQ3RCQyxFQUFVLEVBQUVDLEVBQVUsRUFDdEJDLE1BQWMsRUFDTDtRQUNULE1BQU1sQixLQUFLYyxLQUFLRTtRQUNoQixNQUFNZixLQUFLYyxLQUFLRTtRQUNoQixPQUFPakIsS0FBS0EsS0FBS0MsS0FBS0EsTUFBTWlCLFNBQVNBO0lBQ3ZDO0lBRUEsb0JBQW9CO0lBQ3BCLE9BQWNDLGdCQUFnQi9CLENBQVUsRUFBRUMsQ0FBVSxFQUFVO1FBQzVELE9BQU9ELEVBQUVnQyxVQUFVLENBQUMvQjtJQUN0QjtJQUVBLE9BQWNnQyxZQUFZakMsQ0FBVSxFQUFFQyxDQUFVLEVBQUVDLENBQVMsRUFBVztRQUNwRSxPQUFPLElBQUlWLHlEQUFPQSxHQUFHMEMsV0FBVyxDQUFDbEMsR0FBR0MsR0FBR0M7SUFDekM7SUFFQSw2QkFBNkI7SUFDN0IsT0FBY2lDLFNBQVNDLE9BQWUsRUFBVTtRQUM5QyxPQUFPQSxVQUFVLElBQUksQ0FBQ0MsVUFBVTtJQUNsQztJQUVBLDZCQUE2QjtJQUM3QixPQUFjQyxTQUFTQyxPQUFlLEVBQVU7UUFDOUMsT0FBT0EsVUFBVSxJQUFJLENBQUNDLFVBQVU7SUFDbEM7SUFFQSx5RUFBeUU7SUFDekUsT0FBY0MsY0FBY3pDLENBQVMsRUFBRUMsQ0FBUyxFQUFxQztZQUFuQ3lDLFVBQUFBLGlFQUFrQjtRQUNsRSxPQUFPNUMsS0FBSzZDLEdBQUcsQ0FBQzNDLElBQUlDLEtBQUt5QztJQUMzQjtJQUVBLHNDQUFzQztJQUN0QyxPQUFjRSxJQUNaakQsS0FBYSxFQUNia0QsT0FBZSxFQUFFQyxPQUFlLEVBQ2hDQyxLQUFhLEVBQUVDLEtBQWEsRUFDcEI7UUFDUixPQUFPLENBQUNyRCxRQUFRa0QsT0FBTSxJQUFNRyxDQUFBQSxRQUFRRCxLQUFJLElBQU1ELENBQUFBLFVBQVVELE9BQU0sSUFBS0U7SUFDckU7QUFDRjtBQWxHYXRELFVBQ1k0QyxhQUFhdkMsS0FBS3VCLEVBQUUsR0FBRztBQURuQzVCLFVBRVkrQyxhQUFhLE1BQU0xQyxLQUFLdUIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvTWF0aFV0aWxzLnRzPzhjMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTWF0aCB1dGlsaXRpZXMgZm9yIGdhbWUgZGV2ZWxvcG1lbnRcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG5leHBvcnQgY2xhc3MgTWF0aFV0aWxzIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBSQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcblxuICAvLyBDbGFtcCB2YWx1ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gIHB1YmxpYyBzdGF0aWMgY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG4gIH1cblxuICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxuICBwdWJsaWMgc3RhdGljIGxlcnAoYTogbnVtYmVyLCBiOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGEgKyAoYiAtIGEpICogdDtcbiAgfVxuXG4gIC8vIFNtb290aCBzdGVwIGludGVycG9sYXRpb25cbiAgcHVibGljIHN0YXRpYyBzbW9vdGhTdGVwKGVkZ2UwOiBudW1iZXIsIGVkZ2UxOiBudW1iZXIsIHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAsIDEpO1xuICAgIHJldHVybiB0ICogdCAqICgzIC0gMiAqIHQpO1xuICB9XG5cbiAgLy8gRGlzdGFuY2UgYmV0d2VlbiB0d28gMkQgcG9pbnRzXG4gIHB1YmxpYyBzdGF0aWMgZGlzdGFuY2UyRCh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9XG5cbiAgLy8gRGlzdGFuY2UgYmV0d2VlbiB0d28gM0QgcG9pbnRzXG4gIHB1YmxpYyBzdGF0aWMgZGlzdGFuY2UzRChcbiAgICB4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB6MTogbnVtYmVyLFxuICAgIHgyOiBudW1iZXIsIHkyOiBudW1iZXIsIHoyOiBudW1iZXJcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IGR6ID0gejIgLSB6MTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgYW5nbGUgdG8gWy1QSSwgUEldXG4gIHB1YmxpYyBzdGF0aWMgbm9ybWFsaXplQW5nbGUoYW5nbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgd2hpbGUgKGFuZ2xlID4gTWF0aC5QSSkgYW5nbGUgLT0gMiAqIE1hdGguUEk7XG4gICAgd2hpbGUgKGFuZ2xlIDwgLU1hdGguUEkpIGFuZ2xlICs9IDIgKiBNYXRoLlBJO1xuICAgIHJldHVybiBhbmdsZTtcbiAgfVxuXG4gIC8vIFJhbmRvbSBudW1iZXIgYmV0d2VlbiBtaW4gYW5kIG1heFxuICBwdWJsaWMgc3RhdGljIHJhbmRvbShtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG4gIH1cblxuICAvLyBSYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpXG4gIHB1YmxpYyBzdGF0aWMgcmFuZG9tSW50KG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gIH1cblxuICAvLyBDaGVjayBpZiBwb2ludCBpcyBpbnNpZGUgY2lyY2xlXG4gIHB1YmxpYyBzdGF0aWMgcG9pbnRJbkNpcmNsZShcbiAgICBweDogbnVtYmVyLCBweTogbnVtYmVyLFxuICAgIGN4OiBudW1iZXIsIGN5OiBudW1iZXIsXG4gICAgcmFkaXVzOiBudW1iZXJcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZHggPSBweCAtIGN4O1xuICAgIGNvbnN0IGR5ID0gcHkgLSBjeTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPD0gcmFkaXVzICogcmFkaXVzO1xuICB9XG5cbiAgLy8gVmVjdG9yMyB1dGlsaXRpZXNcbiAgcHVibGljIHN0YXRpYyB2ZWN0b3IzRGlzdGFuY2UoYTogVmVjdG9yMywgYjogVmVjdG9yMyk6IG51bWJlciB7XG4gICAgcmV0dXJuIGEuZGlzdGFuY2VUbyhiKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgdmVjdG9yM0xlcnAoYTogVmVjdG9yMywgYjogVmVjdG9yMywgdDogbnVtYmVyKTogVmVjdG9yMyB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCkubGVycFZlY3RvcnMoYSwgYiwgdCk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xuICBwdWJsaWMgc3RhdGljIGRlZ1RvUmFkKGRlZ3JlZXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiB0aGlzLkRFR19UT19SQUQ7XG4gIH1cblxuICAvLyBDb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlc1xuICBwdWJsaWMgc3RhdGljIHJhZFRvRGVnKHJhZGlhbnM6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHJhZGlhbnMgKiB0aGlzLlJBRF9UT19ERUc7XG4gIH1cblxuICAvLyBDaGVjayBpZiBudW1iZXIgaXMgYXBwcm94aW1hdGVseSBlcXVhbCAoZm9yIGZsb2F0aW5nIHBvaW50IGNvbXBhcmlzb24pXG4gIHB1YmxpYyBzdGF0aWMgYXBwcm94aW1hdGVseShhOiBudW1iZXIsIGI6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyID0gMC4wMDAxKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IGVwc2lsb247XG4gIH1cblxuICAvLyBNYXAgdmFsdWUgZnJvbSBvbmUgcmFuZ2UgdG8gYW5vdGhlclxuICBwdWJsaWMgc3RhdGljIG1hcChcbiAgICB2YWx1ZTogbnVtYmVyLFxuICAgIGZyb21NaW46IG51bWJlciwgZnJvbU1heDogbnVtYmVyLFxuICAgIHRvTWluOiBudW1iZXIsIHRvTWF4OiBudW1iZXJcbiAgKTogbnVtYmVyIHtcbiAgICByZXR1cm4gKHZhbHVlIC0gZnJvbU1pbikgKiAodG9NYXggLSB0b01pbikgLyAoZnJvbU1heCAtIGZyb21NaW4pICsgdG9NaW47XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiTWF0aFV0aWxzIiwiY2xhbXAiLCJ2YWx1ZSIsIm1pbiIsIm1heCIsIk1hdGgiLCJsZXJwIiwiYSIsImIiLCJ0Iiwic21vb3RoU3RlcCIsImVkZ2UwIiwiZWRnZTEiLCJ4IiwiZGlzdGFuY2UyRCIsIngxIiwieTEiLCJ4MiIsInkyIiwiZHgiLCJkeSIsInNxcnQiLCJkaXN0YW5jZTNEIiwiejEiLCJ6MiIsImR6Iiwibm9ybWFsaXplQW5nbGUiLCJhbmdsZSIsIlBJIiwicmFuZG9tIiwicmFuZG9tSW50IiwiZmxvb3IiLCJwb2ludEluQ2lyY2xlIiwicHgiLCJweSIsImN4IiwiY3kiLCJyYWRpdXMiLCJ2ZWN0b3IzRGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwidmVjdG9yM0xlcnAiLCJsZXJwVmVjdG9ycyIsImRlZ1RvUmFkIiwiZGVncmVlcyIsIkRFR19UT19SQUQiLCJyYWRUb0RlZyIsInJhZGlhbnMiLCJSQURfVE9fREVHIiwiYXBwcm94aW1hdGVseSIsImVwc2lsb24iLCJhYnMiLCJtYXAiLCJmcm9tTWluIiwiZnJvbU1heCIsInRvTWluIiwidG9NYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/MathUtils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/MountainGenerator.ts":
/*!****************************************!*\
  !*** ./src/utils/MountainGenerator.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPeakGeometry: function() { return /* binding */ createPeakGeometry; },\n/* harmony export */   generateMountains: function() { return /* binding */ generateMountains; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n\n/**\n * Generates mountain positions around the hexagonal map perimeter\n * Creates a natural mountain border with controlled randomness\n */ const generateMountains = ()=>{\n    const mountains = [];\n    const numberOfMountains = 22;\n    const radius = 46;\n    // Create evenly spaced mountains around the perimeter\n    for(let i = 0; i < numberOfMountains; i++){\n        const angle = i / numberOfMountains * Math.PI * 2;\n        // Controlled randomness for natural variation\n        const randomRadius = radius + (Math.random() * 4 - 2); // Varies radius by ±2 units\n        const x = Math.cos(angle) * randomRadius;\n        const z = Math.sin(angle) * randomRadius;\n        const scale = 0.75 + Math.random() * 0.4; // More consistent scaling\n        // Primary mountain ring\n        mountains.push({\n            position: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, 0, z),\n            scale: scale\n        });\n        // Second row of mountains slightly offset for depth\n        const innerRadius = radius - 12;\n        const offsetAngle = angle + Math.PI / numberOfMountains;\n        const innerX = Math.cos(offsetAngle) * innerRadius;\n        const innerZ = Math.sin(offsetAngle) * innerRadius;\n        mountains.push({\n            position: new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(innerX, 0, innerZ),\n            scale: scale * 0.9\n        });\n    }\n    return mountains;\n};\n/**\n * Creates varied peak geometries for natural snowtop variation\n * Uses deterministic randomness based on index for consistent results\n */ const createPeakGeometry = (index)=>{\n    // Use index as seed for consistent variation per mountain\n    const seed = index * 0.618033988749; // Golden ratio for good distribution\n    // Create detailed cone geometry with higher resolution\n    const geometry = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.ConeGeometry(5, 8, 16, 8);\n    const positions = geometry.attributes.position.array;\n    // Add natural variation to the peak shape with multiple noise layers\n    for(let i = 0; i < positions.length; i += 3){\n        const x = positions[i];\n        const y = positions[i + 1];\n        const z = positions[i + 2];\n        // Only modify vertices that are not at the very top or bottom\n        if (y > -3.5 && y < 3.5) {\n            // Create multiple layers of noise for more realistic terrain\n            const noiseX1 = Math.sin(x * 0.5 + seed) * Math.cos(z * 0.3 + seed * 2);\n            const noiseZ1 = Math.cos(x * 0.3 + seed * 3) * Math.sin(z * 0.5 + seed * 4);\n            // Add finer detail noise\n            const noiseX2 = Math.sin(x * 1.2 + seed * 5) * Math.cos(z * 0.8 + seed * 6) * 0.3;\n            const noiseZ2 = Math.cos(x * 0.9 + seed * 7) * Math.sin(z * 1.1 + seed * 8) * 0.3;\n            // Apply variation that's stronger at the snow line (middle of the peak)\n            const heightFactor = 1 - Math.abs(y) / 2; // Stronger variation in middle\n            const variation = 0.4 + Math.sin(seed * 10) * 0.3; // More dramatic variation\n            positions[i] += (noiseX1 + noiseX2) * variation * heightFactor;\n            positions[i + 2] += (noiseZ1 + noiseZ2) * variation * heightFactor;\n            // Add subtle height variation for more natural ridges\n            positions[i + 1] += Math.sin(x * 0.2 + z * 0.2 + seed) * 0.2 * heightFactor;\n        }\n    }\n    geometry.attributes.position.needsUpdate = true;\n    geometry.computeVertexNormals(); // Recompute normals for proper lighting\n    return geometry;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9Nb3VudGFpbkdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEQ7QUFPOUQ7OztDQUdDLEdBQ00sTUFBTUUsb0JBQW9CO0lBQy9CLE1BQU1DLFlBQTRCLEVBQUU7SUFDcEMsTUFBTUMsb0JBQW9CO0lBQzFCLE1BQU1DLFNBQVM7SUFFZixzREFBc0Q7SUFDdEQsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLG1CQUFtQkUsSUFBSztRQUMxQyxNQUFNQyxRQUFRLElBQUtILG9CQUFxQkksS0FBS0MsRUFBRSxHQUFHO1FBRWxELDhDQUE4QztRQUM5QyxNQUFNQyxlQUFlTCxTQUFVRyxDQUFBQSxLQUFLRyxNQUFNLEtBQUssSUFBSSxJQUFJLDRCQUE0QjtRQUNuRixNQUFNQyxJQUFJSixLQUFLSyxHQUFHLENBQUNOLFNBQVNHO1FBQzVCLE1BQU1JLElBQUlOLEtBQUtPLEdBQUcsQ0FBQ1IsU0FBU0c7UUFDNUIsTUFBTU0sUUFBUSxPQUFPUixLQUFLRyxNQUFNLEtBQUssS0FBSywwQkFBMEI7UUFFcEUsd0JBQXdCO1FBQ3hCUixVQUFVYyxJQUFJLENBQUM7WUFDYkMsVUFBVSxJQUFJbEIseURBQU9BLENBQUNZLEdBQUcsR0FBR0U7WUFDNUJFLE9BQU9BO1FBQ1Q7UUFFQSxvREFBb0Q7UUFDcEQsTUFBTUcsY0FBY2QsU0FBUztRQUM3QixNQUFNZSxjQUFjYixRQUFTQyxLQUFLQyxFQUFFLEdBQUdMO1FBQ3ZDLE1BQU1pQixTQUFTYixLQUFLSyxHQUFHLENBQUNPLGVBQWVEO1FBQ3ZDLE1BQU1HLFNBQVNkLEtBQUtPLEdBQUcsQ0FBQ0ssZUFBZUQ7UUFFdkNoQixVQUFVYyxJQUFJLENBQUM7WUFDYkMsVUFBVSxJQUFJbEIseURBQU9BLENBQUNxQixRQUFRLEdBQUdDO1lBQ2pDTixPQUFPQSxRQUFRO1FBQ2pCO0lBQ0Y7SUFFQSxPQUFPYjtBQUNULEVBQUU7QUFFRjs7O0NBR0MsR0FDTSxNQUFNb0IscUJBQXFCLENBQUNDO0lBQ2pDLDBEQUEwRDtJQUMxRCxNQUFNQyxPQUFPRCxRQUFRLGdCQUFnQixxQ0FBcUM7SUFFMUUsdURBQXVEO0lBQ3ZELE1BQU1FLFdBQVcsSUFBSXpCLDhEQUFZQSxDQUFDLEdBQUcsR0FBRyxJQUFJO0lBQzVDLE1BQU0wQixZQUFZRCxTQUFTRSxVQUFVLENBQUNWLFFBQVEsQ0FBQ1csS0FBSztJQUVwRCxxRUFBcUU7SUFDckUsSUFBSyxJQUFJdkIsSUFBSSxHQUFHQSxJQUFJcUIsVUFBVUcsTUFBTSxFQUFFeEIsS0FBSyxFQUFHO1FBQzVDLE1BQU1NLElBQUllLFNBQVMsQ0FBQ3JCLEVBQUU7UUFDdEIsTUFBTXlCLElBQUlKLFNBQVMsQ0FBQ3JCLElBQUksRUFBRTtRQUMxQixNQUFNUSxJQUFJYSxTQUFTLENBQUNyQixJQUFJLEVBQUU7UUFFMUIsOERBQThEO1FBQzlELElBQUl5QixJQUFJLENBQUMsT0FBT0EsSUFBSSxLQUFLO1lBQ3ZCLDZEQUE2RDtZQUM3RCxNQUFNQyxVQUFVeEIsS0FBS08sR0FBRyxDQUFDSCxJQUFJLE1BQU1hLFFBQVFqQixLQUFLSyxHQUFHLENBQUNDLElBQUksTUFBTVcsT0FBTztZQUNyRSxNQUFNUSxVQUFVekIsS0FBS0ssR0FBRyxDQUFDRCxJQUFJLE1BQU1hLE9BQU8sS0FBS2pCLEtBQUtPLEdBQUcsQ0FBQ0QsSUFBSSxNQUFNVyxPQUFPO1lBRXpFLHlCQUF5QjtZQUN6QixNQUFNUyxVQUFVMUIsS0FBS08sR0FBRyxDQUFDSCxJQUFJLE1BQU1hLE9BQU8sS0FBS2pCLEtBQUtLLEdBQUcsQ0FBQ0MsSUFBSSxNQUFNVyxPQUFPLEtBQUs7WUFDOUUsTUFBTVUsVUFBVTNCLEtBQUtLLEdBQUcsQ0FBQ0QsSUFBSSxNQUFNYSxPQUFPLEtBQUtqQixLQUFLTyxHQUFHLENBQUNELElBQUksTUFBTVcsT0FBTyxLQUFLO1lBRTlFLHdFQUF3RTtZQUN4RSxNQUFNVyxlQUFlLElBQUk1QixLQUFLNkIsR0FBRyxDQUFDTixLQUFLLEdBQUcsK0JBQStCO1lBQ3pFLE1BQU1PLFlBQVksTUFBTTlCLEtBQUtPLEdBQUcsQ0FBQ1UsT0FBTyxNQUFNLEtBQUssMEJBQTBCO1lBRTdFRSxTQUFTLENBQUNyQixFQUFFLElBQUksQ0FBQzBCLFVBQVVFLE9BQU0sSUFBS0ksWUFBWUY7WUFDbERULFNBQVMsQ0FBQ3JCLElBQUksRUFBRSxJQUFJLENBQUMyQixVQUFVRSxPQUFNLElBQUtHLFlBQVlGO1lBRXRELHNEQUFzRDtZQUN0RFQsU0FBUyxDQUFDckIsSUFBSSxFQUFFLElBQUlFLEtBQUtPLEdBQUcsQ0FBQ0gsSUFBSSxNQUFNRSxJQUFJLE1BQU1XLFFBQVEsTUFBTVc7UUFDakU7SUFDRjtJQUVBVixTQUFTRSxVQUFVLENBQUNWLFFBQVEsQ0FBQ3FCLFdBQVcsR0FBRztJQUMzQ2IsU0FBU2Msb0JBQW9CLElBQUksd0NBQXdDO0lBRXpFLE9BQU9kO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvTW91bnRhaW5HZW5lcmF0b3IudHM/YTdkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzLCBDb25lR2VvbWV0cnkgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1vdW50YWluRGF0YSB7XG4gIHBvc2l0aW9uOiBWZWN0b3IzO1xuICBzY2FsZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBtb3VudGFpbiBwb3NpdGlvbnMgYXJvdW5kIHRoZSBoZXhhZ29uYWwgbWFwIHBlcmltZXRlclxuICogQ3JlYXRlcyBhIG5hdHVyYWwgbW91bnRhaW4gYm9yZGVyIHdpdGggY29udHJvbGxlZCByYW5kb21uZXNzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZU1vdW50YWlucyA9ICgpOiBNb3VudGFpbkRhdGFbXSA9PiB7XG4gIGNvbnN0IG1vdW50YWluczogTW91bnRhaW5EYXRhW10gPSBbXTtcbiAgY29uc3QgbnVtYmVyT2ZNb3VudGFpbnMgPSAyMjtcbiAgY29uc3QgcmFkaXVzID0gNDY7XG4gIFxuICAvLyBDcmVhdGUgZXZlbmx5IHNwYWNlZCBtb3VudGFpbnMgYXJvdW5kIHRoZSBwZXJpbWV0ZXJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZk1vdW50YWluczsgaSsrKSB7XG4gICAgY29uc3QgYW5nbGUgPSAoaSAvIG51bWJlck9mTW91bnRhaW5zKSAqIE1hdGguUEkgKiAyO1xuICAgIFxuICAgIC8vIENvbnRyb2xsZWQgcmFuZG9tbmVzcyBmb3IgbmF0dXJhbCB2YXJpYXRpb25cbiAgICBjb25zdCByYW5kb21SYWRpdXMgPSByYWRpdXMgKyAoTWF0aC5yYW5kb20oKSAqIDQgLSAyKTsgLy8gVmFyaWVzIHJhZGl1cyBieSDCsTIgdW5pdHNcbiAgICBjb25zdCB4ID0gTWF0aC5jb3MoYW5nbGUpICogcmFuZG9tUmFkaXVzO1xuICAgIGNvbnN0IHogPSBNYXRoLnNpbihhbmdsZSkgKiByYW5kb21SYWRpdXM7XG4gICAgY29uc3Qgc2NhbGUgPSAwLjc1ICsgTWF0aC5yYW5kb20oKSAqIDAuNDsgLy8gTW9yZSBjb25zaXN0ZW50IHNjYWxpbmdcblxuICAgIC8vIFByaW1hcnkgbW91bnRhaW4gcmluZ1xuICAgIG1vdW50YWlucy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMyh4LCAwLCB6KSxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICB9KTtcblxuICAgIC8vIFNlY29uZCByb3cgb2YgbW91bnRhaW5zIHNsaWdodGx5IG9mZnNldCBmb3IgZGVwdGhcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyAtIDEyO1xuICAgIGNvbnN0IG9mZnNldEFuZ2xlID0gYW5nbGUgKyAoTWF0aC5QSSAvIG51bWJlck9mTW91bnRhaW5zKTtcbiAgICBjb25zdCBpbm5lclggPSBNYXRoLmNvcyhvZmZzZXRBbmdsZSkgKiBpbm5lclJhZGl1cztcbiAgICBjb25zdCBpbm5lclogPSBNYXRoLnNpbihvZmZzZXRBbmdsZSkgKiBpbm5lclJhZGl1cztcblxuICAgIG1vdW50YWlucy5wdXNoKHtcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMyhpbm5lclgsIDAsIGlubmVyWiksXG4gICAgICBzY2FsZTogc2NhbGUgKiAwLjksXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbW91bnRhaW5zO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHZhcmllZCBwZWFrIGdlb21ldHJpZXMgZm9yIG5hdHVyYWwgc25vd3RvcCB2YXJpYXRpb25cbiAqIFVzZXMgZGV0ZXJtaW5pc3RpYyByYW5kb21uZXNzIGJhc2VkIG9uIGluZGV4IGZvciBjb25zaXN0ZW50IHJlc3VsdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBlYWtHZW9tZXRyeSA9IChpbmRleDogbnVtYmVyKTogQ29uZUdlb21ldHJ5ID0+IHtcbiAgLy8gVXNlIGluZGV4IGFzIHNlZWQgZm9yIGNvbnNpc3RlbnQgdmFyaWF0aW9uIHBlciBtb3VudGFpblxuICBjb25zdCBzZWVkID0gaW5kZXggKiAwLjYxODAzMzk4ODc0OTsgLy8gR29sZGVuIHJhdGlvIGZvciBnb29kIGRpc3RyaWJ1dGlvblxuICBcbiAgLy8gQ3JlYXRlIGRldGFpbGVkIGNvbmUgZ2VvbWV0cnkgd2l0aCBoaWdoZXIgcmVzb2x1dGlvblxuICBjb25zdCBnZW9tZXRyeSA9IG5ldyBDb25lR2VvbWV0cnkoNSwgOCwgMTYsIDgpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5IGFzIEZsb2F0MzJBcnJheTtcbiAgXG4gIC8vIEFkZCBuYXR1cmFsIHZhcmlhdGlvbiB0byB0aGUgcGVhayBzaGFwZSB3aXRoIG11bHRpcGxlIG5vaXNlIGxheWVyc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNvbnN0IHggPSBwb3NpdGlvbnNbaV07XG4gICAgY29uc3QgeSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgY29uc3QgeiA9IHBvc2l0aW9uc1tpICsgMl07XG4gICAgXG4gICAgLy8gT25seSBtb2RpZnkgdmVydGljZXMgdGhhdCBhcmUgbm90IGF0IHRoZSB2ZXJ5IHRvcCBvciBib3R0b21cbiAgICBpZiAoeSA+IC0zLjUgJiYgeSA8IDMuNSkge1xuICAgICAgLy8gQ3JlYXRlIG11bHRpcGxlIGxheWVycyBvZiBub2lzZSBmb3IgbW9yZSByZWFsaXN0aWMgdGVycmFpblxuICAgICAgY29uc3Qgbm9pc2VYMSA9IE1hdGguc2luKHggKiAwLjUgKyBzZWVkKSAqIE1hdGguY29zKHogKiAwLjMgKyBzZWVkICogMik7XG4gICAgICBjb25zdCBub2lzZVoxID0gTWF0aC5jb3MoeCAqIDAuMyArIHNlZWQgKiAzKSAqIE1hdGguc2luKHogKiAwLjUgKyBzZWVkICogNCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBmaW5lciBkZXRhaWwgbm9pc2VcbiAgICAgIGNvbnN0IG5vaXNlWDIgPSBNYXRoLnNpbih4ICogMS4yICsgc2VlZCAqIDUpICogTWF0aC5jb3MoeiAqIDAuOCArIHNlZWQgKiA2KSAqIDAuMztcbiAgICAgIGNvbnN0IG5vaXNlWjIgPSBNYXRoLmNvcyh4ICogMC45ICsgc2VlZCAqIDcpICogTWF0aC5zaW4oeiAqIDEuMSArIHNlZWQgKiA4KSAqIDAuMztcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgdmFyaWF0aW9uIHRoYXQncyBzdHJvbmdlciBhdCB0aGUgc25vdyBsaW5lIChtaWRkbGUgb2YgdGhlIHBlYWspXG4gICAgICBjb25zdCBoZWlnaHRGYWN0b3IgPSAxIC0gTWF0aC5hYnMoeSkgLyAyOyAvLyBTdHJvbmdlciB2YXJpYXRpb24gaW4gbWlkZGxlXG4gICAgICBjb25zdCB2YXJpYXRpb24gPSAwLjQgKyBNYXRoLnNpbihzZWVkICogMTApICogMC4zOyAvLyBNb3JlIGRyYW1hdGljIHZhcmlhdGlvblxuICAgICAgXG4gICAgICBwb3NpdGlvbnNbaV0gKz0gKG5vaXNlWDEgKyBub2lzZVgyKSAqIHZhcmlhdGlvbiAqIGhlaWdodEZhY3RvcjtcbiAgICAgIHBvc2l0aW9uc1tpICsgMl0gKz0gKG5vaXNlWjEgKyBub2lzZVoyKSAqIHZhcmlhdGlvbiAqIGhlaWdodEZhY3RvcjtcbiAgICAgIFxuICAgICAgLy8gQWRkIHN1YnRsZSBoZWlnaHQgdmFyaWF0aW9uIGZvciBtb3JlIG5hdHVyYWwgcmlkZ2VzXG4gICAgICBwb3NpdGlvbnNbaSArIDFdICs9IE1hdGguc2luKHggKiAwLjIgKyB6ICogMC4yICsgc2VlZCkgKiAwLjIgKiBoZWlnaHRGYWN0b3I7XG4gICAgfVxuICB9XG4gIFxuICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gUmVjb21wdXRlIG5vcm1hbHMgZm9yIHByb3BlciBsaWdodGluZ1xuICBcbiAgcmV0dXJuIGdlb21ldHJ5O1xufTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQ29uZUdlb21ldHJ5IiwiZ2VuZXJhdGVNb3VudGFpbnMiLCJtb3VudGFpbnMiLCJudW1iZXJPZk1vdW50YWlucyIsInJhZGl1cyIsImkiLCJhbmdsZSIsIk1hdGgiLCJQSSIsInJhbmRvbVJhZGl1cyIsInJhbmRvbSIsIngiLCJjb3MiLCJ6Iiwic2luIiwic2NhbGUiLCJwdXNoIiwicG9zaXRpb24iLCJpbm5lclJhZGl1cyIsIm9mZnNldEFuZ2xlIiwiaW5uZXJYIiwiaW5uZXJaIiwiY3JlYXRlUGVha0dlb21ldHJ5IiwiaW5kZXgiLCJzZWVkIiwiZ2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJhdHRyaWJ1dGVzIiwiYXJyYXkiLCJsZW5ndGgiLCJ5Iiwibm9pc2VYMSIsIm5vaXNlWjEiLCJub2lzZVgyIiwibm9pc2VaMiIsImhlaWdodEZhY3RvciIsImFicyIsInZhcmlhdGlvbiIsIm5lZWRzVXBkYXRlIiwiY29tcHV0ZVZlcnRleE5vcm1hbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/MountainGenerator.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/ObjectPool.ts":
/*!*********************************!*\
  !*** ./src/utils/ObjectPool.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObjectPool: function() { return /* binding */ ObjectPool; }\n/* harmony export */ });\n// Object Pool for performance optimization\nclass ObjectPool {\n    acquire() {\n        if (this.pool.length > 0) {\n            return this.pool.pop();\n        }\n        return this.createFn();\n    }\n    release(obj) {\n        if (this.pool.length < this.maxSize) {\n            this.resetFn(obj);\n            this.pool.push(obj);\n        }\n    }\n    clear() {\n        this.pool.length = 0;\n    }\n    getPoolSize() {\n        return this.pool.length;\n    }\n    constructor(createFn, resetFn, maxSize = 100){\n        this.pool = [];\n        this.createFn = createFn;\n        this.resetFn = resetFn;\n        this.maxSize = maxSize;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9PYmplY3RQb29sLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwyQ0FBMkM7QUFDcEMsTUFBTUE7SUFnQkpDLFVBQWE7UUFDbEIsSUFBSSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEdBQUc7WUFDeEIsT0FBTyxJQUFJLENBQUNELElBQUksQ0FBQ0UsR0FBRztRQUN0QjtRQUNBLE9BQU8sSUFBSSxDQUFDQyxRQUFRO0lBQ3RCO0lBRU9DLFFBQVFDLEdBQU0sRUFBUTtRQUMzQixJQUFJLElBQUksQ0FBQ0wsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSSxDQUFDSyxPQUFPLEVBQUU7WUFDbkMsSUFBSSxDQUFDQyxPQUFPLENBQUNGO1lBQ2IsSUFBSSxDQUFDTCxJQUFJLENBQUNRLElBQUksQ0FBQ0g7UUFDakI7SUFDRjtJQUVPSSxRQUFjO1FBQ25CLElBQUksQ0FBQ1QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7SUFDckI7SUFFT1MsY0FBc0I7UUFDM0IsT0FBTyxJQUFJLENBQUNWLElBQUksQ0FBQ0MsTUFBTTtJQUN6QjtJQTlCQVUsWUFDRVIsUUFBaUIsRUFDakJJLE9BQXlCLEVBQ3pCRCxVQUFrQixHQUFHLENBQ3JCO2FBVE1OLE9BQVksRUFBRTtRQVVwQixJQUFJLENBQUNHLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDSSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO0lBQ2pCO0FBdUJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9PYmplY3RQb29sLnRzPzMwMmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT2JqZWN0IFBvb2wgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxuZXhwb3J0IGNsYXNzIE9iamVjdFBvb2w8VD4ge1xuICBwcml2YXRlIHBvb2w6IFRbXSA9IFtdO1xuICBwcml2YXRlIGNyZWF0ZUZuOiAoKSA9PiBUO1xuICBwcml2YXRlIHJlc2V0Rm46IChvYmo6IFQpID0+IHZvaWQ7XG4gIHByaXZhdGUgbWF4U2l6ZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNyZWF0ZUZuOiAoKSA9PiBULFxuICAgIHJlc2V0Rm46IChvYmo6IFQpID0+IHZvaWQsXG4gICAgbWF4U2l6ZTogbnVtYmVyID0gMTAwXG4gICkge1xuICAgIHRoaXMuY3JlYXRlRm4gPSBjcmVhdGVGbjtcbiAgICB0aGlzLnJlc2V0Rm4gPSByZXNldEZuO1xuICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gIH1cblxuICBwdWJsaWMgYWNxdWlyZSgpOiBUIHtcbiAgICBpZiAodGhpcy5wb29sLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnBvb2wucG9wKCkhO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGbigpO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2Uob2JqOiBUKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucG9vbC5sZW5ndGggPCB0aGlzLm1heFNpemUpIHtcbiAgICAgIHRoaXMucmVzZXRGbihvYmopO1xuICAgICAgdGhpcy5wb29sLnB1c2gob2JqKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5wb29sLmxlbmd0aCA9IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0UG9vbFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wb29sLmxlbmd0aDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdFBvb2wiLCJhY3F1aXJlIiwicG9vbCIsImxlbmd0aCIsInBvcCIsImNyZWF0ZUZuIiwicmVsZWFzZSIsIm9iaiIsIm1heFNpemUiLCJyZXNldEZuIiwicHVzaCIsImNsZWFyIiwiZ2V0UG9vbFNpemUiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/ObjectPool.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/SpatialHash.ts":
/*!**********************************!*\
  !*** ./src/utils/SpatialHash.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpatialHash: function() { return /* binding */ SpatialHash; }\n/* harmony export */ });\n/* harmony import */ var _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils/three-exports */ \"(app-pages-browser)/./src/utils/three-exports.ts\");\n// Spatial hash for efficient collision detection\n\nclass SpatialHash {\n    getCellKey(x, y, z) {\n        return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n    }\n    getCellCoords(position) {\n        return new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.floor(position.x / this.cellSize), Math.floor(position.y / this.cellSize), Math.floor(position.z / this.cellSize));\n    }\n    getCellsForBounds(bounds) {\n        const cells = [];\n        const minCell = this.getCellCoords(bounds.min);\n        const maxCell = this.getCellCoords(bounds.max);\n        for(let x = minCell.x; x <= maxCell.x; x++){\n            for(let y = minCell.y; y <= maxCell.y; y++){\n                for(let z = minCell.z; z <= maxCell.z; z++){\n                    cells.push(this.getCellKey(x, y, z));\n                }\n            }\n        }\n        return cells;\n    }\n    insert(entity, bounds) {\n        // Remove entity from old cells first\n        this.remove(entity);\n        const entry = {\n            entity,\n            bounds: bounds.clone()\n        };\n        const cells = this.getCellsForBounds(bounds);\n        // Add to new cells\n        for (const cellKey of cells){\n            if (!this.grid.has(cellKey)) {\n                this.grid.set(cellKey, []);\n            }\n            this.grid.get(cellKey).push(entry);\n        }\n        // Track which cells this entity is in\n        this.entityCells.set(entity.id, cells);\n    }\n    remove(entity) {\n        const cells = this.entityCells.get(entity.id);\n        if (!cells) return;\n        // Remove from all cells\n        for (const cellKey of cells){\n            const cellEntries = this.grid.get(cellKey);\n            if (cellEntries) {\n                const index = cellEntries.findIndex((entry)=>entry.entity.id === entity.id);\n                if (index !== -1) {\n                    cellEntries.splice(index, 1);\n                }\n                // Clean up empty cells\n                if (cellEntries.length === 0) {\n                    this.grid.delete(cellKey);\n                }\n            }\n        }\n        this.entityCells.delete(entity.id);\n    }\n    update(entity, newBounds) {\n        const oldCells = this.entityCells.get(entity.id) || [];\n        const newCells = this.getCellsForBounds(newBounds);\n        // Check if cells have changed\n        if (this.arraysEqual(oldCells, newCells)) {\n            // Just update the bounds in existing cells\n            for (const cellKey of oldCells){\n                const cellEntries = this.grid.get(cellKey);\n                if (cellEntries) {\n                    const entry = cellEntries.find((e)=>e.entity.id === entity.id);\n                    if (entry) {\n                        entry.bounds.copy(newBounds);\n                    }\n                }\n            }\n        } else {\n            // Cells have changed, need to re-insert\n            this.insert(entity, newBounds);\n        }\n    }\n    arraysEqual(a, b) {\n        if (a.length !== b.length) return false;\n        const sortedA = [\n            ...a\n        ].sort();\n        const sortedB = [\n            ...b\n        ].sort();\n        return sortedA.every((val, index)=>val === sortedB[index]);\n    }\n    query(bounds) {\n        const results = [];\n        const seenEntities = new Set();\n        const cells = this.getCellsForBounds(bounds);\n        for (const cellKey of cells){\n            const cellEntries = this.grid.get(cellKey);\n            if (!cellEntries) continue;\n            for (const entry of cellEntries){\n                // Avoid duplicates (entity might be in multiple cells)\n                if (seenEntities.has(entry.entity.id)) continue;\n                seenEntities.add(entry.entity.id);\n                // Check if bounds actually intersect\n                if (bounds.intersectsBox(entry.bounds)) {\n                    results.push(entry);\n                }\n            }\n        }\n        return results;\n    }\n    queryRadius(center, radius) {\n        // Create bounding box for the sphere\n        this.tempBox.setFromCenterAndSize(center, new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3(radius * 2, radius * 2, radius * 2));\n        const candidates = this.query(this.tempBox);\n        // Filter by actual distance\n        const results = [];\n        const radiusSquared = radius * radius;\n        for (const entry of candidates){\n            // Get closest point on bounds to center\n            this.tempVector.copy(center);\n            entry.bounds.clampPoint(this.tempVector, this.tempVector);\n            if (center.distanceToSquared(this.tempVector) <= radiusSquared) {\n                results.push(entry);\n            }\n        }\n        return results;\n    }\n    queryPoint(point) {\n        const cellCoords = this.getCellCoords(point);\n        const cellKey = this.getCellKey(cellCoords.x, cellCoords.y, cellCoords.z);\n        const cellEntries = this.grid.get(cellKey);\n        if (!cellEntries) return [];\n        const results = [];\n        for (const entry of cellEntries){\n            if (entry.bounds.containsPoint(point)) {\n                results.push(entry);\n            }\n        }\n        return results;\n    }\n    getNearbyEntities(entity, maxDistance) {\n        const cells = this.entityCells.get(entity.id);\n        if (!cells) return [];\n        const results = [];\n        const seenEntities = new Set();\n        const maxDistanceSquared = maxDistance * maxDistance;\n        // Get entity's bounds\n        const entityEntry = this.getEntityEntry(entity);\n        if (!entityEntry) return [];\n        const entityCenter = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        entityEntry.bounds.getCenter(entityCenter);\n        // Check nearby cells\n        const expandedCells = this.getExpandedCells(cells, Math.ceil(maxDistance / this.cellSize));\n        for (const cellKey of expandedCells){\n            const cellEntries = this.grid.get(cellKey);\n            if (!cellEntries) continue;\n            for (const entry of cellEntries){\n                if (entry.entity.id === entity.id || seenEntities.has(entry.entity.id)) continue;\n                seenEntities.add(entry.entity.id);\n                // Check distance\n                const otherCenter = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                entry.bounds.getCenter(otherCenter);\n                if (entityCenter.distanceToSquared(otherCenter) <= maxDistanceSquared) {\n                    results.push(entry.entity);\n                }\n            }\n        }\n        return results;\n    }\n    getEntityEntry(entity) {\n        const cells = this.entityCells.get(entity.id);\n        if (!cells || cells.length === 0) return null;\n        const cellEntries = this.grid.get(cells[0]);\n        if (!cellEntries) return null;\n        return cellEntries.find((entry)=>entry.entity.id === entity.id) || null;\n    }\n    getExpandedCells(baseCells, expansion) {\n        const expandedCells = new Set();\n        for (const cellKey of baseCells){\n            const [x, y, z] = cellKey.split(\",\").map(Number);\n            for(let dx = -expansion; dx <= expansion; dx++){\n                for(let dy = -expansion; dy <= expansion; dy++){\n                    for(let dz = -expansion; dz <= expansion; dz++){\n                        expandedCells.add(this.getCellKey(x + dx, y + dy, z + dz));\n                    }\n                }\n            }\n        }\n        return Array.from(expandedCells);\n    }\n    clear() {\n        this.grid.clear();\n        this.entityCells.clear();\n    }\n    getStats() {\n        const totalCells = this.grid.size;\n        const totalEntities = this.entityCells.size;\n        let maxEntitiesInCell = 0;\n        let totalEntitiesInCells = 0;\n        this.grid.forEach((entries)=>{\n            totalEntitiesInCells += entries.length;\n            maxEntitiesInCell = Math.max(maxEntitiesInCell, entries.length);\n        });\n        return {\n            totalCells,\n            totalEntities,\n            averageEntitiesPerCell: totalCells > 0 ? totalEntitiesInCells / totalCells : 0,\n            maxEntitiesInCell\n        };\n    }\n    debugVisualize() {\n        const lines = [];\n        lines.push(\"Spatial Hash Stats: \".concat(JSON.stringify(this.getStats(), null, 2)));\n        this.grid.forEach((entries, cellKey)=>{\n            if (entries.length > 0) {\n                lines.push(\"Cell \".concat(cellKey, \": \").concat(entries.length, \" entities\"));\n            }\n        });\n        return lines;\n    }\n    constructor(cellSize = 5){\n        // Reusable objects to reduce allocations\n        this.tempBox = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Box3();\n        this.tempVector = new _utils_three_exports__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.cellSize = cellSize;\n        this.grid = new Map();\n        this.entityCells = new Map();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9TcGF0aWFsSGFzaC50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlEQUFpRDtBQUNLO0FBUS9DLE1BQU1FO0lBZUhDLFdBQVdDLENBQVMsRUFBRUMsQ0FBUyxFQUFFQyxDQUFTLEVBQVU7UUFDMUQsT0FBTyxHQUFRRCxPQUFMRCxHQUFFLEtBQVFFLE9BQUxELEdBQUUsS0FBSyxPQUFGQztJQUN0QjtJQUVRQyxjQUFjQyxRQUFpQixFQUFXO1FBQ2hELE9BQU8sSUFBSVIseURBQU9BLENBQ2hCUyxLQUFLQyxLQUFLLENBQUNGLFNBQVNKLENBQUMsR0FBRyxJQUFJLENBQUNPLFFBQVEsR0FDckNGLEtBQUtDLEtBQUssQ0FBQ0YsU0FBU0gsQ0FBQyxHQUFHLElBQUksQ0FBQ00sUUFBUSxHQUNyQ0YsS0FBS0MsS0FBSyxDQUFDRixTQUFTRixDQUFDLEdBQUcsSUFBSSxDQUFDSyxRQUFRO0lBRXpDO0lBRVFDLGtCQUFrQkMsTUFBWSxFQUFZO1FBQ2hELE1BQU1DLFFBQWtCLEVBQUU7UUFFMUIsTUFBTUMsVUFBVSxJQUFJLENBQUNSLGFBQWEsQ0FBQ00sT0FBT0csR0FBRztRQUM3QyxNQUFNQyxVQUFVLElBQUksQ0FBQ1YsYUFBYSxDQUFDTSxPQUFPSyxHQUFHO1FBRTdDLElBQUssSUFBSWQsSUFBSVcsUUFBUVgsQ0FBQyxFQUFFQSxLQUFLYSxRQUFRYixDQUFDLEVBQUVBLElBQUs7WUFDM0MsSUFBSyxJQUFJQyxJQUFJVSxRQUFRVixDQUFDLEVBQUVBLEtBQUtZLFFBQVFaLENBQUMsRUFBRUEsSUFBSztnQkFDM0MsSUFBSyxJQUFJQyxJQUFJUyxRQUFRVCxDQUFDLEVBQUVBLEtBQUtXLFFBQVFYLENBQUMsRUFBRUEsSUFBSztvQkFDM0NRLE1BQU1LLElBQUksQ0FBQyxJQUFJLENBQUNoQixVQUFVLENBQUNDLEdBQUdDLEdBQUdDO2dCQUNuQztZQUNGO1FBQ0Y7UUFFQSxPQUFPUTtJQUNUO0lBRU9NLE9BQU9DLE1B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T0FBekN1RixLQUFLQyxTQUFTLENBQUMsSUFBSSxDQUFDWixRQUFRLElBQUksTUFBTTtRQUV4RSxJQUFJLENBQUNyRSxJQUFJLENBQUMyRSxPQUFPLENBQUMsQ0FBQ0MsU0FBUzdFO1lBQzFCLElBQUk2RSxRQUFRbEUsTUFBTSxHQUFHLEdBQUc7Z0JBQ3RCcUUsTUFBTXRGLElBQUksQ0FBQyxRQUFvQm1GLE9BQVo3RSxTQUFRLE1BQW1CLE9BQWY2RSxRQUFRbEUsTUFBTSxFQUFDO1lBQ2hEO1FBQ0Y7UUFFQSxPQUFPcUU7SUFDVDtJQXBSQUcsWUFBWWpHLFdBQW1CLENBQUMsQ0FBRTtRQUpsQyx5Q0FBeUM7YUFDakNtRCxVQUFVLElBQUk3RCxzREFBSUE7YUFDbEJpRSxhQUFhLElBQUlsRSx5REFBT0E7UUFHOUIsSUFBSSxDQUFDVyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2UsSUFBSSxHQUFHLElBQUltRjtRQUNoQixJQUFJLENBQUMvRSxXQUFXLEdBQUcsSUFBSStFO0lBQ3pCO0FBaVJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9TcGF0aWFsSGFzaC50cz9mODM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNwYXRpYWwgaGFzaCBmb3IgZWZmaWNpZW50IGNvbGxpc2lvbiBkZXRlY3Rpb25cbmltcG9ydCB7IFZlY3RvcjMsIEJveDMgfSBmcm9tICdAL3V0aWxzL3RocmVlLWV4cG9ydHMnO1xuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnQC9lY3MvRW50aXR5JztcblxuZXhwb3J0IGludGVyZmFjZSBTcGF0aWFsSGFzaEVudHJ5IHtcbiAgZW50aXR5OiBFbnRpdHk7XG4gIGJvdW5kczogQm94Mztcbn1cblxuZXhwb3J0IGNsYXNzIFNwYXRpYWxIYXNoIHtcbiAgcHJpdmF0ZSBjZWxsU2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIGdyaWQ6IE1hcDxzdHJpbmcsIFNwYXRpYWxIYXNoRW50cnlbXT47XG4gIHByaXZhdGUgZW50aXR5Q2VsbHM6IE1hcDxudW1iZXIsIHN0cmluZ1tdPjsgLy8gVHJhY2sgd2hpY2ggY2VsbHMgZWFjaCBlbnRpdHkgaXMgaW5cbiAgXG4gIC8vIFJldXNhYmxlIG9iamVjdHMgdG8gcmVkdWNlIGFsbG9jYXRpb25zXG4gIHByaXZhdGUgdGVtcEJveCA9IG5ldyBCb3gzKCk7XG4gIHByaXZhdGUgdGVtcFZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgY29uc3RydWN0b3IoY2VsbFNpemU6IG51bWJlciA9IDUpIHtcbiAgICB0aGlzLmNlbGxTaXplID0gY2VsbFNpemU7XG4gICAgdGhpcy5ncmlkID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW50aXR5Q2VsbHMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBwcml2YXRlIGdldENlbGxLZXkoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3h9LCR7eX0sJHt6fWA7XG4gIH1cblxuICBwcml2YXRlIGdldENlbGxDb29yZHMocG9zaXRpb246IFZlY3RvcjMpOiBWZWN0b3IzIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoXG4gICAgICBNYXRoLmZsb29yKHBvc2l0aW9uLnggLyB0aGlzLmNlbGxTaXplKSxcbiAgICAgIE1hdGguZmxvb3IocG9zaXRpb24ueSAvIHRoaXMuY2VsbFNpemUpLFxuICAgICAgTWF0aC5mbG9vcihwb3NpdGlvbi56IC8gdGhpcy5jZWxsU2l6ZSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDZWxsc0ZvckJvdW5kcyhib3VuZHM6IEJveDMpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgY2VsbHM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgY29uc3QgbWluQ2VsbCA9IHRoaXMuZ2V0Q2VsbENvb3Jkcyhib3VuZHMubWluKTtcbiAgICBjb25zdCBtYXhDZWxsID0gdGhpcy5nZXRDZWxsQ29vcmRzKGJvdW5kcy5tYXgpO1xuXG4gICAgZm9yIChsZXQgeCA9IG1pbkNlbGwueDsgeCA8PSBtYXhDZWxsLng7IHgrKykge1xuICAgICAgZm9yIChsZXQgeSA9IG1pbkNlbGwueTsgeSA8PSBtYXhDZWxsLnk7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB6ID0gbWluQ2VsbC56OyB6IDw9IG1heENlbGwuejsgeisrKSB7XG4gICAgICAgICAgY2VsbHMucHVzaCh0aGlzLmdldENlbGxLZXkoeCwgeSwgeikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9XG5cbiAgcHVibGljIGluc2VydChlbnRpdHk6IEVudGl0eSwgYm91bmRzOiBCb3gzKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGVudGl0eSBmcm9tIG9sZCBjZWxscyBmaXJzdFxuICAgIHRoaXMucmVtb3ZlKGVudGl0eSk7XG5cbiAgICBjb25zdCBlbnRyeTogU3BhdGlhbEhhc2hFbnRyeSA9IHsgZW50aXR5LCBib3VuZHM6IGJvdW5kcy5jbG9uZSgpIH07XG4gICAgY29uc3QgY2VsbHMgPSB0aGlzLmdldENlbGxzRm9yQm91bmRzKGJvdW5kcyk7XG5cbiAgICAvLyBBZGQgdG8gbmV3IGNlbGxzXG4gICAgZm9yIChjb25zdCBjZWxsS2V5IG9mIGNlbGxzKSB7XG4gICAgICBpZiAoIXRoaXMuZ3JpZC5oYXMoY2VsbEtleSkpIHtcbiAgICAgICAgdGhpcy5ncmlkLnNldChjZWxsS2V5LCBbXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmdyaWQuZ2V0KGNlbGxLZXkpIS5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB3aGljaCBjZWxscyB0aGlzIGVudGl0eSBpcyBpblxuICAgIHRoaXMuZW50aXR5Q2VsbHMuc2V0KGVudGl0eS5pZCwgY2VsbHMpO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZShlbnRpdHk6IEVudGl0eSk6IHZvaWQge1xuICAgIGNvbnN0IGNlbGxzID0gdGhpcy5lbnRpdHlDZWxscy5nZXQoZW50aXR5LmlkKTtcbiAgICBpZiAoIWNlbGxzKSByZXR1cm47XG5cbiAgICAvLyBSZW1vdmUgZnJvbSBhbGwgY2VsbHNcbiAgICBmb3IgKGNvbnN0IGNlbGxLZXkgb2YgY2VsbHMpIHtcbiAgICAgIGNvbnN0IGNlbGxFbnRyaWVzID0gdGhpcy5ncmlkLmdldChjZWxsS2V5KTtcbiAgICAgIGlmIChjZWxsRW50cmllcykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNlbGxFbnRyaWVzLmZpbmRJbmRleChlbnRyeSA9PiBlbnRyeS5lbnRpdHkuaWQgPT09IGVudGl0eS5pZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjZWxsRW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhbiB1cCBlbXB0eSBjZWxsc1xuICAgICAgICBpZiAoY2VsbEVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5ncmlkLmRlbGV0ZShjZWxsS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW50aXR5Q2VsbHMuZGVsZXRlKGVudGl0eS5pZCk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlKGVudGl0eTogRW50aXR5LCBuZXdCb3VuZHM6IEJveDMpOiB2b2lkIHtcbiAgICBjb25zdCBvbGRDZWxscyA9IHRoaXMuZW50aXR5Q2VsbHMuZ2V0KGVudGl0eS5pZCkgfHwgW107XG4gICAgY29uc3QgbmV3Q2VsbHMgPSB0aGlzLmdldENlbGxzRm9yQm91bmRzKG5ld0JvdW5kcyk7XG5cbiAgICAvLyBDaGVjayBpZiBjZWxscyBoYXZlIGNoYW5nZWRcbiAgICBpZiAodGhpcy5hcnJheXNFcXVhbChvbGRDZWxscywgbmV3Q2VsbHMpKSB7XG4gICAgICAvLyBKdXN0IHVwZGF0ZSB0aGUgYm91bmRzIGluIGV4aXN0aW5nIGNlbGxzXG4gICAgICBmb3IgKGNvbnN0IGNlbGxLZXkgb2Ygb2xkQ2VsbHMpIHtcbiAgICAgICAgY29uc3QgY2VsbEVudHJpZXMgPSB0aGlzLmdyaWQuZ2V0KGNlbGxLZXkpO1xuICAgICAgICBpZiAoY2VsbEVudHJpZXMpIHtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IGNlbGxFbnRyaWVzLmZpbmQoZSA9PiBlLmVudGl0eS5pZCA9PT0gZW50aXR5LmlkKTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5LmJvdW5kcy5jb3B5KG5ld0JvdW5kcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENlbGxzIGhhdmUgY2hhbmdlZCwgbmVlZCB0byByZS1pbnNlcnRcbiAgICAgIHRoaXMuaW5zZXJ0KGVudGl0eSwgbmV3Qm91bmRzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFycmF5c0VxdWFsKGE6IHN0cmluZ1tdLCBiOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzb3J0ZWRBID0gWy4uLmFdLnNvcnQoKTtcbiAgICBjb25zdCBzb3J0ZWRCID0gWy4uLmJdLnNvcnQoKTtcbiAgICByZXR1cm4gc29ydGVkQS5ldmVyeSgodmFsLCBpbmRleCkgPT4gdmFsID09PSBzb3J0ZWRCW2luZGV4XSk7XG4gIH1cblxuICBwdWJsaWMgcXVlcnkoYm91bmRzOiBCb3gzKTogU3BhdGlhbEhhc2hFbnRyeVtdIHtcbiAgICBjb25zdCByZXN1bHRzOiBTcGF0aWFsSGFzaEVudHJ5W10gPSBbXTtcbiAgICBjb25zdCBzZWVuRW50aXRpZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICBjb25zdCBjZWxscyA9IHRoaXMuZ2V0Q2VsbHNGb3JCb3VuZHMoYm91bmRzKTtcblxuICAgIGZvciAoY29uc3QgY2VsbEtleSBvZiBjZWxscykge1xuICAgICAgY29uc3QgY2VsbEVudHJpZXMgPSB0aGlzLmdyaWQuZ2V0KGNlbGxLZXkpO1xuICAgICAgaWYgKCFjZWxsRW50cmllcykgY29udGludWU7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgY2VsbEVudHJpZXMpIHtcbiAgICAgICAgLy8gQXZvaWQgZHVwbGljYXRlcyAoZW50aXR5IG1pZ2h0IGJlIGluIG11bHRpcGxlIGNlbGxzKVxuICAgICAgICBpZiAoc2VlbkVudGl0aWVzLmhhcyhlbnRyeS5lbnRpdHkuaWQpKSBjb250aW51ZTtcbiAgICAgICAgc2VlbkVudGl0aWVzLmFkZChlbnRyeS5lbnRpdHkuaWQpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGJvdW5kcyBhY3R1YWxseSBpbnRlcnNlY3RcbiAgICAgICAgaWYgKGJvdW5kcy5pbnRlcnNlY3RzQm94KGVudHJ5LmJvdW5kcykpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBwdWJsaWMgcXVlcnlSYWRpdXMoY2VudGVyOiBWZWN0b3IzLCByYWRpdXM6IG51bWJlcik6IFNwYXRpYWxIYXNoRW50cnlbXSB7XG4gICAgLy8gQ3JlYXRlIGJvdW5kaW5nIGJveCBmb3IgdGhlIHNwaGVyZVxuICAgIHRoaXMudGVtcEJveC5zZXRGcm9tQ2VudGVyQW5kU2l6ZShjZW50ZXIsIG5ldyBWZWN0b3IzKHJhZGl1cyAqIDIsIHJhZGl1cyAqIDIsIHJhZGl1cyAqIDIpKTtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gdGhpcy5xdWVyeSh0aGlzLnRlbXBCb3gpO1xuXG4gICAgLy8gRmlsdGVyIGJ5IGFjdHVhbCBkaXN0YW5jZVxuICAgIGNvbnN0IHJlc3VsdHM6IFNwYXRpYWxIYXNoRW50cnlbXSA9IFtdO1xuICAgIGNvbnN0IHJhZGl1c1NxdWFyZWQgPSByYWRpdXMgKiByYWRpdXM7XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgIC8vIEdldCBjbG9zZXN0IHBvaW50IG9uIGJvdW5kcyB0byBjZW50ZXJcbiAgICAgIHRoaXMudGVtcFZlY3Rvci5jb3B5KGNlbnRlcik7XG4gICAgICBlbnRyeS5ib3VuZHMuY2xhbXBQb2ludCh0aGlzLnRlbXBWZWN0b3IsIHRoaXMudGVtcFZlY3Rvcik7XG4gICAgICBcbiAgICAgIGlmIChjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy50ZW1wVmVjdG9yKSA8PSByYWRpdXNTcXVhcmVkKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBwdWJsaWMgcXVlcnlQb2ludChwb2ludDogVmVjdG9yMyk6IFNwYXRpYWxIYXNoRW50cnlbXSB7XG4gICAgY29uc3QgY2VsbENvb3JkcyA9IHRoaXMuZ2V0Q2VsbENvb3Jkcyhwb2ludCk7XG4gICAgY29uc3QgY2VsbEtleSA9IHRoaXMuZ2V0Q2VsbEtleShjZWxsQ29vcmRzLngsIGNlbGxDb29yZHMueSwgY2VsbENvb3Jkcy56KTtcbiAgICBjb25zdCBjZWxsRW50cmllcyA9IHRoaXMuZ3JpZC5nZXQoY2VsbEtleSk7XG4gICAgXG4gICAgaWYgKCFjZWxsRW50cmllcykgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgcmVzdWx0czogU3BhdGlhbEhhc2hFbnRyeVtdID0gW107XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBjZWxsRW50cmllcykge1xuICAgICAgaWYgKGVudHJ5LmJvdW5kcy5jb250YWluc1BvaW50KHBvaW50KSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgcHVibGljIGdldE5lYXJieUVudGl0aWVzKGVudGl0eTogRW50aXR5LCBtYXhEaXN0YW5jZTogbnVtYmVyKTogRW50aXR5W10ge1xuICAgIGNvbnN0IGNlbGxzID0gdGhpcy5lbnRpdHlDZWxscy5nZXQoZW50aXR5LmlkKTtcbiAgICBpZiAoIWNlbGxzKSByZXR1cm4gW107XG5cbiAgICBjb25zdCByZXN1bHRzOiBFbnRpdHlbXSA9IFtdO1xuICAgIGNvbnN0IHNlZW5FbnRpdGllcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICAgIGNvbnN0IG1heERpc3RhbmNlU3F1YXJlZCA9IG1heERpc3RhbmNlICogbWF4RGlzdGFuY2U7XG5cbiAgICAvLyBHZXQgZW50aXR5J3MgYm91bmRzXG4gICAgY29uc3QgZW50aXR5RW50cnkgPSB0aGlzLmdldEVudGl0eUVudHJ5KGVudGl0eSk7XG4gICAgaWYgKCFlbnRpdHlFbnRyeSkgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgZW50aXR5Q2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbiAgICBlbnRpdHlFbnRyeS5ib3VuZHMuZ2V0Q2VudGVyKGVudGl0eUNlbnRlcik7XG5cbiAgICAvLyBDaGVjayBuZWFyYnkgY2VsbHNcbiAgICBjb25zdCBleHBhbmRlZENlbGxzID0gdGhpcy5nZXRFeHBhbmRlZENlbGxzKGNlbGxzLCBNYXRoLmNlaWwobWF4RGlzdGFuY2UgLyB0aGlzLmNlbGxTaXplKSk7XG5cbiAgICBmb3IgKGNvbnN0IGNlbGxLZXkgb2YgZXhwYW5kZWRDZWxscykge1xuICAgICAgY29uc3QgY2VsbEVudHJpZXMgPSB0aGlzLmdyaWQuZ2V0KGNlbGxLZXkpO1xuICAgICAgaWYgKCFjZWxsRW50cmllcykgY29udGludWU7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgY2VsbEVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJ5LmVudGl0eS5pZCA9PT0gZW50aXR5LmlkIHx8IHNlZW5FbnRpdGllcy5oYXMoZW50cnkuZW50aXR5LmlkKSkgY29udGludWU7XG4gICAgICAgIHNlZW5FbnRpdGllcy5hZGQoZW50cnkuZW50aXR5LmlkKTtcblxuICAgICAgICAvLyBDaGVjayBkaXN0YW5jZVxuICAgICAgICBjb25zdCBvdGhlckNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIGVudHJ5LmJvdW5kcy5nZXRDZW50ZXIob3RoZXJDZW50ZXIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVudGl0eUNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChvdGhlckNlbnRlcikgPD0gbWF4RGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGVudHJ5LmVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RW50aXR5RW50cnkoZW50aXR5OiBFbnRpdHkpOiBTcGF0aWFsSGFzaEVudHJ5IHwgbnVsbCB7XG4gICAgY29uc3QgY2VsbHMgPSB0aGlzLmVudGl0eUNlbGxzLmdldChlbnRpdHkuaWQpO1xuICAgIGlmICghY2VsbHMgfHwgY2VsbHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IGNlbGxFbnRyaWVzID0gdGhpcy5ncmlkLmdldChjZWxsc1swXSk7XG4gICAgaWYgKCFjZWxsRW50cmllcykgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gY2VsbEVudHJpZXMuZmluZChlbnRyeSA9PiBlbnRyeS5lbnRpdHkuaWQgPT09IGVudGl0eS5pZCkgfHwgbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RXhwYW5kZWRDZWxscyhiYXNlQ2VsbHM6IHN0cmluZ1tdLCBleHBhbnNpb246IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBleHBhbmRlZENlbGxzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgICBmb3IgKGNvbnN0IGNlbGxLZXkgb2YgYmFzZUNlbGxzKSB7XG4gICAgICBjb25zdCBbeCwgeSwgel0gPSBjZWxsS2V5LnNwbGl0KCcsJykubWFwKE51bWJlcik7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGR4ID0gLWV4cGFuc2lvbjsgZHggPD0gZXhwYW5zaW9uOyBkeCsrKSB7XG4gICAgICAgIGZvciAobGV0IGR5ID0gLWV4cGFuc2lvbjsgZHkgPD0gZXhwYW5zaW9uOyBkeSsrKSB7XG4gICAgICAgICAgZm9yIChsZXQgZHogPSAtZXhwYW5zaW9uOyBkeiA8PSBleHBhbnNpb247IGR6KyspIHtcbiAgICAgICAgICAgIGV4cGFuZGVkQ2VsbHMuYWRkKHRoaXMuZ2V0Q2VsbEtleSh4ICsgZHgsIHkgKyBkeSwgeiArIGR6KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZXhwYW5kZWRDZWxscyk7XG4gIH1cblxuICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5ncmlkLmNsZWFyKCk7XG4gICAgdGhpcy5lbnRpdHlDZWxscy5jbGVhcigpO1xuICB9XG5cbiAgcHVibGljIGdldFN0YXRzKCk6IHtcbiAgICB0b3RhbENlbGxzOiBudW1iZXI7XG4gICAgdG90YWxFbnRpdGllczogbnVtYmVyO1xuICAgIGF2ZXJhZ2VFbnRpdGllc1BlckNlbGw6IG51bWJlcjtcbiAgICBtYXhFbnRpdGllc0luQ2VsbDogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCB0b3RhbENlbGxzID0gdGhpcy5ncmlkLnNpemU7XG4gICAgY29uc3QgdG90YWxFbnRpdGllcyA9IHRoaXMuZW50aXR5Q2VsbHMuc2l6ZTtcbiAgICBsZXQgbWF4RW50aXRpZXNJbkNlbGwgPSAwO1xuICAgIGxldCB0b3RhbEVudGl0aWVzSW5DZWxscyA9IDA7XG5cbiAgICB0aGlzLmdyaWQuZm9yRWFjaCgoZW50cmllcykgPT4ge1xuICAgICAgdG90YWxFbnRpdGllc0luQ2VsbHMgKz0gZW50cmllcy5sZW5ndGg7XG4gICAgICBtYXhFbnRpdGllc0luQ2VsbCA9IE1hdGgubWF4KG1heEVudGl0aWVzSW5DZWxsLCBlbnRyaWVzLmxlbmd0aCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxDZWxscyxcbiAgICAgIHRvdGFsRW50aXRpZXMsXG4gICAgICBhdmVyYWdlRW50aXRpZXNQZXJDZWxsOiB0b3RhbENlbGxzID4gMCA/IHRvdGFsRW50aXRpZXNJbkNlbGxzIC8gdG90YWxDZWxscyA6IDAsXG4gICAgICBtYXhFbnRpdGllc0luQ2VsbFxuICAgIH07XG4gIH1cbiBcbiAgcHVibGljIGRlYnVnVmlzdWFsaXplKCk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICBsaW5lcy5wdXNoKGBTcGF0aWFsIEhhc2ggU3RhdHM6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5nZXRTdGF0cygpLCBudWxsLCAyKX1gKTtcbiAgICBcbiAgICB0aGlzLmdyaWQuZm9yRWFjaCgoZW50cmllcywgY2VsbEtleSkgPT4ge1xuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsaW5lcy5wdXNoKGBDZWxsICR7Y2VsbEtleX06ICR7ZW50cmllcy5sZW5ndGh9IGVudGl0aWVzYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiQm94MyIsIlNwYXRpYWxIYXNoIiwiZ2V0Q2VsbEtleSIsIngiLCJ5IiwieiIsImdldENlbGxDb29yZHMiLCJwb3NpdGlvbiIsIk1hdGgiLCJmbG9vciIsImNlbGxTaXplIiwiZ2V0Q2VsbHNGb3JCb3VuZHMiLCJib3VuZHMiLCJjZWxscyIsIm1pbkNlbGwiLCJtaW4iLCJtYXhDZWxsIiwibWF4IiwicHVzaCIsImluc2VydCIsImVudGl0eSIsInJlbW92ZSIsImVudHJ5IiwiY2xvbmUiLCJjZWxsS2V5IiwiZ3JpZCIsImhhcyIsInNldCIsImdldCIsImVudGl0eUNlbGxzIiwiaWQiLCJjZWxsRW50cmllcyIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwibGVuZ3RoIiwiZGVsZXRlIiwidXBkYXRlIiwibmV3Qm91bmRzIiwib2xkQ2VsbHMiLCJuZXdDZWxscyIsImFycmF5c0VxdWFsIiwiZmluZCIsImUiLCJjb3B5IiwiYSIsImIiLCJzb3J0ZWRBIiwic29ydCIsInNvcnRlZEIiLCJldmVyeSIsInZhbCIsInF1ZXJ5IiwicmVzdWx0cyIsInNlZW5FbnRpdGllcyIsIlNldCIsImFkZCIsImludGVyc2VjdHNCb3giLCJxdWVyeVJhZGl1cyIsImNlbnRlciIsInJhZGl1cyIsInRlbXBCb3giLCJzZXRGcm9tQ2VudGVyQW5kU2l6ZSIsImNhbmRpZGF0ZXMiLCJyYWRpdXNTcXVhcmVkIiwidGVtcFZlY3RvciIsImNsYW1wUG9pbnQiLCJkaXN0YW5jZVRvU3F1YXJlZCIsInF1ZXJ5UG9pbnQiLCJwb2ludCIsImNlbGxDb29yZHMiLCJjb250YWluc1BvaW50IiwiZ2V0TmVhcmJ5RW50aXRpZXMiLCJtYXhEaXN0YW5jZSIsIm1heERpc3RhbmNlU3F1YXJlZCIsImVudGl0eUVudHJ5IiwiZ2V0RW50aXR5RW50cnkiLCJlbnRpdHlDZW50ZXIiLCJnZXRDZW50ZXIiLCJleHBhbmRlZENlbGxzIiwiZ2V0RXhwYW5kZWRDZWxscyIsImNlaWwiLCJvdGhlckNlbnRlciIsImJhc2VDZWxscyIsImV4cGFuc2lvbiIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiZHgiLCJkeSIsImR6IiwiQXJyYXkiLCJmcm9tIiwiY2xlYXIiLCJnZXRTdGF0cyIsInRvdGFsQ2VsbHMiLCJzaXplIiwidG90YWxFbnRpdGllcyIsIm1heEVudGl0aWVzSW5DZWxsIiwidG90YWxFbnRpdGllc0luQ2VsbHMiLCJmb3JFYWNoIiwiZW50cmllcyIsImF2ZXJhZ2VFbnRpdGllc1BlckNlbGwiLCJkZWJ1Z1Zpc3VhbGl6ZSIsImxpbmVzIiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnN0cnVjdG9yIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/SpatialHash.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/three-exports.ts":
/*!************************************!*\
  !*** ./src/utils/three-exports.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdditiveBlending: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.AdditiveBlending; },\n/* harmony export */   AmbientLight: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.AmbientLight; },\n/* harmony export */   AnimationAction: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.AnimationAction; },\n/* harmony export */   AnimationClip: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip; },\n/* harmony export */   AnimationMixer: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer; },\n/* harmony export */   BackSide: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.BackSide; },\n/* harmony export */   Box3: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Box3; },\n/* harmony export */   BoxGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.BoxGeometry; },\n/* harmony export */   BufferAttribute: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute; },\n/* harmony export */   BufferGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry; },\n/* harmony export */   Camera: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Camera; },\n/* harmony export */   CanvasTexture: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture; },\n/* harmony export */   CatmullRomCurve3: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.CatmullRomCurve3; },\n/* harmony export */   Color: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Color; },\n/* harmony export */   ConeGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.ConeGeometry; },\n/* harmony export */   CubeTexture: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.CubeTexture; },\n/* harmony export */   CubeTextureLoader: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.CubeTextureLoader; },\n/* harmony export */   CubicBezierCurve3: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.CubicBezierCurve3; },\n/* harmony export */   CylinderGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry; },\n/* harmony export */   DirectionalLight: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight; },\n/* harmony export */   DoubleSide: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide; },\n/* harmony export */   DynamicDrawUsage: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.DynamicDrawUsage; },\n/* harmony export */   Euler: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Euler; },\n/* harmony export */   Fog: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Fog; },\n/* harmony export */   FogExp2: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.FogExp2; },\n/* harmony export */   FrontSide: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.FrontSide; },\n/* harmony export */   Frustum: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Frustum; },\n/* harmony export */   Group: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Group; },\n/* harmony export */   InstancedMesh: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh; },\n/* harmony export */   Light: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Light; },\n/* harmony export */   Line: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Line; },\n/* harmony export */   LineBasicMaterial: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial; },\n/* harmony export */   LinearEncoding: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.LinearEncoding; },\n/* harmony export */   LinearFilter: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter; },\n/* harmony export */   LoopOnce: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.LoopOnce; },\n/* harmony export */   LoopRepeat: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat; },\n/* harmony export */   Material: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Material; },\n/* harmony export */   MathUtils: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.MathUtils; },\n/* harmony export */   Matrix4: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Matrix4; },\n/* harmony export */   Mesh: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Mesh; },\n/* harmony export */   MeshBasicMaterial: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial; },\n/* harmony export */   MeshPhongMaterial: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.MeshPhongMaterial; },\n/* harmony export */   MeshStandardMaterial: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial; },\n/* harmony export */   Object3D: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Object3D; },\n/* harmony export */   OctahedronGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.OctahedronGeometry; },\n/* harmony export */   OrthographicCamera: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera; },\n/* harmony export */   PCFSoftShadowMap: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.PCFSoftShadowMap; },\n/* harmony export */   PerspectiveCamera: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera; },\n/* harmony export */   PlaneGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry; },\n/* harmony export */   PointLight: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.PointLight; },\n/* harmony export */   Points: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Points; },\n/* harmony export */   PointsMaterial: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial; },\n/* harmony export */   Quaternion: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Quaternion; },\n/* harmony export */   Ray: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Ray; },\n/* harmony export */   Raycaster: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Raycaster; },\n/* harmony export */   RingGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.RingGeometry; },\n/* harmony export */   Scene: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Scene; },\n/* harmony export */   ShaderMaterial: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial; },\n/* harmony export */   Shape: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Shape; },\n/* harmony export */   Sphere: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Sphere; },\n/* harmony export */   SphereGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.SphereGeometry; },\n/* harmony export */   Spherical: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Spherical; },\n/* harmony export */   SpotLight: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.SpotLight; },\n/* harmony export */   Texture: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Texture; },\n/* harmony export */   TextureLoader: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader; },\n/* harmony export */   TorusGeometry: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.TorusGeometry; },\n/* harmony export */   Vector2: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Vector2; },\n/* harmony export */   Vector3: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.Vector3; },\n/* harmony export */   WebGLRenderer: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer; },\n/* harmony export */   sRGBEncoding: function() { return /* reexport safe */ three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/**\n * Three.js barrel export - Only export what we actually use\n * This helps with tree shaking and reduces bundle size\n */ // Core math classes\n\n// Geometry classes\n\n// Curve classes\n\n// Material classes\n\n// Object3D and mesh classes\n\n// Scene and rendering\n\n// Lights\n\n// Animation\n\n// Textures and loaders\n\n// Constants\n\n// Raycasting\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy90aHJlZS1leHBvcnRzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBRUQsb0JBQW9CO0FBVUw7QUFFZixtQkFBbUI7QUFlSjtBQUVmLGdCQUFnQjtBQUlEO0FBRWYsbUJBQW1CO0FBU0o7QUFFZiw0QkFBNEI7QUFRYjtBQUVmLHNCQUFzQjtBQVNQO0FBRWYsU0FBUztBQU9NO0FBRWYsWUFBWTtBQU9HO0FBRWYsdUJBQXVCO0FBT1I7QUFFZixZQUFZO0FBV0c7QUFFZixhQUFhO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3RocmVlLWV4cG9ydHMudHM/YTVjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRocmVlLmpzIGJhcnJlbCBleHBvcnQgLSBPbmx5IGV4cG9ydCB3aGF0IHdlIGFjdHVhbGx5IHVzZVxuICogVGhpcyBoZWxwcyB3aXRoIHRyZWUgc2hha2luZyBhbmQgcmVkdWNlcyBidW5kbGUgc2l6ZVxuICovXG5cbi8vIENvcmUgbWF0aCBjbGFzc2VzXG5leHBvcnQge1xuICBWZWN0b3IzLFxuICBWZWN0b3IyLFxuICBNYXRyaXg0LFxuICBFdWxlcixcbiAgUXVhdGVybmlvbixcbiAgQ29sb3IsXG4gIE1hdGhVdGlscyxcbiAgU3BoZXJpY2FsXG59IGZyb20gJ3RocmVlJztcblxuLy8gR2VvbWV0cnkgY2xhc3Nlc1xuZXhwb3J0IHtcbiAgQnVmZmVyR2VvbWV0cnksXG4gIFNwaGVyZUdlb21ldHJ5LFxuICBQbGFuZUdlb21ldHJ5LFxuICBCb3hHZW9tZXRyeSxcbiAgQ3lsaW5kZXJHZW9tZXRyeSxcbiAgQ29uZUdlb21ldHJ5LFxuICBTaGFwZSxcbiAgQm94MyxcbiAgU3BoZXJlLFxuICBSaW5nR2VvbWV0cnksXG4gIE9jdGFoZWRyb25HZW9tZXRyeSxcbiAgVG9ydXNHZW9tZXRyeSxcbiAgQnVmZmVyQXR0cmlidXRlXG59IGZyb20gJ3RocmVlJztcblxuLy8gQ3VydmUgY2xhc3Nlc1xuZXhwb3J0IHtcbiAgQ2F0bXVsbFJvbUN1cnZlMyxcbiAgQ3ViaWNCZXppZXJDdXJ2ZTNcbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBNYXRlcmlhbCBjbGFzc2VzXG5leHBvcnQge1xuICBNYXRlcmlhbCxcbiAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gIE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxuICBNZXNoUGhvbmdNYXRlcmlhbCxcbiAgU2hhZGVyTWF0ZXJpYWwsXG4gIFBvaW50c01hdGVyaWFsLFxuICBMaW5lQmFzaWNNYXRlcmlhbFxufSBmcm9tICd0aHJlZSc7XG5cbi8vIE9iamVjdDNEIGFuZCBtZXNoIGNsYXNzZXNcbmV4cG9ydCB7XG4gIE9iamVjdDNELFxuICBNZXNoLFxuICBHcm91cCxcbiAgUG9pbnRzLFxuICBMaW5lLFxuICBJbnN0YW5jZWRNZXNoXG59IGZyb20gJ3RocmVlJztcblxuLy8gU2NlbmUgYW5kIHJlbmRlcmluZ1xuZXhwb3J0IHtcbiAgU2NlbmUsXG4gIENhbWVyYSxcbiAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gIE9ydGhvZ3JhcGhpY0NhbWVyYSxcbiAgV2ViR0xSZW5kZXJlcixcbiAgRm9nLFxuICBGb2dFeHAyXG59IGZyb20gJ3RocmVlJztcblxuLy8gTGlnaHRzXG5leHBvcnQge1xuICBMaWdodCxcbiAgRGlyZWN0aW9uYWxMaWdodCxcbiAgUG9pbnRMaWdodCxcbiAgQW1iaWVudExpZ2h0LFxuICBTcG90TGlnaHRcbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBBbmltYXRpb25cbmV4cG9ydCB7XG4gIEFuaW1hdGlvbk1peGVyLFxuICBBbmltYXRpb25DbGlwLFxuICBBbmltYXRpb25BY3Rpb24sXG4gIExvb3BSZXBlYXQsXG4gIExvb3BPbmNlXG59IGZyb20gJ3RocmVlJztcblxuLy8gVGV4dHVyZXMgYW5kIGxvYWRlcnNcbmV4cG9ydCB7XG4gIFRleHR1cmUsXG4gIFRleHR1cmVMb2FkZXIsXG4gIEN1YmVUZXh0dXJlTG9hZGVyLFxuICBDYW52YXNUZXh0dXJlLFxuICBDdWJlVGV4dHVyZVxufSBmcm9tICd0aHJlZSc7XG5cbi8vIENvbnN0YW50c1xuZXhwb3J0IHtcbiAgUENGU29mdFNoYWRvd01hcCxcbiAgc1JHQkVuY29kaW5nLFxuICBMaW5lYXJFbmNvZGluZyxcbiAgRG91YmxlU2lkZSxcbiAgRnJvbnRTaWRlLFxuICBCYWNrU2lkZSxcbiAgQWRkaXRpdmVCbGVuZGluZyxcbiAgTGluZWFyRmlsdGVyLFxuICBEeW5hbWljRHJhd1VzYWdlXG59IGZyb20gJ3RocmVlJztcblxuLy8gUmF5Y2FzdGluZ1xuZXhwb3J0IHtcbiAgUmF5Y2FzdGVyLFxuICBSYXksXG4gIEZydXN0dW1cbn0gZnJvbSAndGhyZWUnO1xuXG4vLyBDb250cm9scyAoaWYgdXNlZClcbmV4cG9ydCB0eXBlIHsgV2ViR0xSZW5kZXJlclBhcmFtZXRlcnMgfSBmcm9tICd0aHJlZSc7XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlZlY3RvcjIiLCJNYXRyaXg0IiwiRXVsZXIiLCJRdWF0ZXJuaW9uIiwiQ29sb3IiLCJNYXRoVXRpbHMiLCJTcGhlcmljYWwiLCJCdWZmZXJHZW9tZXRyeSIsIlNwaGVyZUdlb21ldHJ5IiwiUGxhbmVHZW9tZXRyeSIsIkJveEdlb21ldHJ5IiwiQ3lsaW5kZXJHZW9tZXRyeSIsIkNvbmVHZW9tZXRyeSIsIlNoYXBlIiwiQm94MyIsIlNwaGVyZSIsIlJpbmdHZW9tZXRyeSIsIk9jdGFoZWRyb25HZW9tZXRyeSIsIlRvcnVzR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJDYXRtdWxsUm9tQ3VydmUzIiwiQ3ViaWNCZXppZXJDdXJ2ZTMiLCJNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJNZXNoUGhvbmdNYXRlcmlhbCIsIlNoYWRlck1hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJMaW5lQmFzaWNNYXRlcmlhbCIsIk9iamVjdDNEIiwiTWVzaCIsIkdyb3VwIiwiUG9pbnRzIiwiTGluZSIsIkluc3RhbmNlZE1lc2giLCJTY2VuZSIsIkNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiV2ViR0xSZW5kZXJlciIsIkZvZyIsIkZvZ0V4cDIiLCJMaWdodCIsIkRpcmVjdGlvbmFsTGlnaHQiLCJQb2ludExpZ2h0IiwiQW1iaWVudExpZ2h0IiwiU3BvdExpZ2h0IiwiQW5pbWF0aW9uTWl4ZXIiLCJBbmltYXRpb25DbGlwIiwiQW5pbWF0aW9uQWN0aW9uIiwiTG9vcFJlcGVhdCIsIkxvb3BPbmNlIiwiVGV4dHVyZSIsIlRleHR1cmVMb2FkZXIiLCJDdWJlVGV4dHVyZUxvYWRlciIsIkNhbnZhc1RleHR1cmUiLCJDdWJlVGV4dHVyZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJzUkdCRW5jb2RpbmciLCJMaW5lYXJFbmNvZGluZyIsIkRvdWJsZVNpZGUiLCJGcm9udFNpZGUiLCJCYWNrU2lkZSIsIkFkZGl0aXZlQmxlbmRpbmciLCJMaW5lYXJGaWx0ZXIiLCJEeW5hbWljRHJhd1VzYWdlIiwiUmF5Y2FzdGVyIiwiUmF5IiwiRnJ1c3R1bSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/three-exports.ts\n"));

/***/ })

}]);